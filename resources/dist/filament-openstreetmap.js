var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ol/events/Event.js
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      /**
       * @param {string} type Type.
       */
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      /**
       * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
       * will be fired.
       * @api
       */
      preventDefault() {
        this.defaultPrevented = true;
      }
      /**
       * Stop event propagation.
       * @api
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default;
var init_ObjectEventType = __esm({
  "node_modules/ol/ObjectEventType.js"() {
    ObjectEventType_default = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: "propertychange"
    };
  }
});

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      /**
       * Clean up.
       */
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      /**
       * Extension point for disposable objects.
       * @protected
       */
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
var init_array = __esm({
  "node_modules/ol/array.js"() {
  }
});

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
var init_obj = __esm({
  "node_modules/ol/obj.js"() {
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_Event();
    init_functions();
    init_obj();
    Target = class extends Disposable_default {
      /**
       * @param {*} [target] Default event target for dispatched events.
       */
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : (
          /** @type {Event} */
          event
        );
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i = 0, ii = listeners.length; i < ii; ++i) {
          if ("handleEvent" in listeners[i]) {
            propagate = /** @type {import("../events.js").ListenerObject} */
            listeners[i].handleEvent(evt);
          } else {
            propagate = /** @type {import("../events.js").ListenerFunction} */
            listeners[i].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      /**
       * @param {string} [type] Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      removeEventListener(type, listener) {
        if (!this.listeners_) {
          return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
          return;
        }
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: "change",
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/Observable.js
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_Target();
    init_EventType();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */
        this.unInternal;
        this.revision_ = 0;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      getRevision() {
        return this.revision_;
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i = 0; i < len; ++i) {
            keys[i] = listen(this, type[i], listener);
          }
          return keys;
        }
        return listen(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
          const len = type.length;
          key = new Array(len);
          for (let i = 0; i < len; ++i) {
            key[i] = listenOnce(this, type[i], listener);
          }
        } else {
          key = listenOnce(
            this,
            /** @type {string} */
            type,
            listener
          );
        }
        listener.ol_key = key;
        return key;
      }
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @protected
       */
      unInternal(type, listener) {
        const key = (
          /** @type {Object} */
          listener.ol_key
        );
        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (let i = 0, ii = type.length; i < ii; ++i) {
            this.removeEventListener(type[i], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var uidCounter_;
var init_util = __esm({
  "node_modules/ol/util.js"() {
    uidCounter_ = 0;
  }
});

// node_modules/ol/Object.js
var ObjectEvent, BaseObject, Object_default;
var init_Object = __esm({
  "node_modules/ol/Object.js"() {
    init_Event();
    init_ObjectEventType();
    init_Observable();
    init_util();
    init_obj();
    ObjectEvent = class extends Event_default {
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      constructor(type, key, oldValue) {
        super(type);
        this.key = key;
        this.oldValue = oldValue;
      }
    };
    BaseObject = class extends Observable_default {
      /**
       * @param {Object<string, *>} [values] An object with key-value pairs.
       */
      constructor(values) {
        super();
        this.on;
        this.once;
        this.un;
        getUid(this);
        this.values_ = null;
        if (values !== void 0) {
          this.setProperties(values);
        }
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }
        return value;
      }
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.values_;
      }
      /**
       * @return {boolean} The object has properties.
       */
      hasProperties() {
        return !!this.values_;
      }
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = ObjectEventType_default.PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
      }
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
          values[key] = value;
        } else {
          const oldValue = values[key];
          values[key] = value;
          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      }
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      setProperties(values, silent) {
        for (const key in values) {
          this.set(key, values[key], silent);
        }
      }
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */
      applyProperties(source) {
        if (!source.values_) {
          return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
      }
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean} [silent] Unset without triggering an event.
       * @api
       */
      unset(key, silent) {
        if (this.values_ && key in this.values_) {
          const oldValue = this.values_[key];
          delete this.values_[key];
          if (isEmpty(this.values_)) {
            this.values_ = null;
          }
          if (!silent) {
            this.notify(key, oldValue);
          }
        }
      }
    };
    Object_default = BaseObject;
  }
});

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default;
var init_CollectionEventType = __esm({
  "node_modules/ol/CollectionEventType.js"() {
    CollectionEventType_default = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: "add",
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: "remove"
    };
  }
});

// node_modules/ol/Collection.js
var Property, CollectionEvent, Collection, Collection_default;
var init_Collection = __esm({
  "node_modules/ol/Collection.js"() {
    init_Object();
    init_CollectionEventType();
    init_Event();
    Property = {
      LENGTH: "length"
    };
    CollectionEvent = class extends Event_default {
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {T} element Element.
       * @param {number} index The index of the added or removed element.
       */
      constructor(type, element, index) {
        super(type);
        this.element = element;
        this.index = index;
      }
    };
    Collection = class extends Object_default {
      /**
       * @param {Array<T>} [array] Array.
       * @param {Options} [options] Collection options.
       */
      constructor(array, options) {
        super();
        this.on;
        this.once;
        this.un;
        options = options || {};
        this.unique_ = !!options.unique;
        this.array_ = array ? array : [];
        if (this.unique_) {
          for (let i = 0, ii = this.array_.length; i < ii; ++i) {
            this.assertUnique_(this.array_[i], i);
          }
        }
        this.updateLength_();
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      clear() {
        while (this.getLength() > 0) {
          this.pop();
        }
      }
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      extend(arr) {
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          this.push(arr[i]);
        }
        return this;
      }
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      forEach(f) {
        const array = this.array_;
        for (let i = 0, ii = array.length; i < ii; ++i) {
          f(array[i], i, array);
        }
      }
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      getArray() {
        return this.array_;
      }
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      item(index) {
        return this.array_[index];
      }
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      getLength() {
        return this.get(Property.LENGTH);
      }
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      pop() {
        return this.removeAt(this.getLength() - 1);
      }
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      push(elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
      }
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      remove(elem) {
        const arr = this.array_;
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          if (arr[i] === elem) {
            return this.removeAt(i);
          }
        }
        return void 0;
      }
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      removeAt(index) {
        if (index < 0 || index >= this.getLength()) {
          return void 0;
        }
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        return prev;
      }
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
          this.insertAt(index, elem);
          return;
        }
        if (index < 0) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem, index);
        }
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * @private
       */
      updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
      }
      /**
       * @private
       * @param {T} elem Element.
       * @param {number} [except] Optional index to ignore.
       */
      assertUnique_(elem, except) {
        for (let i = 0, ii = this.array_.length; i < ii; ++i) {
          if (this.array_[i] === elem && i !== except) {
            throw new Error("Duplicate item added to a unique collection");
          }
        }
      }
    };
    Collection_default = Collection;
  }
});

// node_modules/ol/has.js
var ua, FIREFOX, SAFARI, SAFARI_BUG_237906, WEBKIT, MAC, DEVICE_PIXEL_RATIO, WORKER_OFFSCREEN_CANVAS, IMAGE_DECODE, PASSIVE_EVENT_LISTENERS;
var init_has = __esm({
  "node_modules/ol/has.js"() {
    ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
    FIREFOX = ua.includes("firefox");
    SAFARI = ua.includes("safari") && !ua.includes("chrom");
    SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
    WEBKIT = ua.includes("webkit") && !ua.includes("edge");
    MAC = ua.includes("macintosh");
    DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
    WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
    IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
    PASSIVE_EVENT_LISTENERS = function() {
      let passive = false;
      try {
        const options = Object.defineProperty({}, "passive", {
          get: function() {
            passive = true;
          }
        });
        window.addEventListener("_", null, options);
        window.removeEventListener("_", null, options);
      } catch (error) {
      }
      return passive;
    }();
  }
});

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
var init_asserts = __esm({
  "node_modules/ol/asserts.js"() {
  }
});

// node_modules/ol/transform.js
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function set(transform2, a, b, c, d, e, f) {
  transform2[0] = a;
  transform2[1] = b;
  transform2[2] = c;
  transform2[3] = d;
  transform2[4] = e;
  transform2[5] = f;
  return transform2;
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply(transform2, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
function toString(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  if (WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  const node = transformStringDiv || (transformStringDiv = document.createElement("div"));
  node.style.transform = transformString;
  return node.style.transform;
}
var tmp_, transformStringDiv;
var init_transform = __esm({
  "node_modules/ol/transform.js"() {
    init_has();
    init_asserts();
    tmp_ = new Array(6);
  }
});

// node_modules/ol/extent/Relationship.js
var Relationship_default;
var init_Relationship = __esm({
  "node_modules/ol/extent/Relationship.js"() {
    Relationship_default = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16
    };
  }
});

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value
  ];
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty2(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start, end) {
  let intersects3 = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects3 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
    if (!intersects3 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
  }
  return intersects3;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}
var init_extent = __esm({
  "node_modules/ol/extent.js"() {
    init_Relationship();
  }
});

// node_modules/color-space/rgb.js
var rgb_default;
var init_rgb = __esm({
  "node_modules/color-space/rgb.js"() {
    rgb_default = {
      name: "rgb",
      min: [0, 0, 0],
      max: [255, 255, 255],
      channel: ["red", "green", "blue"],
      alias: ["RGB"]
    };
  }
});

// node_modules/color-space/xyz.js
var xyz, xyz_default;
var init_xyz = __esm({
  "node_modules/color-space/xyz.js"() {
    init_rgb();
    xyz = {
      name: "xyz",
      min: [0, 0, 0],
      channel: ["X", "Y", "Z"],
      alias: ["XYZ", "ciexyz", "cie1931"]
    };
    xyz.whitepoint = {
      //1931 2°
      2: {
        //incadescent
        A: [109.85, 100, 35.585],
        // B:[],
        C: [98.074, 100, 118.232],
        D50: [96.422, 100, 82.521],
        D55: [95.682, 100, 92.149],
        //daylight
        D65: [95.045592705167, 100, 108.9057750759878],
        D75: [94.972, 100, 122.638],
        //flourescent
        // F1: [],
        F2: [99.187, 100, 67.395],
        // F3: [],
        // F4: [],
        // F5: [],
        // F6:[],
        F7: [95.044, 100, 108.755],
        // F8: [],
        // F9: [],
        // F10: [],
        F11: [100.966, 100, 64.37],
        // F12: [],
        E: [100, 100, 100]
      },
      //1964  10°
      10: {
        //incadescent
        A: [111.144, 100, 35.2],
        C: [97.285, 100, 116.145],
        D50: [96.72, 100, 81.427],
        D55: [95.799, 100, 90.926],
        //daylight
        D65: [94.811, 100, 107.304],
        D75: [94.416, 100, 120.641],
        //flourescent
        F2: [103.28, 100, 69.026],
        F7: [95.792, 100, 107.687],
        F11: [103.866, 100, 65.627],
        E: [100, 100, 100]
      }
    };
    xyz.max = xyz.whitepoint[2].D65;
    xyz.rgb = function(_xyz, white) {
      white = white || xyz.whitepoint[2].E;
      var x = _xyz[0] / white[0], y = _xyz[1] / white[1], z = _xyz[2] / white[2], r, g, b;
      r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
      g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
      b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    rgb_default.xyz = function(rgb, white) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
      var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
      var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
      white = white || xyz.whitepoint[2].E;
      return [x * white[0], y * white[1], z * white[2]];
    };
    xyz_default = xyz;
  }
});

// node_modules/color-space/luv.js
var luv_default;
var init_luv = __esm({
  "node_modules/color-space/luv.js"() {
    init_xyz();
    luv_default = {
      name: "luv",
      //NOTE: luv has no rigidly defined limits
      //easyrgb fails to get proper coords
      //boronine states no rigid limits
      //colorMine refers this ones:
      min: [0, -134, -140],
      max: [100, 224, 122],
      channel: ["lightness", "u", "v"],
      alias: ["LUV", "cieluv", "cie1976"],
      xyz: function(arg, i, o) {
        var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
        l = arg[0], u = arg[1], v = arg[2];
        if (l === 0)
          return [0, 0, 0];
        var k = 0.0011070564598794539;
        i = i || "D65";
        o = o || 2;
        xn = xyz_default.whitepoint[o][i][0];
        yn = xyz_default.whitepoint[o][i][1];
        zn = xyz_default.whitepoint[o][i][2];
        un = 4 * xn / (xn + 15 * yn + 3 * zn);
        vn = 9 * yn / (xn + 15 * yn + 3 * zn);
        _u = u / (13 * l) + un || 0;
        _v = v / (13 * l) + vn || 0;
        y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;
        x = y * 9 * _u / (4 * _v) || 0;
        z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;
        return [x, y, z];
      }
    };
    xyz_default.luv = function(arg, i, o) {
      var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
      var e = 0.008856451679035631;
      var k = 903.2962962962961;
      i = i || "D65";
      o = o || 2;
      xn = xyz_default.whitepoint[o][i][0];
      yn = xyz_default.whitepoint[o][i][1];
      zn = xyz_default.whitepoint[o][i][2];
      un = 4 * xn / (xn + 15 * yn + 3 * zn);
      vn = 9 * yn / (xn + 15 * yn + 3 * zn);
      x = arg[0], y = arg[1], z = arg[2];
      _u = 4 * x / (x + 15 * y + 3 * z) || 0;
      _v = 9 * y / (x + 15 * y + 3 * z) || 0;
      var yr = y / yn;
      l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
      u = 13 * l * (_u - un);
      v = 13 * l * (_v - vn);
      return [l, u, v];
    };
  }
});

// node_modules/color-space/lchuv.js
var lchuv, lchuv_default;
var init_lchuv = __esm({
  "node_modules/color-space/lchuv.js"() {
    init_luv();
    init_xyz();
    lchuv = {
      name: "lchuv",
      channel: ["lightness", "chroma", "hue"],
      alias: ["LCHuv", "cielchuv"],
      min: [0, 0, 0],
      max: [100, 100, 360],
      luv: function(luv) {
        var l = luv[0], c = luv[1], h = luv[2], u, v, hr;
        hr = h / 360 * 2 * Math.PI;
        u = c * Math.cos(hr);
        v = c * Math.sin(hr);
        return [l, u, v];
      },
      xyz: function(arg) {
        return luv_default.xyz(lchuv.luv(arg));
      }
    };
    lchuv_default = lchuv;
    luv_default.lchuv = function(luv) {
      var l = luv[0], u = luv[1], v = luv[2];
      var c = Math.sqrt(u * u + v * v);
      var hr = Math.atan2(v, u);
      var h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      return [l, c, h];
    };
    xyz_default.lchuv = function(arg) {
      return luv_default.lchuv(xyz_default.luv(arg));
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-parse/index.js
function parse(cstr) {
  var m, parts = [], alpha = 1, space;
  if (typeof cstr === "number") {
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  }
  if (typeof cstr === "number")
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  cstr = String(cstr).toLowerCase();
  if (import_color_name.default[cstr]) {
    parts = import_color_name.default[cstr].slice();
    space = "rgb";
  } else if (cstr === "transparent") {
    alpha = 0;
    space = "rgb";
    parts = [0, 0, 0];
  } else if (cstr[0] === "#") {
    var base = cstr.slice(1);
    var size = base.length;
    var isShort = size <= 4;
    alpha = 1;
    if (isShort) {
      parts = [
        parseInt(base[0] + base[0], 16),
        parseInt(base[1] + base[1], 16),
        parseInt(base[2] + base[2], 16)
      ];
      if (size === 4) {
        alpha = parseInt(base[3] + base[3], 16) / 255;
      }
    } else {
      parts = [
        parseInt(base[0] + base[1], 16),
        parseInt(base[2] + base[3], 16),
        parseInt(base[4] + base[5], 16)
      ];
      if (size === 8) {
        alpha = parseInt(base[6] + base[7], 16) / 255;
      }
    }
    if (!parts[0])
      parts[0] = 0;
    if (!parts[1])
      parts[1] = 0;
    if (!parts[2])
      parts[2] = 0;
    space = "rgb";
  } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name = m[1];
    space = name.replace(/a$/, "");
    var dims = space === "cmyk" ? 4 : space === "gray" ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
    if (space === "color")
      space = parts.shift();
    parts = parts.map(function(x, i) {
      if (x[x.length - 1] === "%") {
        x = parseFloat(x) / 100;
        if (i === 3)
          return x;
        if (space === "rgb")
          return x * 255;
        if (space[0] === "h")
          return x * 100;
        if (space[0] === "l" && !i)
          return x * 100;
        if (space === "lab")
          return x * 125;
        if (space === "lch")
          return i < 2 ? x * 150 : x * 360;
        if (space[0] === "o" && !i)
          return x;
        if (space === "oklab")
          return x * 0.4;
        if (space === "oklch")
          return i < 2 ? x * 0.4 : x * 360;
        return x;
      }
      if (space[i] === "h" || i === 2 && space[space.length - 1] === "h") {
        if (baseHues[x] !== void 0)
          return baseHues[x];
        if (x.endsWith("deg"))
          return parseFloat(x);
        if (x.endsWith("turn"))
          return parseFloat(x) * 360;
        if (x.endsWith("grad"))
          return parseFloat(x) * 360 / 400;
        if (x.endsWith("rad"))
          return parseFloat(x) * 180 / Math.PI;
      }
      if (x === "none")
        return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function(value) {
      return parseFloat(value);
    });
    space = cstr.match(/([a-z])/ig)?.join("")?.toLowerCase() || "rgb";
  }
  return {
    space,
    values: parts,
    alpha
  };
}
var import_color_name, color_parse_default, baseHues;
var init_color_parse = __esm({
  "node_modules/color-parse/index.js"() {
    import_color_name = __toESM(require_color_name(), 1);
    color_parse_default = parse;
    baseHues = {
      red: 0,
      orange: 60,
      yellow: 120,
      green: 180,
      blue: 240,
      purple: 300
    };
  }
});

// node_modules/color-space/hsl.js
var hsl_default;
var init_hsl = __esm({
  "node_modules/color-space/hsl.js"() {
    init_rgb();
    hsl_default = {
      name: "hsl",
      min: [0, 0, 0],
      max: [360, 100, 100],
      channel: ["hue", "saturation", "lightness"],
      alias: ["HSL"],
      rgb: function(hsl) {
        var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
        if (s === 0)
          return val = l * 255, [val, val, val];
        t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (; i < 3; ) {
          t3 = h + 1 / 3 * -(i - 1);
          t3 < 0 ? t3++ : t3 > 1 && t3--;
          val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
          rgb[i++] = val * 255;
        }
        return rgb;
      }
    };
    rgb_default.hsl = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
  }
});

// node_modules/color-rgba/index.js
function rgba(color) {
  if (Array.isArray(color) && color.raw)
    color = String.raw(...arguments);
  if (color instanceof Number)
    color = +color;
  var values, i, l;
  var parsed = color_parse_default(color);
  if (!parsed.space)
    return [];
  const min = parsed.space[0] === "h" ? hsl_default.min : rgb_default.min;
  const max = parsed.space[0] === "h" ? hsl_default.max : rgb_default.max;
  values = Array(3);
  values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
  values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
  values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
  if (parsed.space[0] === "h") {
    values = hsl_default.rgb(values);
  }
  values.push(Math.min(Math.max(parsed.alpha, 0), 1));
  return values;
}
var init_color_rgba = __esm({
  "node_modules/color-rgba/index.js"() {
    init_color_parse();
    init_rgb();
    init_hsl();
  }
});

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}
var init_math = __esm({
  "node_modules/ol/math.js"() {
  }
});

// node_modules/ol/color.js
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}
function rgbaToLcha(color) {
  const output = xyz_default.lchuv(rgb_default.xyz(color));
  output[3] = color[3];
  return output;
}
function lchaToRgba(color) {
  const output = xyz_default.rgb(lchuv_default.xyz(color));
  output[3] = color[3];
  return output;
}
function fromString(s) {
  if (cache.hasOwnProperty(s)) {
    return cache[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key in cache) {
      if ((i++ & 3) === 0) {
        delete cache[key];
        --cacheSize;
      }
    }
  }
  const color = rgba(s);
  if (color.length !== 4) {
    throw new Error('Failed to parse "' + s + '" as color');
  }
  for (const c of color) {
    if (isNaN(c)) {
      throw new Error('Failed to parse "' + s + '" as color');
    }
  }
  normalize(color);
  cache[s] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString2(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}
function isStringColor(s) {
  try {
    fromString(s);
    return true;
  } catch (_) {
    return false;
  }
}
var MAX_CACHE_SIZE, cache, cacheSize;
var init_color = __esm({
  "node_modules/ol/color.js"() {
    init_lchuv();
    init_color_rgba();
    init_rgb();
    init_xyz();
    init_math();
    MAX_CACHE_SIZE = 1024;
    cache = {};
    cacheSize = 0;
  }
});

// node_modules/ol/style/IconImageCache.js
function getKey(src, crossOrigin, color) {
  const colorString = color ? asString(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var IconImageCache, shared;
var init_IconImageCache = __esm({
  "node_modules/ol/style/IconImageCache.js"() {
    init_color();
    IconImageCache = class {
      constructor() {
        this.cache_ = {};
        this.cacheSize_ = 0;
        this.maxCacheSize_ = 32;
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        this.cache_ = {};
        this.cacheSize_ = 0;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
      }
      /**
       * FIXME empty description for jsdoc
       */
      expire() {
        if (this.canExpireCache()) {
          let i = 0;
          for (const key in this.cache_) {
            const iconImage = this.cache_[key];
            if ((i++ & 3) === 0 && !iconImage.hasListener()) {
              delete this.cache_[key];
              --this.cacheSize_;
            }
          }
        }
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      get(src, crossOrigin, color) {
        const key = getKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @param {import("./IconImage.js").default} iconImage Icon image.
       */
      set(src, crossOrigin, color, iconImage) {
        const key = getKey(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
      }
      /**
       * Set the cache size of the icon cache. Default is `32`. Change this value when
       * your map uses more than 32 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
      }
    };
    shared = new IconImageCache();
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_Property();
    init_util();
    init_asserts();
    init_math();
    BaseLayer = class extends Object_default {
      /**
       * @param {Options} options Layer options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options.background;
        const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options.properties);
        }
        properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
        properties[Property_default.Z_INDEX] = options.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      /**
       * Get the background for this layer.
       * @return {BackgroundColor|false} Layer background.
       */
      getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */
      getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      getLayerState(managed) {
        const state = this.state_ || /** @type {?} */
        {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        return abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(Property_default.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer. Returns Infinity if
       * the layer has no maximum resolution set.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      getMaxResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer. Returns 0 if
       * the layer has no minimum resolution set.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      getMinResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer. Returns -Infinity if
       * the layer has no minimum zoom set.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer. Returns Infinity if
       * the layer has no maximum zoom set.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      getOpacity() {
        return (
          /** @type {number} */
          this.get(Property_default.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return abstract();
      }
      /**
       * Return the value of this layer's `visible` property. To find out whether the layer
       * is visible on a map, use `isVisible()` instead.
       * @return {boolean} The value of the `visible` property of the layer.
       * @observable
       * @api
       */
      getVisible() {
        return (
          /** @type {boolean} */
          this.get(Property_default.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. Returns undefined if the layer is unmanaged.
       * @return {number|undefined} The Z-index of the layer.
       * @observable
       * @api
       */
      getZIndex() {
        return (
          /** @type {number|undefined} */
          this.get(Property_default.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

// node_modules/ol/render/EventType.js
var EventType_default2;
var init_EventType2 = __esm({
  "node_modules/ol/render/EventType.js"() {
    EventType_default2 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: "prerender",
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered before layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: "precompose",
      /**
       * Triggered after layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: "postcompose",
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: "rendercomplete"
    };
  }
});

// node_modules/ol/ViewHint.js
var ViewHint_default;
var init_ViewHint = __esm({
  "node_modules/ol/ViewHint.js"() {
    ViewHint_default = {
      ANIMATING: 0,
      INTERACTING: 1
    };
  }
});

// node_modules/ol/ViewProperty.js
var ViewProperty_default;
var init_ViewProperty = __esm({
  "node_modules/ol/ViewProperty.js"() {
    ViewProperty_default = {
      CENTER: "center",
      RESOLUTION: "resolution",
      ROTATION: "rotation"
    };
  }
});

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE;
var init_common = __esm({
  "node_modules/ol/tilegrid/common.js"() {
    DEFAULT_MAX_ZOOM = 42;
    DEFAULT_TILE_SIZE = 256;
  }
});

// node_modules/ol/proj/Units.js
var METERS_PER_UNIT;
var init_Units = __esm({
  "node_modules/ol/proj/Units.js"() {
    METERS_PER_UNIT = {
      // use the radius of the Normal sphere
      "radians": 6370997 / (2 * Math.PI),
      "degrees": 2 * Math.PI * 6370997 / 360,
      "ft": 0.3048,
      "m": 1,
      "us-ft": 1200 / 3937
    };
  }
});

// node_modules/ol/proj/Projection.js
var Projection, Projection_default;
var init_Projection = __esm({
  "node_modules/ol/proj/Projection.js"() {
    init_Units();
    Projection = class {
      /**
       * @param {Options} options Projection options.
       */
      constructor(options) {
        this.code_ = options.code;
        this.units_ = /** @type {import("./Units.js").Units} */
        options.units;
        this.extent_ = options.extent !== void 0 ? options.extent : null;
        this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
        this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
        this.global_ = options.global !== void 0 ? options.global : false;
        this.canWrapX_ = !!(this.global_ && this.extent_);
        this.getPointResolutionFunc_ = options.getPointResolution;
        this.defaultTileGrid_ = null;
        this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      canWrapX() {
        return this.canWrapX_;
      }
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      getCode() {
        return this.code_;
      }
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").Units} Units.
       * @api
       */
      getUnits() {
        return this.units_;
      }
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      }
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getWorldExtent() {
        return this.worldExtent_;
      }
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      getAxisOrientation() {
        return this.axisOrientation_;
      }
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      isGlobal() {
        return this.global_;
      }
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
      }
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      getDefaultTileGrid() {
        return this.defaultTileGrid_;
      }
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
      }
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
      }
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
      }
      /**
       * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
      }
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */
      getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
      }
    };
    Projection_default = Projection;
  }
});

// node_modules/ol/proj/epsg3857.js
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}
var RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, MAX_SAFE_Y, EPSG3857Projection, PROJECTIONS;
var init_epsg3857 = __esm({
  "node_modules/ol/proj/epsg3857.js"() {
    init_Projection();
    RADIUS = 6378137;
    HALF_SIZE = Math.PI * RADIUS;
    EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
    WORLD_EXTENT = [-180, -85, 180, 85];
    MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
    EPSG3857Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       */
      constructor(code) {
        super({
          code,
          units: "m",
          extent: EXTENT,
          global: true,
          worldExtent: WORLD_EXTENT,
          getPointResolution: function(resolution, point) {
            return resolution / Math.cosh(point[1] / RADIUS);
          }
        });
      }
    };
    PROJECTIONS = [
      new EPSG3857Projection("EPSG:3857"),
      new EPSG3857Projection("EPSG:102100"),
      new EPSG3857Projection("EPSG:102113"),
      new EPSG3857Projection("EPSG:900913"),
      new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
      new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
    ];
  }
});

// node_modules/ol/proj/epsg4326.js
var RADIUS2, EXTENT2, METERS_PER_UNIT2, EPSG4326Projection, PROJECTIONS2;
var init_epsg4326 = __esm({
  "node_modules/ol/proj/epsg4326.js"() {
    init_Projection();
    RADIUS2 = 6378137;
    EXTENT2 = [-180, -90, 180, 90];
    METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
    EPSG4326Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       * @param {string} [axisOrientation] Axis orientation.
       */
      constructor(code, axisOrientation) {
        super({
          code,
          units: "degrees",
          extent: EXTENT2,
          axisOrientation,
          global: true,
          metersPerUnit: METERS_PER_UNIT2,
          worldExtent: EXTENT2
        });
      }
    };
    PROJECTIONS2 = [
      new EPSG4326Projection("CRS:84"),
      new EPSG4326Projection("EPSG:4326", "neu"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
      new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
    ];
  }
});

// node_modules/ol/proj/projections.js
function clear2() {
  cache2 = {};
}
function get(code) {
  return cache2[code] || cache2[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add(code, projection) {
  cache2[code] = projection;
}
var cache2;
var init_projections = __esm({
  "node_modules/ol/proj/projections.js"() {
    cache2 = {};
  }
});

// node_modules/ol/proj/transforms.js
function clear3() {
  transforms = {};
}
function add2(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get2(sourceCode, destinationCode) {
  let transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}
var transforms;
var init_transforms = __esm({
  "node_modules/ol/proj/transforms.js"() {
    transforms = {};
  }
});

// node_modules/ol/coordinate.js
function add3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function(coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}
function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template.replace("{x}", coordinate[0].toFixed(fractionDigits)).replace("{y}", coordinate[1].toFixed(fractionDigits));
  }
  return "";
}
function equals3(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
function scale(coordinate, scale4) {
  coordinate[0] *= scale4;
  coordinate[1] *= scale4;
  return coordinate;
}
function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, "{x}, {y}", fractionDigits);
}
function wrapX2(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}
var init_coordinate = __esm({
  "node_modules/ol/coordinate.js"() {
    init_extent();
  }
});

// node_modules/ol/sphere.js
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
var DEFAULT_RADIUS;
var init_sphere = __esm({
  "node_modules/ol/sphere.js"() {
    init_math();
    DEFAULT_RADIUS = 63710088e-1;
  }
});

// node_modules/ol/console.js
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}
var levels, level;
var init_console = __esm({
  "node_modules/ol/console.js"() {
    levels = {
      info: 1,
      warn: 2,
      error: 3,
      none: 4
    };
    level = levels.info;
  }
});

// node_modules/ol/proj.js
var proj_exports = {};
__export(proj_exports, {
  METERS_PER_UNIT: () => METERS_PER_UNIT,
  Projection: () => Projection_default,
  addCommon: () => addCommon,
  addCoordinateTransforms: () => addCoordinateTransforms,
  addEquivalentProjections: () => addEquivalentProjections,
  addEquivalentTransforms: () => addEquivalentTransforms,
  addProjection: () => addProjection,
  addProjections: () => addProjections,
  clearAllProjections: () => clearAllProjections,
  clearUserProjection: () => clearUserProjection,
  cloneTransform: () => cloneTransform,
  createProjection: () => createProjection,
  createSafeCoordinateTransform: () => createSafeCoordinateTransform,
  createTransformFromCoordinateTransform: () => createTransformFromCoordinateTransform,
  disableCoordinateWarning: () => disableCoordinateWarning,
  equivalent: () => equivalent,
  fromLonLat: () => fromLonLat,
  fromUserCoordinate: () => fromUserCoordinate,
  fromUserExtent: () => fromUserExtent,
  fromUserResolution: () => fromUserResolution,
  get: () => get3,
  getPointResolution: () => getPointResolution,
  getTransform: () => getTransform,
  getTransformFromProjections: () => getTransformFromProjections,
  getUserProjection: () => getUserProjection,
  identityTransform: () => identityTransform,
  setUserProjection: () => setUserProjection,
  toLonLat: () => toLonLat,
  toUserCoordinate: () => toUserCoordinate,
  toUserExtent: () => toUserExtent,
  toUserResolution: () => toUserResolution,
  transform: () => transform,
  transformExtent: () => transformExtent,
  transformWithProjections: () => transformWithProjections,
  useGeographic: () => useGeographic
});
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output) {
  if (output !== void 0 && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add(projection.getCode(), projection);
  add2(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  return typeof projectionLike === "string" ? get(
    /** @type {string} */
    projectionLike
  ) : (
    /** @type {Projection} */
    projectionLike || null
  );
}
function getPointResolution(projection, resolution, point, units) {
  projection = get3(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get3("EPSG:4326")
      );
      if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add2(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add2(projection1, projection2, forwardTransform);
      add2(projection2, projection1, inverseTransform);
    });
  });
}
function clearAllProjections() {
  clear2();
  clear3();
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(input, output, dimension) {
      const length = input.length;
      dimension = dimension !== void 0 ? dimension : 2;
      output = output !== void 0 ? output : new Array(length);
      for (let i = 0; i < length; i += dimension) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get3(source);
  const destProj = get3(destination);
  add2(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward)
  );
  add2(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse)
  );
}
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function toLonLat(coordinate, projection) {
  const lonLat = transform(
    coordinate,
    projection !== void 0 ? projection : "EPSG:3857",
    "EPSG:4326"
  );
  const lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = modulo(lon + 180, 360) - 180;
  }
  return lonLat;
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
  const transformFunc = getTransformFromProjections(
    sourceProjection,
    destinationProjection
  );
  return transformFunc(point);
}
function setUserProjection(projection) {
  userProjection = get3(projection);
}
function clearUserProjection() {
  userProjection = null;
}
function getUserProjection() {
  return userProjection;
}
function useGeographic() {
  setUserProjection("EPSG:4326");
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceMetersPerUnit = get3(sourceProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }
  const destMetersPerUnit = get3(destProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform2(coord);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
var showCoordinateWarning, userProjection;
var init_proj = __esm({
  "node_modules/ol/proj.js"() {
    init_Projection();
    init_epsg3857();
    init_epsg4326();
    init_Units();
    init_projections();
    init_transforms();
    init_extent();
    init_math();
    init_coordinate();
    init_sphere();
    init_console();
    showCoordinateWarning = true;
    userProjection = null;
    addCommon();
  }
});

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none(center) {
  return center;
}
var init_centerconstraint = __esm({
  "node_modules/ol/centerconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}
var init_resolutionconstraint = __esm({
  "node_modules/ol/resolutionconstraint.js"() {
    init_math();
    init_extent();
    init_array();
  }
});

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}
var init_rotationconstraint = __esm({
  "node_modules/ol/rotationconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/easing.js
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
  return t;
}
var init_easing = __esm({
  "node_modules/ol/easing.js"() {
  }
});

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset, end, stride, transform2, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate2(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale2(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
var init_transform2 = __esm({
  "node_modules/ol/geom/flat/transform.js"() {
  }
});

// node_modules/ol/geom/Geometry.js
var tmpTransform, Geometry, Geometry_default;
var init_Geometry = __esm({
  "node_modules/ol/geom/Geometry.js"() {
    init_Object();
    init_util();
    init_transform();
    init_extent();
    init_proj();
    init_functions();
    init_transform2();
    tmpTransform = create();
    Geometry = class extends Object_default {
      constructor() {
        super();
        this.extent_ = createEmpty();
        this.extentRevision_ = -1;
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = 0;
        this.simplifyTransformedInternal = memoizeOne(
          (revision, squaredTolerance, transform2) => {
            if (!transform2) {
              return this.getSimplifiedGeometry(squaredTolerance);
            }
            const clone2 = this.clone();
            clone2.applyTransform(transform2);
            return clone2.getSimplifiedGeometry(squaredTolerance);
          }
        );
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform2) {
        return this.simplifyTransformedInternal(
          this.getRevision(),
          squaredTolerance,
          transform2
        );
      }
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      clone() {
        return abstract();
      }
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return abstract();
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        const coord = this.getClosestPoint([x, y]);
        return coord[0] === x && coord[1] === y;
      }
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      }
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      }
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return abstract();
      }
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
          const extent2 = this.computeExtent(this.extent_);
          if (isNaN(extent2[0]) || isNaN(extent2[1])) {
            createOrUpdateEmpty(extent2);
          }
          this.extentRevision_ = this.getRevision();
        }
        return returnOrUpdate(this.extent_, extent);
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        abstract();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        abstract();
      }
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return abstract();
      }
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {Type} Geometry type.
       */
      getType() {
        return abstract();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      applyTransform(transformFn) {
        abstract();
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      intersectsExtent(extent) {
        return abstract();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        abstract();
      }
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {Geometry} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      transform(source, destination) {
        const sourceProj = get3(source);
        const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
          const pixelExtent = sourceProj.getExtent();
          const projectedExtent = sourceProj.getWorldExtent();
          const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform,
            projectedExtent[0],
            projectedExtent[3],
            scale4,
            -scale4,
            0,
            0,
            0
          );
          transform2D(
            inCoordinates,
            0,
            inCoordinates.length,
            stride,
            tmpTransform,
            outCoordinates
          );
          return getTransform(sourceProj, destination)(
            inCoordinates,
            outCoordinates,
            stride
          );
        } : getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
      }
    };
    Geometry_default = Geometry;
  }
});

// node_modules/ol/geom/SimpleGeometry.js
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
function transformGeom2D(simpleGeometry, transform2, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return transform2D(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform2,
    dest
  );
}
var SimpleGeometry, SimpleGeometry_default;
var init_SimpleGeometry = __esm({
  "node_modules/ol/geom/SimpleGeometry.js"() {
    init_Geometry();
    init_util();
    init_extent();
    init_transform2();
    SimpleGeometry = class extends Geometry_default {
      constructor() {
        super();
        this.layout = "XY";
        this.stride = 2;
        this.flatCoordinates;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return createOrUpdateFromFlatCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * @abstract
       * @return {Array<*> | null} Coordinates.
       */
      getCoordinates() {
        return abstract();
      }
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getFlatCoordinates() {
        return this.flatCoordinates;
      }
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      getLastCoordinate() {
        return this.flatCoordinates.slice(
          this.flatCoordinates.length - this.stride
        );
      }
      /**
       * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
       * @return {import("./Geometry.js").GeometryLayout} Layout.
       * @api
       */
      getLayout() {
        return this.layout;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
          return simplifiedGeometry;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride;
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      }
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      setCoordinates(coordinates2, layout) {
        abstract();
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      setLayout(layout, coordinates2, nesting) {
        let stride;
        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (let i = 0; i < nesting; ++i) {
            if (coordinates2.length === 0) {
              this.layout = "XY";
              this.stride = 2;
              return;
            }
            coordinates2 = /** @type {Array<unknown>} */
            coordinates2[0];
          }
          stride = coordinates2.length;
          layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */
      applyTransform(transformFn) {
        if (this.flatCoordinates) {
          transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
          this.changed();
        }
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          rotate2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            angle,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        if (sy === void 0) {
          sy = sx;
        }
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          scale2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            sx,
            sy,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          translate(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            deltaX,
            deltaY,
            flatCoordinates
          );
          this.changed();
        }
      }
    };
    SimpleGeometry_default = SimpleGeometry;
  }
});

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = end;
  }
  return minSquaredDistance;
}
var init_closest = __esm({
  "node_modules/ol/geom/flat/closest.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}
var init_deflate = __esm({
  "node_modules/ol/geom/flat/deflate.js"() {
  }
});

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance2 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance2 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance2;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
var init_simplify = __esm({
  "node_modules/ol/geom/flat/simplify.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      coordinatesss[i]
    );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}
var init_inflate = __esm({
  "node_modules/ol/geom/flat/inflate.js"() {
  }
});

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}
var init_area = __esm({
  "node_modules/ol/geom/flat/area.js"() {
  }
});

// node_modules/ol/geom/LinearRing.js
var LinearRing, LinearRing_default;
var init_LinearRing = __esm({
  "node_modules/ol/geom/LinearRing.js"() {
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_simplify();
    init_inflate();
    init_area();
    LinearRing = class _LinearRing extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       */
      clone() {
        return new _LinearRing(this.flatCoordinates.slice(), this.layout);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRing(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LinearRing(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "LinearRing";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return false;
      }
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LinearRing_default = LinearRing;
  }
});

// node_modules/ol/geom/Point.js
var Point_exports = {};
__export(Point_exports, {
  default: () => Point_default
});
var Point, Point_default;
var init_Point = __esm({
  "node_modules/ol/geom/Point.js"() {
    init_SimpleGeometry();
    init_extent();
    init_deflate();
    init_math();
    Point = class _Point extends SimpleGeometry_default {
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.setCoordinates(coordinates2, layout);
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       */
      clone() {
        const point = new _Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance2 = squaredDistance(
          x,
          y,
          flatCoordinates[0],
          flatCoordinates[1]
        );
        if (squaredDistance2 < minSquaredDistance) {
          const stride = this.stride;
          for (let i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[i];
          }
          closestPoint.length = stride;
          return squaredDistance2;
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       */
      getCoordinates() {
        return this.flatCoordinates.slice();
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Point";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinate(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    Point_default = Point;
  }
});

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}
var init_contains = __esm({
  "node_modules/ol/geom/flat/contains.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}
var init_interiorpoint = __esm({
  "node_modules/ol/geom/flat/interiorpoint.js"() {
    init_array();
    init_contains();
  }
});

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}
var init_segments = __esm({
  "node_modules/ol/geom/flat/segments.js"() {
  }
});

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  const coordinatesExtent = extendFlatCoordinates(
    createEmpty(),
    flatCoordinates,
    offset,
    end,
    stride
  );
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}
var init_intersectsextent = __esm({
  "node_modules/ol/geom/flat/intersectsextent.js"() {
    init_extent();
    init_segments();
    init_contains();
  }
});

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}
var init_reverse = __esm({
  "node_modules/ol/geom/flat/reverse.js"() {
  }
});

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === void 0) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset = end;
  }
  return endss;
}
var init_orient = __esm({
  "node_modules/ol/geom/flat/orient.js"() {
    init_reverse();
  }
});

// node_modules/ol/geom/Polygon.js
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
var Polygon, Polygon_default;
var init_Polygon = __esm({
  "node_modules/ol/geom/Polygon.js"() {
    init_LinearRing();
    init_Point();
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_array();
    init_interiorpoint();
    init_inflate();
    init_intersectsextent();
    init_orient();
    init_area();
    init_contains();
    init_simplify();
    Polygon = class _Polygon extends SimpleGeometry_default {
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.flatInteriorPointRevision_ = -1;
        this.flatInteriorPoint_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      appendLinearRing(linearRing2) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
        } else {
          extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       */
      clone() {
        const polygon = new _Polygon(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        polygon.applyProperties(this);
        return polygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        return linearRingsContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          x,
          y
        );
      }
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRings(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * @return {Array<number>} Interior point.
       */
      getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            flatCenter,
            0
          );
          this.flatInteriorPointRevision_ = this.getRevision();
        }
        return (
          /** @type {import("../coordinate.js").Coordinate} */
          this.flatInteriorPoint_
        );
      }
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoint() {
        return new Point_default(this.getFlatInteriorPoint(), "XYM");
      }
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      getLinearRingCount() {
        return this.ends_.length;
      }
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing|null} Linear ring.
       * @api
       */
      getLinearRing(index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }
        return new LinearRing_default(
          this.flatCoordinates.slice(
            index === 0 ? 0 : this.ends_[index - 1],
            this.ends_[index]
          ),
          this.layout
        );
      }
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings2 = [];
        let offset = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const linearRing2 = new LinearRing_default(
            flatCoordinates.slice(offset, end),
            layout
          );
          linearRings2.push(linearRing2);
          offset = end;
        }
        return linearRings2;
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRings(
              this.orientedFlatCoordinates_,
              0,
              this.ends_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Polygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLinearRingArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    Polygon_default = Polygon;
  }
});

// node_modules/ol/View.js
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var DEFAULT_MIN_ZOOM, View, View_default;
var init_View = __esm({
  "node_modules/ol/View.js"() {
    init_Object();
    init_ViewHint();
    init_ViewProperty();
    init_common();
    init_proj();
    init_functions();
    init_coordinate();
    init_asserts();
    init_centerconstraint();
    init_math();
    init_resolutionconstraint();
    init_rotationconstraint();
    init_easing();
    init_extent();
    init_array();
    init_Polygon();
    DEFAULT_MIN_ZOOM = 0;
    View = class extends Object_default {
      /**
       * @param {ViewOptions} [options] View options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        options = Object.assign({}, options);
        this.hints_ = [0, 0];
        this.animations_ = [];
        this.updateAnimationKey_;
        this.projection_ = createProjection(options.projection, "EPSG:3857");
        this.viewportSize_ = [100, 100];
        this.targetCenter_ = null;
        this.targetResolution_;
        this.targetRotation_;
        this.nextCenter_ = null;
        this.nextResolution_;
        this.nextRotation_;
        this.cancelAnchor_ = void 0;
        if (options.projection) {
          disableCoordinateWarning();
        }
        if (options.center) {
          options.center = fromUserCoordinate(options.center, this.projection_);
        }
        if (options.extent) {
          options.extent = fromUserExtent(options.extent, this.projection_);
        }
        this.applyOptions_(options);
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      applyOptions_(options) {
        const properties = Object.assign({}, options);
        for (const key in ViewProperty_default) {
          delete properties[key];
        }
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        this.minResolution_ = resolutionConstraintInfo.minResolution;
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        this.resolutions_ = options.resolutions;
        this.padding_ = options.padding;
        this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
        this.setCenterInternal(
          options.center !== void 0 ? options.center : null
        );
        if (options.resolution !== void 0) {
          this.setResolution(options.resolution);
        } else if (options.zoom !== void 0) {
          this.setZoom(options.zoom);
        }
      }
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */
      get padding() {
        return this.padding_;
      }
      set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
          const newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          const resolution = this.getResolution();
          const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      }
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        if (options.resolution !== void 0) {
          options.resolution = this.getResolution();
        } else {
          options.zoom = this.getZoom();
        }
        options.center = this.getCenterInternal();
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
      }
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
          this.resolveConstraints(0);
        }
        const args = new Array(arguments.length);
        for (let i = 0; i < args.length; ++i) {
          let options = arguments[i];
          if (options.center) {
            options = Object.assign({}, options);
            options.center = fromUserCoordinate(
              options.center,
              this.getProjection()
            );
          }
          if (options.anchor) {
            options = Object.assign({}, options);
            options.anchor = fromUserCoordinate(
              options.anchor,
              this.getProjection()
            );
          }
          args[i] = options;
        }
        this.animateInternal.apply(this, args);
      }
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
          callback = arguments[animationCount - 1];
          --animationCount;
        }
        let i = 0;
        for (; i < animationCount && !this.isDef(); ++i) {
          const state = arguments[i];
          if (state.center) {
            this.setCenterInternal(state.center);
          }
          if (state.zoom !== void 0) {
            this.setZoom(state.zoom);
          } else if (state.resolution) {
            this.setResolution(state.resolution);
          }
          if (state.rotation !== void 0) {
            this.setRotation(state.rotation);
          }
        }
        if (i === animationCount) {
          if (callback) {
            animationCallback(callback, true);
          }
          return;
        }
        let start = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for (; i < animationCount; ++i) {
          const options = (
            /** @type {AnimationOptions} */
            arguments[i]
          );
          const animation = {
            start,
            complete: false,
            anchor: options.anchor,
            duration: options.duration !== void 0 ? options.duration : 1e3,
            easing: options.easing || inAndOut,
            callback
          };
          if (options.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options.center.slice();
            center = animation.targetCenter;
          }
          if (options.zoom !== void 0) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this.getResolutionForZoom(options.zoom);
            resolution = animation.targetResolution;
          } else if (options.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options.resolution;
            resolution = animation.targetResolution;
          }
          if (options.rotation !== void 0) {
            animation.sourceRotation = rotation;
            const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          }
          if (isNoopAnimation(animation)) {
            animation.complete = true;
          } else {
            start += animation.duration;
          }
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint_default.ANIMATING, 1);
        this.updateAnimations_();
      }
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      getAnimating() {
        return this.hints_[ViewHint_default.ANIMATING] > 0;
      }
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      getInteracting() {
        return this.hints_[ViewHint_default.INTERACTING] > 0;
      }
      /**
       * Cancel any ongoing animations.
       * @api
       */
      cancelAnimations() {
        this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
        let anchor;
        for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
          const series = this.animations_[i];
          if (series[0].callback) {
            animationCallback(series[0].callback, false);
          }
          if (!anchor) {
            for (let j = 0, jj = series.length; j < jj; ++j) {
              const animation = series[j];
              if (!animation.complete) {
                anchor = animation.anchor;
                break;
              }
            }
          }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
      }
      /**
       * Update all animations.
       */
      updateAnimations_() {
        if (this.updateAnimationKey_ !== void 0) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = void 0;
        }
        if (!this.getAnimating()) {
          return;
        }
        const now = Date.now();
        let more = false;
        for (let i = this.animations_.length - 1; i >= 0; --i) {
          const series = this.animations_[i];
          let seriesComplete = true;
          for (let j = 0, jj = series.length; j < jj; ++j) {
            const animation = series[j];
            if (animation.complete) {
              continue;
            }
            const elapsed = now - animation.start;
            let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }
            const progress = animation.easing(fraction);
            if (animation.sourceCenter) {
              const x0 = animation.sourceCenter[0];
              const y0 = animation.sourceCenter[1];
              const x1 = animation.targetCenter[0];
              const y1 = animation.targetCenter[1];
              this.nextCenter_ = animation.targetCenter;
              const x = x0 + progress * (x1 - x0);
              const y = y0 + progress * (y1 - y0);
              this.targetCenter_ = [x, y];
            }
            if (animation.sourceResolution && animation.targetResolution) {
              const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
              if (animation.anchor) {
                const size = this.getViewportSize_(this.getRotation());
                const constrainedResolution = this.constraints_.resolution(
                  resolution,
                  0,
                  size,
                  true
                );
                this.targetCenter_ = this.calculateCenterZoom(
                  constrainedResolution,
                  animation.anchor
                );
              }
              this.nextResolution_ = animation.targetResolution;
              this.targetResolution_ = resolution;
              this.applyTargetState_(true);
            }
            if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
              const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
              if (animation.anchor) {
                const constrainedRotation = this.constraints_.rotation(
                  rotation,
                  true
                );
                this.targetCenter_ = this.calculateCenterRotate(
                  constrainedRotation,
                  animation.anchor
                );
              }
              this.nextRotation_ = animation.targetRotation;
              this.targetRotation_ = rotation;
            }
            this.applyTargetState_(true);
            more = true;
            if (!animation.complete) {
              break;
            }
          }
          if (seriesComplete) {
            this.animations_[i] = null;
            this.setHint(ViewHint_default.ANIMATING, -1);
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
            const callback = series[0].callback;
            if (callback) {
              animationCallback(callback, true);
            }
          }
        }
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === void 0) {
          this.updateAnimationKey_ = requestAnimationFrame(
            this.updateAnimations_.bind(this)
          );
        }
      }
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== void 0) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate(center, rotation - this.getRotation());
          add3(center, anchor);
        }
        return center;
      }
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== void 0 && currentResolution !== void 0) {
          const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x, y];
        }
        return center;
      }
      /**
       * Returns the current viewport size.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
          const w = size[0];
          const h = size[1];
          return [
            Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
            Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
          ];
        }
        return size;
      }
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
       */
      setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
        if (!this.getAnimating()) {
          this.resolveConstraints(0);
        }
      }
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      getCenter() {
        const center = this.getCenterInternal();
        if (!center) {
          return center;
        }
        return toUserCoordinate(center, this.getProjection());
      }
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      getCenterInternal() {
        return (
          /** @type {import("./coordinate.js").Coordinate|undefined} */
          this.get(ViewProperty_default.CENTER)
        );
      }
      /**
       * @return {Constraints} Constraints.
       */
      getConstraints() {
        return this.constraints_;
      }
      /**
       * @return {boolean} Resolution constraint is set
       */
      getConstrainResolution() {
        return this.get("constrainResolution");
      }
      /**
       * @param {Array<number>} [hints] Destination array.
       * @return {Array<number>} Hint.
       */
      getHints(hints) {
        if (hints !== void 0) {
          hints[0] = this.hints_[0];
          hints[1] = this.hints_[1];
          return hints;
        }
        return this.hints_.slice();
      }
      /**
       * Calculate the extent for the current view state and the passed box size.
       * @param {import("./size.js").Size} [size] The pixel dimensions of the box
       * into which the calculated extent should fit. Defaults to the size of the
       * map the view is associated with.
       * If no map or multiple maps are connected to the view, provide the desired
       * box size (e.g. `map.getSize()`).
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return toUserExtent(extent, this.getProjection());
      }
      /**
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
       * the map's last known viewport size will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = (
          /** @type {!import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        assert(center, "The view center is not defined");
        const resolution = (
          /** @type {!number} */
          this.getResolution()
        );
        assert(resolution !== void 0, "The view resolution is not defined");
        const rotation = (
          /** @type {!number} */
          this.getRotation()
        );
        assert(rotation !== void 0, "The view rotation is not defined");
        return getForViewAndSize(center, resolution, rotation, size);
      }
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      getMaxResolution() {
        return this.maxResolution_;
      }
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      getMinResolution() {
        return this.minResolution_;
      }
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.minResolution_)
        );
      }
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      }
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.maxResolution_)
        );
      }
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      }
      /**
       * Set whether the view should allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      }
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      getProjection() {
        return this.projection_;
      }
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      getResolution() {
        return (
          /** @type {number|undefined} */
          this.get(ViewProperty_default.RESOLUTION)
        );
      }
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal(
          fromUserExtent(extent, this.getProjection()),
          size
        );
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = getWidth(extent) / size[0];
        const yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      }
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Resolution for value function.
       */
      getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          }
        );
      }
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      getRotation() {
        return (
          /** @type {number} */
          this.get(ViewProperty_default.ROTATION)
        );
      }
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Value for resolution function.
       */
      getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
          }
        );
      }
      /**
       * Returns the size of the viewport minus padding.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size reduced by the padding.
       */
      getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) {
          size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
          ];
        }
        return size;
      }
      /**
       * @return {State} View state.
       */
      getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = (
          /** @type {import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        const padding = this.padding_;
        if (padding) {
          const reducedSize = this.getViewportSizeMinusPadding_();
          center = calculateCenterOn(
            center,
            this.getViewportSize_(),
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
        }
        return {
          center: center.slice(0),
          projection: projection !== void 0 ? projection : null,
          resolution,
          nextCenter: this.nextCenter_,
          nextResolution: this.nextResolution_,
          nextRotation: this.nextRotation_,
          rotation,
          zoom: this.getZoom()
        };
      }
      /**
       * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
       */
      getViewStateAndExtent() {
        return {
          viewState: this.getState(),
          extent: this.calculateExtent()
        };
      }
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== void 0) {
          zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
      }
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
          const nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset = nearest;
          max = this.resolutions_[nearest];
          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      }
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      getResolutionForZoom(zoom) {
        if (this.resolutions_) {
          if (this.resolutions_.length <= 1) {
            return 0;
          }
          const baseLevel = clamp(
            Math.floor(zoom),
            0,
            this.resolutions_.length - 2
          );
          const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
          return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions} [options] Options.
       * @api
       */
      fit(geometryOrExtent, options) {
        let geometry;
        assert(
          Array.isArray(geometryOrExtent) || typeof /** @type {?} */
          geometryOrExtent.getSimplifiedGeometry === "function",
          "Invalid extent or geometry provided as `geometry`"
        );
        if (Array.isArray(geometryOrExtent)) {
          assert(
            !isEmpty2(geometryOrExtent),
            "Cannot fit empty extent provided as `geometry`"
          );
          const extent = fromUserExtent(geometryOrExtent, this.getProjection());
          geometry = fromExtent(extent);
        } else if (geometryOrExtent.getType() === "Circle") {
          const extent = fromUserExtent(
            geometryOrExtent.getExtent(),
            this.getProjection()
          );
          geometry = fromExtent(extent);
          geometry.rotate(this.getRotation(), getCenter(extent));
        } else {
          const userProjection2 = getUserProjection();
          if (userProjection2) {
            geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
            geometryOrExtent.clone().transform(userProjection2, this.getProjection());
          } else {
            geometry = geometryOrExtent;
          }
        }
        this.fitInternal(geometry, options);
      }
      /**
       * Calculate rotated extent
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @return {import("./extent").Extent} The rotated extent for the geometry.
       */
      rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for (let i = 0, ii = coords.length; i < ii; i += stride) {
          const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
          const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }
        return [minRotX, minRotY, maxRotX, maxRotY];
      }
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions} [options] Options.
       */
      fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) {
          size = this.getViewportSizeMinusPadding_();
        }
        const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
        const nearest = options.nearest !== void 0 ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== void 0) {
          minResolution = options.minResolution;
        } else if (options.maxZoom !== void 0) {
          minResolution = this.getResolutionForZoom(options.maxZoom);
        } else {
          minResolution = 0;
        }
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([centerX, centerY], resolution);
        const callback = options.callback ? options.callback : VOID;
        if (options.duration !== void 0) {
          this.animateInternal(
            {
              resolution,
              center,
              duration: options.duration,
              easing: options.easing
            },
            callback
          );
        } else {
          this.targetResolution_ = resolution;
          this.targetCenter_ = center;
          this.applyTargetState_(false, true);
          animationCallback(callback, true);
        }
      }
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      centerOn(coordinate, size, position) {
        this.centerOnInternal(
          fromUserCoordinate(coordinate, this.getProjection()),
          size,
          position
        );
      }
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(
          calculateCenterOn(
            coordinate,
            size,
            position,
            this.getResolution(),
            this.getRotation()
          )
        );
      }
      /**
       * Calculates the shift between map and viewport center.
       * @param {import("./coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {import("./size.js").Size} size Size.
       * @return {Array<number>|undefined} Center shift.
       */
      calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
          const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
          const shiftedCenter = calculateCenterOn(
            center,
            size,
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
          centerShift = [
            center[0] - shiftedCenter[0],
            center[1] - shiftedCenter[1]
          ];
        }
        return centerShift;
      }
      /**
       * @return {boolean} Is defined.
       */
      isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== void 0;
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      adjustCenter(deltaCoordinates) {
        const center = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustResolution(ratio, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(
          this.targetResolution_ * ratio,
          0,
          size,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
      }
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
      }
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       * @api
       */
      adjustRotation(delta, anchor) {
        if (anchor) {
          anchor = fromUserCoordinate(anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, anchor);
      }
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       */
      adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(
          this.targetRotation_ + delta,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
      }
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      setCenter(center) {
        this.setCenterInternal(
          center ? fromUserCoordinate(center, this.getProjection()) : center
        );
      }
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
      }
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      }
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
      }
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
      }
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      }
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean} [doNotCancelAnims] Do not cancel animations.
       * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
       * @private
       */
      applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        const newRotation = this.constraints_.rotation(
          this.targetRotation_,
          isMoving
        );
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          0,
          size,
          isMoving
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          isMoving,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
          this.set(ViewProperty_default.ROTATION, newRotation);
        }
        if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
          this.set(ViewProperty_default.RESOLUTION, newResolution);
          this.set("zoom", this.getZoom(), true);
        }
        if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
          this.set(ViewProperty_default.CENTER, newCenter);
        }
        if (this.getAnimating() && !doNotCancelAnims) {
          this.cancelAnimations();
        }
        this.cancelAnchor_ = void 0;
      }
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number} [duration] The animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== void 0 ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          direction,
          size
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          false,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (duration === 0 && !this.cancelAnchor_) {
          this.targetResolution_ = newResolution;
          this.targetRotation_ = newRotation;
          this.targetCenter_ = newCenter;
          this.applyTargetState_();
          return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
        this.cancelAnchor_ = void 0;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
          if (this.getAnimating()) {
            this.cancelAnimations();
          }
          this.animateInternal({
            rotation: newRotation,
            center: newCenter,
            resolution: newResolution,
            duration,
            easing: easeOut,
            anchor
          });
        }
      }
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(ViewHint_default.INTERACTING, 1);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) {
          return;
        }
        this.setHint(ViewHint_default.INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
      }
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(
          targetCenter,
          targetResolution || this.getResolution(),
          size
        );
      }
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(
          this.getConstrainedResolution(targetRes, direction)
        );
      }
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
      }
    };
    View_default = View;
  }
});

// node_modules/ol/layer/Layer.js
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer, Layer_default;
var init_Layer = __esm({
  "node_modules/ol/layer/Layer.js"() {
    init_Base();
    init_EventType();
    init_Property();
    init_EventType2();
    init_View();
    init_asserts();
    init_extent();
    init_events();
    Layer = class extends Base_default {
      /**
       * @param {Options<SourceType>} options Layer options.
       */
      constructor(options) {
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.mapPrecomposeKey_ = null;
        this.mapRenderKey_ = null;
        this.sourceChangeKey_ = null;
        this.renderer_ = null;
        this.sourceReady_ = false;
        this.rendered = false;
        if (options.render) {
          this.render = options.render;
        }
        if (options.map) {
          this.setMap(options.map);
        }
        this.addChangeListener(
          Property_default.SOURCE,
          this.handleSourcePropertyChange_
        );
        const source = options.source ? (
          /** @type {SourceType} */
          options.source
        ) : null;
        this.setSource(source);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
      }
      /**
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
      }
      /**
       * Get the layer source.
       * @return {SourceType|null} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      getSource() {
        return (
          /** @type {SourceType} */
          this.get(Property_default.SOURCE) || null
        );
      }
      /**
       * @return {SourceType|null} The source being rendered.
       */
      getRenderSource() {
        return this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        const source = this.getSource();
        return !source ? "undefined" : source.getState();
      }
      /**
       * @private
       */
      handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== "ready") {
          return;
        }
        this.sourceReady_ = true;
        this.dispatchEvent("sourceready");
      }
      /**
       * @private
       */
      handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
          this.sourceChangeKey_ = listen(
            source,
            EventType_default.CHANGE,
            this.handleSourceChange_,
            this
          );
          if (source.getState() === "ready") {
            this.sourceReady_ = true;
            setTimeout(() => {
              this.dispatchEvent("sourceready");
            }, 0);
          }
        }
        this.changed();
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        if (!this.renderer_) {
          return Promise.resolve([]);
        }
        return this.renderer_.getFeatures(pixel);
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
          return null;
        }
        return this.renderer_.getData(pixel);
      }
      /**
       * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
       * extent, not set to `visible: false`, and not inside a layer group that is set
       * to `visible: false`.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {boolean} The layer is visible in the map view.
       * @api
       */
      isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) {
          view = map.getView();
        }
        if (view instanceof View_default) {
          frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
          };
        } else {
          frameState = view;
        }
        if (!frameState.layerStatesArray && map) {
          frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        }
        let layerState;
        if (frameState.layerStatesArray) {
          layerState = frameState.layerStatesArray.find(
            (layerState2) => layerState2.layer === this
          );
        } else {
          layerState = this.getLayerState();
        }
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
      }
      /**
       * Get the attributions of the source of this layer for the given view.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {Array<string>} Attributions for this layer at the given view.
       * @api
       */
      getAttributions(view) {
        if (!this.isVisible(view)) {
          return [];
        }
        let getAttributions;
        const source = this.getSource();
        if (source) {
          getAttributions = source.getAttributions();
        }
        if (!getAttributions) {
          return [];
        }
        const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) {
          attributions = [attributions];
        }
        return attributions;
      }
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement|null} The rendered element.
       */
      render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
          this.rendered = true;
          return layerRenderer.renderFrame(frameState, target);
        }
        return null;
      }
      /**
       * Called when a layer is not visible during a map render.
       */
      unrender() {
        this.rendered = false;
      }
      /**
       * For use inside the library only.
       * @param {import("../Map.js").default|null} map Map.
       */
      setMapInternal(map) {
        if (!map) {
          this.unrender();
        }
        this.set(Property_default.MAP, map);
      }
      /**
       * For use inside the library only.
       * @return {import("../Map.js").default|null} Map.
       */
      getMapInternal() {
        return this.get(Property_default.MAP);
      }
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map~Map#addLayer} instead.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }
        if (!map) {
          this.changed();
        }
        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }
        if (map) {
          this.mapPrecomposeKey_ = listen(
            map,
            EventType_default2.PRECOMPOSE,
            function(evt) {
              const renderEvent = (
                /** @type {import("../render/Event.js").default} */
                evt
              );
              const layerStatesArray = renderEvent.frameState.layerStatesArray;
              const layerState = this.getLayerState(false);
              assert(
                !layerStatesArray.some(function(arrayLayerState) {
                  return arrayLayerState.layer === layerState.layer;
                }),
                "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
              );
              layerStatesArray.push(layerState);
            },
            this
          );
          this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
          this.changed();
        }
      }
      /**
       * Set the layer source.
       * @param {SourceType|null} source The layer source.
       * @observable
       * @api
       */
      setSource(source) {
        this.set(Property_default.SOURCE, source);
      }
      /**
       * Get the renderer for this layer.
       * @return {RendererType|null} The layer renderer.
       */
      getRenderer() {
        if (!this.renderer_) {
          this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
      }
      /**
       * @return {boolean} The layer has a renderer.
       */
      hasRenderer() {
        return !!this.renderer_;
      }
      /**
       * Create a renderer for this layer.
       * @return {RendererType} A layer renderer.
       * @protected
       */
      createRenderer() {
        return null;
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        if (this.renderer_) {
          this.renderer_.dispose();
          delete this.renderer_;
        }
        this.setSource(null);
        super.disposeInternal();
      }
    };
    Layer_default = Layer;
  }
});

// node_modules/ol/render/Event.js
var RenderEvent, Event_default2;
var init_Event2 = __esm({
  "node_modules/ol/render/Event.js"() {
    init_Event();
    RenderEvent = class extends Event_default {
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../Map.js").FrameState} [frameState] Frame state.
       * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
       */
      constructor(type, inversePixelTransform, frameState, context) {
        super(type);
        this.inversePixelTransform = inversePixelTransform;
        this.frameState = frameState;
        this.context = context;
      }
    };
    Event_default2 = RenderEvent;
  }
});

// node_modules/ol/css.js
var CLASS_HIDDEN, CLASS_UNSELECTABLE, CLASS_CONTROL, CLASS_COLLAPSED, fontRegEx, fontRegExMatchIndex, getFontParameters;
var init_css = __esm({
  "node_modules/ol/css.js"() {
    CLASS_HIDDEN = "ol-hidden";
    CLASS_UNSELECTABLE = "ol-unselectable";
    CLASS_CONTROL = "ol-control";
    CLASS_COLLAPSED = "ol-collapsed";
    fontRegEx = new RegExp(
      [
        "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
        "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
        "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
        "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
        `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
      ].join(""),
      "i"
    );
    fontRegExMatchIndex = [
      "style",
      "variant",
      "weight",
      "size",
      "lineHeight",
      "family"
    ];
    getFontParameters = function(fontSpec) {
      const match = fontSpec.match(fontRegEx);
      if (!match) {
        return null;
      }
      const style = (
        /** @type {FontParameters} */
        {
          lineHeight: "normal",
          size: "1.2em",
          style: "normal",
          weight: "normal",
          variant: "normal"
        }
      );
      for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
        const value = match[i + 1];
        if (value !== void 0) {
          style[fontRegExMatchIndex[i]] = value;
        }
      }
      style.families = style.family.split(/,\s?/);
      return style;
    };
  }
});

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool3, settings) {
  let canvas;
  if (canvasPool3 && canvasPool3.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool3.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;
  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }
    node.insertBefore(newChild, oldChild);
  }
}
var init_dom = __esm({
  "node_modules/ol/dom.js"() {
    init_has();
  }
});

// node_modules/ol/render/canvas.js
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache3) {
  if (text in cache3) {
    return cache3[text];
  }
  const width = text.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache3[text] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
    const text = chunks[i];
    if (text === "\n" || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }
    const font = chunks[i + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale4) {
  context.save();
  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }
  if (transform2) {
    context.transform.apply(context, transform2);
  }
  if (
    /** @type {*} */
    labelOrImage.contextInstructions
  ) {
    context.translate(x, y);
    context.scale(scale4[0], scale4[1]);
    executeLabelInstructions(
      /** @type {Label} */
      labelOrImage,
      context
    );
  } else if (scale4[0] < 0 || scale4[1] < 0) {
    context.translate(x, y);
    context.scale(scale4[0], scale4[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale4[0],
      h * scale4[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(
        context,
        contextInstructions[i + 1]
      );
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
var defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, checkedFonts, measureContext, measureFont, textHeights, registerFont, measureTextHeight;
var init_canvas = __esm({
  "node_modules/ol/render/canvas.js"() {
    init_Object();
    init_has();
    init_obj();
    init_dom();
    init_css();
    defaultFont = "10px sans-serif";
    defaultFillStyle = "#000";
    defaultLineCap = "round";
    defaultLineDash = [];
    defaultLineDashOffset = 0;
    defaultLineJoin = "round";
    defaultMiterLimit = 10;
    defaultStrokeStyle = "#000";
    defaultTextAlign = "center";
    defaultTextBaseline = "middle";
    defaultPadding = [0, 0, 0, 0];
    defaultLineWidth = 1;
    checkedFonts = new Object_default();
    measureContext = null;
    textHeights = {};
    registerFont = function() {
      const retries = 100;
      const size = "32px ";
      const referenceFonts = ["monospace", "serif"];
      const len = referenceFonts.length;
      const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
      let interval, referenceWidth;
      function isAvailable(fontStyle, fontWeight, fontFamily) {
        let available = true;
        for (let i = 0; i < len; ++i) {
          const referenceFont = referenceFonts[i];
          referenceWidth = measureTextWidth(
            fontStyle + " " + fontWeight + " " + size + referenceFont,
            text
          );
          if (fontFamily != referenceFont) {
            const width = measureTextWidth(
              fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
              text
            );
            available = available && width != referenceWidth;
          }
        }
        if (available) {
          return true;
        }
        return false;
      }
      function check() {
        let done = true;
        const fonts = checkedFonts.getKeys();
        for (let i = 0, ii = fonts.length; i < ii; ++i) {
          const font = fonts[i];
          if (checkedFonts.get(font) < retries) {
            if (isAvailable.apply(this, font.split("\n"))) {
              clear(textHeights);
              measureContext = null;
              measureFont = void 0;
              checkedFonts.set(font, retries);
            } else {
              checkedFonts.set(font, checkedFonts.get(font) + 1, true);
              done = false;
            }
          }
        }
        if (done) {
          clearInterval(interval);
          interval = void 0;
        }
      }
      return function(fontSpec) {
        const font = getFontParameters(fontSpec);
        if (!font) {
          return;
        }
        const families = font.families;
        for (let i = 0, ii = families.length; i < ii; ++i) {
          const family = families[i];
          const key = font.style + "\n" + font.weight + "\n" + family;
          if (checkedFonts.get(key) === void 0) {
            checkedFonts.set(key, retries, true);
            if (!isAvailable(font.style, font.weight, family)) {
              checkedFonts.set(key, 0, true);
              if (interval === void 0) {
                interval = setInterval(check, 32);
              }
            }
          }
        }
      };
    }();
    measureTextHeight = /* @__PURE__ */ function() {
      let measureElement;
      return function(fontSpec) {
        let height = textHeights[fontSpec];
        if (height == void 0) {
          if (WORKER_OFFSCREEN_CANVAS) {
            const font = getFontParameters(fontSpec);
            const metrics = measureText(fontSpec, "\u017Dg");
            const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
            height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
          } else {
            if (!measureElement) {
              measureElement = document.createElement("div");
              measureElement.innerHTML = "M";
              measureElement.style.minHeight = "0";
              measureElement.style.maxHeight = "none";
              measureElement.style.height = "auto";
              measureElement.style.padding = "0";
              measureElement.style.border = "none";
              measureElement.style.position = "absolute";
              measureElement.style.display = "block";
              measureElement.style.left = "-99999px";
            }
            measureElement.style.font = fontSpec;
            document.body.appendChild(measureElement);
            height = measureElement.offsetHeight;
            document.body.removeChild(measureElement);
          }
          textHeights[fontSpec] = height;
        }
        return height;
      };
    }();
  }
});

// node_modules/ol/MapEventType.js
var MapEventType_default;
var init_MapEventType = __esm({
  "node_modules/ol/MapEventType.js"() {
    MapEventType_default = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: "movestart",
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: "moveend",
      /**
       * Triggered when loading of additional map data (tiles, images, features) starts.
       * @event module:ol/MapEvent~MapEvent#loadstart
       * @api
       */
      LOADSTART: "loadstart",
      /**
       * Triggered when loading of additional map data has completed.
       * @event module:ol/MapEvent~MapEvent#loadend
       * @api
       */
      LOADEND: "loadend"
    };
  }
});

// node_modules/ol/control/Control.js
var Control_exports = {};
__export(Control_exports, {
  default: () => Control_default
});
var Control, Control_default;
var init_Control = __esm({
  "node_modules/ol/control/Control.js"() {
    init_Object();
    init_MapEventType();
    init_functions();
    init_events();
    init_dom();
    Control = class extends Object_default {
      /**
       * @param {Options} options Control options.
       */
      constructor(options) {
        super();
        const element = options.element;
        if (element && !options.target && !element.style.pointerEvents) {
          element.style.pointerEvents = "auto";
        }
        this.element = element ? element : null;
        this.target_ = null;
        this.map_ = null;
        this.listenerKeys = [];
        if (options.render) {
          this.render = options.render;
        }
        if (options.target) {
          this.setTarget(options.target);
        }
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        removeNode(this.element);
        super.disposeInternal();
      }
      /**
       * Get the map associated with this control.
       * @return {import("../Map.js").default|null} Map.
       * @api
       */
      getMap() {
        return this.map_;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Pass `null` to just remove the control from the current map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.map_) {
          removeNode(this.element);
        }
        for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
          unlistenByKey(this.listenerKeys[i]);
        }
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
          const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
          target.appendChild(this.element);
          if (this.render !== VOID) {
            this.listenerKeys.push(
              listen(map, MapEventType_default.POSTRENDER, this.render, this)
            );
          }
          map.render();
        }
      }
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */
      render(mapEvent) {
      }
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      setTarget(target) {
        this.target_ = typeof target === "string" ? document.getElementById(target) : target;
      }
    };
    Control_default = Control;
  }
});

// node_modules/ol/size.js
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale3(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
var init_size = __esm({
  "node_modules/ol/size.js"() {
  }
});

// node_modules/ol/ImageState.js
var ImageState_default;
var init_ImageState = __esm({
  "node_modules/ol/ImageState.js"() {
    ImageState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e) => image.complete && image.width ? resolve(image) : reject(e)
    )
  ) : load(image);
}
var init_Image = __esm({
  "node_modules/ol/Image.js"() {
    init_EventType();
    init_has();
    init_events();
  }
});

// node_modules/ol/source/Source.js
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  return function(frameState) {
    return [attributionLike];
  };
}
var Source, Source_default;
var init_Source = __esm({
  "node_modules/ol/source/Source.js"() {
    init_Object();
    init_proj();
    Source = class extends Object_default {
      /**
       * @param {Options} options Source options.
       */
      constructor(options) {
        super();
        this.projection = get3(options.projection);
        this.attributions_ = adaptAttributions(options.attributions);
        this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
        this.loading = false;
        this.state_ = options.state !== void 0 ? options.state : "ready";
        this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
        this.interpolate_ = !!options.interpolate;
        this.viewResolver = null;
        this.viewRejector = null;
        const self2 = this;
        this.viewPromise_ = new Promise(function(resolve, reject) {
          self2.viewResolver = resolve;
          self2.viewRejector = reject;
        });
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       * @api
       */
      getAttributions() {
        return this.attributions_;
      }
      /**
       * @return {boolean} Attributions are collapsible.
       * @api
       */
      getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default|null} Projection.
       * @api
       */
      getProjection() {
        return this.projection;
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       */
      getResolutions(projection) {
        return null;
      }
      /**
       * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
       */
      getView() {
        return this.viewPromise_;
      }
      /**
       * Get the state of the source, see {@link import("./Source.js").State} for possible states.
       * @return {import("./Source.js").State} State.
       * @api
       */
      getState() {
        return this.state_;
      }
      /**
       * @return {boolean|undefined} Wrap X.
       */
      getWrapX() {
        return this.wrapX_;
      }
      /**
       * @return {boolean} Use linear interpolation when resampling.
       */
      getInterpolate() {
        return this.interpolate_;
      }
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      refresh() {
        this.changed();
      }
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
      }
      /**
       * Set the state of the source.
       * @param {import("./Source.js").State} state State.
       */
      setState(state) {
        this.state_ = state;
        this.changed();
      }
    };
    Source_default = Source;
  }
});

// node_modules/ol/renderer/Layer.js
var LayerRenderer, Layer_default2;
var init_Layer2 = __esm({
  "node_modules/ol/renderer/Layer.js"() {
    init_EventType();
    init_ImageState();
    init_Observable();
    init_util();
    LayerRenderer = class extends Observable_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super();
        this.ready = true;
        this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        this.layer_ = layer;
        this.declutterExecutorGroup = null;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        return abstract();
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        return null;
      }
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        return abstract();
      }
      /**
       * Render the layer.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement|null} The rendered element.
       */
      renderFrame(frameState, target) {
        return abstract();
      }
      /**
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      loadedTileCallback(tiles, zoom, tile) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }
        tiles[zoom][tile.tileCoord.toString()] = tile;
        return void 0;
      }
      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {import("../source/Tile.js").default} source Tile source.
       * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */
      createLoadedTileFinder(source, projection, tiles) {
        return (
          /**
           * @param {number} zoom Zoom level.
           * @param {import("../TileRange.js").default} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           */
          (zoom, tileRange) => {
            const callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }
        );
      }
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return void 0;
      }
      /**
       * @return {LayerType} Layer.
       */
      getLayer() {
        return this.layer_;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      handleFontsChanged() {
      }
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      handleImageChange_(event) {
        const image = (
          /** @type {import("../Image.js").default} */
          event.target
        );
        if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
          this.renderIfReadyAndVisible();
        }
      }
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../Image.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      loadImage(image) {
        let imageState = image.getState();
        if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
          image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == ImageState_default.IDLE) {
          image.load();
          imageState = image.getState();
        }
        return imageState == ImageState_default.LOADED;
      }
      /**
       * @protected
       */
      renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
          layer.changed();
        }
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
      }
    };
    Layer_default2 = LayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/Layer.js
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var canvasPool2, pixelContext, CanvasLayerRenderer, Layer_default3;
var init_Layer3 = __esm({
  "node_modules/ol/renderer/canvas/Layer.js"() {
    init_Layer2();
    init_Event2();
    init_EventType2();
    init_transform();
    init_color();
    init_dom();
    init_array();
    init_extent();
    canvasPool2 = [];
    pixelContext = null;
    CanvasLayerRenderer = class extends Layer_default2 {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super(layer);
        this.container = null;
        this.renderedResolution;
        this.tempTransform = create();
        this.pixelTransform = create();
        this.inversePixelTransform = create();
        this.context = null;
        this.containerReused = false;
        this.pixelContext_ = null;
        this.frameState = null;
      }
      /**
       * @param {import('../../DataTile.js').ImageLike} image Image.
       * @param {number} col The column index.
       * @param {number} row The row index.
       * @return {Uint8ClampedArray|null} The image data.
       */
      getImageData(image, col, row) {
        if (!pixelContext) {
          createPixelContext();
        }
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
          pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
          data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
          pixelContext = null;
          return null;
        }
        return data;
      }
      /**
       * @param {import('../../Map.js').FrameState} frameState Frame state.
       * @return {string} Background color.
       */
      getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === "function") {
          background = background(frameState.viewState.resolution);
        }
        return background || void 0;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {string} [backgroundColor] Background color.
       */
      useContainer(target, transform2, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
          asArray(target.style.backgroundColor),
          asArray(backgroundColor)
        ))) {
          const canvas = target.firstElementChild;
          if (canvas instanceof HTMLCanvasElement) {
            context = canvas.getContext("2d");
          }
        }
        if (context && context.canvas.style.transform === transform2) {
          this.container = target;
          this.context = context;
          this.containerReused = true;
        } else if (this.containerReused) {
          this.container = null;
          this.context = null;
          this.containerReused = false;
        } else if (this.container) {
          this.container.style.backgroundColor = null;
        }
        if (!this.container) {
          container = document.createElement("div");
          container.className = layerClassName;
          let style = container.style;
          style.position = "absolute";
          style.width = "100%";
          style.height = "100%";
          context = createCanvasContext2D();
          const canvas = context.canvas;
          container.appendChild(canvas);
          style = canvas.style;
          style.position = "absolute";
          style.left = "0";
          style.transformOrigin = "top left";
          this.container = container;
          this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
          this.container.style.backgroundColor = backgroundColor;
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      clipUnrotated(context, frameState, extent) {
        const topLeft = getTopLeft(extent);
        const topRight = getTopRight(extent);
        const bottomRight = getBottomRight(extent);
        const bottomLeft = getBottomLeft(extent);
        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        apply(inverted, topLeft);
        apply(inverted, topRight);
        apply(inverted, bottomRight);
        apply(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */
      dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
          const event = new Event_default2(
            type,
            this.inversePixelTransform,
            frameState,
            context
          );
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      preRender(context, frameState) {
        this.frameState = frameState;
        this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      postRender(context, frameState) {
        this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
      }
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return compose(
          this.tempTransform,
          dx1,
          dy1,
          sx,
          sy,
          -rotation,
          dx2,
          dy2
        );
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
      }
    };
    Layer_default3 = CanvasLayerRenderer;
  }
});

// node_modules/ol/Feature.js
var Feature_exports = {};
__export(Feature_exports, {
  createStyleFunction: () => createStyleFunction,
  default: () => Feature_default
});
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(
      typeof /** @type {?} */
      obj.getZIndex === "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    );
    const style = (
      /** @type {import("./style/Style.js").default} */
      obj
    );
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature, Feature_default;
var init_Feature = __esm({
  "node_modules/ol/Feature.js"() {
    init_Object();
    init_EventType();
    init_asserts();
    init_events();
    Feature = class _Feature extends Object_default {
      /**
       * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      constructor(geometryOrProperties) {
        super();
        this.on;
        this.once;
        this.un;
        this.id_ = void 0;
        this.geometryName_ = "geometry";
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
          if (typeof /** @type {?} */
          geometryOrProperties.getSimplifiedGeometry === "function") {
            const geometry = (
              /** @type {Geometry} */
              geometryOrProperties
            );
            this.setGeometry(geometry);
          } else {
            const properties = geometryOrProperties;
            this.setProperties(properties);
          }
        }
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature<Geometry>} The clone.
       * @api
       */
      clone() {
        const clone2 = (
          /** @type {Feature<Geometry>} */
          new _Feature(this.hasProperties() ? this.getProperties() : null)
        );
        clone2.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) {
          clone2.setGeometry(
            /** @type {Geometry} */
            geometry.clone()
          );
        }
        const style = this.getStyle();
        if (style) {
          clone2.setStyle(style);
        }
        return clone2;
      }
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      getGeometry() {
        return (
          /** @type {Geometry|undefined} */
          this.get(this.geometryName_)
        );
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      getGeometryName() {
        return this.geometryName_;
      }
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @private
       */
      handleGeometryChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) {
          this.geometryChangeKey_ = listen(
            geometry,
            EventType_default.CHANGE,
            this.handleGeometryChange_,
            this
          );
        }
        this.changed();
      }
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
      }
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
        this.changed();
      }
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setId(id) {
        this.id_ = id;
        this.changed();
      }
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
      }
    };
    Feature_default = Feature;
  }
});

// node_modules/ol/style/Fill.js
var Fill, Fill_default;
var init_Fill = __esm({
  "node_modules/ol/style/Fill.js"() {
    Fill = class _Fill {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.color_ = options.color !== void 0 ? options.color : null;
      }
      /**
       * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Fill({
          color: Array.isArray(color) ? color.slice() : color || void 0
        });
      }
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
    };
    Fill_default = Fill;
  }
});

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
  let o, t;
  const n = (end - offset) / stride;
  if (n === 1) {
    o = offset;
  } else if (n === 2) {
    o = offset;
    t = fraction;
  } else if (n !== 0) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index = binarySearch(cumulativeLengths, target);
    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset + (-index - 2) * stride;
    } else {
      o = offset + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] = o === void 0 ? NaN : t === void 0 ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }
  return dest;
}
var init_interpolate = __esm({
  "node_modules/ol/geom/flat/interpolate.js"() {
    init_array();
    init_math();
  }
});

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i = offset + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}
var init_length = __esm({
  "node_modules/ol/geom/flat/length.js"() {
  }
});

// node_modules/ol/style/Stroke.js
var Stroke, Stroke_default;
var init_Stroke = __esm({
  "node_modules/ol/style/Stroke.js"() {
    Stroke = class _Stroke {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.color_ = options.color !== void 0 ? options.color : null;
        this.lineCap_ = options.lineCap;
        this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
        this.lineDashOffset_ = options.lineDashOffset;
        this.lineJoin_ = options.lineJoin;
        this.miterLimit_ = options.miterLimit;
        this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Stroke({
          color: Array.isArray(color) ? color.slice() : color || void 0,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth()
        });
      }
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      getLineCap() {
        return this.lineCap_;
      }
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>|null} Line dash.
       * @api
       */
      getLineDash() {
        return this.lineDash_;
      }
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      getLineDashOffset() {
        return this.lineDashOffset_;
      }
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      getLineJoin() {
        return this.lineJoin_;
      }
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      getMiterLimit() {
        return this.miterLimit_;
      }
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      getWidth() {
        return this.width_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      setLineCap(lineCap) {
        this.lineCap_ = lineCap;
      }
      /**
       * Set the line dash.
       *
       * @param {Array<number>|null} lineDash Line dash.
       * @api
       */
      setLineDash(lineDash) {
        this.lineDash_ = lineDash;
      }
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
      }
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
      }
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
      }
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      setWidth(width) {
        this.width_ = width;
      }
    };
    Stroke_default = Stroke;
  }
});

// node_modules/ol/style/Image.js
var ImageStyle, Image_default;
var init_Image2 = __esm({
  "node_modules/ol/style/Image.js"() {
    init_util();
    init_size();
    ImageStyle = class _ImageStyle {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        this.opacity_ = options.opacity;
        this.rotateWithView_ = options.rotateWithView;
        this.rotation_ = options.rotation;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale);
        this.displacement_ = options.displacement;
        this.declutterMode_ = options.declutterMode;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      clone() {
        const scale4 = this.getScale();
        return new _ImageStyle({
          opacity: this.getOpacity(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      getOpacity() {
        return this.opacity_;
      }
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      getDisplacement() {
        return this.displacement_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      getAnchor() {
        return abstract();
      }
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getImage(pixelRatio) {
        return abstract();
      }
      /**
       * @abstract
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getHitDetectionImage() {
        return abstract();
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return 1;
      }
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return abstract();
      }
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return abstract();
      }
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      getOrigin() {
        return abstract();
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      getSize() {
        return abstract();
      }
      /**
       * Set the displacement.
       *
       * @param {Array<number>} displacement Displacement.
       * @api
       */
      setDisplacement(displacement) {
        this.displacement_ = displacement;
      }
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      setOpacity(opacity) {
        this.opacity_ = opacity;
      }
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale4) {
        this.scale_ = scale4;
        this.scaleArray_ = toSize(scale4);
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        abstract();
      }
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      load() {
        abstract();
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        abstract();
      }
    };
    Image_default = ImageStyle;
  }
});

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (Array.isArray(color)) {
    return toString2(color);
  }
  return color;
}
var init_colorlike = __esm({
  "node_modules/ol/colorlike.js"() {
    init_color();
  }
});

// node_modules/ol/style/RegularShape.js
var RegularShape, RegularShape_default;
var init_RegularShape = __esm({
  "node_modules/ol/style/RegularShape.js"() {
    init_ImageState();
    init_Image2();
    init_color();
    init_colorlike();
    init_dom();
    init_canvas();
    RegularShape = class _RegularShape extends Image_default {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
        super({
          opacity: 1,
          rotateWithView,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          scale: options.scale !== void 0 ? options.scale : 1,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
        this.canvases_;
        this.hitDetectionCanvas_ = null;
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.origin_ = [0, 0];
        this.points_ = options.points;
        this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
        this.radius2_ = options.radius2;
        this.angle_ = options.angle !== void 0 ? options.angle : 0;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.size_;
        this.renderOptions_;
        this.render();
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       */
      clone() {
        const scale4 = this.getScale();
        const style = new _RegularShape({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale4 = this.getScaleArray();
        return [
          size[0] / 2 - displacement[0] / scale4[0],
          size[1] / 2 + displacement[1] / scale4[1]
        ];
      }
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      getAngle() {
        return this.angle_;
      }
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
        this.render();
      }
      /**
       * @return {HTMLCanvasElement} Image element.
       */
      getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) {
          this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
            this.renderOptions_
          );
        }
        return this.hitDetectionCanvas_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      getImage(pixelRatio) {
        let image = this.canvases_[pixelRatio];
        if (!image) {
          const renderOptions = this.renderOptions_;
          const context = createCanvasContext2D(
            renderOptions.size * pixelRatio,
            renderOptions.size * pixelRatio
          );
          this.draw_(renderOptions, context, pixelRatio);
          image = context.canvas;
          this.canvases_[pixelRatio] = image;
        }
        return image;
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return pixelRatio;
      }
      /**
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return this.size_;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return ImageState_default.LOADED;
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      getOrigin() {
        return this.origin_;
      }
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      getPoints() {
        return this.points_;
      }
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return this.radius_;
      }
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      getRadius2() {
        return this.radius2_;
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       */
      getSize() {
        return this.size_;
      }
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
      }
      /**
       * Calculate additional canvas size needed for the miter.
       * @param {string} lineJoin Line join
       * @param {number} strokeWidth Stroke width
       * @param {number} miterLimit Miter limit
       * @return {number} Additional canvas size needed
       * @private
       */
      calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
          return strokeWidth;
        }
        let r1 = this.radius_;
        let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
        if (r1 < r2) {
          const tmp = r1;
          r1 = r2;
          r2 = tmp;
        }
        const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a = r2 * Math.sin(alpha);
        const b = Math.sqrt(r2 * r2 - a * a);
        const d = r1 - b;
        const e = Math.sqrt(a * a + d * d);
        const miterRatio = e / a;
        if (lineJoin === "miter" && miterRatio <= miterLimit) {
          return miterRatio * strokeWidth;
        }
        const k = strokeWidth / 2 / miterRatio;
        const l = strokeWidth / 2 * (d / e);
        const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === void 0 || lineJoin === "bevel") {
          return bevelAdd * 2;
        }
        const aa = r1 * Math.sin(alpha);
        const bb = Math.sqrt(r1 * r1 - aa * aa);
        const dd = r2 - bb;
        const ee = Math.sqrt(aa * aa + dd * dd);
        const innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
          const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
          return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
      }
      /**
       * @return {RenderOptions}  The render options
       * @protected
       */
      createRenderOptions() {
        let lineCap = defaultLineCap;
        let lineJoin = defaultLineJoin;
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
          strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
          strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
          lineDash = this.stroke_.getLineDash();
          lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
          lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
          lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
          miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
        }
        const add4 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add4);
        return {
          strokeStyle,
          strokeWidth,
          size,
          lineCap,
          lineDash,
          lineDashOffset,
          lineJoin,
          miterLimit
        };
      }
      /**
       * @protected
       */
      render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.canvases_ = {};
        this.hitDetectionCanvas_ = null;
        this.size_ = [size, size];
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} pixelRatio The pixel ratio.
       */
      draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
          let color = this.fill_.getColor();
          if (color === null) {
            color = defaultFillStyle;
          }
          context.fillStyle = asColorLike(color);
          context.fill();
        }
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineCap = renderOptions.lineCap;
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @return {HTMLCanvasElement} Canvas containing the icon
       */
      createHitDetectionCanvas_(renderOptions) {
        let context;
        if (this.fill_) {
          let color = this.fill_.getColor();
          let opacity = 0;
          if (typeof color === "string") {
            color = asArray(color);
          }
          if (color === null) {
            opacity = 1;
          } else if (Array.isArray(color)) {
            opacity = color.length === 4 ? color[3] : 1;
          }
          if (opacity === 0) {
            context = createCanvasContext2D(renderOptions.size, renderOptions.size);
            this.drawHitDetectionCanvas_(renderOptions, context);
          }
        }
        return context ? context.canvas : this.getImage(1);
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context The context to draw in.
       */
      createPath_(context) {
        let points = this.points_;
        const radius = this.radius_;
        if (points === Infinity) {
          context.arc(0, 0, radius, 0, 2 * Math.PI);
        } else {
          const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
          if (this.radius2_ !== void 0) {
            points *= 2;
          }
          const startAngle = this.angle_ - Math.PI / 2;
          const step = 2 * Math.PI / points;
          for (let i = 0; i < points; i++) {
            const angle0 = startAngle + i * step;
            const radiusC = i % 2 === 0 ? radius : radius2;
            context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
          }
          context.closePath();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       */
      drawHitDetectionCanvas_(renderOptions, context) {
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = defaultFillStyle;
        context.fill();
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
    };
    RegularShape_default = RegularShape;
  }
});

// node_modules/ol/style/Circle.js
var CircleStyle, Circle_default;
var init_Circle = __esm({
  "node_modules/ol/style/Circle.js"() {
    init_RegularShape();
    CircleStyle = class _CircleStyle extends RegularShape_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options ? options : { radius: 5 };
        super({
          points: Infinity,
          fill: options.fill,
          radius: options.radius,
          stroke: options.stroke,
          scale: options.scale !== void 0 ? options.scale : 1,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       */
      clone() {
        const scale4 = this.getScale();
        const style = new _CircleStyle({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          radius: this.getRadius(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      setRadius(radius) {
        this.radius_ = radius;
        this.render();
      }
    };
    Circle_default = CircleStyle;
  }
});

// node_modules/ol/style/Style.js
var Style_exports = {};
__export(Style_exports, {
  createDefaultStyle: () => createDefaultStyle,
  createEditingStyle: () => createEditingStyle,
  default: () => Style_default,
  toFunction: () => toFunction
});
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `Style` or an array of `Style`"
      );
      const style = (
        /** @type {Style} */
        obj
      );
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function createEditingStyle() {
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles["Polygon"] = [
    new Style({
      fill: new Fill_default({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles["MultiPolygon"] = styles["Polygon"];
  styles["LineString"] = [
    new Style({
      stroke: new Stroke_default({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new Stroke_default({
        color: blue,
        width
      })
    })
  ];
  styles["MultiLineString"] = styles["LineString"];
  styles["Circle"] = styles["Polygon"].concat(styles["LineString"]);
  styles["Point"] = [
    new Style({
      image: new Circle_default({
        radius: width * 2,
        fill: new Fill_default({
          color: blue
        }),
        stroke: new Stroke_default({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles["MultiPoint"] = styles["Point"];
  styles["GeometryCollection"] = styles["Polygon"].concat(
    styles["LineString"],
    styles["Point"]
  );
  return styles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style, defaultStyles, Style_default;
var init_Style = __esm({
  "node_modules/ol/style/Style.js"() {
    init_Circle();
    init_Fill();
    init_Stroke();
    init_asserts();
    Style = class _Style {
      /**
       * @param {Options} [options] Style options.
       */
      constructor(options) {
        options = options || {};
        this.geometry_ = null;
        this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== void 0) {
          this.setGeometry(options.geometry);
        }
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.image_ = options.image !== void 0 ? options.image : null;
        this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
        this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.text_ = options.text !== void 0 ? options.text : null;
        this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === "object") {
          geometry = /** @type {import("../geom/Geometry.js").default} */
          geometry.clone();
        }
        return new _Style({
          geometry: geometry ?? void 0,
          fill: this.getFill() ? this.getFill().clone() : void 0,
          image: this.getImage() ? this.getImage().clone() : void 0,
          renderer: this.getRenderer() ?? void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          text: this.getText() ? this.getText().clone() : void 0,
          zIndex: this.getZIndex()
        });
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getRenderer() {
        return this.renderer_;
      }
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setRenderer(renderer) {
        this.renderer_ = renderer;
      }
      /**
       * Sets a custom renderer function for this style used
       * in hit detection.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
      }
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      getGeometry() {
        return this.geometry_;
      }
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      getGeometryFunction() {
        return this.geometryFunction_;
      }
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Get the image style.
       * @return {import("./Image.js").default|null} Image style.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Get the text style.
       * @return {import("./Text.js").default|null} Text style.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      setText(text) {
        this.text_ = text;
      }
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      getZIndex() {
        return this.zIndex_;
      }
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      setGeometry(geometry) {
        if (typeof geometry === "function") {
          this.geometryFunction_ = geometry;
        } else if (typeof geometry === "string") {
          this.geometryFunction_ = function(feature) {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              feature.get(geometry)
            );
          };
        } else if (!geometry) {
          this.geometryFunction_ = defaultGeometryFunction;
        } else if (geometry !== void 0) {
          this.geometryFunction_ = function() {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              geometry
            );
          };
        }
        this.geometry_ = geometry;
      }
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      setZIndex(zIndex) {
        this.zIndex_ = zIndex;
      }
    };
    defaultStyles = null;
    Style_default = Style;
  }
});

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR, Text, Text_default;
var init_Text = __esm({
  "node_modules/ol/style/Text.js"() {
    init_Fill();
    init_size();
    DEFAULT_FILL_COLOR = "#333";
    Text = class _Text {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.font_ = options.font;
        this.rotation_ = options.rotation;
        this.rotateWithView_ = options.rotateWithView;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
        this.text_ = options.text;
        this.textAlign_ = options.textAlign;
        this.justify_ = options.justify;
        this.repeat_ = options.repeat;
        this.textBaseline_ = options.textBaseline;
        this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
        this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
        this.placement_ = options.placement !== void 0 ? options.placement : "point";
        this.overflow_ = !!options.overflow;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
        this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
        this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        this.padding_ = options.padding === void 0 ? null : options.padding;
      }
      /**
       * Clones the style.
       * @return {Text} The cloned style.
       * @api
       */
      clone() {
        const scale4 = this.getScale();
        return new _Text({
          font: this.getFont(),
          placement: this.getPlacement(),
          repeat: this.getRepeat(),
          maxAngle: this.getMaxAngle(),
          overflow: this.getOverflow(),
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale4) ? scale4.slice() : scale4,
          text: this.getText(),
          textAlign: this.getTextAlign(),
          justify: this.getJustify(),
          textBaseline: this.getTextBaseline(),
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          offsetX: this.getOffsetX(),
          offsetY: this.getOffsetY(),
          backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
          backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
          padding: this.getPadding() || void 0
        });
      }
      /**
       * Get the `overflow` configuration.
       * @return {boolean} Let text overflow the length of the path they follow.
       * @api
       */
      getOverflow() {
        return this.overflow_;
      }
      /**
       * Get the font name.
       * @return {string|undefined} Font.
       * @api
       */
      getFont() {
        return this.font_;
      }
      /**
       * Get the maximum angle between adjacent characters.
       * @return {number} Angle in radians.
       * @api
       */
      getMaxAngle() {
        return this.maxAngle_;
      }
      /**
       * Get the label placement.
       * @return {TextPlacement} Text placement.
       * @api
       */
      getPlacement() {
        return this.placement_;
      }
      /**
       * Get the repeat interval of the text.
       * @return {number|undefined} Repeat interval in pixels.
       * @api
       */
      getRepeat() {
        return this.repeat_;
      }
      /**
       * Get the x-offset for the text.
       * @return {number} Horizontal text offset.
       * @api
       */
      getOffsetX() {
        return this.offsetX_;
      }
      /**
       * Get the y-offset for the text.
       * @return {number} Vertical text offset.
       * @api
       */
      getOffsetY() {
        return this.offsetY_;
      }
      /**
       * Get the fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Determine whether the text rotates with the map.
       * @return {boolean|undefined} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the text rotation.
       * @return {number|undefined} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the text scale.
       * @return {number|import("../size.js").Size|undefined} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Get the text to be rendered.
       * @return {string|Array<string>|undefined} Text.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Get the text alignment.
       * @return {CanvasTextAlign|undefined} Text align.
       * @api
       */
      getTextAlign() {
        return this.textAlign_;
      }
      /**
       * Get the justification.
       * @return {TextJustify|undefined} Justification.
       * @api
       */
      getJustify() {
        return this.justify_;
      }
      /**
       * Get the text baseline.
       * @return {CanvasTextBaseline|undefined} Text baseline.
       * @api
       */
      getTextBaseline() {
        return this.textBaseline_;
      }
      /**
       * Get the background fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getBackgroundFill() {
        return this.backgroundFill_;
      }
      /**
       * Get the background stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getBackgroundStroke() {
        return this.backgroundStroke_;
      }
      /**
       * Get the padding for the text.
       * @return {Array<number>|null} Padding.
       * @api
       */
      getPadding() {
        return this.padding_;
      }
      /**
       * Set the `overflow` property.
       *
       * @param {boolean} overflow Let text overflow the path that it follows.
       * @api
       */
      setOverflow(overflow) {
        this.overflow_ = overflow;
      }
      /**
       * Set the font.
       *
       * @param {string|undefined} font Font.
       * @api
       */
      setFont(font) {
        this.font_ = font;
      }
      /**
       * Set the maximum angle between adjacent characters.
       *
       * @param {number} maxAngle Angle in radians.
       * @api
       */
      setMaxAngle(maxAngle) {
        this.maxAngle_ = maxAngle;
      }
      /**
       * Set the x offset.
       *
       * @param {number} offsetX Horizontal text offset.
       * @api
       */
      setOffsetX(offsetX) {
        this.offsetX_ = offsetX;
      }
      /**
       * Set the y offset.
       *
       * @param {number} offsetY Vertical text offset.
       * @api
       */
      setOffsetY(offsetY) {
        this.offsetY_ = offsetY;
      }
      /**
       * Set the text placement.
       *
       * @param {TextPlacement} placement Placement.
       * @api
       */
      setPlacement(placement) {
        this.placement_ = placement;
      }
      /**
       * Set the repeat interval of the text.
       * @param {number|undefined} [repeat] Repeat interval in pixels.
       * @api
       */
      setRepeat(repeat) {
        this.repeat_ = repeat;
      }
      /**
       * Set whether to rotate the text with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Set the rotation.
       *
       * @param {number|undefined} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size|undefined} scale Scale.
       * @api
       */
      setScale(scale4) {
        this.scale_ = scale4;
        this.scaleArray_ = toSize(scale4 !== void 0 ? scale4 : 1);
      }
      /**
       * Set the stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Set the text.
       *
       * @param {string|Array<string>|undefined} text Text.
       * @api
       */
      setText(text) {
        this.text_ = text;
      }
      /**
       * Set the text alignment.
       *
       * @param {CanvasTextAlign|undefined} textAlign Text align.
       * @api
       */
      setTextAlign(textAlign) {
        this.textAlign_ = textAlign;
      }
      /**
       * Set the justification.
       *
       * @param {TextJustify|undefined} justify Justification.
       * @api
       */
      setJustify(justify) {
        this.justify_ = justify;
      }
      /**
       * Set the text baseline.
       *
       * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
       * @api
       */
      setTextBaseline(textBaseline) {
        this.textBaseline_ = textBaseline;
      }
      /**
       * Set the background fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setBackgroundFill(fill) {
        this.backgroundFill_ = fill;
      }
      /**
       * Set the background stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setBackgroundStroke(stroke) {
        this.backgroundStroke_ = stroke;
      }
      /**
       * Set the padding (`[top, right, bottom, left]`).
       *
       * @param {Array<number>|null} padding Padding.
       * @api
       */
      setPadding(padding) {
        this.padding_ = padding;
      }
    };
    Text_default = Text;
  }
});

// node_modules/quickselect/index.js
function quickselect(arr, k, left, right, compare) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0)
      swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0)
        i++;
      while (compare(arr[j], t) > 0)
        j--;
    }
    if (compare(arr[left], t) === 0)
      swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var init_quickselect = __esm({
  "node_modules/quickselect/index.js"() {
  }
});

// node_modules/rbush/index.js
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i]))
      return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend3(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend3(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects2(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n)
      continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
var RBush;
var init_rbush = __esm({
  "node_modules/rbush/index.js"() {
    init_quickselect();
    RBush = class {
      constructor(maxEntries = 9) {
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      }
      all() {
        return this._all(this.data, []);
      }
      search(bbox) {
        let node = this.data;
        const result = [];
        if (!intersects2(bbox, node))
          return result;
        const toBBox = this.toBBox;
        const nodesToSearch = [];
        while (node) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childBBox = node.leaf ? toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf)
                result.push(child);
              else if (contains(bbox, childBBox))
                this._all(child, result);
              else
                nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      }
      collides(bbox) {
        let node = this.data;
        if (!intersects2(bbox, node))
          return false;
        const nodesToSearch = [];
        while (node) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox))
                return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      }
      load(data) {
        if (!(data && data.length))
          return this;
        if (data.length < this._minEntries) {
          for (let i = 0; i < data.length; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        let node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            const tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      }
      insert(item) {
        if (item)
          this._insert(item, this.data.height - 1);
        return this;
      }
      clear() {
        this.data = createNode([]);
        return this;
      }
      remove(item, equalsFn) {
        if (!item)
          return this;
        let node = this.data;
        const bbox = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            const index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else
            node = null;
        }
        return this;
      }
      toBBox(item) {
        return item;
      }
      compareMinX(a, b) {
        return a.minX - b.minX;
      }
      compareMinY(a, b) {
        return a.minY - b.minY;
      }
      toJSON() {
        return this.data;
      }
      fromJSON(data) {
        this.data = data;
        return this;
      }
      _all(node, result) {
        const nodesToSearch = [];
        while (node) {
          if (node.leaf)
            result.push(...node.children);
          else
            nodesToSearch.push(...node.children);
          node = nodesToSearch.pop();
        }
        return result;
      }
      _build(items, left, right, height) {
        const N = right - left + 1;
        let M = this._maxEntries;
        let node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        const N2 = Math.ceil(N / M);
        const N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (let i = left; i <= right; i += N1) {
          const right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (let j = i; j <= right2; j += N2) {
            const right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      }
      _chooseSubtree(bbox, node, level2, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level2)
            break;
          let minArea = Infinity;
          let minEnlargement = Infinity;
          let targetNode;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const area = bboxArea(child);
            const enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      }
      _insert(item, level2, isNode) {
        const bbox = isNode ? item : this.toBBox(item);
        const insertPath = [];
        const node = this._chooseSubtree(bbox, this.data, level2, insertPath);
        node.children.push(item);
        extend3(node, bbox);
        while (level2 >= 0) {
          if (insertPath[level2].children.length > this._maxEntries) {
            this._split(insertPath, level2);
            level2--;
          } else
            break;
        }
        this._adjustParentBBoxes(bbox, insertPath, level2);
      }
      // split overflowed node into two
      _split(insertPath, level2) {
        const node = insertPath[level2];
        const M = node.children.length;
        const m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        const splitIndex = this._chooseSplitIndex(node, m, M);
        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level2)
          insertPath[level2 - 1].children.push(newNode);
        else
          this._splitRoot(node, newNode);
      }
      _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      }
      _chooseSplitIndex(node, m, M) {
        let index;
        let minOverlap = Infinity;
        let minArea = Infinity;
        for (let i = m; i <= M - m; i++) {
          const bbox1 = distBBox(node, 0, i, this.toBBox);
          const bbox2 = distBBox(node, i, M, this.toBBox);
          const overlap = intersectionArea(bbox1, bbox2);
          const area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index || M - m;
      }
      // sorts node children by the best axis for split
      _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m, M, compareMinX);
        const yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin)
          node.children.sort(compareMinX);
      }
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m, toBBox);
        const rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (let i = m; i < M - m; i++) {
          const child = node.children[i];
          extend3(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (let i = M - m - 1; i >= m; i--) {
          const child = node.children[i];
          extend3(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      }
      _adjustParentBBoxes(bbox, path, level2) {
        for (let i = level2; i >= 0; i--) {
          extend3(path[i], bbox);
        }
      }
      _condense(path) {
        for (let i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else
              this.clear();
          } else
            calcBBox(path[i], this.toBBox);
        }
      }
    };
  }
});

// node_modules/ol/style/IconImage.js
function get4(image, cacheKey, crossOrigin, imageState, color) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image instanceof HTMLImageElement ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage);
  }
  return iconImage;
}
var taintedTestContext, IconImage;
var init_IconImage = __esm({
  "node_modules/ol/style/IconImage.js"() {
    init_Target();
    init_EventType();
    init_ImageState();
    init_color();
    init_dom();
    init_Image();
    init_IconImageCache();
    taintedTestContext = null;
    IconImage = class extends Target_default {
      /**
       * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
       * @param {string|undefined} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default} imageState Image state.
       * @param {import("../color.js").Color} color Color.
       */
      constructor(image, src, crossOrigin, imageState, color) {
        super();
        this.hitDetectionImage_ = null;
        this.image_ = image;
        this.crossOrigin_ = crossOrigin;
        this.canvas_ = {};
        this.color_ = color;
        this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
        this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
        this.src_ = src;
        this.tainted_;
      }
      /**
       * @private
       */
      initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      isTainted_() {
        if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
          if (!taintedTestContext) {
            taintedTestContext = createCanvasContext2D(1, 1, void 0, {
              willReadFrequently: true
            });
          }
          taintedTestContext.drawImage(this.image_, 0, 0);
          try {
            taintedTestContext.getImageData(0, 0, 1, 1);
            this.tainted_ = false;
          } catch (e) {
            taintedTestContext = null;
            this.tainted_ = true;
          }
        }
        return this.tainted_ === true;
      }
      /**
       * @private
       */
      dispatchChangeEvent_() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @private
       */
      handleImageError_() {
        this.imageState_ = ImageState_default.ERROR;
        this.dispatchChangeEvent_();
      }
      /**
       * @private
       */
      handleImageLoad_() {
        this.imageState_ = ImageState_default.LOADED;
        this.size_ = [this.image_.width, this.image_.height];
        this.dispatchChangeEvent_();
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
       */
      getImage(pixelRatio) {
        if (!this.image_) {
          this.initializeImage_();
        }
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        if (!this.image_) {
          this.initializeImage_();
        }
        if (!this.hitDetectionImage_) {
          if (this.isTainted_()) {
            const width = this.size_[0];
            const height = this.size_[1];
            const context = createCanvasContext2D(width, height);
            context.fillRect(0, 0, width, height);
            this.hitDetectionImage_ = context.canvas;
          } else {
            this.hitDetectionImage_ = this.image_;
          }
        }
        return this.hitDetectionImage_;
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      getSize() {
        return this.size_;
      }
      /**
       * @return {string|undefined} Image src.
       */
      getSrc() {
        return this.src_;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.imageState_ !== ImageState_default.IDLE) {
          return;
        }
        if (!this.image_) {
          this.initializeImage_();
        }
        this.imageState_ = ImageState_default.LOADING;
        try {
          if (this.src_ !== void 0) {
            this.image_.src = this.src_;
          }
        } catch (e) {
          this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) {
          decodeFallback(this.image_, this.src_).then((image) => {
            this.image_ = image;
            this.handleImageLoad_();
          }).catch(this.handleImageError_.bind(this));
        }
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
          return;
        }
        const image = this.image_;
        const canvas = document.createElement("canvas");
        canvas.width = Math.ceil(image.width * pixelRatio);
        canvas.height = Math.ceil(image.height * pixelRatio);
        const ctx = canvas.getContext("2d");
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = asString(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
      }
    };
  }
});

// node_modules/ol/style/Icon.js
var Icon_exports = {};
__export(Icon_exports, {
  default: () => Icon_default
});
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
var Icon, Icon_default;
var init_Icon = __esm({
  "node_modules/ol/style/Icon.js"() {
    init_EventType();
    init_ImageState();
    init_Image2();
    init_color();
    init_asserts();
    init_IconImage();
    init_util();
    Icon = class _Icon extends Image_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        const opacity = options.opacity !== void 0 ? options.opacity : 1;
        const rotation = options.rotation !== void 0 ? options.rotation : 0;
        const scale4 = options.scale !== void 0 ? options.scale : 1;
        const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
        super({
          opacity,
          rotation,
          scale: scale4,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          rotateWithView,
          declutterMode: options.declutterMode
        });
        this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
        this.normalizedAnchor_ = null;
        this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
        this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
        this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
        this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
        const image = options.img !== void 0 ? options.img : null;
        let cacheKey = options.src;
        assert(
          !(cacheKey !== void 0 && image),
          "`image` and `src` cannot be provided at the same time"
        );
        if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
          cacheKey = /** @type {HTMLImageElement} */
          image.src || getUid(image);
        }
        assert(
          cacheKey !== void 0 && cacheKey.length > 0,
          "A defined and non-empty `src` or `image` must be provided"
        );
        assert(
          !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
          "`width` or `height` cannot be provided together with `scale`"
        );
        let imageState;
        if (options.src !== void 0) {
          imageState = ImageState_default.IDLE;
        } else if (image !== void 0) {
          if (image instanceof HTMLImageElement) {
            if (image.complete) {
              imageState = image.src ? ImageState_default.LOADED : ImageState_default.IDLE;
            } else {
              imageState = ImageState_default.LOADING;
            }
          } else {
            imageState = ImageState_default.LOADED;
          }
        }
        this.color_ = options.color !== void 0 ? asArray(options.color) : null;
        this.iconImage_ = get4(
          image,
          /** @type {string} */
          cacheKey,
          this.crossOrigin_,
          imageState,
          this.color_
        );
        this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
        this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
        this.origin_ = null;
        this.size_ = options.size !== void 0 ? options.size : null;
        if (options.width !== void 0 || options.height !== void 0) {
          let width, height;
          if (options.size) {
            [width, height] = options.size;
          } else {
            const image2 = this.getImage(1);
            if (image2.width && image2.height) {
              width = image2.width;
              height = image2.height;
            } else if (image2 instanceof HTMLImageElement) {
              this.initialOptions_ = options;
              const onload = () => {
                this.unlistenImageChange(onload);
                if (!this.initialOptions_) {
                  return;
                }
                const imageSize = this.iconImage_.getSize();
                this.setScale(
                  calculateScale(
                    imageSize[0],
                    imageSize[1],
                    options.width,
                    options.height
                  )
                );
              };
              this.listenImageChange(onload);
              return;
            }
          }
          if (width !== void 0) {
            this.setScale(
              calculateScale(width, height, options.width, options.height)
            );
          }
        }
      }
      /**
       * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
       * @return {Icon} The cloned style.
       * @api
       */
      clone() {
        let scale4, width, height;
        if (this.initialOptions_) {
          width = this.initialOptions_.width;
          height = this.initialOptions_.height;
        } else {
          scale4 = this.getScale();
          scale4 = Array.isArray(scale4) ? scale4.slice() : scale4;
        }
        return new _Icon({
          anchor: this.anchor_.slice(),
          anchorOrigin: this.anchorOrigin_,
          anchorXUnits: this.anchorXUnits_,
          anchorYUnits: this.anchorYUnits_,
          color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
          crossOrigin: this.crossOrigin_,
          offset: this.offset_.slice(),
          offsetOrigin: this.offsetOrigin_,
          opacity: this.getOpacity(),
          rotateWithView: this.getRotateWithView(),
          rotation: this.getRotation(),
          scale: scale4,
          width,
          height,
          size: this.size_ !== null ? this.size_.slice() : void 0,
          src: this.getSrc(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      getAnchor() {
        let anchor = this.normalizedAnchor_;
        if (!anchor) {
          anchor = this.anchor_;
          const size = this.getSize();
          if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
            if (!size) {
              return null;
            }
            anchor = this.anchor_.slice();
            if (this.anchorXUnits_ == "fraction") {
              anchor[0] *= size[0];
            }
            if (this.anchorYUnits_ == "fraction") {
              anchor[1] *= size[1];
            }
          }
          if (this.anchorOrigin_ != "top-left") {
            if (!size) {
              return null;
            }
            if (anchor === this.anchor_) {
              anchor = this.anchor_.slice();
            }
            if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
              anchor[0] = -anchor[0] + size[0];
            }
            if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
              anchor[1] = -anchor[1] + size[1];
            }
          }
          this.normalizedAnchor_ = anchor;
        }
        const displacement = this.getDisplacement();
        const scale4 = this.getScaleArray();
        return [
          anchor[0] - displacement[0] / scale4[0],
          anchor[1] + displacement[1] / scale4[1]
        ];
      }
      /**
       * Set the anchor point. The anchor determines the center point for the
       * symbolizer.
       *
       * @param {Array<number>} anchor Anchor.
       * @api
       */
      setAnchor(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
      }
      /**
       * Get the icon color.
       * @return {import("../color.js").Color} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
       * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
       * @api
       */
      getImage(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
      }
      /**
       * Get the pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} The pixel ratio of the image.
       * @api
       */
      getPixelRatio(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
      }
      /**
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return this.iconImage_.getSize();
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.iconImage_.getImageState();
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      getOrigin() {
        if (this.origin_) {
          return this.origin_;
        }
        let offset = this.offset_;
        if (this.offsetOrigin_ != "top-left") {
          const size = this.getSize();
          const iconImageSize = this.iconImage_.getSize();
          if (!size || !iconImageSize) {
            return null;
          }
          offset = offset.slice();
          if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
            offset[0] = iconImageSize[0] - size[0] - offset[0];
          }
          if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
            offset[1] = iconImageSize[1] - size[1] - offset[1];
          }
        }
        this.origin_ = offset;
        return this.origin_;
      }
      /**
       * Get the image URL.
       * @return {string|undefined} Image src.
       * @api
       */
      getSrc() {
        return this.iconImage_.getSrc();
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       * @api
       */
      getSize() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
      }
      /**
       * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon width (in pixels).
       * @api
       */
      getWidth() {
        const scale4 = this.getScaleArray();
        if (this.size_) {
          return this.size_[0] * scale4[0];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[0] * scale4[0];
        }
        return void 0;
      }
      /**
       * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon height (in pixels).
       * @api
       */
      getHeight() {
        const scale4 = this.getScaleArray();
        if (this.size_) {
          return this.size_[1] * scale4[1];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[1] * scale4[1];
        }
        return void 0;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale4) {
        delete this.initialOptions_;
        super.setScale(scale4);
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
      }
      /**
       * Load not yet loaded URI.
       * When rendering a feature with an icon style, the vector renderer will
       * automatically call this method. However, you might want to call this
       * method yourself for preloading or other purposes.
       * @api
       */
      load() {
        this.iconImage_.load();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
      }
    };
    Icon_default = Icon;
  }
});

// node_modules/ol/expr/expression.js
function typeName(type) {
  const names2 = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names2.push(typeNames[namedType]);
    }
  }
  if (names2.length === 0) {
    return "untyped";
  }
  if (names2.length < 3) {
    return names2.join(" or ");
  }
  return names2.slice(0, -1).join(", ") + ", or " + names2[names2.length - 1];
}
function includesType(broad, specific) {
  return (broad & specific) === specific;
}
function overlapsType(oneType, otherType) {
  return !!(oneType & otherType);
}
function isType(type, expected) {
  return type === expected;
}
function newParsingContext() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: false,
    style: {}
  };
}
function getTypeFromHint(typeHint) {
  switch (typeHint) {
    case "string":
      return StringType;
    case "color":
      return ColorType;
    case "number":
      return NumberType;
    case "boolean":
      return BooleanType;
    case "number[]":
      return NumberArrayType;
    default:
      throw new Error(`Unrecognized type hint: ${typeHint}`);
  }
}
function parse2(encoded, context, typeHint) {
  switch (typeof encoded) {
    case "boolean": {
      return new LiteralExpression(BooleanType, encoded);
    }
    case "number": {
      return new LiteralExpression(NumberType, encoded);
    }
    case "string": {
      let type2 = StringType;
      if (isStringColor(encoded)) {
        type2 |= ColorType;
      }
      if (!isType(type2 & typeHint, NoneType)) {
        type2 &= typeHint;
      }
      return new LiteralExpression(type2, encoded);
    }
    default: {
    }
  }
  if (!Array.isArray(encoded)) {
    throw new Error("Expression must be an array or a primitive value");
  }
  if (encoded.length === 0) {
    throw new Error("Empty expression");
  }
  if (typeof encoded[0] === "string") {
    return parseCallExpression(encoded, context, typeHint);
  }
  for (const item of encoded) {
    if (typeof item !== "number") {
      throw new Error("Expected an array of numbers");
    }
  }
  let type = NumberArrayType;
  if (encoded.length === 3 || encoded.length === 4) {
    type |= ColorType;
  }
  if (typeHint) {
    type &= typeHint;
  }
  return new LiteralExpression(type, encoded);
}
function withGetArgs(encoded, context) {
  const arg = parse2(encoded[1], context);
  if (!(arg instanceof LiteralExpression)) {
    throw new Error("Expected a literal argument for get operation");
  }
  if (typeof arg.value !== "string") {
    throw new Error("Expected a string argument for get operation");
  }
  context.properties.add(arg.value);
  if (encoded.length === 3) {
    const hint = parse2(encoded[2], context);
    return [arg, hint];
  }
  return [arg];
}
function withVarArgs(encoded, context, parsedArgs, typeHint) {
  const varName = encoded[1];
  if (typeof varName !== "string") {
    throw new Error("Expected a string argument for var operation");
  }
  context.variables.add(varName);
  if (!("variables" in context.style) || context.style.variables[varName] === void 0) {
    return [new LiteralExpression(AnyType, varName)];
  }
  const initialValue = context.style.variables[varName];
  const arg = (
    /** @type {LiteralExpression} */
    parse2(initialValue, context)
  );
  arg.value = varName;
  if (typeHint && !overlapsType(typeHint, arg.type)) {
    throw new Error(
      `The variable ${varName} has type ${typeName(
        arg.type
      )} but the following type was expected: ${typeName(typeHint)}`
    );
  }
  return [arg];
}
function usesFeatureId(encoded, context) {
  context.featureId = true;
}
function withNoArgs(encoded, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`Expected no arguments for ${operation} operation`);
  }
  return [];
}
function withArgsCount(minArgs, maxArgs) {
  return function(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? "" : "s";
        throw new Error(
          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `Expected ${range} arguments for ${operation}, got ${argCount}`
      );
    }
  };
}
function parseArgsOfType(argType) {
  return function(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse2(encoded[i + 1], context);
      if (!overlapsType(argType, expression.type)) {
        const gotType = typeName(argType);
        const expectedType = typeName(expression.type);
        throw new Error(
          `Unexpected type for argument ${i} of ${operation} operation, got ${gotType} but expected ${expectedType}`
        );
      }
      expression.type &= argType;
      args[i] = expression;
    }
    return args;
  };
}
function narrowArgsType(encoded, context, parsedArgs) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  let sameType = AnyType;
  for (let i = 0; i < parsedArgs.length; ++i) {
    sameType &= parsedArgs[i].type;
  }
  if (sameType === NoneType) {
    throw new Error(
      `No common type could be found for arguments of ${operation} operation`
    );
  }
  const args = new Array(argCount);
  for (let i = 0; i < argCount; ++i) {
    args[i] = parse2(encoded[i + 1], context, sameType);
  }
  return args;
}
function withOddArgs(encoded, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(
        argCount
      )} instead`
    );
  }
}
function withEvenArgs(encoded, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(
        argCount
      )} instead`
    );
  }
}
function parseMatchArgs(encoded, context, parsedArgs, typeHint) {
  const argsCount = encoded.length - 1;
  const input = parse2(encoded[1], context);
  let inputType = input.type;
  const fallback = parse2(encoded[encoded.length - 1], context);
  let outputType = typeHint !== void 0 ? typeHint & fallback.type : fallback.type;
  const args = new Array(argsCount - 2);
  for (let i = 0; i < argsCount - 2; i += 2) {
    const match = parse2(encoded[i + 2], context);
    const output = parse2(encoded[i + 3], context);
    inputType &= match.type;
    outputType &= output.type;
    args[i] = match;
    args[i + 1] = output;
  }
  const expectedInputType = StringType | NumberType | BooleanType;
  if (!overlapsType(expectedInputType, inputType)) {
    throw new Error(
      `Expected an input of type ${typeName(
        expectedInputType
      )} for the interpolate operation, got ${typeName(inputType)} instead`
    );
  }
  if (isType(outputType, NoneType)) {
    throw new Error(
      `Could not find a common output type for the following match operation: ` + JSON.stringify(encoded)
    );
  }
  for (let i = 0; i < argsCount - 2; i += 2) {
    const match = parse2(encoded[i + 2], context, inputType);
    const output = parse2(encoded[i + 3], context, outputType);
    args[i] = match;
    args[i + 1] = output;
  }
  return [
    parse2(encoded[1], context, inputType),
    ...args,
    parse2(encoded[encoded.length - 1], context, outputType)
  ];
}
function parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {
  const interpolationType = encoded[1];
  let interpolation;
  switch (interpolationType[0]) {
    case "linear":
      interpolation = 1;
      break;
    case "exponential":
      interpolation = interpolationType[1];
      if (typeof interpolation !== "number") {
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(interpolation)} instead`
        );
      }
      break;
    default:
      interpolation = null;
  }
  if (!interpolation) {
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`
    );
  }
  interpolation = parse2(interpolation, context);
  let input = parse2(encoded[2], context);
  if (!overlapsType(NumberType, input.type)) {
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${typeName(input.type)} instead`
    );
  }
  input = parse2(encoded[2], context, NumberType);
  const args = new Array(encoded.length - 3);
  for (let i = 0; i < args.length; i += 2) {
    let stop = parse2(encoded[i + 3], context);
    if (!overlapsType(NumberType, stop.type)) {
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${typeName(stop.type)} at position ${i + 2} instead`
      );
    }
    let output = parse2(encoded[i + 4], context);
    if (!overlapsType(NumberType | ColorType, output.type)) {
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${typeName(output.type)} at position ${i + 3} instead`
      );
    }
    stop = parse2(encoded[i + 3], context, NumberType);
    output = parse2(encoded[i + 4], context, NumberType | ColorType);
    args[i] = stop;
    args[i + 1] = output;
  }
  return [interpolation, input, ...args];
}
function parseCaseArgs(encoded, context, parsedArgs, typeHint) {
  const fallback = parse2(encoded[encoded.length - 1], context);
  let outputType = typeHint !== void 0 ? typeHint & fallback.type : fallback.type;
  const args = new Array(encoded.length - 1);
  for (let i = 0; i < args.length - 1; i += 2) {
    const condition = parse2(encoded[i + 1], context);
    const output = parse2(encoded[i + 2], context);
    if (!overlapsType(BooleanType, condition.type)) {
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${typeName(condition.type)} at position ${i} instead`
      );
    }
    outputType &= output.type;
    args[i] = condition;
    args[i + 1] = output;
  }
  if (isType(outputType, NoneType)) {
    throw new Error(
      `Could not find a common output type for the following case operation: ` + JSON.stringify(encoded)
    );
  }
  for (let i = 0; i < args.length - 1; i += 2) {
    args[i + 1] = parse2(encoded[i + 2], context, outputType);
  }
  args[args.length - 1] = parse2(
    encoded[encoded.length - 1],
    context,
    outputType
  );
  return args;
}
function parseInArgs(encoded, context) {
  let haystack = (
    /** @type {any} */
    encoded[2]
  );
  if (!Array.isArray(haystack)) {
    throw new Error(
      `The "in" operator was provided a literal value which was not an array as second argument.`
    );
  }
  if (typeof haystack[0] === "string") {
    if (haystack[0] !== "literal") {
      throw new Error(
        `For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.`
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `The "in" operator was provided a literal value which was not an array as second argument.`
      );
    }
    haystack = haystack[1];
  }
  let needleType = StringType | NumberType;
  const args = new Array(haystack.length);
  for (let i = 0; i < args.length; i++) {
    const arg = parse2(haystack[i], context);
    needleType &= arg.type;
    args[i] = arg;
  }
  if (isType(needleType, NoneType)) {
    throw new Error(
      `Could not find a common type for the following in operation: ` + JSON.stringify(encoded)
    );
  }
  const needle = parse2(encoded[1], context, needleType);
  return [needle, ...args];
}
function parsePaletteArgs(encoded, context) {
  const index = parse2(encoded[1], context, NumberType);
  if (index.type !== NumberType) {
    throw new Error(
      `The first argument of palette must be an number, got ${typeName(
        index.type
      )} instead`
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error("The second argument of palette must be an array");
  }
  const parsedColors = new Array(colors.length);
  for (let i = 0; i < parsedColors.length; i++) {
    const color = parse2(colors[i], context, ColorType);
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `The palette color at index ${i} must be a literal value`
      );
    }
    if (!overlapsType(color.type, ColorType)) {
      throw new Error(
        `The palette color at index ${i} should be of type color, got ${typeName(
          color.type
        )} instead`
      );
    }
    parsedColors[i] = color;
  }
  return [index, ...parsedColors];
}
function createParser(returnType, ...argValidators) {
  return function(encoded, context, typeHint) {
    const operator = encoded[0];
    let parsedArgs = [];
    for (let i = 0; i < argValidators.length; i++) {
      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;
    }
    let actualType = typeof returnType === "function" ? returnType(parsedArgs) : returnType;
    if (typeHint !== void 0) {
      if (!overlapsType(actualType, typeHint)) {
        throw new Error(
          `The following expression was expected to return ${typeName(
            typeHint
          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(
            encoded
          )}`
        );
      }
      actualType &= typeHint;
    }
    if (actualType === NoneType) {
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          encoded
        )}`
      );
    }
    return new CallExpression(actualType, operator, ...parsedArgs);
  };
}
function parseCallExpression(encoded, context, typeHint) {
  const operator = encoded[0];
  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`Unknown operator: ${operator}`);
  }
  return parser(encoded, context, typeHint);
}
var numTypes, NoneType, BooleanType, NumberType, StringType, ColorType, NumberArrayType, AnyType, typeNames, namedTypes, LiteralExpression, CallExpression, Ops, parsers;
var init_expression = __esm({
  "node_modules/ol/expr/expression.js"() {
    init_array();
    init_color();
    numTypes = 0;
    NoneType = 0;
    BooleanType = 1 << numTypes++;
    NumberType = 1 << numTypes++;
    StringType = 1 << numTypes++;
    ColorType = 1 << numTypes++;
    NumberArrayType = 1 << numTypes++;
    AnyType = Math.pow(2, numTypes) - 1;
    typeNames = {
      [BooleanType]: "boolean",
      [NumberType]: "number",
      [StringType]: "string",
      [ColorType]: "color",
      [NumberArrayType]: "number[]"
    };
    namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
    LiteralExpression = class {
      /**
       * @param {number} type The value type.
       * @param {LiteralValue} value The literal value.
       */
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
    };
    CallExpression = class {
      /**
       * @param {number} type The return type.
       * @param {string} operator The operator.
       * @param {...Expression} args The arguments.
       */
      constructor(type, operator, ...args) {
        this.type = type;
        this.operator = operator;
        this.args = args;
      }
    };
    Ops = {
      Get: "get",
      Var: "var",
      Concat: "concat",
      GeometryType: "geometry-type",
      Any: "any",
      All: "all",
      Not: "!",
      Resolution: "resolution",
      Zoom: "zoom",
      Time: "time",
      Equal: "==",
      NotEqual: "!=",
      GreaterThan: ">",
      GreaterThanOrEqualTo: ">=",
      LessThan: "<",
      LessThanOrEqualTo: "<=",
      Multiply: "*",
      Divide: "/",
      Add: "+",
      Subtract: "-",
      Clamp: "clamp",
      Mod: "%",
      Pow: "^",
      Abs: "abs",
      Floor: "floor",
      Ceil: "ceil",
      Round: "round",
      Sin: "sin",
      Cos: "cos",
      Atan: "atan",
      Sqrt: "sqrt",
      Match: "match",
      Between: "between",
      Interpolate: "interpolate",
      Case: "case",
      In: "in",
      Number: "number",
      String: "string",
      Array: "array",
      Color: "color",
      Id: "id",
      Band: "band",
      Palette: "palette"
    };
    parsers = {
      [Ops.Get]: createParser(
        ([_, typeHint]) => {
          if (typeHint !== void 0) {
            return getTypeFromHint(
              /** @type {string} */
              /** @type {LiteralExpression} */
              typeHint.value
            );
          }
          return AnyType;
        },
        withArgsCount(1, 2),
        withGetArgs
      ),
      [Ops.Var]: createParser(
        ([firstArg]) => firstArg.type,
        withArgsCount(1, 1),
        withVarArgs
      ),
      [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),
      [Ops.Concat]: createParser(
        StringType,
        withArgsCount(2, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.GeometryType]: createParser(StringType, withNoArgs),
      [Ops.Resolution]: createParser(NumberType, withNoArgs),
      [Ops.Zoom]: createParser(NumberType, withNoArgs),
      [Ops.Time]: createParser(NumberType, withNoArgs),
      [Ops.Any]: createParser(
        BooleanType,
        withArgsCount(2, Infinity),
        parseArgsOfType(BooleanType)
      ),
      [Ops.All]: createParser(
        BooleanType,
        withArgsCount(2, Infinity),
        parseArgsOfType(BooleanType)
      ),
      [Ops.Not]: createParser(
        BooleanType,
        withArgsCount(1, 1),
        parseArgsOfType(BooleanType)
      ),
      [Ops.Equal]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.NotEqual]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.GreaterThan]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.GreaterThanOrEqualTo]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.LessThan]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.LessThanOrEqualTo]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.Multiply]: createParser(
        (parsedArgs) => {
          let outputType = NumberType | ColorType;
          for (let i = 0; i < parsedArgs.length; i++) {
            outputType &= parsedArgs[i].type;
          }
          return outputType;
        },
        withArgsCount(2, Infinity),
        parseArgsOfType(NumberType | ColorType),
        narrowArgsType
      ),
      [Ops.Divide]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Add]: createParser(
        NumberType,
        withArgsCount(2, Infinity),
        parseArgsOfType(NumberType)
      ),
      [Ops.Subtract]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Clamp]: createParser(
        NumberType,
        withArgsCount(3, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Mod]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Pow]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Abs]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Floor]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Ceil]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Round]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Sin]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Cos]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Atan]: createParser(
        NumberType,
        withArgsCount(1, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Sqrt]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Match]: createParser(
        (parsedArgs) => {
          let type = AnyType;
          for (let i = 2; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          type &= parsedArgs[parsedArgs.length - 1].type;
          return type;
        },
        withArgsCount(4, Infinity),
        withEvenArgs,
        parseMatchArgs
      ),
      [Ops.Between]: createParser(
        BooleanType,
        withArgsCount(3, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Interpolate]: createParser(
        (parsedArgs) => {
          let type = ColorType | NumberType;
          for (let i = 3; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          return type;
        },
        withArgsCount(6, Infinity),
        withEvenArgs,
        parseInterpolateArgs
      ),
      [Ops.Case]: createParser(
        (parsedArgs) => {
          let type = AnyType;
          for (let i = 1; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          type &= parsedArgs[parsedArgs.length - 1].type;
          return type;
        },
        withArgsCount(3, Infinity),
        withOddArgs,
        parseCaseArgs
      ),
      [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),
      [Ops.Number]: createParser(
        NumberType,
        withArgsCount(1, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.String]: createParser(
        StringType,
        withArgsCount(1, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.Array]: createParser(
        (parsedArgs) => {
          return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;
        },
        withArgsCount(1, Infinity),
        parseArgsOfType(NumberType)
      ),
      [Ops.Color]: createParser(
        ColorType,
        withArgsCount(3, 4),
        parseArgsOfType(NumberType)
      ),
      [Ops.Band]: createParser(
        NumberType,
        withArgsCount(1, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)
    };
  }
});

// node_modules/ol/expr/cpu.js
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null
  };
}
function buildExpression(encoded, type, context) {
  const expression = parse2(encoded, context);
  if (!overlapsType(type, expression.type)) {
    const expected = typeName(type);
    const actual = typeName(expression.type);
    throw new Error(
      `Expected expression to be of type ${expected}, got ${actual}`
    );
  }
  return compileExpression(expression, context);
}
function compileExpression(expression, context) {
  if (expression instanceof LiteralExpression) {
    if (expression.type === ColorType && typeof expression.value === "string") {
      const colorValue = fromString(expression.value);
      return function() {
        return colorValue;
      };
    }
    return function() {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case Ops.Number:
    case Ops.String: {
      return compileAssertionExpression(expression, context);
    }
    case Ops.Get:
    case Ops.Var: {
      return compileAccessorExpression(expression, context);
    }
    case Ops.Id: {
      return (expression2) => expression2.featureId;
    }
    case Ops.Concat: {
      const args = expression.args.map((e) => compileExpression(e, context));
      return (context2) => "".concat(...args.map((arg) => arg(context2).toString()));
    }
    case Ops.Resolution: {
      return (context2) => context2.resolution;
    }
    case Ops.Any:
    case Ops.All:
    case Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    case Ops.Interpolate: {
      return compileInterpolateExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case Ops.Number:
    case Ops.String: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}
function compileAccessorExpression(expression, context) {
  const nameExpression = (
    /** @type {LiteralExpression} */
    expression.args[0]
  );
  const name = (
    /** @type {string} */
    nameExpression.value
  );
  switch (expression.operator) {
    case Ops.Get: {
      return (context2) => context2.properties[name];
    }
    case Ops.Var: {
      return (context2) => context2.variables[name];
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case Ops.Equal: {
      return (context2) => left(context2) === right(context2);
    }
    case Ops.NotEqual: {
      return (context2) => left(context2) !== right(context2);
    }
    case Ops.LessThan: {
      return (context2) => left(context2) < right(context2);
    }
    case Ops.LessThanOrEqualTo: {
      return (context2) => left(context2) <= right(context2);
    }
    case Ops.GreaterThan: {
      return (context2) => left(context2) > right(context2);
    }
    case Ops.GreaterThanOrEqualTo: {
      return (context2) => left(context2) >= right(context2);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Any: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.All: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context2)) {
            return false;
          }
        }
        return true;
      };
    }
    case Ops.Not: {
      return (context2) => !args[0](context2);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Multiply: {
      return (context2) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context2);
        }
        return value;
      };
    }
    case Ops.Divide: {
      return (context2) => args[0](context2) / args[1](context2);
    }
    case Ops.Add: {
      return (context2) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context2);
        }
        return value;
      };
    }
    case Ops.Subtract: {
      return (context2) => args[0](context2) - args[1](context2);
    }
    case Ops.Clamp: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        if (value < min) {
          return min;
        }
        const max = args[2](context2);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case Ops.Mod: {
      return (context2) => args[0](context2) % args[1](context2);
    }
    case Ops.Pow: {
      return (context2) => Math.pow(args[0](context2), args[1](context2));
    }
    case Ops.Abs: {
      return (context2) => Math.abs(args[0](context2));
    }
    case Ops.Floor: {
      return (context2) => Math.floor(args[0](context2));
    }
    case Ops.Ceil: {
      return (context2) => Math.ceil(args[0](context2));
    }
    case Ops.Round: {
      return (context2) => Math.round(args[0](context2));
    }
    case Ops.Sin: {
      return (context2) => Math.sin(args[0](context2));
    }
    case Ops.Cos: {
      return (context2) => Math.cos(args[0](context2));
    }
    case Ops.Atan: {
      if (length === 2) {
        return (context2) => Math.atan2(args[0](context2), args[1](context2));
      }
      return (context2) => Math.atan(args[0](context2));
    }
    case Ops.Sqrt: {
      return (context2) => Math.sqrt(args[0](context2));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const value = args[0](context2);
    for (let i = 1; i < length; i += 2) {
      if (value === args[i](context2)) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const base = args[0](context2);
    const value = args[1](context2);
    let previousInput;
    let previousOutput;
    for (let i = 2; i < length; i += 2) {
      const input = args[i](context2);
      let output = args[i + 1](context2);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = withAlpha(output);
      }
      if (input >= value) {
        if (i === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = rgbaToLcha(rgba1);
  const lcha2 = rgbaToLcha(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
  ];
  return normalize(lchaToRgba(lcha));
}
var init_cpu = __esm({
  "node_modules/ol/expr/cpu.js"() {
    init_expression();
    init_color();
  }
});

// node_modules/ol/render/canvas/style.js
function always2(context) {
  return true;
}
function rulesToStyleFunction(rules) {
  const parsingContext = newParsingContext();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = newEvaluationContext();
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    return evaluator(evaluationContext);
  };
}
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = newParsingContext();
  const length = flatStyles.length;
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = newEvaluationContext();
  const styles = new Array(length);
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i = 0; i < length; ++i) {
      const style = evaluators[i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}
function buildRuleSet(rules, context) {
  const length = rules.length;
  const compiledRules = new Array(length);
  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always2;
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i] = { filter, styles };
  }
  return function(context2) {
    const styles = [];
    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context2)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context2);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }
    return styles;
  };
}
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, "", context);
  const evaluateStroke = buildStroke(flatStyle, "", context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle)
    );
  }
  const style = new Style_default();
  return function(context2) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context2);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context2);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context2);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context2);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context2));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}
function buildFill(flatStyle, prefix, context) {
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "fill-color",
    context
  );
  if (!evaluateColor) {
    return null;
  }
  const fill = new Fill_default();
  return function(context2) {
    const color = evaluateColor(context2);
    if (color === "none") {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + "stroke-width",
    context
  );
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "stroke-color",
    context
  );
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-cap",
    context
  );
  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-join",
    context
  );
  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + "stroke-line-dash",
    context
  );
  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + "stroke-line-dash-offset",
    context
  );
  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + "stroke-miter-limit",
    context
  );
  const stroke = new Stroke_default();
  return function(context2) {
    if (evaluateColor) {
      const color = evaluateColor(context2);
      if (color === "none") {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context2));
    }
    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context2);
      if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
        throw new Error("Expected butt, round, or square line cap");
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context2);
      if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
        throw new Error("Expected bevel, round, or miter line join");
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context2));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context2));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context2));
    }
    return stroke;
  };
}
function buildText(flatStyle, context) {
  const prefix = "text-";
  const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
  if (!evaluateValue) {
    return null;
  }
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + "max-angle",
    context
  );
  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + "offset-x",
    context
  );
  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + "offset-y",
    context
  );
  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + "overflow",
    context
  );
  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + "placement",
    context
  );
  const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + "justify",
    context
  );
  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + "baseline",
    context
  );
  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + "padding",
    context
  );
  const text = new Text_default({});
  return function(context2) {
    text.setText(evaluateValue(context2));
    if (evaluateFill) {
      text.setFill(evaluateFill(context2));
    }
    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context2));
    }
    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context2));
    }
    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context2));
    }
    if (evaluateFont) {
      text.setFont(evaluateFont(context2));
    }
    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context2));
    }
    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context2));
    }
    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context2));
    }
    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context2));
    }
    if (evaluatePlacement) {
      const placement = evaluatePlacement(context2);
      if (placement !== "point" && placement !== "line") {
        throw new Error("Expected point or line for text-placement");
      }
      text.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context2));
    }
    if (evaluateScale) {
      text.setScale(evaluateScale(context2));
    }
    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context2));
    }
    if (evaluateAlign) {
      const textAlign = evaluateAlign(context2);
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      }
      text.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      const justify = evaluateJustify(context2);
      if (justify !== "left" && justify !== "right" && justify !== "center") {
        throw new Error("Expected left, right, or center for text-justify");
      }
      text.setJustify(justify);
    }
    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context2);
      if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      }
      text.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context2));
    }
    return text;
  };
}
function buildImage(flatStyle, context) {
  if ("icon-src" in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ("shape-points" in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ("circle-radius" in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}
function buildIcon(flatStyle, context) {
  const prefix = "icon-";
  const srcName = prefix + "src";
  const src = requireString(flatStyle[srcName], srcName);
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + "anchor",
    context
  );
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + "opacity",
    context
  );
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-x-units"
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-y-units"
  );
  const color = optionalColorLike(flatStyle, prefix + "color");
  const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
  const offset = optionalNumberArray(flatStyle, prefix + "offset");
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
  const width = optionalNumber(flatStyle, prefix + "width");
  const height = optionalNumber(flatStyle, prefix + "height");
  const size = optionalSize(flatStyle, prefix + "size");
  const declutterMode = optionalDeclutterMode(flatStyle, prefix + "declutter");
  const icon = new Icon_default({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode
  });
  return function(context2) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context2));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context2));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context2));
    }
    return icon;
  };
}
function buildShape(flatStyle, context) {
  const prefix = "shape-";
  const pointsName = prefix + "points";
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const radius = optionalNumber(flatStyle, prefix + "radius");
  const radius1 = optionalNumber(flatStyle, prefix + "radius1");
  const radius2 = optionalNumber(flatStyle, prefix + "radius2");
  const angle = optionalNumber(flatStyle, prefix + "angle");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const shape = new RegularShape_default({
    points,
    radius,
    radius1,
    radius2,
    angle,
    declutterMode
  });
  return function(context2) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context2));
    }
    return shape;
  };
}
function buildCircle(flatStyle, context) {
  const prefix = "circle-";
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const circle = new Circle_default({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode
  });
  return function(context2) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context2));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context2));
    }
    return circle;
  };
}
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return void 0;
  }
  const evaluator = buildExpression(flatStyle[name], NumberType, context);
  return function(context2) {
    return requireNumber(evaluator(context2), name);
  };
}
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], StringType, context);
  return function(context2) {
    return requireString(evaluator(context2), name);
  };
}
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], BooleanType, context);
  return function(context2) {
    const value = evaluator(context2);
    if (typeof value !== "boolean") {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    ColorType | StringType,
    context
  );
  return function(context2) {
    return requireColorLike(evaluator(context2), name);
  };
}
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireNumberArray(evaluator(context2), name);
  };
}
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    const array = requireNumberArray(evaluator(context2), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    NumberArrayType | NumberType,
    context
  );
  return function(context2) {
    return requireSizeLike(evaluator(context2), name);
  };
}
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === void 0) {
    return void 0;
  }
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded === "number") {
    return toSize(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "pixels" && encoded !== "fraction") {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireNumberArray(encoded, property);
}
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireColorLike(encoded, property);
}
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== "number") {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}
function requireString(value, property) {
  if (typeof value !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}
function requireNumber(value, property) {
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function requireColorLike(value, property) {
  if (typeof value === "string") {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}
function requireSizeLike(value, property) {
  if (typeof value === "number") {
    return value;
  }
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}
var init_style = __esm({
  "node_modules/ol/render/canvas/style.js"() {
    init_Circle();
    init_Fill();
    init_Icon();
    init_RegularShape();
    init_Stroke();
    init_Style();
    init_Text();
    init_expression();
    init_cpu();
    init_obj();
    init_size();
  }
});

// node_modules/ol/layer/BaseVector.js
function toStyleLike(style) {
  if (style === void 0) {
    return createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === "function") {
    return style;
  }
  if (style instanceof Style_default) {
    return style;
  }
  if (!Array.isArray(style)) {
    return flatStylesToStyleFunction([style]);
  }
  if (style.length === 0) {
    return [];
  }
  const length = style.length;
  const first = style[0];
  if (first instanceof Style_default) {
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof Style_default)) {
        throw new Error("Expected a list of style instances");
      }
      styles[i] = candidate;
    }
    return styles;
  }
  if ("style" in first) {
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!("style" in candidate)) {
        throw new Error("Expected a list of rules with a style property");
      }
      rules[i] = candidate;
    }
    return rulesToStyleFunction(rules);
  }
  const flatStyles = (
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    style
  );
  return flatStylesToStyleFunction(flatStyles);
}
var Property3, BaseVectorLayer, BaseVector_default;
var init_BaseVector = __esm({
  "node_modules/ol/layer/BaseVector.js"() {
    init_Layer();
    init_rbush();
    init_Style();
    init_style();
    Property3 = {
      RENDER_ORDER: "renderOrder"
    };
    BaseVectorLayer = class extends Layer_default {
      /**
       * @param {Options<VectorSourceType>} [options] Options.
       */
      constructor(options) {
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
        this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.setStyle(options.style);
        this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
        this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
      }
      /**
       * @return {boolean} Declutter.
       */
      getDeclutter() {
        return this.declutter_;
      }
      /**
       * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
       * that resolves with an array of features. The array will either contain the topmost feature
       * when a hit was detected, or it will be empty.
       *
       * The hit detection algorithm used for this method is optimized for performance, but is less
       * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
       * Text is not considered, and icons are only represented by their bounding box instead of the exact
       * image.
       *
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
       * @api
       */
      getFeatures(pixel) {
        return super.getFeatures(pixel);
      }
      /**
       * @return {number|undefined} Render buffer.
       */
      getRenderBuffer() {
        return this.renderBuffer_;
      }
      /**
       * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
       *     order.
       */
      getRenderOrder() {
        return (
          /** @type {import("../render.js").OrderFunction|null|undefined} */
          this.get(Property3.RENDER_ORDER)
        );
      }
      /**
       * Get the style for features.  This returns whatever was passed to the `style`
       * option at construction or to the `setStyle` method.
       * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the style function.
       * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     animating.
       */
      getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     interacting.
       */
      getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
      }
      /**
       * Render declutter items for this layer
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */
      renderDeclutter(frameState) {
        if (!frameState.declutterTree) {
          frameState.declutterTree = new RBush(9);
        }
        this.getRenderer().renderDeclutter(frameState);
      }
      /**
       * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
       *     Render order.
       */
      setRenderOrder(renderOrder) {
        this.set(Property3.RENDER_ORDER, renderOrder);
      }
      /**
       * Set the style for features.  This can be a single style object, an array
       * of styles, or a function that takes a feature and resolution and returns
       * an array of styles. If set to `null`, the layer has no style (a `null` style),
       * so only features that have their own styles will be rendered in the layer. Call
       * `setStyle()` without arguments to reset to the default style. See
       * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
       *
       * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
       * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
       * ```js
       * vectorLayer.setStyle({
       *   "fill-color": "yellow",
       *   "stroke-color": "black",
       *   "stroke-width": 4
       * })
       * ```
       *
       * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
       * @api
       */
      setStyle(style) {
        this.style_ = toStyleLike(style);
        this.styleFunction_ = style === null ? void 0 : toFunction(this.style_);
        this.changed();
      }
    };
    BaseVector_default = BaseVectorLayer;
  }
});

// node_modules/ol/render/canvas/Instruction.js
var Instruction, fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction, Instruction_default;
var init_Instruction = __esm({
  "node_modules/ol/render/canvas/Instruction.js"() {
    Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12
    };
    fillInstruction = [Instruction.FILL];
    strokeInstruction = [Instruction.STROKE];
    beginPathInstruction = [Instruction.BEGIN_PATH];
    closePathInstruction = [Instruction.CLOSE_PATH];
    Instruction_default = Instruction;
  }
});

// node_modules/ol/render/VectorContext.js
var VectorContext, VectorContext_default;
var init_VectorContext = __esm({
  "node_modules/ol/render/VectorContext.js"() {
    VectorContext = class {
      /**
       * Render a geometry with a custom renderer.
       *
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
      }
      /**
       * Render a geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
       */
      drawGeometry(geometry) {
      }
      /**
       * Set the rendering style.
       *
       * @param {import("../style/Style.js").default} style The rendering style.
       */
      setStyle(style) {
      }
      /**
       * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../Feature.js").default} feature Feature.
       */
      drawCircle(circleGeometry, feature) {
      }
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("../style/Style.js").default} style Style.
       */
      drawFeature(feature, style) {
      }
      /**
       * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
       * @param {import("../Feature.js").default} feature Feature.
       */
      drawGeometryCollection(geometryCollectionGeometry, feature) {
      }
      /**
       * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawLineString(lineStringGeometry, feature) {
      }
      /**
       * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiLineString(multiLineStringGeometry, feature) {
      }
      /**
       * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPoint(multiPointGeometry, feature) {
      }
      /**
       * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPolygon(multiPolygonGeometry, feature) {
      }
      /**
       * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawPoint(pointGeometry, feature) {
      }
      /**
       * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawPolygon(polygonGeometry, feature) {
      }
      /**
       * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawText(geometry, feature) {
      }
      /**
       * @param {import("../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
      }
      /**
       * @param {import("../style/Image.js").default} imageStyle Image style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
       */
      setImageStyle(imageStyle, declutterImageWithText) {
      }
      /**
       * @param {import("../style/Text.js").default} textStyle Text style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
       */
      setTextStyle(textStyle, declutterImageWithText) {
      }
    };
    VectorContext_default = VectorContext;
  }
});

// node_modules/ol/render/canvas/Builder.js
var CanvasBuilder, Builder_default;
var init_Builder = __esm({
  "node_modules/ol/render/canvas/Builder.js"() {
    init_Instruction();
    init_Relationship();
    init_VectorContext();
    init_colorlike();
    init_extent();
    init_canvas();
    init_array();
    init_inflate();
    CanvasBuilder = class extends VectorContext_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super();
        this.tolerance = tolerance;
        this.maxExtent = maxExtent;
        this.pixelRatio = pixelRatio;
        this.maxLineWidth = 0;
        this.resolution = resolution;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_ = null;
        this.bufferedMaxExtent_ = null;
        this.instructions = [];
        this.coordinates = [];
        this.tmpCoordinate_ = [];
        this.hitDetectionInstructions = [];
        this.state = /** @type {import("../canvas.js").FillStrokeState} */
        {};
      }
      /**
       * @protected
       * @param {Array<number>} dashArray Dash array.
       * @return {Array<number>} Dash array with pixel ratio applied
       */
      applyPixelRatio(dashArray) {
        const pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
          return dash * pixelRatio;
        });
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} stride Stride.
       * @protected
       * @return {number} My end
       */
      appendFlatPointCoordinates(flatCoordinates, stride) {
        const extent = this.getBufferedMaxExtent();
        const tmpCoord = this.tmpCoordinate_;
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          tmpCoord[0] = flatCoordinates[i];
          tmpCoord[1] = flatCoordinates[i + 1];
          if (containsCoordinate(extent, tmpCoord)) {
            coordinates2[myEnd++] = tmpCoord[0];
            coordinates2[myEnd++] = tmpCoord[1];
          }
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        const extent = this.getBufferedMaxExtent();
        if (skipFirst) {
          offset += stride;
        }
        let lastXCoord = flatCoordinates[offset];
        let lastYCoord = flatCoordinates[offset + 1];
        const nextCoord = this.tmpCoordinate_;
        let skipped = true;
        let i, lastRel, nextRel;
        for (i = offset + stride; i < end; i += stride) {
          nextCoord[0] = flatCoordinates[i];
          nextCoord[1] = flatCoordinates[i + 1];
          nextRel = coordinateRelationship(extent, nextCoord);
          if (nextRel !== lastRel) {
            if (skipped) {
              coordinates2[myEnd++] = lastXCoord;
              coordinates2[myEnd++] = lastYCoord;
              skipped = false;
            }
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
          } else if (nextRel === Relationship_default.INTERSECTING) {
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
            skipped = false;
          } else {
            skipped = true;
          }
          lastXCoord = nextCoord[0];
          lastYCoord = nextCoord[1];
          lastRel = nextRel;
        }
        if (closed && skipped || i === offset + stride) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array<number>} builderEnds Builder ends.
       * @return {number} Offset.
       */
      drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const builderEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset,
            end,
            stride,
            false,
            false
          );
          builderEnds.push(builderEnd);
          offset = end;
        }
        return offset;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
        this.beginGeometry(geometry, feature);
        const type = geometry.getType();
        const stride = geometry.getStride();
        const builderBegin = this.coordinates.length;
        let flatCoordinates, builderEnd, builderEnds, builderEndss;
        let offset;
        switch (type) {
          case "MultiPolygon":
            flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getOrientedFlatCoordinates();
            builderEndss = [];
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            offset = 0;
            for (let i = 0, ii = endss.length; i < ii; ++i) {
              const myEnds = [];
              offset = this.drawCustomCoordinates_(
                flatCoordinates,
                offset,
                endss[i],
                stride,
                myEnds
              );
              builderEndss.push(myEnds);
            }
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              renderer,
              inflateMultiCoordinatesArray
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              hitDetectionRenderer || renderer,
              inflateMultiCoordinatesArray
            ]);
            break;
          case "Polygon":
          case "MultiLineString":
            builderEnds = [];
            flatCoordinates = type == "Polygon" ? (
              /** @type {import("../../geom/Polygon.js").default} */
              geometry.getOrientedFlatCoordinates()
            ) : geometry.getFlatCoordinates();
            offset = this.drawCustomCoordinates_(
              flatCoordinates,
              0,
              /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
              geometry.getEnds(),
              stride,
              builderEnds
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              renderer,
              inflateCoordinatesArray
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinatesArray
            ]);
            break;
          case "LineString":
          case "Circle":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatLineCoordinates(
              flatCoordinates,
              0,
              flatCoordinates.length,
              stride,
              false,
              false
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              inflateCoordinates
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinates
            ]);
            break;
          case "MultiPoint":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (builderEnd > builderBegin) {
              this.instructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                renderer,
                inflateCoordinates
              ]);
              this.hitDetectionInstructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                hitDetectionRenderer || renderer,
                inflateCoordinates
              ]);
            }
            break;
          case "Point":
            flatCoordinates = geometry.getFlatCoordinates();
            this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
            builderEnd = this.coordinates.length;
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer
            ]);
            break;
          default:
        }
        this.endGeometry(feature);
      }
      /**
       * @protected
       * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      beginGeometry(geometry, feature) {
        this.beginGeometryInstruction1_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        return {
          instructions: this.instructions,
          hitDetectionInstructions: this.hitDetectionInstructions,
          coordinates: this.coordinates
        };
      }
      /**
       * Reverse the hit detection instructions.
       */
      reverseHitDetectionInstructions() {
        const hitDetectionInstructions = this.hitDetectionInstructions;
        hitDetectionInstructions.reverse();
        let i;
        const n = hitDetectionInstructions.length;
        let instruction;
        let type;
        let begin = -1;
        for (i = 0; i < n; ++i) {
          instruction = hitDetectionInstructions[i];
          type = /** @type {import("./Instruction.js").default} */
          instruction[0];
          if (type == Instruction_default.END_GEOMETRY) {
            begin = i;
          } else if (type == Instruction_default.BEGIN_GEOMETRY) {
            instruction[2] = i;
            reverseSubArray(this.hitDetectionInstructions, begin, i);
            begin = -1;
          }
        }
      }
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        const state = this.state;
        if (fillStyle) {
          const fillStyleColor = fillStyle.getColor();
          state.fillStyle = asColorLike(
            fillStyleColor ? fillStyleColor : defaultFillStyle
          );
        } else {
          state.fillStyle = void 0;
        }
        if (strokeStyle) {
          const strokeStyleColor = strokeStyle.getColor();
          state.strokeStyle = asColorLike(
            strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
          );
          const strokeStyleLineCap = strokeStyle.getLineCap();
          state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
          const strokeStyleLineDash = strokeStyle.getLineDash();
          state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
          const strokeStyleWidth = strokeStyle.getWidth();
          state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
          if (state.lineWidth > this.maxLineWidth) {
            this.maxLineWidth = state.lineWidth;
            this.bufferedMaxExtent_ = null;
          }
        } else {
          state.strokeStyle = void 0;
          state.lineCap = void 0;
          state.lineDash = null;
          state.lineDashOffset = void 0;
          state.lineJoin = void 0;
          state.lineWidth = void 0;
          state.miterLimit = void 0;
        }
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Fill instruction.
       */
      createFill(state) {
        const fillStyle = state.fillStyle;
        const fillInstruction2 = [Instruction_default.SET_FILL_STYLE, fillStyle];
        if (typeof fillStyle !== "string") {
          fillInstruction2.push(true);
        }
        return fillInstruction2;
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      applyStroke(state) {
        this.instructions.push(this.createStroke(state));
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Stroke instruction.
       */
      createStroke(state) {
        return [
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth * this.pixelRatio,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          this.applyPixelRatio(state.lineDash),
          state.lineDashOffset * this.pixelRatio
        ];
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
       */
      updateFillStyle(state, createFill) {
        const fillStyle = state.fillStyle;
        if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
          if (fillStyle !== void 0) {
            this.instructions.push(createFill.call(this, state));
          }
          state.currentFillStyle = fillStyle;
        }
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
       */
      updateStrokeStyle(state, applyStroke) {
        const strokeStyle = state.strokeStyle;
        const lineCap = state.lineCap;
        const lineDash = state.lineDash;
        const lineDashOffset = state.lineDashOffset;
        const lineJoin = state.lineJoin;
        const lineWidth = state.lineWidth;
        const miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
          if (strokeStyle !== void 0) {
            applyStroke.call(this, state);
          }
          state.currentStrokeStyle = strokeStyle;
          state.currentLineCap = lineCap;
          state.currentLineDash = lineDash;
          state.currentLineDashOffset = lineDashOffset;
          state.currentLineJoin = lineJoin;
          state.currentLineWidth = lineWidth;
          state.currentMiterLimit = miterLimit;
        }
      }
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      endGeometry(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        const endGeometryInstruction = [Instruction_default.END_GEOMETRY, feature];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
      }
      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {import("../../extent.js").Extent} The buffered rendering extent.
       * @protected
       */
      getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_) {
          this.bufferedMaxExtent_ = clone(this.maxExtent);
          if (this.maxLineWidth > 0) {
            const width = this.resolution * (this.maxLineWidth + 1) / 2;
            buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
          }
        }
        return this.bufferedMaxExtent_;
      }
    };
    Builder_default = CanvasBuilder;
  }
});

// node_modules/ol/render/canvas/ImageBuilder.js
var CanvasImageBuilder, ImageBuilder_default;
var init_ImageBuilder = __esm({
  "node_modules/ol/render/canvas/ImageBuilder.js"() {
    init_Builder();
    init_Instruction();
    CanvasImageBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.height_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.scale_ = void 0;
        this.width_ = void 0;
        this.declutterMode_ = void 0;
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawPoint(pointGeometry, feature) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(pointGeometry, feature);
        const flatCoordinates = pointGeometry.getFlatCoordinates();
        const stride = pointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPoint(multiPointGeometry, feature) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(multiPointGeometry, feature);
        const flatCoordinates = multiPointGeometry.getFlatCoordinates();
        const stride = multiPointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.height_ = void 0;
        this.scale_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.width_ = void 0;
        return super.finish();
      }
      /**
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @param {Object} [sharedData] Shared data.
       */
      setImageStyle(imageStyle, sharedData) {
        const anchor = imageStyle.getAnchor();
        const size = imageStyle.getSize();
        const origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
        this.image_ = imageStyle.getImage(this.pixelRatio);
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterMode_ = imageStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
      }
    };
    ImageBuilder_default = CanvasImageBuilder;
  }
});

// node_modules/ol/render/canvas/LineStringBuilder.js
var CanvasLineStringBuilder, LineStringBuilder_default;
var init_LineStringBuilder = __esm({
  "node_modules/ol/render/canvas/LineStringBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_canvas();
    CanvasLineStringBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          offset,
          end,
          stride,
          false,
          false
        );
        const moveToLineToInstruction = [
          Instruction_default.MOVE_TO_LINE_TO,
          myBegin,
          myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
      }
      /**
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawLineString(lineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const flatCoordinates = lineStringGeometry.getFlatCoordinates();
        const stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride
        );
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiLineString(multiLineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const ends = multiLineStringGeometry.getEnds();
        const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        const stride = multiLineStringGeometry.getStride();
        let offset = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          offset = this.drawFlatCoordinates_(
            flatCoordinates,
            offset,
            /** @type {number} */
            ends[i],
            stride
          );
        }
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        const state = this.state;
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
        }
        this.reverseHitDetectionInstructions();
        this.state = null;
        return super.finish();
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      applyStroke(state) {
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
          state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        super.applyStroke(state);
        this.instructions.push(beginPathInstruction);
      }
    };
    LineStringBuilder_default = CanvasLineStringBuilder;
  }
});

// node_modules/ol/render/canvas/PolygonBuilder.js
var CanvasPolygonBuilder, PolygonBuilder_default;
var init_PolygonBuilder = __esm({
  "node_modules/ol/render/canvas/PolygonBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_canvas();
    init_simplify();
    CanvasPolygonBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
        const state = this.state;
        const fill = state.fillStyle !== void 0;
        const stroke = state.strokeStyle !== void 0;
        const numEnds = ends.length;
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (let i = 0; i < numEnds; ++i) {
          const end = ends[i];
          const myBegin = this.coordinates.length;
          const myEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset,
            end,
            stride,
            true,
            !stroke
          );
          const moveToLineToInstruction = [
            Instruction_default.MOVE_TO_LINE_TO,
            myBegin,
            myEnd
          ];
          this.instructions.push(moveToLineToInstruction);
          this.hitDetectionInstructions.push(moveToLineToInstruction);
          if (stroke) {
            this.instructions.push(closePathInstruction);
            this.hitDetectionInstructions.push(closePathInstruction);
          }
          offset = end;
        }
        if (fill) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (stroke) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        return offset;
      }
      /**
       * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../../Feature.js").default} feature Feature.
       */
      drawCircle(circleGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const flatCoordinates = circleGeometry.getFlatCoordinates();
        const stride = circleGeometry.getStride();
        const myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        const circleInstruction = [Instruction_default.CIRCLE, myBegin];
        this.instructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
        if (state.fillStyle !== void 0) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (state.strokeStyle !== void 0) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawPolygon(polygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const ends = polygonGeometry.getEnds();
        const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        const stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(
          flatCoordinates,
          0,
          /** @type {Array<number>} */
          ends,
          stride
        );
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPolygon(multiPolygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const endss = multiPolygonGeometry.getEndss();
        const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        const stride = multiPolygonGeometry.getStride();
        let offset = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          offset = this.drawFlatCoordinatess_(
            flatCoordinates,
            offset,
            endss[i],
            stride
          );
        }
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        const tolerance = this.tolerance;
        if (tolerance !== 0) {
          const coordinates2 = this.coordinates;
          for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
            coordinates2[i] = snap(coordinates2[i], tolerance);
          }
        }
        return super.finish();
      }
      /**
       * @private
       */
      setFillStrokeStyles_() {
        const state = this.state;
        const fillStyle = state.fillStyle;
        if (fillStyle !== void 0) {
          this.updateFillStyle(state, this.createFill);
        }
        if (state.strokeStyle !== void 0) {
          this.updateStrokeStyle(state, this.applyStroke);
        }
      }
    };
    PolygonBuilder_default = CanvasPolygonBuilder;
  }
});

// node_modules/ol/geom/flat/linechunk.js
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
  const chunks = [];
  let cursor = offset;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x2 = flatCoordinates[cursor + stride];
    const y2 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x = lerp(x1, x2, m);
      const y = lerp(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x = lerp(x1, x2, missing / segmentLength);
      const y = lerp(y1, y2, missing / segmentLength);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}
var init_linechunk = __esm({
  "node_modules/ol/geom/flat/linechunk.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/straightchunk.js
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  let chunkStart = offset;
  let chunkEnd = offset;
  let chunkM = 0;
  let m = 0;
  let start = offset;
  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
var init_straightchunk = __esm({
  "node_modules/ol/geom/flat/straightchunk.js"() {
  }
});

// node_modules/ol/render/canvas/TextBuilder.js
var TEXT_ALIGN, CanvasTextBuilder, TextBuilder_default;
var init_TextBuilder = __esm({
  "node_modules/ol/render/canvas/TextBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_colorlike();
    init_canvas();
    init_util();
    init_extent();
    init_linechunk();
    init_straightchunk();
    TEXT_ALIGN = {
      "left": 0,
      "center": 0.5,
      "right": 1,
      "top": 0,
      "middle": 0.5,
      "hanging": 0.2,
      "alphabetic": 0.8,
      "ideographic": 0.8,
      "bottom": 1
    };
    CanvasTextBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.labels_ = null;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = void 0;
        this.textRotation_ = 0;
        this.textFillState_ = null;
        this.fillStates = {};
        this.fillStates[defaultFillStyle] = { fillStyle: defaultFillStyle };
        this.textStrokeState_ = null;
        this.strokeStates = {};
        this.textState_ = /** @type {import("../canvas.js").TextState} */
        {};
        this.textStates = {};
        this.textKey_ = "";
        this.fillKey_ = "";
        this.strokeKey_ = "";
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        const instructions = super.finish();
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawText(geometry, feature) {
        const fillState = this.textFillState_;
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        if (this.text_ === "" || !textState || !fillState && !strokeState) {
          return;
        }
        const coordinates2 = this.coordinates;
        let begin = coordinates2.length;
        const geometryType = geometry.getType();
        let flatCoordinates = null;
        let stride = geometry.getStride();
        if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
          if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
            return;
          }
          let ends;
          flatCoordinates = geometry.getFlatCoordinates();
          if (geometryType == "LineString") {
            ends = [flatCoordinates.length];
          } else if (geometryType == "MultiLineString") {
            ends = /** @type {import("../../geom/MultiLineString.js").default} */
            geometry.getEnds();
          } else if (geometryType == "Polygon") {
            ends = /** @type {import("../../geom/Polygon.js").default} */
            geometry.getEnds().slice(0, 1);
          } else if (geometryType == "MultiPolygon") {
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            ends = [];
            for (let i = 0, ii = endss.length; i < ii; ++i) {
              ends.push(endss[i][0]);
            }
          }
          this.beginGeometry(geometry, feature);
          const repeat = textState.repeat;
          const textAlign = repeat ? void 0 : textState.textAlign;
          let flatOffset = 0;
          for (let o = 0, oo = ends.length; o < oo; ++o) {
            let chunks;
            if (repeat) {
              chunks = lineChunk(
                repeat * this.resolution,
                flatCoordinates,
                flatOffset,
                ends[o],
                stride
              );
            } else {
              chunks = [flatCoordinates.slice(flatOffset, ends[o])];
            }
            for (let c = 0, cc = chunks.length; c < cc; ++c) {
              const chunk = chunks[c];
              let chunkBegin = 0;
              let chunkEnd = chunk.length;
              if (textAlign == void 0) {
                const range = matchingChunk(
                  textState.maxAngle,
                  chunk,
                  0,
                  chunk.length,
                  2
                );
                chunkBegin = range[0];
                chunkEnd = range[1];
              }
              for (let i = chunkBegin; i < chunkEnd; i += stride) {
                coordinates2.push(chunk[i], chunk[i + 1]);
              }
              const end = coordinates2.length;
              flatOffset = ends[o];
              this.drawChars_(begin, end);
              begin = end;
            }
          }
          this.endGeometry(feature);
        } else {
          let geometryWidths = textState.overflow ? null : [];
          switch (geometryType) {
            case "Point":
            case "MultiPoint":
              flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
              geometry.getFlatCoordinates();
              break;
            case "LineString":
              flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
              geometry.getFlatMidpoint();
              break;
            case "Circle":
              flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
              geometry.getCenter();
              break;
            case "MultiLineString":
              flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
              geometry.getFlatMidpoints();
              stride = 2;
              break;
            case "Polygon":
              flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
              geometry.getFlatInteriorPoint();
              if (!textState.overflow) {
                geometryWidths.push(flatCoordinates[2] / this.resolution);
              }
              stride = 3;
              break;
            case "MultiPolygon":
              const interiorPoints = (
                /** @type {import("../../geom/MultiPolygon.js").default} */
                geometry.getFlatInteriorPoints()
              );
              flatCoordinates = [];
              for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                if (!textState.overflow) {
                  geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                }
                flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
              }
              if (flatCoordinates.length === 0) {
                return;
              }
              stride = 2;
              break;
            default:
          }
          const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (end === begin) {
            return;
          }
          if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
            let beg = begin / 2;
            geometryWidths = geometryWidths.filter((w, i) => {
              const keep = coordinates2[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates2[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
              if (!keep) {
                --beg;
              }
              return keep;
            });
          }
          this.saveTextStates_();
          if (textState.backgroundFill || textState.backgroundStroke) {
            this.setFillStrokeStyle(
              textState.backgroundFill,
              textState.backgroundStroke
            );
            if (textState.backgroundFill) {
              this.updateFillStyle(this.state, this.createFill);
            }
            if (textState.backgroundStroke) {
              this.updateStrokeStyle(this.state, this.applyStroke);
              this.hitDetectionInstructions.push(this.createStroke(this.state));
            }
          }
          this.beginGeometry(geometry, feature);
          let padding = textState.padding;
          if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
            let p0 = textState.padding[0];
            let p12 = textState.padding[1];
            let p22 = textState.padding[2];
            let p32 = textState.padding[3];
            if (textState.scale[0] < 0) {
              p12 = -p12;
              p32 = -p32;
            }
            if (textState.scale[1] < 0) {
              p0 = -p0;
              p22 = -p22;
            }
            padding = [p0, p12, p22, p32];
          }
          const pixelRatio = this.pixelRatio;
          this.instructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [1, 1],
            NaN,
            void 0,
            this.declutterImageWithText_,
            padding == defaultPadding ? defaultPadding : padding.map(function(p) {
              return p * pixelRatio;
            }),
            !!textState.backgroundFill,
            !!textState.backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          const scale4 = 1 / pixelRatio;
          const currentFillStyle = this.state.fillStyle;
          if (textState.backgroundFill) {
            this.state.fillStyle = defaultFillStyle;
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }
          this.hitDetectionInstructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [scale4, scale4],
            NaN,
            void 0,
            this.declutterImageWithText_,
            padding,
            !!textState.backgroundFill,
            !!textState.backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_ ? defaultFillStyle : this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          if (textState.backgroundFill) {
            this.state.fillStyle = currentFillStyle;
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }
          this.endGeometry(feature);
        }
      }
      /**
       * @private
       */
      saveTextStates_() {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const fillState = this.textFillState_;
        const strokeKey = this.strokeKey_;
        if (strokeState) {
          if (!(strokeKey in this.strokeStates)) {
            this.strokeStates[strokeKey] = {
              strokeStyle: strokeState.strokeStyle,
              lineCap: strokeState.lineCap,
              lineDashOffset: strokeState.lineDashOffset,
              lineWidth: strokeState.lineWidth,
              lineJoin: strokeState.lineJoin,
              miterLimit: strokeState.miterLimit,
              lineDash: strokeState.lineDash
            };
          }
        }
        const textKey = this.textKey_;
        if (!(textKey in this.textStates)) {
          this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || defaultTextAlign,
            justify: textState.justify,
            textBaseline: textState.textBaseline || defaultTextBaseline,
            scale: textState.scale
          };
        }
        const fillKey = this.fillKey_;
        if (fillState) {
          if (!(fillKey in this.fillStates)) {
            this.fillStates[fillKey] = {
              fillStyle: fillState.fillStyle
            };
          }
        }
      }
      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       */
      drawChars_(begin, end) {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const strokeKey = this.strokeKey_;
        const textKey = this.textKey_;
        const fillKey = this.fillKey_;
        this.saveTextStates_();
        const pixelRatio = this.pixelRatio;
        const baseline = TEXT_ALIGN[textState.textBaseline];
        const offsetY = this.textOffsetY_ * pixelRatio;
        const text = this.text_;
        const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text,
          textKey,
          1
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey ? defaultFillStyle : fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text,
          textKey,
          1 / pixelRatio
        ]);
      }
      /**
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @param {Object} [sharedData] Shared data.
       */
      setTextStyle(textStyle, sharedData) {
        let textState, fillState, strokeState;
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            fillState = null;
            this.textFillState_ = fillState;
          } else {
            fillState = this.textFillState_;
            if (!fillState) {
              fillState = /** @type {import("../canvas.js").FillState} */
              {};
              this.textFillState_ = fillState;
            }
            fillState.fillStyle = asColorLike(
              textFillStyle.getColor() || defaultFillStyle
            );
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            strokeState = null;
            this.textStrokeState_ = strokeState;
          } else {
            strokeState = this.textStrokeState_;
            if (!strokeState) {
              strokeState = /** @type {import("../canvas.js").StrokeState} */
              {};
              this.textStrokeState_ = strokeState;
            }
            const lineDash = textStrokeStyle.getLineDash();
            const lineDashOffset = textStrokeStyle.getLineDashOffset();
            const lineWidth = textStrokeStyle.getWidth();
            const miterLimit = textStrokeStyle.getMiterLimit();
            strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
            strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
            strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
            strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
            strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
            strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
            strokeState.strokeStyle = asColorLike(
              textStrokeStyle.getColor() || defaultStrokeStyle
            );
          }
          textState = this.textState_;
          const font = textStyle.getFont() || defaultFont;
          registerFont(font);
          const textScale = textStyle.getScaleArray();
          textState.overflow = textStyle.getOverflow();
          textState.font = font;
          textState.maxAngle = textStyle.getMaxAngle();
          textState.placement = textStyle.getPlacement();
          textState.textAlign = textStyle.getTextAlign();
          textState.repeat = textStyle.getRepeat();
          textState.justify = textStyle.getJustify();
          textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
          textState.backgroundFill = textStyle.getBackgroundFill();
          textState.backgroundStroke = textStyle.getBackgroundStroke();
          textState.padding = textStyle.getPadding() || defaultPadding;
          textState.scale = textScale === void 0 ? [1, 1] : textScale;
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textRotation = textStyle.getRotation();
          this.text_ = textStyle.getText() || "";
          this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
          this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
          this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
          this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
          this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
          this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
          this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
        }
        this.declutterImageWithText_ = sharedData;
      }
    };
    TextBuilder_default = CanvasTextBuilder;
  }
});

// node_modules/ol/render/canvas/BuilderGroup.js
var BATCH_CONSTRUCTORS, BuilderGroup, BuilderGroup_default;
var init_BuilderGroup = __esm({
  "node_modules/ol/render/canvas/BuilderGroup.js"() {
    init_Builder();
    init_ImageBuilder();
    init_LineStringBuilder();
    init_PolygonBuilder();
    init_TextBuilder();
    BATCH_CONSTRUCTORS = {
      "Circle": PolygonBuilder_default,
      "Default": Builder_default,
      "Image": ImageBuilder_default,
      "LineString": LineStringBuilder_default,
      "Polygon": PolygonBuilder_default,
      "Text": TextBuilder_default
    };
    BuilderGroup = class {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Max extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        this.tolerance_ = tolerance;
        this.maxExtent_ = maxExtent;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.buildersByZIndex_ = {};
      }
      /**
       * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
       */
      finish() {
        const builderInstructions = {};
        for (const zKey in this.buildersByZIndex_) {
          builderInstructions[zKey] = builderInstructions[zKey] || {};
          const builders = this.buildersByZIndex_[zKey];
          for (const builderKey in builders) {
            const builderInstruction = builders[builderKey].finish();
            builderInstructions[zKey][builderKey] = builderInstruction;
          }
        }
        return builderInstructions;
      }
      /**
       * @param {number|undefined} zIndex Z index.
       * @param {import("../canvas.js").BuilderType} builderType Replay type.
       * @return {import("../VectorContext.js").default} Replay.
       */
      getBuilder(zIndex, builderType) {
        const zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
        let replays = this.buildersByZIndex_[zIndexKey];
        if (replays === void 0) {
          replays = {};
          this.buildersByZIndex_[zIndexKey] = replays;
        }
        let replay = replays[builderType];
        if (replay === void 0) {
          const Constructor = BATCH_CONSTRUCTORS[builderType];
          replay = new Constructor(
            this.tolerance_,
            this.maxExtent_,
            this.resolution_,
            this.pixelRatio_
          );
          replays[builderType] = replay;
        }
        return replay;
      }
    };
    BuilderGroup_default = BuilderGroup;
  }
});

// node_modules/ol/geom/flat/textpath.js
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale4, measureAndCacheTextWidth2, font, cache3, rotation) {
  let x2 = flatCoordinates[offset];
  let y2 = flatCoordinates[offset + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);
  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = lerp(x1, x2, interpolate);
  const beginY = lerp(y1, y2, interpolate);
  const startOffset = offset - stride;
  const startLength = segmentM;
  const endM = startM + scale4 * measureAndCacheTextWidth2(font, text, cache3);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = lerp(x1, x2, interpolate);
  const endY = lerp(y1, y2, interpolate);
  let reverse;
  if (rotation) {
    const flat = [beginX, beginY, endX, endY];
    rotate2(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }
  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];
  let previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x = (endX + beginX) / 2;
    const y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }
  text = text.replace(/\n/g, " ");
  for (let i = 0, ii = text.length; i < ii; ) {
    advance();
    let angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    const iStart = i;
    let charLength = 0;
    for (; i < ii; ++i) {
      const index = reverse ? ii - i - 1 : i;
      const len = scale4 * measureAndCacheTextWidth2(font, text[index], cache3);
      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    const x = lerp(x1, x2, interpolate);
    const y = lerp(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}
var init_textpath = __esm({
  "node_modules/ol/geom/flat/textpath.js"() {
    init_math();
    init_transform2();
  }
});

// node_modules/ol/render/canvas/Executor.js
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
function horizontalTextAlign(text, align) {
  if (align === "start") {
    align = rtlRegEx.test(text) ? "right" : "left";
  } else if (align === "end") {
    align = rtlRegEx.test(text) ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
var tmpExtent, p1, p2, p3, p4, rtlRegEx, Executor, Executor_default;
var init_Executor = __esm({
  "node_modules/ol/render/canvas/Executor.js"() {
    init_Instruction();
    init_TextBuilder();
    init_transform();
    init_extent();
    init_canvas();
    init_textpath();
    init_array();
    init_length();
    init_transform2();
    tmpExtent = createEmpty();
    p1 = [];
    p2 = [];
    p3 = [];
    p4 = [];
    rtlRegEx = new RegExp(
      /* eslint-disable prettier/prettier */
      "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
      /* eslint-enable prettier/prettier */
    );
    Executor = class {
      /**
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The replay can have overlapping geometries.
       * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
       */
      constructor(resolution, pixelRatio, overlaps, instructions) {
        this.overlaps = overlaps;
        this.pixelRatio = pixelRatio;
        this.resolution = resolution;
        this.alignFill_;
        this.instructions = instructions.instructions;
        this.coordinates = instructions.coordinates;
        this.coordinateCache_ = {};
        this.renderedTransform_ = create();
        this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        this.pixelCoordinates_ = null;
        this.viewRotation_ = 0;
        this.fillStates = instructions.fillStates || {};
        this.strokeStates = instructions.strokeStates || {};
        this.textStates = instructions.textStates || {};
        this.widths_ = {};
        this.labels_ = {};
      }
      /**
       * @param {string|Array<string>} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {import("../canvas.js").Label} Label.
       */
      createLabel(text, textKey, fillKey, strokeKey) {
        const key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) {
          return this.labels_[key];
        }
        const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        const fillState = fillKey ? this.fillStates[fillKey] : null;
        const textState = this.textStates[textKey];
        const pixelRatio = this.pixelRatio;
        const scale4 = [
          textState.scale[0] * pixelRatio,
          textState.scale[1] * pixelRatio
        ];
        const textIsArray = Array.isArray(text);
        const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || defaultTextAlign
        );
        const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
        const { width, height, widths, heights, lineWidths } = getTextDimensions(
          textState,
          chunks
        );
        const renderWidth = width + strokeWidth;
        const contextInstructions = [];
        const w = (renderWidth + 2) * scale4[0];
        const h = (height + strokeWidth) * scale4[1];
        const label = {
          width: w < 0 ? Math.floor(w) : Math.ceil(w),
          height: h < 0 ? Math.floor(h) : Math.ceil(h),
          contextInstructions
        };
        if (scale4[0] != 1 || scale4[1] != 1) {
          contextInstructions.push("scale", scale4);
        }
        if (strokeKey) {
          contextInstructions.push("strokeStyle", strokeState.strokeStyle);
          contextInstructions.push("lineWidth", strokeWidth);
          contextInstructions.push("lineCap", strokeState.lineCap);
          contextInstructions.push("lineJoin", strokeState.lineJoin);
          contextInstructions.push("miterLimit", strokeState.miterLimit);
          contextInstructions.push("setLineDash", [strokeState.lineDash]);
          contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
        }
        if (fillKey) {
          contextInstructions.push("fillStyle", fillState.fillStyle);
        }
        contextInstructions.push("textBaseline", "middle");
        contextInstructions.push("textAlign", "center");
        const leftRight = 0.5 - align;
        let x = align * renderWidth + leftRight * strokeWidth;
        const strokeInstructions = [];
        const fillInstructions = [];
        let lineHeight = 0;
        let lineOffset = 0;
        let widthHeightIndex = 0;
        let lineWidthIndex = 0;
        let previousFont;
        for (let i = 0, ii = chunks.length; i < ii; i += 2) {
          const text2 = chunks[i];
          if (text2 === "\n") {
            lineOffset += lineHeight;
            lineHeight = 0;
            x = align * renderWidth + leftRight * strokeWidth;
            ++lineWidthIndex;
            continue;
          }
          const font = chunks[i + 1] || textState.font;
          if (font !== previousFont) {
            if (strokeKey) {
              strokeInstructions.push("font", font);
            }
            if (fillKey) {
              fillInstructions.push("font", font);
            }
            previousFont = font;
          }
          lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
          const fillStrokeArgs = [
            text2,
            x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
            0.5 * (strokeWidth + lineHeight) + lineOffset
          ];
          x += widths[widthHeightIndex];
          if (strokeKey) {
            strokeInstructions.push("strokeText", fillStrokeArgs);
          }
          if (fillKey) {
            fillInstructions.push("fillText", fillStrokeArgs);
          }
          ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       */
      replayTextBackground_(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
        context.beginPath();
        context.moveTo.apply(context, p12);
        context.lineTo.apply(context, p22);
        context.lineTo.apply(context, p32);
        context.lineTo.apply(context, p42);
        context.lineTo.apply(context, p12);
        if (fillInstruction2) {
          this.alignFill_ = /** @type {boolean} */
          fillInstruction2[2];
          this.fill_(context);
        }
        if (strokeInstruction2) {
          this.setStrokeStyle_(
            context,
            /** @type {Array<*>} */
            strokeInstruction2
          );
          context.stroke();
        }
      }
      /**
       * @private
       * @param {number} sheetWidth Width of the sprite sheet.
       * @param {number} sheetHeight Height of the sprite sheet.
       * @param {number} centerX X.
       * @param {number} centerY Y.
       * @param {number} width Width.
       * @param {number} height Height.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {import("../../size.js").Size} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {Array<number>} padding Padding.
       * @param {boolean} fillStroke Background fill or stroke.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
       */
      calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale4, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale4[0];
        anchorY *= scale4[1];
        let x = centerX - anchorX;
        let y = centerY - anchorY;
        const w = width + originX > sheetWidth ? sheetWidth - originX : width;
        const h = height + originY > sheetHeight ? sheetHeight - originY : height;
        const boxW = padding[3] + w * scale4[0] + padding[1];
        const boxH = padding[0] + h * scale4[1] + padding[2];
        const boxX = x - padding[3];
        const boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
          p1[0] = boxX;
          p4[0] = boxX;
          p1[1] = boxY;
          p2[1] = boxY;
          p2[0] = boxX + boxW;
          p3[0] = p2[0];
          p3[1] = boxY + boxH;
          p4[1] = p3[1];
        }
        let transform2;
        if (rotation !== 0) {
          transform2 = compose(
            create(),
            centerX,
            centerY,
            1,
            1,
            rotation,
            -centerX,
            -centerY
          );
          apply(transform2, p1);
          apply(transform2, p2);
          apply(transform2, p3);
          apply(transform2, p4);
          createOrUpdate(
            Math.min(p1[0], p2[0], p3[0], p4[0]),
            Math.min(p1[1], p2[1], p3[1], p4[1]),
            Math.max(p1[0], p2[0], p3[0], p4[0]),
            Math.max(p1[1], p2[1], p3[1], p4[1]),
            tmpExtent
          );
        } else {
          createOrUpdate(
            Math.min(boxX, boxX + boxW),
            Math.min(boxY, boxY + boxH),
            Math.max(boxX, boxX + boxW),
            Math.max(boxY, boxY + boxH),
            tmpExtent
          );
        }
        if (snapToPixel) {
          x = Math.round(x);
          y = Math.round(y);
        }
        return {
          drawImageX: x,
          drawImageY: y,
          drawImageW: w,
          drawImageH: h,
          originX,
          originY,
          declutterBox: {
            minX: tmpExtent[0],
            minY: tmpExtent[1],
            maxX: tmpExtent[2],
            maxY: tmpExtent[3],
            value: feature
          },
          canvasTransform: transform2,
          scale: scale4
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
       * @param {ImageOrLabelDimensions} dimensions Dimensions.
       * @param {number} opacity Opacity.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @return {boolean} The image or label was rendered.
       */
      replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
        const fillStroke = !!(fillInstruction2 || strokeInstruction2);
        const box = dimensions.declutterBox;
        const canvas = context.canvas;
        const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
        const intersects3 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
        if (intersects3) {
          if (fillStroke) {
            this.replayTextBackground_(
              context,
              p1,
              p2,
              p3,
              p4,
              /** @type {Array<*>} */
              fillInstruction2,
              /** @type {Array<*>} */
              strokeInstruction2
            );
          }
          drawImageOrLabel(
            context,
            dimensions.canvasTransform,
            opacity,
            imageOrLabel,
            dimensions.originX,
            dimensions.originY,
            dimensions.drawImageW,
            dimensions.drawImageH,
            dimensions.drawImageX,
            dimensions.drawImageY,
            dimensions.scale
          );
        }
        return true;
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      fill_(context) {
        if (this.alignFill_) {
          const origin = apply(this.renderedTransform_, [0, 0]);
          const repeatSize = 512 * this.pixelRatio;
          context.save();
          context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
          context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) {
          context.restore();
        }
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array<*>} instruction Instruction.
       */
      setStrokeStyle_(context, instruction) {
        context["strokeStyle"] = /** @type {import("../../colorlike.js").ColorLike} */
        instruction[1];
        context.lineWidth = /** @type {number} */
        instruction[2];
        context.lineCap = /** @type {CanvasLineCap} */
        instruction[3];
        context.lineJoin = /** @type {CanvasLineJoin} */
        instruction[4];
        context.miterLimit = /** @type {number} */
        instruction[5];
        context.lineDashOffset = /** @type {number} */
        instruction[7];
        context.setLineDash(
          /** @type {Array<number>} */
          instruction[6]
        );
      }
      /**
       * @private
       * @param {string|Array<string>} text The text to draw.
       * @param {string} textKey The key of the text state.
       * @param {string} strokeKey The key for the stroke state.
       * @param {string} fillKey The key for the fill state.
       * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
       */
      drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
        const textState = this.textStates[textKey];
        const label = this.createLabel(text, textKey, fillKey, strokeKey);
        const strokeState = this.strokeStates[strokeKey];
        const pixelRatio = this.pixelRatio;
        const align = horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || defaultTextAlign
        );
        const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
        const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const width = label.width / pixelRatio - 2 * textState.scale[0];
        const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
          label,
          anchorX,
          anchorY
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {Array<*>} instructions Instructions array.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       * @return {T|undefined} Callback result.
       * @template T
       */
      execute_(context, contextScale, transform2, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
        let pixelCoordinates;
        if (this.pixelCoordinates_ && equals(transform2, this.renderedTransform_)) {
          pixelCoordinates = this.pixelCoordinates_;
        } else {
          if (!this.pixelCoordinates_) {
            this.pixelCoordinates_ = [];
          }
          pixelCoordinates = transform2D(
            this.coordinates,
            0,
            this.coordinates.length,
            2,
            transform2,
            this.pixelCoordinates_
          );
          setFromArray(this.renderedTransform_, transform2);
        }
        let i = 0;
        const ii = instructions.length;
        let d = 0;
        let dd;
        let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        let pendingFill = 0;
        let pendingStroke = 0;
        let lastFillInstruction = null;
        let lastStrokeInstruction = null;
        const coordinateCache = this.coordinateCache_;
        const viewRotation = this.viewRotation_;
        const viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
        const state = (
          /** @type {import("../../render.js").State} */
          {
            context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
          }
        );
        const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        let feature;
        let x, y, currentGeometry;
        while (i < ii) {
          const instruction = instructions[i];
          const type = (
            /** @type {import("./Instruction.js").default} */
            instruction[0]
          );
          switch (type) {
            case Instruction_default.BEGIN_GEOMETRY:
              feature = /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              currentGeometry = instruction[3];
              if (!feature.getGeometry()) {
                i = /** @type {number} */
                instruction[2];
              } else if (hitExtent !== void 0 && !intersects(hitExtent, currentGeometry.getExtent())) {
                i = /** @type {number} */
                instruction[2] + 1;
              } else {
                ++i;
              }
              break;
            case Instruction_default.BEGIN_PATH:
              if (pendingFill > batchSize) {
                this.fill_(context);
                pendingFill = 0;
              }
              if (pendingStroke > batchSize) {
                context.stroke();
                pendingStroke = 0;
              }
              if (!pendingFill && !pendingStroke) {
                context.beginPath();
                prevX = NaN;
                prevY = NaN;
              }
              ++i;
              break;
            case Instruction_default.CIRCLE:
              d = /** @type {number} */
              instruction[1];
              const x1 = pixelCoordinates[d];
              const y1 = pixelCoordinates[d + 1];
              const x2 = pixelCoordinates[d + 2];
              const y2 = pixelCoordinates[d + 3];
              const dx = x2 - x1;
              const dy = y2 - y1;
              const r = Math.sqrt(dx * dx + dy * dy);
              context.moveTo(x1 + r, y1);
              context.arc(x1, y1, r, 0, 2 * Math.PI, true);
              ++i;
              break;
            case Instruction_default.CLOSE_PATH:
              context.closePath();
              ++i;
              break;
            case Instruction_default.CUSTOM:
              d = /** @type {number} */
              instruction[1];
              dd = instruction[2];
              const geometry = (
                /** @type {import("../../geom/SimpleGeometry.js").default} */
                instruction[3]
              );
              const renderer = instruction[4];
              const fn = instruction.length == 6 ? instruction[5] : void 0;
              state.geometry = geometry;
              state.feature = feature;
              if (!(i in coordinateCache)) {
                coordinateCache[i] = [];
              }
              const coords = coordinateCache[i];
              if (fn) {
                fn(pixelCoordinates, d, dd, 2, coords);
              } else {
                coords[0] = pixelCoordinates[d];
                coords[1] = pixelCoordinates[d + 1];
                coords.length = 2;
              }
              renderer(coords, state);
              ++i;
              break;
            case Instruction_default.DRAW_IMAGE:
              d = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
              instruction[3];
              anchorX = /** @type {number} */
              instruction[4];
              anchorY = /** @type {number} */
              instruction[5];
              let height = (
                /** @type {number} */
                instruction[6]
              );
              const opacity = (
                /** @type {number} */
                instruction[7]
              );
              const originX = (
                /** @type {number} */
                instruction[8]
              );
              const originY = (
                /** @type {number} */
                instruction[9]
              );
              const rotateWithView = (
                /** @type {boolean} */
                instruction[10]
              );
              let rotation = (
                /** @type {number} */
                instruction[11]
              );
              const scale4 = (
                /** @type {import("../../size.js").Size} */
                instruction[12]
              );
              let width = (
                /** @type {number} */
                instruction[13]
              );
              const declutterMode = (
                /** @type {"declutter"|"obstacle"|"none"|undefined} */
                instruction[14]
              );
              const declutterImageWithText = (
                /** @type {import("../canvas.js").DeclutterImageWithText} */
                instruction[15]
              );
              if (!image && instruction.length >= 20) {
                text = /** @type {string} */
                instruction[19];
                textKey = /** @type {string} */
                instruction[20];
                strokeKey = /** @type {string} */
                instruction[21];
                fillKey = /** @type {string} */
                instruction[22];
                const labelWithAnchor = this.drawLabelWithPointPlacement_(
                  text,
                  textKey,
                  strokeKey,
                  fillKey
                );
                image = labelWithAnchor.label;
                instruction[3] = image;
                const textOffsetX = (
                  /** @type {number} */
                  instruction[23]
                );
                anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                instruction[4] = anchorX;
                const textOffsetY = (
                  /** @type {number} */
                  instruction[24]
                );
                anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                instruction[5] = anchorY;
                height = image.height;
                instruction[6] = height;
                width = image.width;
                instruction[13] = width;
              }
              let geometryWidths;
              if (instruction.length > 25) {
                geometryWidths = /** @type {number} */
                instruction[25];
              }
              let padding, backgroundFill, backgroundStroke;
              if (instruction.length > 17) {
                padding = /** @type {Array<number>} */
                instruction[16];
                backgroundFill = /** @type {boolean} */
                instruction[17];
                backgroundStroke = /** @type {boolean} */
                instruction[18];
              } else {
                padding = defaultPadding;
                backgroundFill = false;
                backgroundStroke = false;
              }
              if (rotateWithView && viewRotationFromTransform) {
                rotation += viewRotation;
              } else if (!rotateWithView && !viewRotationFromTransform) {
                rotation -= viewRotation;
              }
              let widthIndex = 0;
              for (; d < dd; d += 2) {
                if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                  continue;
                }
                const dimensions = this.calculateImageOrLabelDimensions_(
                  image.width,
                  image.height,
                  pixelCoordinates[d],
                  pixelCoordinates[d + 1],
                  width,
                  height,
                  anchorX,
                  anchorY,
                  originX,
                  originY,
                  rotation,
                  scale4,
                  snapToPixel,
                  padding,
                  backgroundFill || backgroundStroke,
                  feature
                );
                const args = [
                  context,
                  contextScale,
                  image,
                  dimensions,
                  opacity,
                  backgroundFill ? (
                    /** @type {Array<*>} */
                    lastFillInstruction
                  ) : null,
                  backgroundStroke ? (
                    /** @type {Array<*>} */
                    lastStrokeInstruction
                  ) : null
                ];
                if (declutterTree) {
                  if (declutterMode === "none") {
                    continue;
                  } else if (declutterMode === "obstacle") {
                    declutterTree.insert(dimensions.declutterBox);
                    continue;
                  } else {
                    let imageArgs;
                    let imageDeclutterBox;
                    if (declutterImageWithText) {
                      const index = dd - d;
                      if (!declutterImageWithText[index]) {
                        declutterImageWithText[index] = args;
                        continue;
                      }
                      imageArgs = declutterImageWithText[index];
                      delete declutterImageWithText[index];
                      imageDeclutterBox = getDeclutterBox(imageArgs);
                      if (declutterTree.collides(imageDeclutterBox)) {
                        continue;
                      }
                    }
                    if (declutterTree.collides(dimensions.declutterBox)) {
                      continue;
                    }
                    if (imageArgs) {
                      declutterTree.insert(imageDeclutterBox);
                      this.replayImageOrLabel_.apply(this, imageArgs);
                    }
                    declutterTree.insert(dimensions.declutterBox);
                  }
                }
                this.replayImageOrLabel_.apply(this, args);
              }
              ++i;
              break;
            case Instruction_default.DRAW_CHARS:
              const begin = (
                /** @type {number} */
                instruction[1]
              );
              const end = (
                /** @type {number} */
                instruction[2]
              );
              const baseline = (
                /** @type {number} */
                instruction[3]
              );
              const overflow = (
                /** @type {number} */
                instruction[4]
              );
              fillKey = /** @type {string} */
              instruction[5];
              const maxAngle = (
                /** @type {number} */
                instruction[6]
              );
              const measurePixelRatio = (
                /** @type {number} */
                instruction[7]
              );
              const offsetY = (
                /** @type {number} */
                instruction[8]
              );
              strokeKey = /** @type {string} */
              instruction[9];
              const strokeWidth = (
                /** @type {number} */
                instruction[10]
              );
              text = /** @type {string} */
              instruction[11];
              textKey = /** @type {string} */
              instruction[12];
              const pixelRatioScale = [
                /** @type {number} */
                instruction[13],
                /** @type {number} */
                instruction[13]
              ];
              const textState = this.textStates[textKey];
              const font = textState.font;
              const textScale = [
                textState.scale[0] * measurePixelRatio,
                textState.scale[1] * measurePixelRatio
              ];
              let cachedWidths;
              if (font in this.widths_) {
                cachedWidths = this.widths_[font];
              } else {
                cachedWidths = {};
                this.widths_[font] = cachedWidths;
              }
              const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
              const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
              if (overflow || textLength <= pathLength) {
                const textAlign = this.textStates[textKey].textAlign;
                const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
                const parts = drawTextOnPath(
                  pixelCoordinates,
                  begin,
                  end,
                  2,
                  text,
                  startM,
                  maxAngle,
                  Math.abs(textScale[0]),
                  measureAndCacheTextWidth,
                  font,
                  cachedWidths,
                  viewRotationFromTransform ? 0 : this.viewRotation_
                );
                drawChars:
                  if (parts) {
                    const replayImageOrLabelArgs = [];
                    let c, cc, chars, label, part;
                    if (strokeKey) {
                      for (c = 0, cc = parts.length; c < cc; ++c) {
                        part = parts[c];
                        chars = /** @type {string} */
                        part[4];
                        label = this.createLabel(chars, textKey, "", strokeKey);
                        anchorX = /** @type {number} */
                        part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                        anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                        const dimensions = this.calculateImageOrLabelDimensions_(
                          label.width,
                          label.height,
                          part[0],
                          part[1],
                          label.width,
                          label.height,
                          anchorX,
                          anchorY,
                          0,
                          0,
                          part[3],
                          pixelRatioScale,
                          false,
                          defaultPadding,
                          false,
                          feature
                        );
                        if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                          break drawChars;
                        }
                        replayImageOrLabelArgs.push([
                          context,
                          contextScale,
                          label,
                          dimensions,
                          1,
                          null,
                          null
                        ]);
                      }
                    }
                    if (fillKey) {
                      for (c = 0, cc = parts.length; c < cc; ++c) {
                        part = parts[c];
                        chars = /** @type {string} */
                        part[4];
                        label = this.createLabel(chars, textKey, fillKey, "");
                        anchorX = /** @type {number} */
                        part[2];
                        anchorY = baseline * label.height - offsetY;
                        const dimensions = this.calculateImageOrLabelDimensions_(
                          label.width,
                          label.height,
                          part[0],
                          part[1],
                          label.width,
                          label.height,
                          anchorX,
                          anchorY,
                          0,
                          0,
                          part[3],
                          pixelRatioScale,
                          false,
                          defaultPadding,
                          false,
                          feature
                        );
                        if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                          break drawChars;
                        }
                        replayImageOrLabelArgs.push([
                          context,
                          contextScale,
                          label,
                          dimensions,
                          1,
                          null,
                          null
                        ]);
                      }
                    }
                    if (declutterTree) {
                      declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                    }
                    for (let i2 = 0, ii2 = replayImageOrLabelArgs.length; i2 < ii2; ++i2) {
                      this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i2]);
                    }
                  }
              }
              ++i;
              break;
            case Instruction_default.END_GEOMETRY:
              if (featureCallback !== void 0) {
                feature = /** @type {import("../../Feature.js").FeatureLike} */
                instruction[1];
                const result = featureCallback(feature, currentGeometry);
                if (result) {
                  return result;
                }
              }
              ++i;
              break;
            case Instruction_default.FILL:
              if (batchSize) {
                pendingFill++;
              } else {
                this.fill_(context);
              }
              ++i;
              break;
            case Instruction_default.MOVE_TO_LINE_TO:
              d = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              x = pixelCoordinates[d];
              y = pixelCoordinates[d + 1];
              roundX = x + 0.5 | 0;
              roundY = y + 0.5 | 0;
              if (roundX !== prevX || roundY !== prevY) {
                context.moveTo(x, y);
                prevX = roundX;
                prevY = roundY;
              }
              for (d += 2; d < dd; d += 2) {
                x = pixelCoordinates[d];
                y = pixelCoordinates[d + 1];
                roundX = x + 0.5 | 0;
                roundY = y + 0.5 | 0;
                if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                  context.lineTo(x, y);
                  prevX = roundX;
                  prevY = roundY;
                }
              }
              ++i;
              break;
            case Instruction_default.SET_FILL_STYLE:
              lastFillInstruction = instruction;
              this.alignFill_ = instruction[2];
              if (pendingFill) {
                this.fill_(context);
                pendingFill = 0;
                if (pendingStroke) {
                  context.stroke();
                  pendingStroke = 0;
                }
              }
              context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
              instruction[1];
              ++i;
              break;
            case Instruction_default.SET_STROKE_STYLE:
              lastStrokeInstruction = instruction;
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
              this.setStrokeStyle_(
                context,
                /** @type {Array<*>} */
                instruction
              );
              ++i;
              break;
            case Instruction_default.STROKE:
              if (batchSize) {
                pendingStroke++;
              } else {
                context.stroke();
              }
              ++i;
              break;
            default:
              ++i;
              break;
          }
        }
        if (pendingFill) {
          this.fill_(context);
        }
        if (pendingStroke) {
          context.stroke();
        }
        return void 0;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       */
      execute(context, contextScale, transform2, viewRotation, snapToPixel, declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(
          context,
          contextScale,
          transform2,
          this.instructions,
          snapToPixel,
          void 0,
          void 0,
          declutterTree
        );
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      executeHitDetection(context, transform2, viewRotation, featureCallback, hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(
          context,
          1,
          transform2,
          this.hitDetectionInstructions,
          true,
          featureCallback,
          hitExtent
        );
      }
    };
    Executor_default = Executor;
  }
});

// node_modules/ol/render/canvas/ExecutorGroup.js
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i = 0; i <= radius; ++i) {
    for (let j = 0; j <= radius; ++j) {
      const distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance = distances[distanceSq];
      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }
      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }
  const pixelIndex = [];
  for (let i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push(...distances[i]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var ORDER, ExecutorGroup, circlePixelIndexArrayCache, ExecutorGroup_default;
var init_ExecutorGroup = __esm({
  "node_modules/ol/render/canvas/ExecutorGroup.js"() {
    init_Executor();
    init_array();
    init_extent();
    init_transform();
    init_dom();
    init_obj();
    init_transform2();
    ORDER = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
    ExecutorGroup = class {
      /**
       * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
       * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
       * should be set here, unless the target context does not exceed that extent (which
       * can be the case when rendering to tiles).
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The executor group can have overlapping geometries.
       * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
       * The serializable instructions.
       * @param {number} [renderBuffer] Optional rendering buffer.
       */
      constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {
        this.maxExtent_ = maxExtent;
        this.overlaps_ = overlaps;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.renderBuffer_ = renderBuffer;
        this.executorsByZIndex_ = {};
        this.hitDetectionContext_ = null;
        this.hitDetectionTransform_ = create();
        this.createExecutors_(allInstructions);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      clip(context, transform2) {
        const flatClipCoords = this.getClipCoords(transform2);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
      }
      /**
       * Create executors and populate them using the provided instructions.
       * @private
       * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
       */
      createExecutors_(allInstructions) {
        for (const zIndex in allInstructions) {
          let executors = this.executorsByZIndex_[zIndex];
          if (executors === void 0) {
            executors = {};
            this.executorsByZIndex_[zIndex] = executors;
          }
          const instructionByZindex = allInstructions[zIndex];
          for (const builderType in instructionByZindex) {
            const instructions = instructionByZindex[builderType];
            executors[builderType] = new Executor_default(
              this.resolution_,
              this.pixelRatio_,
              this.overlaps_,
              instructions
            );
          }
        }
      }
      /**
       * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
       * @return {boolean} Has executors of the provided types.
       */
      hasExecutors(executors) {
        for (const zIndex in this.executorsByZIndex_) {
          const candidates = this.executorsByZIndex_[zIndex];
          for (let i = 0, ii = executors.length; i < ii; ++i) {
            if (executors[i] in candidates) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        const contextSize = hitTolerance * 2 + 1;
        const transform2 = compose(
          this.hitDetectionTransform_,
          hitTolerance + 0.5,
          hitTolerance + 0.5,
          1 / resolution,
          -1 / resolution,
          -rotation,
          -coordinate[0],
          -coordinate[1]
        );
        const newContext = !this.hitDetectionContext_;
        if (newContext) {
          this.hitDetectionContext_ = createCanvasContext2D(
            contextSize,
            contextSize,
            void 0,
            { willReadFrequently: true }
          );
        }
        const context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
          context.canvas.width = contextSize;
          context.canvas.height = contextSize;
        } else if (!newContext) {
          context.clearRect(0, 0, contextSize, contextSize);
        }
        let hitExtent;
        if (this.renderBuffer_ !== void 0) {
          hitExtent = createEmpty();
          extendCoordinate(hitExtent, coordinate);
          buffer(
            hitExtent,
            resolution * (this.renderBuffer_ + hitTolerance),
            hitExtent
          );
        }
        const indexes = getPixelIndexArray(hitTolerance);
        let builderType;
        function featureCallback(feature, geometry) {
          const imageData = context.getImageData(
            0,
            0,
            contextSize,
            contextSize
          ).data;
          for (let i2 = 0, ii = indexes.length; i2 < ii; i2++) {
            if (imageData[indexes[i2]] > 0) {
              if (!declutteredFeatures || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
                const idx = (indexes[i2] - 3) / 4;
                const x = hitTolerance - idx % contextSize;
                const y = hitTolerance - (idx / contextSize | 0);
                const result2 = callback(feature, geometry, x * x + y * y);
                if (result2) {
                  return result2;
                }
              }
              context.clearRect(0, 0, contextSize, contextSize);
              break;
            }
          }
          return void 0;
        }
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(ascending);
        let i, j, executors, executor, result;
        for (i = zs.length - 1; i >= 0; --i) {
          const zIndexKey = zs[i].toString();
          executors = this.executorsByZIndex_[zIndexKey];
          for (j = ORDER.length - 1; j >= 0; --j) {
            builderType = ORDER[j];
            executor = executors[builderType];
            if (executor !== void 0) {
              result = executor.executeHitDetection(
                context,
                transform2,
                rotation,
                featureCallback,
                hitExtent
              );
              if (result) {
                return result;
              }
            }
          }
        }
        return void 0;
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       * @return {Array<number>|null} Clip coordinates.
       */
      getClipCoords(transform2) {
        const maxExtent = this.maxExtent_;
        if (!maxExtent) {
          return null;
        }
        const minX = maxExtent[0];
        const minY = maxExtent[1];
        const maxX = maxExtent[2];
        const maxY = maxExtent[3];
        const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
        transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
        return flatClipCoords;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty(this.executorsByZIndex_);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
       * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ORDER}
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       */
      execute(context, contextScale, transform2, viewRotation, snapToPixel, builderTypes, declutterTree) {
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(ascending);
        if (this.maxExtent_) {
          context.save();
          this.clip(context, transform2);
        }
        builderTypes = builderTypes ? builderTypes : ORDER;
        let i, ii, j, jj, replays, replay;
        if (declutterTree) {
          zs.reverse();
        }
        for (i = 0, ii = zs.length; i < ii; ++i) {
          const zIndexKey = zs[i].toString();
          replays = this.executorsByZIndex_[zIndexKey];
          for (j = 0, jj = builderTypes.length; j < jj; ++j) {
            const builderType = builderTypes[j];
            replay = replays[builderType];
            if (replay !== void 0) {
              replay.execute(
                context,
                contextScale,
                transform2,
                viewRotation,
                snapToPixel,
                declutterTree
              );
            }
          }
        }
        if (this.maxExtent_) {
          context.restore();
        }
      }
    };
    circlePixelIndexArrayCache = {};
    ExecutorGroup_default = ExecutorGroup;
  }
});

// node_modules/ol/render/canvas/Immediate.js
var CanvasImmediateRenderer, Immediate_default;
var init_Immediate = __esm({
  "node_modules/ol/render/canvas/Immediate.js"() {
    init_VectorContext();
    init_colorlike();
    init_transform();
    init_canvas();
    init_array();
    init_extent();
    init_math();
    init_transform2();
    init_SimpleGeometry();
    CanvasImmediateRenderer = class extends VectorContext_default {
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
       * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
       */
      constructor(context, pixelRatio, extent, transform2, viewRotation, squaredTolerance, userTransform) {
        super();
        this.context_ = context;
        this.pixelRatio_ = pixelRatio;
        this.extent_ = extent;
        this.transform_ = transform2;
        this.transformRotation_ = transform2 ? toFixed(Math.atan2(transform2[1], transform2[0]), 10) : 0;
        this.viewRotation_ = viewRotation;
        this.squaredTolerance_ = squaredTolerance;
        this.userTransform_ = userTransform;
        this.contextFillState_ = null;
        this.contextStrokeState_ = null;
        this.contextTextState_ = null;
        this.fillState_ = null;
        this.strokeState_ = null;
        this.image_ = null;
        this.imageAnchorX_ = 0;
        this.imageAnchorY_ = 0;
        this.imageHeight_ = 0;
        this.imageOpacity_ = 0;
        this.imageOriginX_ = 0;
        this.imageOriginY_ = 0;
        this.imageRotateWithView_ = false;
        this.imageRotation_ = 0;
        this.imageScale_ = [0, 0];
        this.imageWidth_ = 0;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = false;
        this.textRotation_ = 0;
        this.textScale_ = [0, 0];
        this.textFillState_ = null;
        this.textStrokeState_ = null;
        this.textState_ = null;
        this.pixelCoordinates_ = [];
        this.tmpLocalTransform_ = create();
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawImages_(flatCoordinates, offset, end, stride) {
        if (!this.image_) {
          return;
        }
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        const localTransform = this.tmpLocalTransform_;
        const alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha * this.imageOpacity_;
        }
        let rotation = this.imageRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.imageRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
          const x = pixelCoordinates[i] - this.imageAnchorX_;
          const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
          if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
            const centerX = x + this.imageAnchorX_;
            const centerY = y + this.imageAnchorY_;
            compose(
              localTransform,
              centerX,
              centerY,
              1,
              1,
              rotation,
              -centerX,
              -centerY
            );
            context.save();
            context.transform.apply(context, localTransform);
            context.translate(centerX, centerY);
            context.scale(this.imageScale_[0], this.imageScale_[1]);
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              -this.imageAnchorX_,
              -this.imageAnchorY_,
              this.imageWidth_,
              this.imageHeight_
            );
            context.restore();
          } else {
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              x,
              y,
              this.imageWidth_,
              this.imageHeight_
            );
          }
        }
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha;
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawText_(flatCoordinates, offset, end, stride) {
        if (!this.textState_ || this.text_ === "") {
          return;
        }
        if (this.textFillState_) {
          this.setContextFillState_(this.textFillState_);
        }
        if (this.textStrokeState_) {
          this.setContextStrokeState_(this.textStrokeState_);
        }
        this.setContextTextState_(this.textState_);
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        let rotation = this.textRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.textRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (; offset < end; offset += stride) {
          const x = pixelCoordinates[offset] + this.textOffsetX_;
          const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
          if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
            context.save();
            context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
            context.rotate(rotation);
            context.translate(this.textOffsetX_, this.textOffsetY_);
            context.scale(this.textScale_[0], this.textScale_[1]);
            if (this.textStrokeState_) {
              context.strokeText(this.text_, 0, 0);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, 0, 0);
            }
            context.restore();
          } else {
            if (this.textStrokeState_) {
              context.strokeText(this.text_, x, y);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, x, y);
            }
          }
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      moveToLineTo_(flatCoordinates, offset, end, stride, close) {
        const context = this.context_;
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        let length = pixelCoordinates.length;
        if (close) {
          length -= 2;
        }
        for (let i = 2; i < length; i += 2) {
          context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        }
        if (close) {
          context.closePath();
        }
        return end;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawRings_(flatCoordinates, offset, ends, stride) {
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          offset = this.moveToLineTo_(
            flatCoordinates,
            offset,
            ends[i],
            stride,
            true
          );
        }
        return offset;
      }
      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
       * @api
       */
      drawCircle(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Circle.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.fillState_ || this.strokeState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const pixelCoordinates = transformGeom2D(
            geometry,
            this.transform_,
            this.pixelCoordinates_
          );
          const dx = pixelCoordinates[2] - pixelCoordinates[0];
          const dy = pixelCoordinates[3] - pixelCoordinates[1];
          const radius = Math.sqrt(dx * dx + dy * dy);
          const context = this.context_;
          context.beginPath();
          context.arc(
            pixelCoordinates[0],
            pixelCoordinates[1],
            radius,
            0,
            2 * Math.PI
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          this.drawText_(geometry.getCenter(), 0, 2, 2);
        }
      }
      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {import("../../style/Style.js").default} style The rendering style.
       * @api
       */
      setStyle(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      setTransform(transform2) {
        this.transform_ = transform2;
      }
      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
       *
       * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
       * @api
       */
      drawGeometry(geometry) {
        const type = geometry.getType();
        switch (type) {
          case "Point":
            this.drawPoint(
              /** @type {import("../../geom/Point.js").default} */
              geometry
            );
            break;
          case "LineString":
            this.drawLineString(
              /** @type {import("../../geom/LineString.js").default} */
              geometry
            );
            break;
          case "Polygon":
            this.drawPolygon(
              /** @type {import("../../geom/Polygon.js").default} */
              geometry
            );
            break;
          case "MultiPoint":
            this.drawMultiPoint(
              /** @type {import("../../geom/MultiPoint.js").default} */
              geometry
            );
            break;
          case "MultiLineString":
            this.drawMultiLineString(
              /** @type {import("../../geom/MultiLineString.js").default} */
              geometry
            );
            break;
          case "MultiPolygon":
            this.drawMultiPolygon(
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry
            );
            break;
          case "GeometryCollection":
            this.drawGeometryCollection(
              /** @type {import("../../geom/GeometryCollection.js").default} */
              geometry
            );
            break;
          case "Circle":
            this.drawCircle(
              /** @type {import("../../geom/Circle.js").default} */
              geometry
            );
            break;
          default:
        }
      }
      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {import("../../style/Style.js").default} style Style.
       * @api
       */
      drawFeature(feature, style) {
        const geometry = style.getGeometryFunction()(feature);
        if (!geometry) {
          return;
        }
        this.setStyle(style);
        this.drawGeometry(geometry);
      }
      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
       */
      drawGeometryCollection(geometry) {
        const geometries = geometry.getGeometriesArray();
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          this.drawGeometry(geometries[i]);
        }
      }
      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
       */
      drawPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Point.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
       */
      drawMultiPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPoint.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
       */
      drawLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/LineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          context.beginPath();
          this.moveToLineTo_(
            flatCoordinates,
            0,
            flatCoordinates.length,
            geometry.getStride(),
            false
          );
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoint = geometry.getFlatMidpoint();
          this.drawText_(flatMidpoint, 0, 2, 2);
        }
      }
      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
       */
      drawMultiLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const geometryExtent = geometry.getExtent();
        if (!intersects(this.extent_, geometryExtent)) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          let offset = 0;
          const ends = (
            /** @type {Array<number>} */
            geometry.getEnds()
          );
          const stride = geometry.getStride();
          context.beginPath();
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            offset = this.moveToLineTo_(
              flatCoordinates,
              offset,
              ends[i],
              stride,
              false
            );
          }
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoints = geometry.getFlatMidpoints();
          this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
      }
      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
       */
      drawPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Polygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          context.beginPath();
          this.drawRings_(
            geometry.getOrientedFlatCoordinates(),
            0,
            /** @type {Array<number>} */
            geometry.getEnds(),
            geometry.getStride()
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoint = geometry.getFlatInteriorPoint();
          this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
      }
      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
       */
      drawMultiPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          const flatCoordinates = geometry.getOrientedFlatCoordinates();
          let offset = 0;
          const endss = geometry.getEndss();
          const stride = geometry.getStride();
          context.beginPath();
          for (let i = 0, ii = endss.length; i < ii; ++i) {
            const ends = endss[i];
            offset = this.drawRings_(flatCoordinates, offset, ends, stride);
          }
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoints = geometry.getFlatInteriorPoints();
          this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
      }
      /**
       * @param {import("../canvas.js").FillState} fillState Fill state.
       * @private
       */
      setContextFillState_(fillState) {
        const context = this.context_;
        const contextFillState = this.contextFillState_;
        if (!contextFillState) {
          context.fillStyle = fillState.fillStyle;
          this.contextFillState_ = {
            fillStyle: fillState.fillStyle
          };
        } else {
          if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
       * @private
       */
      setContextStrokeState_(strokeState) {
        const context = this.context_;
        const contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
          context.lineCap = strokeState.lineCap;
          context.setLineDash(strokeState.lineDash);
          context.lineDashOffset = strokeState.lineDashOffset;
          context.lineJoin = strokeState.lineJoin;
          context.lineWidth = strokeState.lineWidth;
          context.miterLimit = strokeState.miterLimit;
          context.strokeStyle = strokeState.strokeStyle;
          this.contextStrokeState_ = {
            lineCap: strokeState.lineCap,
            lineDash: strokeState.lineDash,
            lineDashOffset: strokeState.lineDashOffset,
            lineJoin: strokeState.lineJoin,
            lineWidth: strokeState.lineWidth,
            miterLimit: strokeState.miterLimit,
            strokeStyle: strokeState.strokeStyle
          };
        } else {
          if (contextStrokeState.lineCap != strokeState.lineCap) {
            contextStrokeState.lineCap = strokeState.lineCap;
            context.lineCap = strokeState.lineCap;
          }
          if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
            context.setLineDash(
              contextStrokeState.lineDash = strokeState.lineDash
            );
          }
          if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
            contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
            context.lineDashOffset = strokeState.lineDashOffset;
          }
          if (contextStrokeState.lineJoin != strokeState.lineJoin) {
            contextStrokeState.lineJoin = strokeState.lineJoin;
            context.lineJoin = strokeState.lineJoin;
          }
          if (contextStrokeState.lineWidth != strokeState.lineWidth) {
            contextStrokeState.lineWidth = strokeState.lineWidth;
            context.lineWidth = strokeState.lineWidth;
          }
          if (contextStrokeState.miterLimit != strokeState.miterLimit) {
            contextStrokeState.miterLimit = strokeState.miterLimit;
            context.miterLimit = strokeState.miterLimit;
          }
          if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
            contextStrokeState.strokeStyle = strokeState.strokeStyle;
            context.strokeStyle = strokeState.strokeStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").TextState} textState Text state.
       * @private
       */
      setContextTextState_(textState) {
        const context = this.context_;
        const contextTextState = this.contextTextState_;
        const textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
        if (!contextTextState) {
          context.font = textState.font;
          context.textAlign = textAlign;
          context.textBaseline = textState.textBaseline;
          this.contextTextState_ = {
            font: textState.font,
            textAlign,
            textBaseline: textState.textBaseline
          };
        } else {
          if (contextTextState.font != textState.font) {
            contextTextState.font = textState.font;
            context.font = textState.font;
          }
          if (contextTextState.textAlign != textAlign) {
            contextTextState.textAlign = textAlign;
            context.textAlign = textAlign;
          }
          if (contextTextState.textBaseline != textState.textBaseline) {
            contextTextState.textBaseline = textState.textBaseline;
            context.textBaseline = textState.textBaseline;
          }
        }
      }
      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        if (!fillStyle) {
          this.fillState_ = null;
        } else {
          const fillStyleColor = fillStyle.getColor();
          this.fillState_ = {
            fillStyle: asColorLike(
              fillStyleColor ? fillStyleColor : defaultFillStyle
            )
          };
        }
        if (!strokeStyle) {
          this.strokeState_ = null;
        } else {
          const strokeStyleColor = strokeStyle.getColor();
          const strokeStyleLineCap = strokeStyle.getLineCap();
          const strokeStyleLineDash = strokeStyle.getLineDash();
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          const strokeStyleWidth = strokeStyle.getWidth();
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
          this.strokeState_ = {
            lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
            lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n) => n * this.pixelRatio_),
            lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
            lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
            lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
            miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
            strokeStyle: asColorLike(
              strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
            )
          };
        }
      }
      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       */
      setImageStyle(imageStyle) {
        let imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
          this.image_ = null;
          return;
        }
        const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
        const imageAnchor = imageStyle.getAnchor();
        const imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        const imageScale = imageStyle.getScaleArray();
        this.imageScale_ = [
          imageScale[0] * this.pixelRatio_ / imagePixelRatio,
          imageScale[1] * this.pixelRatio_ / imagePixelRatio
        ];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
      }
      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {import("../../style/Text.js").default} textStyle Text style.
       */
      setTextStyle(textStyle) {
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            this.textFillState_ = null;
          } else {
            const textFillStyleColor = textFillStyle.getColor();
            this.textFillState_ = {
              fillStyle: asColorLike(
                textFillStyleColor ? textFillStyleColor : defaultFillStyle
              )
            };
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            this.textStrokeState_ = null;
          } else {
            const textStrokeStyleColor = textStrokeStyle.getColor();
            const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
            const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
            const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
            const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
            const textStrokeStyleWidth = textStrokeStyle.getWidth();
            const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
            this.textStrokeState_ = {
              lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
              lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
              lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
              lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
              lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
              miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
              strokeStyle: asColorLike(
                textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle
              )
            };
          }
          const textFont = textStyle.getFont();
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textRotation = textStyle.getRotation();
          const textScale = textStyle.getScaleArray();
          const textText = textStyle.getText();
          const textTextAlign = textStyle.getTextAlign();
          const textTextBaseline = textStyle.getTextBaseline();
          this.textState_ = {
            font: textFont !== void 0 ? textFont : defaultFont,
            textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
            textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
          };
          this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t, i) => acc += i % 2 ? " " : t, "") : textText : "";
          this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
          this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
          this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
          this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
          this.textScale_ = [
            this.pixelRatio_ * textScale[0],
            this.pixelRatio_ * textScale[1]
          ];
        }
      }
    };
    Immediate_default = CanvasImmediateRenderer;
  }
});

// node_modules/ol/style.js
var init_style2 = __esm({
  "node_modules/ol/style.js"() {
    init_Icon();
    init_Style();
  }
});

// node_modules/ol/render/canvas/hitdetect.js
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation) {
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new Immediate_default(
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation
  );
  const featureCount = features.length;
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i = 1; i <= featureCount; ++i) {
    const feature = features[i - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index = i * indexFactor;
    const color = index.toString(16).padStart(7, "#00000");
    for (let j = 0, jj = styles.length; j < jj; ++j) {
      const originalStyle = styles[j];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !intersects(extent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(void 0);
      const image = originalStyle.getImage();
      if (image) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }
        const imgContext = createCanvasContext2D(
          imgSize[0],
          imgSize[1],
          void 0,
          { alpha: false }
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new Icon_default({
            img,
            anchor: image.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView()
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType["Polygon"] = [];
        byGeometryType["Circle"] = [];
        byGeometryType["LineString"] = [];
        byGeometryType["Point"] = [];
      }
      const type = geometry.getType();
      if (type === "GeometryCollection") {
        const geometries = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry.getGeometriesArrayRecursive()
        );
        for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
          const geometry2 = geometries[i2];
          byGeometryType[geometry2.getType().replace("Multi", "")].push(
            geometry2,
            style
          );
        }
      } else {
        byGeometryType[type.replace("Multi", "")].push(geometry, style);
      }
    }
  }
  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ascending);
  for (let i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);
        for (let k = 0, kk = transforms2.length; k < kk; ++k) {
          renderer.setTransform(transforms2[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    const index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
    const r = imageData.data[index];
    const g = imageData.data[index + 1];
    const b = imageData.data[index + 2];
    const i = b + 256 * (g + 256 * r);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  return resultFeatures;
}
var HIT_DETECT_RESOLUTION;
var init_hitdetect = __esm({
  "node_modules/ol/render/canvas/hitdetect.js"() {
    init_Immediate();
    init_style2();
    init_array();
    init_math();
    init_dom();
    init_extent();
    HIT_DETECT_RESOLUTION = 0.5;
  }
});

// node_modules/ol/renderer/vector.js
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform2, declutterBuilderGroup) {
  let loading = false;
  const imageStyle = style.getImage();
  if (imageStyle) {
    const imageState = imageStyle.getImageState();
    if (imageState == ImageState_default.LOADED || imageState == ImageState_default.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == ImageState_default.IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform2,
    declutterBuilderGroup
  );
  return loading;
}
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform2, declutterBuilderGroup) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform2
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      declutterBuilderGroup
    );
  }
}
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == "GeometryCollection") {
    const geometries = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      geometry.getGeometries()
    );
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    geometry,
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer()
  );
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
  const geometries = geometry.getGeometriesArray();
  let i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i],
      style,
      feature,
      declutterBuilderGroup
    );
  }
}
function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(
            style.getZIndex(),
            "Image"
          );
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      "Image"
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(
            style.getZIndex(),
            "Image"
          );
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      "Image"
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
var SIMPLIFY_TOLERANCE, GEOMETRY_RENDERERS;
var init_vector = __esm({
  "node_modules/ol/renderer/vector.js"() {
    init_ImageState();
    init_util();
    SIMPLIFY_TOLERANCE = 0.5;
    GEOMETRY_RENDERERS = {
      "Point": renderPointGeometry,
      "LineString": renderLineStringGeometry,
      "Polygon": renderPolygonGeometry,
      "MultiPoint": renderMultiPointGeometry,
      "MultiLineString": renderMultiLineStringGeometry,
      "MultiPolygon": renderMultiPolygonGeometry,
      "GeometryCollection": renderGeometryCollectionGeometry,
      "Circle": renderCircleGeometry
    };
  }
});

// node_modules/ol/renderer/canvas/VectorLayer.js
var CanvasVectorLayerRenderer, VectorLayer_default;
var init_VectorLayer = __esm({
  "node_modules/ol/renderer/canvas/VectorLayer.js"() {
    init_BuilderGroup();
    init_Layer3();
    init_ExecutorGroup();
    init_EventType2();
    init_ViewHint();
    init_hitdetect();
    init_transform();
    init_extent();
    init_dom();
    init_vector();
    init_array();
    init_proj();
    init_util();
    init_coordinate();
    CanvasVectorLayerRenderer = class extends Layer_default3 {
      /**
       * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
       */
      constructor(vectorLayer) {
        super(vectorLayer);
        this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        this.animatingOrInteracting_;
        this.hitDetectionImageData_ = null;
        this.renderedFeatures_ = null;
        this.renderedRevision_ = -1;
        this.renderedResolution_ = NaN;
        this.renderedExtent_ = createEmpty();
        this.wrappedRenderedExtent_ = createEmpty();
        this.renderedRotation_;
        this.renderedCenter_ = null;
        this.renderedProjection_ = null;
        this.renderedRenderOrder_ = null;
        this.replayGroup_ = null;
        this.replayGroupChanged = true;
        this.declutterExecutorGroup = null;
        this.clipping = true;
        this.compositionContext_ = null;
        this.opacity_ = 1;
      }
      /**
       * @param {ExecutorGroup} executorGroup Executor group.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       */
      renderWorlds(executorGroup, frameState, declutterTree) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
        const context = this.compositionContext_;
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
          const transform2 = this.getRenderTransform(
            center,
            resolution,
            rotation,
            pixelRatio,
            width,
            height,
            world * worldWidth
          );
          executorGroup.execute(
            context,
            1,
            transform2,
            rotation,
            snapToPixel,
            void 0,
            declutterTree
          );
        } while (++world < endWorld);
      }
      setupCompositionContext_() {
        if (this.opacity_ !== 1) {
          const compositionContext = createCanvasContext2D(
            this.context.canvas.width,
            this.context.canvas.height,
            canvasPool2
          );
          this.compositionContext_ = compositionContext;
        } else {
          this.compositionContext_ = this.context;
        }
      }
      releaseCompositionContext_() {
        if (this.opacity_ !== 1) {
          const alpha = this.context.globalAlpha;
          this.context.globalAlpha = this.opacity_;
          this.context.drawImage(this.compositionContext_.canvas, 0, 0);
          this.context.globalAlpha = alpha;
          releaseCanvas(this.compositionContext_);
          canvasPool2.push(this.compositionContext_.canvas);
          this.compositionContext_ = null;
        }
      }
      /**
       * Render declutter items for this layer
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeclutter(frameState) {
        if (this.declutterExecutorGroup) {
          this.setupCompositionContext_();
          this.renderWorlds(
            this.declutterExecutorGroup,
            frameState,
            frameState.declutterTree
          );
          this.releaseCompositionContext_();
        }
      }
      /**
       * Render the layer.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement|null} The rendered element.
       */
      renderFrame(frameState, target) {
        const pixelRatio = frameState.pixelRatio;
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
        makeInverse(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = toString(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        const replayGroup = this.replayGroup_;
        const declutterExecutorGroup = this.declutterExecutorGroup;
        let render2 = replayGroup && !replayGroup.isEmpty() || declutterExecutorGroup && !declutterExecutorGroup.isEmpty();
        if (!render2) {
          const hasRenderListeners = this.getLayer().hasListener(EventType_default2.PRERENDER) || this.getLayer().hasListener(EventType_default2.POSTRENDER);
          if (!hasRenderListeners) {
            return null;
          }
        }
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        if (canvas.width != width || canvas.height != height) {
          canvas.width = width;
          canvas.height = height;
          if (canvas.style.transform !== canvasTransform) {
            canvas.style.transform = canvasTransform;
          }
        } else if (!this.containerReused) {
          context.clearRect(0, 0, width, height);
        }
        this.preRender(context, frameState);
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        this.opacity_ = layerState.opacity;
        this.setupCompositionContext_();
        let clipped = false;
        if (render2 && layerState.extent && this.clipping) {
          const layerExtent = fromUserExtent(layerState.extent, projection);
          render2 = intersects(layerExtent, frameState.extent);
          clipped = render2 && !containsExtent(layerExtent, frameState.extent);
          if (clipped) {
            this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
          }
        }
        if (render2) {
          this.renderWorlds(replayGroup, frameState);
        }
        if (clipped) {
          this.compositionContext_.restore();
        }
        this.releaseCompositionContext_();
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
          this.renderedRotation_ = viewState.rotation;
          this.hitDetectionImageData_ = null;
        }
        return this.container;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../../Feature").default>>} Promise
       * that resolves with an array of features.
       */
      getFeatures(pixel) {
        return new Promise((resolve) => {
          if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
            const size = [this.context.canvas.width, this.context.canvas.height];
            apply(this.pixelTransform, size);
            const center = this.renderedCenter_;
            const resolution = this.renderedResolution_;
            const rotation = this.renderedRotation_;
            const projection = this.renderedProjection_;
            const extent = this.wrappedRenderedExtent_;
            const layer = this.getLayer();
            const transforms2 = [];
            const width = size[0] * HIT_DETECT_RESOLUTION;
            const height = size[1] * HIT_DETECT_RESOLUTION;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                0
              ).slice()
            );
            const source = layer.getSource();
            const projectionExtent = projection.getExtent();
            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
              let startX = extent[0];
              const worldWidth = getWidth(projectionExtent);
              let world = 0;
              let offsetX;
              while (startX < projectionExtent[0]) {
                --world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX += worldWidth;
              }
              world = 0;
              startX = extent[2];
              while (startX > projectionExtent[2]) {
                ++world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX -= worldWidth;
              }
            }
            this.hitDetectionImageData_ = createHitDetectionImageData(
              size,
              transforms2,
              this.renderedFeatures_,
              layer.getStyleFunction(),
              extent,
              resolution,
              rotation
            );
          }
          resolve(
            hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
          );
        });
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) {
          return void 0;
        }
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        const features = {};
        const featureCallback = function(feature, geometry, distanceSq) {
          const key = getUid(feature);
          const match = features[key];
          if (!match) {
            if (distanceSq === 0) {
              features[key] = true;
              return callback(feature, layer, geometry);
            }
            matches.push(
              features[key] = {
                feature,
                layer,
                geometry,
                distanceSq,
                callback
              }
            );
          } else if (match !== true && distanceSq < match.distanceSq) {
            if (distanceSq === 0) {
              features[key] = true;
              matches.splice(matches.lastIndexOf(match), 1);
              return callback(feature, layer, geometry);
            }
            match.geometry = geometry;
            match.distanceSq = distanceSq;
          }
          return void 0;
        };
        let result;
        const executorGroups = [this.replayGroup_];
        if (this.declutterExecutorGroup) {
          executorGroups.push(this.declutterExecutorGroup);
        }
        executorGroups.some((executorGroup) => {
          return result = executorGroup.forEachFeatureAtCoordinate(
            coordinate,
            resolution,
            rotation,
            hitTolerance,
            featureCallback,
            executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item) => item.value) : null
          );
        });
        return result;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       */
      handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) {
          layer.changed();
        }
      }
      /**
       * Handle changes in image style state.
       * @param {import("../../events/Event.js").default} event Image style change event.
       * @private
       */
      handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
      }
      /**
       * Determine whether render should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) {
          return false;
        }
        const animating = frameState.viewHints[ViewHint_default.ANIMATING];
        const interacting = frameState.viewHints[ViewHint_default.INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
          this.animatingOrInteracting_ = true;
          return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === void 0) {
          vectorLayerRenderOrder = defaultOrder;
        }
        const center = viewState.center.slice();
        const extent = buffer(
          frameStateExtent,
          vectorLayerRenderBuffer * resolution
        );
        const renderedExtent = extent.slice();
        const loadExtents = [extent.slice()];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
          const worldWidth = getWidth(projectionExtent);
          const gutter = Math.max(getWidth(extent) / 2, worldWidth);
          extent[0] = projectionExtent[0] - gutter;
          extent[2] = projectionExtent[2] + gutter;
          wrapX2(center, projection);
          const loadExtent = wrapX(loadExtents[0], projection);
          if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] + worldWidth,
              loadExtent[1],
              loadExtent[2] + worldWidth,
              loadExtent[3]
            ]);
          } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] - worldWidth,
              loadExtent[1],
              loadExtent[2] - worldWidth,
              loadExtent[3]
            ]);
          }
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
          if (!equals(this.renderedExtent_, renderedExtent)) {
            this.hitDetectionImageData_ = null;
            this.renderedExtent_ = renderedExtent;
          }
          this.renderedCenter_ = center;
          this.replayGroupChanged = false;
          return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new BuilderGroup_default(
          getTolerance(resolution, pixelRatio),
          extent,
          resolution,
          pixelRatio
        );
        let declutterBuilderGroup;
        if (this.getLayer().getDeclutter()) {
          declutterBuilderGroup = new BuilderGroup_default(
            getTolerance(resolution, pixelRatio),
            extent,
            resolution,
            pixelRatio
          );
        }
        const userProjection2 = getUserProjection();
        let userTransform;
        if (userProjection2) {
          for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
            const extent2 = loadExtents[i];
            const userExtent2 = toUserExtent(extent2, projection);
            vectorSource.loadFeatures(
              userExtent2,
              toUserResolution(resolution, projection),
              userProjection2
            );
          }
          userTransform = getTransformFromProjections(userProjection2, projection);
        } else {
          for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
            vectorSource.loadFeatures(loadExtents[i], resolution, projection);
          }
        }
        const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
        let ready = true;
        const render2 = (
          /**
           * @param {import("../../Feature.js").default} feature Feature.
           */
          (feature) => {
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) {
              styles = styleFunction(feature, resolution);
            }
            if (styles) {
              const dirty = this.renderFeature(
                feature,
                squaredTolerance,
                styles,
                replayGroup,
                userTransform,
                declutterBuilderGroup
              );
              ready = ready && !dirty;
            }
          }
        );
        const userExtent = toUserExtent(extent, projection);
        const features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) {
          features.sort(vectorLayerRenderOrder);
        }
        for (let i = 0, ii = features.length; i < ii; ++i) {
          render2(features[i]);
        }
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new ExecutorGroup_default(
          extent,
          resolution,
          pixelRatio,
          vectorSource.getOverlaps(),
          replayGroupInstructions,
          vectorLayer.getRenderBuffer()
        );
        if (declutterBuilderGroup) {
          this.declutterExecutorGroup = new ExecutorGroup_default(
            extent,
            resolution,
            pixelRatio,
            vectorSource.getOverlaps(),
            declutterBuilderGroup.finish(),
            vectorLayer.getRenderBuffer()
          );
        }
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
      }
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} squaredTolerance Squared render tolerance.
       * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
       * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
       * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
       * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
       * @return {boolean} `true` if an image is loading.
       */
      renderFeature(feature, squaredTolerance, styles, builderGroup, transform2, declutterBuilderGroup) {
        if (!styles) {
          return false;
        }
        let loading = false;
        if (Array.isArray(styles)) {
          for (let i = 0, ii = styles.length; i < ii; ++i) {
            loading = renderFeature(
              builderGroup,
              feature,
              styles[i],
              squaredTolerance,
              this.boundHandleStyleImageChange_,
              transform2,
              declutterBuilderGroup
            ) || loading;
          }
        } else {
          loading = renderFeature(
            builderGroup,
            feature,
            styles,
            squaredTolerance,
            this.boundHandleStyleImageChange_,
            transform2,
            declutterBuilderGroup
          );
        }
        return loading;
      }
    };
    VectorLayer_default = CanvasVectorLayerRenderer;
  }
});

// node_modules/ol/layer/Vector.js
var Vector_exports = {};
__export(Vector_exports, {
  default: () => Vector_default
});
var VectorLayer, Vector_default;
var init_Vector = __esm({
  "node_modules/ol/layer/Vector.js"() {
    init_BaseVector();
    init_VectorLayer();
    VectorLayer = class extends BaseVector_default {
      /**
       * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
       */
      constructor(options) {
        super(options);
      }
      createRenderer() {
        return new VectorLayer_default(this);
      }
    };
    Vector_default = VectorLayer;
  }
});

// node_modules/ol/structs/RBush.js
var RBush2, RBush_default;
var init_RBush = __esm({
  "node_modules/ol/structs/RBush.js"() {
    init_rbush();
    init_extent();
    init_util();
    init_obj();
    RBush2 = class {
      /**
       * @param {number} [maxEntries] Max entries.
       */
      constructor(maxEntries) {
        this.rbush_ = new RBush(maxEntries);
        this.items_ = {};
      }
      /**
       * Insert a value into the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      insert(extent, value) {
        const item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value
        };
        this.rbush_.insert(item);
        this.items_[getUid(value)] = item;
      }
      /**
       * Bulk-insert values into the RBush.
       * @param {Array<import("../extent.js").Extent>} extents Extents.
       * @param {Array<T>} values Values.
       */
      load(extents, values) {
        const items = new Array(values.length);
        for (let i = 0, l = values.length; i < l; i++) {
          const extent = extents[i];
          const value = values[i];
          const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value
          };
          items[i] = item;
          this.items_[getUid(value)] = item;
        }
        this.rbush_.load(items);
      }
      /**
       * Remove a value from the RBush.
       * @param {T} value Value.
       * @return {boolean} Removed.
       */
      remove(value) {
        const uid = getUid(value);
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
      }
      /**
       * Update the extent of a value in the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      update(extent, value) {
        const item = this.items_[getUid(value)];
        const bbox = [item.minX, item.minY, item.maxX, item.maxY];
        if (!equals2(bbox, extent)) {
          this.remove(value);
          this.insert(extent, value);
        }
      }
      /**
       * Return all values in the RBush.
       * @return {Array<T>} All.
       */
      getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Return all values in the given extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<T>} All in extent.
       */
      getInExtent(extent) {
        const bbox = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3]
        };
        const items = this.rbush_.search(bbox);
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Calls a callback function with each value in the tree.
       * If the callback returns a truthy value, this value is returned without
       * checking the rest of the tree.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      forEach(callback) {
        return this.forEach_(this.getAll(), callback);
      }
      /**
       * Calls a callback function with each value in the provided extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
      }
      /**
       * @param {Array<T>} values Values.
       * @param {function(T): *} callback Callback.
       * @private
       * @return {*} Callback return value.
       */
      forEach_(values, callback) {
        let result;
        for (let i = 0, l = values.length; i < l; i++) {
          result = callback(values[i]);
          if (result) {
            return result;
          }
        }
        return result;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty(this.items_);
      }
      /**
       * Remove all values from the RBush.
       */
      clear() {
        this.rbush_.clear();
        this.items_ = {};
      }
      /**
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} Extent.
       */
      getExtent(extent) {
        const data = this.rbush_.toJSON();
        return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
      }
      /**
       * @param {RBush} rbush R-Tree.
       */
      concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for (const i in rbush.items_) {
          this.items_[i] = rbush.items_[i];
        }
      }
    };
    RBush_default = RBush2;
  }
});

// node_modules/ol/geom/flat/center.js
function linearRingss(flatCoordinates, offset, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}
var init_center = __esm({
  "node_modules/ol/geom/flat/center.js"() {
    init_extent();
  }
});

// node_modules/ol/geom.js
var init_geom = __esm({
  "node_modules/ol/geom.js"() {
    init_Point();
  }
});

// node_modules/ol/render/Feature.js
var tmpTransform2, RenderFeature, Feature_default2;
var init_Feature2 = __esm({
  "node_modules/ol/render/Feature.js"() {
    init_transform();
    init_extent();
    init_simplify();
    init_array();
    init_interiorpoint();
    init_proj();
    init_orient();
    init_interpolate();
    init_center();
    init_functions();
    init_transform2();
    tmpTransform2 = create();
    RenderFeature = class _RenderFeature {
      /**
       * @param {Type} type Geometry type.
       * @param {Array<number>} flatCoordinates Flat coordinates. These always need
       *     to be right-handed for polygons.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Object<string, *>} properties Properties.
       * @param {number|string|undefined} id Feature id.
       */
      constructor(type, flatCoordinates, ends, stride, properties, id) {
        this.styleFunction;
        this.extent_;
        this.id_ = id;
        this.type_ = type;
        this.flatCoordinates_ = flatCoordinates;
        this.flatInteriorPoints_ = null;
        this.flatMidpoints_ = null;
        this.ends_ = ends;
        this.properties_ = properties;
        this.squaredTolerance_;
        this.stride_ = stride;
        this.simplifiedGeometry_;
      }
      /**
       * Get a feature property by its key.
       * @param {string} key Key
       * @return {*} Value for the requested key.
       * @api
       */
      get(key) {
        return this.properties_[key];
      }
      /**
       * Get the extent of this feature's geometry.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        if (!this.extent_) {
          this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2
          );
        }
        return this.extent_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoints_ = getInteriorPointOfArray(
            this.flatCoordinates_,
            0,
            /** @type {Array<number>} */
            this.ends_,
            2,
            flatCenter,
            0
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
          const ends = inflateEnds(this.flatCoordinates_, this.ends_);
          const flatCenters = linearRingss(this.flatCoordinates_, 0, ends, 2);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.flatCoordinates_,
            0,
            ends,
            2,
            flatCenters
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = interpolatePoint(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            0.5
          );
        }
        return this.flatMidpoints_;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = [];
          const flatCoordinates = this.flatCoordinates_;
          let offset = 0;
          const ends = (
            /** @type {Array<number>} */
            this.ends_
          );
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            const end = ends[i];
            const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
            extend(this.flatMidpoints_, midpoint);
            offset = end;
          }
        }
        return this.flatMidpoints_;
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is set when reading data from a remote source.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
      }
      /**
       * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
       * determining the geometry type in style function (see {@link #getType}).
       * @return {RenderFeature} Feature.
       * @api
       */
      getGeometry() {
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {RenderFeature} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {RenderFeature} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform2) {
        return this;
      }
      /**
       * Get the feature properties.
       * @return {Object<string, *>} Feature properties.
       * @api
       */
      getProperties() {
        return this.properties_;
      }
      /**
       * Get an object of all property names and values.  This has the same behavior as getProperties,
       * but is here to conform with the {@link module:ol/Feature~Feature} interface.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.properties_;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride_;
      }
      /**
       * @return {import('../style/Style.js').StyleFunction|undefined} Style
       */
      getStyleFunction() {
        return this.styleFunction;
      }
      /**
       * Get the type of this feature's geometry.
       * @return {Type} Geometry type.
       * @api
       */
      getType() {
        return this.type_;
      }
      /**
       * Transform geometry coordinates from tile pixel space to projected.
       *
       * @param {import("../proj.js").ProjectionLike} projection The data projection
       */
      transform(projection) {
        projection = get3(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
          const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform2,
            projectedExtent[0],
            projectedExtent[3],
            scale4,
            -scale4,
            0,
            0,
            0
          );
          transform2D(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            tmpTransform2,
            this.flatCoordinates_
          );
        }
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       */
      applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
      }
      /**
       * @return {RenderFeature} A cloned render feature.
       */
      clone() {
        return new _RenderFeature(
          this.type_,
          this.flatCoordinates_.slice(),
          this.ends_.slice(),
          this.stride_,
          Object.assign({}, this.properties_),
          this.id_
        );
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Add transform and resolution based geometry simplification to this instance.
       * @return {RenderFeature} This render feature.
       */
      enableSimplifyTransformed() {
        this.simplifyTransformed = memoizeOne((squaredTolerance, transform2) => {
          if (squaredTolerance === this.squaredTolerance_) {
            return this.simplifiedGeometry_;
          }
          this.simplifiedGeometry_ = this.clone();
          if (transform2) {
            this.simplifiedGeometry_.applyTransform(transform2);
          }
          const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
          let simplifiedEnds;
          switch (this.type_) {
            case "LineString":
              simplifiedFlatCoordinates.length = douglasPeucker(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.flatCoordinates_.length,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0
              );
              simplifiedEnds = [simplifiedFlatCoordinates.length];
              break;
            case "MultiLineString":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = douglasPeuckerArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            case "Polygon":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = quantizeArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                Math.sqrt(squaredTolerance),
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            default:
          }
          if (simplifiedEnds) {
            this.simplifiedGeometry_ = new _RenderFeature(
              this.type_,
              simplifiedFlatCoordinates,
              simplifiedEnds,
              2,
              this.properties_,
              this.id_
            );
          }
          this.squaredTolerance_ = squaredTolerance;
          return this.simplifiedGeometry_;
        });
        return this;
      }
    };
    RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
    Feature_default2 = RenderFeature;
  }
});

// node_modules/ol/source/VectorEventType.js
var VectorEventType_default;
var init_VectorEventType = __esm({
  "node_modules/ol/source/VectorEventType.js"() {
    VectorEventType_default = {
      /**
       * Triggered when a feature is added to the source.
       * @event module:ol/source/Vector.VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: "addfeature",
      /**
       * Triggered when a feature is updated.
       * @event module:ol/source/Vector.VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: "changefeature",
      /**
       * Triggered when the clear method is called on the source.
       * @event module:ol/source/Vector.VectorSourceEvent#clear
       * @api
       */
      CLEAR: "clear",
      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
       * @event module:ol/source/Vector.VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: "removefeature",
      /**
       * Triggered when features starts loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
       * @api
       */
      FEATURESLOADSTART: "featuresloadstart",
      /**
       * Triggered when features finishes loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
       * @api
       */
      FEATURESLOADEND: "featuresloadend",
      /**
       * Triggered if feature loading results in an error.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
       * @api
       */
      FEATURESLOADERROR: "featuresloaderror"
    };
  }
});

// node_modules/ol/loadingstrategy.js
function all2(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
var init_loadingstrategy = __esm({
  "node_modules/ol/loadingstrategy.js"() {
    init_proj();
  }
});

// node_modules/ol/featureloader.js
function loadFeaturesXhr(url, format2, extent, resolution, projection, success, failure) {
  const xhr2 = new XMLHttpRequest();
  xhr2.open(
    "GET",
    typeof url === "function" ? url(extent, resolution, projection) : url,
    true
  );
  if (format2.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      const type = format2.getType();
      let source;
      if (type == "json") {
        source = JSON.parse(xhr2.responseText);
      } else if (type == "text") {
        source = xhr2.responseText;
      } else if (type == "xml") {
        source = xhr2.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(
            xhr2.responseText,
            "application/xml"
          );
        }
      } else if (type == "arraybuffer") {
        source = /** @type {ArrayBuffer} */
        xhr2.response;
      }
      if (source) {
        success(
          /** @type {Array<import("./Feature.js").default>} */
          format2.readFeatures(source, {
            extent,
            featureProjection: projection
          }),
          format2.readProjection(source)
        );
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format2) {
  return function(extent, resolution, projection, success, failure) {
    const source = (
      /** @type {import("./source/Vector").default} */
      this
    );
    loadFeaturesXhr(
      url,
      format2,
      extent,
      resolution,
      projection,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(features, dataProjection) {
        source.addFeatures(features);
        if (success !== void 0) {
          success(features);
        }
      },
      /* FIXME handle error */
      failure ? failure : VOID
    );
  };
}
var withCredentials;
var init_featureloader = __esm({
  "node_modules/ol/featureloader.js"() {
    init_functions();
    withCredentials = false;
  }
});

// node_modules/ol/source/Vector.js
var Vector_exports2 = {};
__export(Vector_exports2, {
  VectorSourceEvent: () => VectorSourceEvent,
  default: () => Vector_default2
});
var VectorSourceEvent, VectorSource, Vector_default2;
var init_Vector2 = __esm({
  "node_modules/ol/source/Vector.js"() {
    init_Collection();
    init_CollectionEventType();
    init_Event();
    init_EventType();
    init_ObjectEventType();
    init_RBush();
    init_Feature2();
    init_Source();
    init_VectorEventType();
    init_functions();
    init_loadingstrategy();
    init_asserts();
    init_extent();
    init_array();
    init_util();
    init_obj();
    init_events();
    init_featureloader();
    VectorSourceEvent = class extends Event_default {
      /**
       * @param {string} type Type.
       * @param {FeatureClass} [feature] Feature.
       * @param {Array<FeatureClass>} [features] Features.
       */
      constructor(type, feature, features) {
        super(type);
        this.feature = feature;
        this.features = features;
      }
    };
    VectorSource = class extends Source_default {
      /**
       * @param {Options<FeatureClass>} [options] Vector source options.
       */
      constructor(options) {
        options = options || {};
        super({
          attributions: options.attributions,
          interpolate: true,
          projection: void 0,
          state: "ready",
          wrapX: options.wrapX !== void 0 ? options.wrapX : true
        });
        this.on;
        this.once;
        this.un;
        this.loader_ = VOID;
        this.format_ = options.format;
        this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
        this.url_ = options.url;
        if (options.loader !== void 0) {
          this.loader_ = options.loader;
        } else if (this.url_ !== void 0) {
          assert(this.format_, "`format` must be set when `url` is set");
          this.loader_ = xhr(
            this.url_,
            /** @type {import("../format/Feature.js").default} */
            this.format_
          );
        }
        this.strategy_ = options.strategy !== void 0 ? options.strategy : all2;
        const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
        this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
        this.loadedExtentsRtree_ = new RBush_default();
        this.loadingExtentsCount_ = 0;
        this.nullGeometryFeatures_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
        this.featureChangeKeys_ = {};
        this.featuresCollection_ = null;
        let collection;
        let features;
        if (Array.isArray(options.features)) {
          features = options.features;
        } else if (options.features) {
          collection = options.features;
          features = collection.getArray();
        }
        if (!useSpatialIndex && collection === void 0) {
          collection = new Collection_default(features);
        }
        if (features !== void 0) {
          this.addFeaturesInternal(features);
        }
        if (collection !== void 0) {
          this.bindFeaturesCollection_(collection);
        }
      }
      /**
       * Add a single feature to the source.  If you want to add a batch of features
       * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
       * instead. A feature will not be added to the source if feature with
       * the same id is already there. The reason for this behavior is to avoid
       * feature duplication when using bbox or tile loading strategies.
       * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
       * meaning that if a feature with a duplicate id is added in the collection, it will
       * be removed from it right away.
       * @param {FeatureClass} feature Feature to add.
       * @api
       */
      addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
      }
      /**
       * Add a feature without firing a `change` event.
       * @param {FeatureClass} feature Feature.
       * @protected
       */
      addFeatureInternal(feature) {
        const featureKey = getUid(feature);
        if (!this.addToIndex_(featureKey, feature)) {
          if (this.featuresCollection_) {
            this.featuresCollection_.remove(feature);
          }
          return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
          const extent = geometry.getExtent();
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          this.nullGeometryFeatures_[featureKey] = feature;
        }
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature)
        );
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureClass} feature The feature.
       * @private
       */
      setupChangeEvents_(featureKey, feature) {
        if (feature instanceof Feature_default2) {
          return;
        }
        this.featureChangeKeys_[featureKey] = [
          listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
          listen(
            feature,
            ObjectEventType_default.PROPERTYCHANGE,
            this.handleFeatureChange_,
            this
          )
        ];
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureClass} feature The feature.
       * @return {boolean} The feature is "valid", in the sense that it is also a
       *     candidate for insertion into the Rtree.
       * @private
       */
      addToIndex_(featureKey, feature) {
        let valid = true;
        if (feature.getId() !== void 0) {
          const id = String(feature.getId());
          if (!(id in this.idIndex_)) {
            this.idIndex_[id] = feature;
          } else if (feature instanceof Feature_default2) {
            const indexedFeature = this.idIndex_[id];
            if (!(indexedFeature instanceof Feature_default2)) {
              valid = false;
            } else {
              if (!Array.isArray(indexedFeature)) {
                this.idIndex_[id] = [indexedFeature, feature];
              } else {
                indexedFeature.push(feature);
              }
            }
          } else {
            valid = false;
          }
        }
        if (valid) {
          assert(
            !(featureKey in this.uidIndex_),
            "The passed `feature` was already added to the source"
          );
          this.uidIndex_[featureKey] = feature;
        }
        return valid;
      }
      /**
       * Add a batch of features to the source.
       * @param {Array<FeatureClass>} features Features to add.
       * @api
       */
      addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
      }
      /**
       * Add features without firing a `change` event.
       * @param {Array<FeatureClass>} features Features.
       * @protected
       */
      addFeaturesInternal(features) {
        const extents = [];
        const newFeatures = [];
        const geometryFeatures = [];
        for (let i = 0, length = features.length; i < length; i++) {
          const feature = features[i];
          const featureKey = getUid(feature);
          if (this.addToIndex_(featureKey, feature)) {
            newFeatures.push(feature);
          }
        }
        for (let i = 0, length = newFeatures.length; i < length; i++) {
          const feature = newFeatures[i];
          const featureKey = getUid(feature);
          this.setupChangeEvents_(featureKey, feature);
          const geometry = feature.getGeometry();
          if (geometry) {
            const extent = geometry.getExtent();
            extents.push(extent);
            geometryFeatures.push(feature);
          } else {
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.load(extents, geometryFeatures);
        }
        if (this.hasListener(VectorEventType_default.ADDFEATURE)) {
          for (let i = 0, length = newFeatures.length; i < length; i++) {
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i])
            );
          }
        }
      }
      /**
       * @param {!Collection<FeatureClass>} collection Collection.
       * @private
       */
      bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener(
          VectorEventType_default.ADDFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.push(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        this.addEventListener(
          VectorEventType_default.REMOVEFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.remove(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.ADD,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.addFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.REMOVE,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.removeFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        this.featuresCollection_ = collection;
      }
      /**
       * Remove all features from the source.
       * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
       * @api
       */
      clear(fast) {
        if (fast) {
          for (const featureId in this.featureChangeKeys_) {
            const keys = this.featureChangeKeys_[featureId];
            keys.forEach(unlistenByKey);
          }
          if (!this.featuresCollection_) {
            this.featureChangeKeys_ = {};
            this.idIndex_ = {};
            this.uidIndex_ = {};
          }
        } else {
          if (this.featuresRtree_) {
            const removeAndIgnoreReturn = (feature) => {
              this.removeFeatureInternal(feature);
            };
            this.featuresRtree_.forEach(removeAndIgnoreReturn);
            for (const id in this.nullGeometryFeatures_) {
              this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
            }
          }
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.clear();
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.clear();
        }
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
      }
      /**
       * Iterate through all features on the source, calling the provided callback
       * with each one.  If the callback returns any "truthy" value, iteration will
       * stop and the function will return the same value.
       * Note: this function only iterate through the feature that have a defined geometry.
       *
       * @param {function(FeatureClass): T} callback Called with each feature
       *     on the source.  Return a truthy value to stop iteration.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeature(callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEach(callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometries contain the provided
       * coordinate, calling the callback with each feature.  If the callback returns
       * a "truthy" value, iteration will stop and the function will return the same
       * value.
       *
       * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
       * called for all features.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureClass): T} callback Called with each feature
       *     whose goemetry contains the provided coordinate.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       */
      forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
        return this.forEachFeatureInExtent(extent, function(feature) {
          const geometry = feature.getGeometry();
          if (geometry instanceof Feature_default2 || geometry.intersectsCoordinate(coordinate)) {
            return callback(feature);
          }
          return void 0;
        });
      }
      /**
       * Iterate through all features whose bounding box intersects the provided
       * extent (note that the feature's geometry may not intersect the extent),
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you are interested in features whose geometry intersects an extent, call
       * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
       *
       * When `useSpatialIndex` is set to false, this method will loop through all
       * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureClass): T} callback Called with each feature
       *     whose bounding box intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEachInExtent(extent, callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometry intersects the provided extent,
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you only want to test for bounding box intersection, call the
       * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureClass): T} callback Called with each feature
       *     whose geometry intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(
          extent,
          /**
           * @param {FeatureClass} feature Feature.
           * @return {T|undefined} The return value from the last call to the callback.
           */
          function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof Feature_default2 || geometry.intersectsExtent(extent)) {
              const result = callback(feature);
              if (result) {
                return result;
              }
            }
          }
        );
      }
      /**
       * Get the features collection associated with this source. Will be `null`
       * unless the source was configured with `useSpatialIndex` set to `false`, or
       * with an {@link module:ol/Collection~Collection} as `features`.
       * @return {Collection<FeatureClass>|null} The collection of features.
       * @api
       */
      getFeaturesCollection() {
        return this.featuresCollection_;
      }
      /**
       * Get a snapshot of the features currently on the source in random order. The returned array
       * is a copy, the features are references to the features in the source.
       * @return {Array<FeatureClass>} Features.
       * @api
       */
      getFeatures() {
        let features;
        if (this.featuresCollection_) {
          features = this.featuresCollection_.getArray().slice(0);
        } else if (this.featuresRtree_) {
          features = this.featuresRtree_.getAll();
          if (!isEmpty(this.nullGeometryFeatures_)) {
            extend(features, Object.values(this.nullGeometryFeatures_));
          }
        }
        return features;
      }
      /**
       * Get all features whose geometry intersects the provided coordinate.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {Array<import("../Feature.js").default>} Features.
       * @api
       */
      getFeaturesAtCoordinate(coordinate) {
        const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
          features.push(feature);
        });
        return features;
      }
      /**
       * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
       * all features intersecting the given extent in random order (so it may include
       * features whose geometries do not intersect the extent).
       *
       * When `useSpatialIndex` is set to false, this method will return all
       * features.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {import("../proj/Projection.js").default} [projection] Include features
       * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
       * @return {Array<FeatureClass>} Features.
       * @api
       */
      getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
          const multiWorld = projection && projection.canWrapX() && this.getWrapX();
          if (!multiWorld) {
            return this.featuresRtree_.getInExtent(extent);
          }
          const extents = wrapAndSliceX(extent, projection);
          return [].concat(
            ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
          );
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getArray().slice(0);
        }
        return [];
      }
      /**
       * Get the closest feature to the provided coordinate.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false` and the features in this source are of type
       * {@link module:ol/Feature~Feature}.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureClass):boolean} [filter] Feature filter function.
       *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
       *     and it should return a boolean value. By default, no filtering is made.
       * @return {FeatureClass} Closest feature.
       * @api
       */
      getClosestFeatureToCoordinate(coordinate, filter) {
        const x = coordinate[0];
        const y = coordinate[1];
        let closestFeature = null;
        const closestPoint = [NaN, NaN];
        let minSquaredDistance = Infinity;
        const extent = [-Infinity, -Infinity, Infinity, Infinity];
        filter = filter ? filter : TRUE;
        this.featuresRtree_.forEachInExtent(
          extent,
          /**
           * @param {FeatureClass} feature Feature.
           */
          function(feature) {
            if (filter(feature)) {
              const geometry = feature.getGeometry();
              const previousMinSquaredDistance = minSquaredDistance;
              minSquaredDistance = geometry instanceof Feature_default2 ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
              if (minSquaredDistance < previousMinSquaredDistance) {
                closestFeature = feature;
                const minDistance = Math.sqrt(minSquaredDistance);
                extent[0] = x - minDistance;
                extent[1] = y - minDistance;
                extent[2] = x + minDistance;
                extent[3] = y + minDistance;
              }
            }
          }
        );
        return closestFeature;
      }
      /**
       * Get the extent of the features currently in the source.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
       *     will be created. Instead, that extent's coordinates will be overwritten.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
      }
      /**
       * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
       * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
       * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
       * `GeometryCollection` member.
       * Note that the index treats string and numeric identifiers as the same.  So
       * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
       *
       * @param {string|number} id Feature identifier.
       * @return {FeatureClass|Array<RenderFeature>|null} The feature (or `null` if not found).
       * @api
       */
      getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== void 0 ? feature : null;
      }
      /**
       * Get a feature by its internal unique identifier (using `getUid`).
       *
       * @param {string} uid Feature identifier.
       * @return {FeatureClass|null} The feature (or `null` if not found).
       */
      getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== void 0 ? feature : null;
      }
      /**
       * Get the format associated with this source.
       *
       * @return {import("../format/Feature.js").default|undefined} The feature format.
       * @api
       */
      getFormat() {
        return this.format_;
      }
      /**
       * @return {boolean} The source can have overlapping geometries.
       */
      getOverlaps() {
        return this.overlaps_;
      }
      /**
       * Get the url associated with this source.
       *
       * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
       * @api
       */
      getUrl() {
        return this.url_;
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      handleFeatureChange_(event) {
        const feature = (
          /** @type {FeatureClass} */
          event.target
        );
        const featureKey = getUid(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
          if (!(featureKey in this.nullGeometryFeatures_)) {
            if (this.featuresRtree_) {
              this.featuresRtree_.remove(feature);
            }
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        } else {
          const extent = geometry.getExtent();
          if (featureKey in this.nullGeometryFeatures_) {
            delete this.nullGeometryFeatures_[featureKey];
            if (this.featuresRtree_) {
              this.featuresRtree_.insert(extent, feature);
            }
          } else {
            if (this.featuresRtree_) {
              this.featuresRtree_.update(extent, feature);
            }
          }
        }
        const id = feature.getId();
        if (id !== void 0) {
          const sid = id.toString();
          if (this.idIndex_[sid] !== feature) {
            this.removeFromIdIndex_(feature);
            this.idIndex_[sid] = feature;
          }
        } else {
          this.removeFromIdIndex_(feature);
          this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature)
        );
      }
      /**
       * Returns true if the feature is contained within the source.
       * @param {FeatureClass} feature Feature.
       * @return {boolean} Has feature.
       * @api
       */
      hasFeature(feature) {
        const id = feature.getId();
        if (id !== void 0) {
          return id in this.idIndex_;
        }
        return getUid(feature) in this.uidIndex_;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        if (this.featuresRtree_) {
          return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getLength() === 0;
        }
        return true;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {
          const extentToLoad = extentsToLoad[i];
          const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
            extentToLoad,
            /**
             * @param {{extent: import("../extent.js").Extent}} object Object.
             * @return {boolean} Contains.
             */
            function(object) {
              return containsExtent(object.extent, extentToLoad);
            }
          );
          if (!alreadyLoaded) {
            ++this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART)
            );
            this.loader_.call(
              this,
              extentToLoad,
              resolution,
              projection,
              (features) => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(
                    VectorEventType_default.FEATURESLOADEND,
                    void 0,
                    features
                  )
                );
              },
              () => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR)
                );
              }
            );
            loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
          }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
      }
      refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
      }
      /**
       * Remove an extent from the list of loaded extents.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        let obj;
        loadedExtentsRtree.forEachInExtent(extent, function(object) {
          if (equals2(object.extent, extent)) {
            obj = object;
            return true;
          }
        });
        if (obj) {
          loadedExtentsRtree.remove(obj);
        }
      }
      /**
       * Remove a single feature from the source.  If you want to remove all features
       * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
       * instead.
       * @param {FeatureClass} feature Feature to remove.
       * @api
       */
      removeFeature(feature) {
        if (!feature) {
          return;
        }
        const featureKey = getUid(feature);
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
        }
        const result = this.removeFeatureInternal(feature);
        if (result) {
          this.changed();
        }
      }
      /**
       * Remove feature without firing a `change` event.
       * @param {FeatureClass} feature Feature.
       * @return {FeatureClass|undefined} The removed feature
       *     (or undefined if the feature was not found).
       * @protected
       */
      removeFeatureInternal(feature) {
        const featureKey = getUid(feature);
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        if (!featureChangeKeys) {
          return;
        }
        featureChangeKeys.forEach(unlistenByKey);
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== void 0) {
          delete this.idIndex_[id.toString()];
        }
        delete this.uidIndex_[featureKey];
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature)
        );
        return feature;
      }
      /**
       * Remove a feature from the id index.  Called internally when the feature id
       * may have changed.
       * @param {FeatureClass} feature The feature.
       * @return {boolean} Removed the feature from the index.
       * @private
       */
      removeFromIdIndex_(feature) {
        let removed = false;
        for (const id in this.idIndex_) {
          const indexedFeature = this.idIndex_[id];
          if (feature instanceof Feature_default2 && Array.isArray(indexedFeature) && indexedFeature.includes(feature)) {
            indexedFeature.splice(indexedFeature.indexOf(feature), 1);
          } else if (this.idIndex_[id] === feature) {
            delete this.idIndex_[id];
            removed = true;
            break;
          }
        }
        return removed;
      }
      /**
       * Set the new loader of the source. The next render cycle will use the
       * new loader.
       * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
       * @api
       */
      setLoader(loader) {
        this.loader_ = loader;
      }
      /**
       * Points the source to a new url. The next render cycle will use the new url.
       * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
       * @api
       */
      setUrl(url) {
        assert(this.format_, "`format` must be set when `url` is set");
        this.url_ = url;
        this.setLoader(xhr(url, this.format_));
      }
    };
    Vector_default2 = VectorSource;
  }
});

// node_modules/ol-geocoder/dist/ol-geocoder.js
var require_ol_geocoder = __commonJS({
  "node_modules/ol-geocoder/dist/ol-geocoder.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t((init_Control(), __toCommonJS(Control_exports)), (init_Style(), __toCommonJS(Style_exports)), (init_Icon(), __toCommonJS(Icon_exports)), (init_Vector(), __toCommonJS(Vector_exports)), (init_Vector2(), __toCommonJS(Vector_exports2)), (init_Point(), __toCommonJS(Point_exports)), (init_Feature(), __toCommonJS(Feature_exports)), (init_proj(), __toCommonJS(proj_exports))) : "function" == typeof define && define.amd ? define(["ol/control/Control", "ol/style/Style", "ol/style/Icon", "ol/layer/Vector", "ol/source/Vector", "ol/geom/Point", "ol/Feature", "ol/proj"], t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Geocoder = t(e.ol.control.Control, e.ol.style.Style, e.ol.style.Icon, e.ol.layer.Vector, e.ol.source.Vector, e.ol.geom.Point, e.ol.Feature, e.ol.proj);
    }(exports, function(e, t, s, r, n, o, a, i) {
      "use strict";
      function l(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
      }
      function c(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(s2) {
          if ("default" !== s2) {
            var r2 = Object.getOwnPropertyDescriptor(e2, s2);
            Object.defineProperty(t2, s2, r2.get ? r2 : { enumerable: true, get: function() {
              return e2[s2];
            } });
          }
        }), t2.default = e2, Object.freeze(t2);
      }
      var d = l(e), u = l(t), p = l(s), h = l(r), m = l(n), g = l(o), y = l(a), f = c(i), b = "gcd-container", v = "gcd-button-control", w = "gcd-input-query", x = "gcd-input-label", $ = "gcd-input-search", k = { namespace: "ol-geocoder", spin: "gcd-pseudo-rotate", hidden: "gcd-hidden", address: "gcd-address", country: "gcd-country", city: "gcd-city", road: "gcd-road", olControl: "ol-control", glass: { container: "gcd-gl-container", control: "gcd-gl-control", button: "gcd-gl-btn", input: "gcd-gl-input", expanded: "gcd-gl-expanded", search: "gcd-gl-search", result: "gcd-gl-result" }, inputText: { container: "gcd-txt-container", control: "gcd-txt-control", label: "gcd-txt-label", input: "gcd-txt-input", search: "gcd-txt-search", icon: "gcd-txt-glass", result: "gcd-txt-result" } }, S = { containerId: b, buttonControlId: v, inputQueryId: w, inputLabelId: x, inputSearchId: $, cssClasses: k };
      const q = Object.freeze({ __proto__: null, containerId: b, buttonControlId: v, inputQueryId: w, inputLabelId: x, inputSearchId: $, cssClasses: k, default: S }), L = "addresschosen", C = "nominatim", j = "reverse", E = "glass-button", T = "text-input", I = "osm", N = "mapquest", P = "photon", A = "bing", R = "opencage", F = { provider: I, label: "", placeholder: "Search for an address", featureStyle: null, targetType: E, lang: "en-US", limit: 5, keepOpen: false, preventDefault: false, preventPanning: false, preventMarker: false, defaultFlyResolution: 10, debug: false };
      function _(e2, t2 = "Assertion failed") {
        if (!e2) {
          if ("undefined" != typeof Error)
            throw new Error(t2);
          throw t2;
        }
      }
      function M(e2) {
        const t2 = function() {
          if ("performance" in window == 0 && (window.performance = {}), "now" in window.performance == 0) {
            let e3 = Date.now();
            performance.timing && performance.timing.navigationStart && (e3 = performance.timing.navigationStart), window.performance.now = () => Date.now() - e3;
          }
          return window.performance.now();
        }().toString(36);
        return e2 ? e2 + t2 : t2;
      }
      function O(e2) {
        return /^\d+$/u.test(e2);
      }
      function D(e2, t2, s2) {
        if (Array.isArray(e2))
          return void e2.forEach((e3) => D(e3, t2));
        const r2 = Array.isArray(t2) ? t2 : t2.split(/\s+/u);
        let n2 = r2.length;
        for (; n2--; )
          Q(e2, r2[n2]) || z(e2, r2[n2], s2);
      }
      function V(e2, t2, s2) {
        if (Array.isArray(e2))
          return void e2.forEach((e3) => V(e3, t2, s2));
        const r2 = Array.isArray(t2) ? t2 : t2.split(/\s+/u);
        let n2 = r2.length;
        for (; n2--; )
          Q(e2, r2[n2]) && H(e2, r2[n2], s2);
      }
      function Q(e2, t2) {
        return e2.classList ? e2.classList.contains(t2) : G(t2).test(e2.className);
      }
      function B(e2, t2) {
        return e2.replace(/\{\s*([\w-]+)\s*\}/gu, (e3, s2) => {
          const r2 = void 0 === t2[s2] ? "" : t2[s2];
          return String(r2).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
        });
      }
      function U(e2, t2) {
        let s2;
        if (Array.isArray(e2)) {
          if (s2 = document.createElement(e2[0]), e2[1].id && (s2.id = e2[1].id), e2[1].classname && (s2.className = e2[1].classname), e2[1].attr) {
            const { attr: t3 } = e2[1];
            if (Array.isArray(t3)) {
              let e3 = -1;
              for (; ++e3 < t3.length; )
                s2.setAttribute(t3[e3].name, t3[e3].value);
            } else
              s2.setAttribute(t3.name, t3.value);
          }
        } else
          s2 = document.createElement(e2);
        s2.innerHTML = t2;
        const r2 = document.createDocumentFragment();
        for (; s2.childNodes[0]; )
          r2.append(s2.childNodes[0]);
        return s2.append(r2), s2;
      }
      function G(e2) {
        return new RegExp(`(^|\\s+) ${e2} (\\s+|$)`, "u");
      }
      function z(e2, t2, s2) {
        e2.classList ? e2.classList.add(t2) : e2.className = `${e2.className} ${t2}`.trim(), s2 && O(s2) && window.setTimeout(() => H(e2, t2), s2);
      }
      function H(e2, t2, s2) {
        e2.classList ? e2.classList.remove(t2) : e2.className = e2.className.replace(G(t2), " ").trim(), s2 && O(s2) && window.setTimeout(() => z(e2, t2), s2);
      }
      const K = q.cssClasses;
      class J {
        constructor(e2) {
          this.options = e2, this.els = this.createControl();
        }
        createControl() {
          let e2, t2, s2;
          return this.options.targetType === T ? (t2 = `${K.namespace} ${K.inputText.container}`, e2 = U(["div", { id: q.containerId, classname: t2 }], J.input), s2 = { container: e2, control: e2.querySelector(`.${K.inputText.control}`), label: e2.querySelector(`.${K.inputText.label}`), input: e2.querySelector(`.${K.inputText.input}`), search: e2.querySelector(`.${K.inputText.search}`), result: e2.querySelector(`.${K.inputText.result}`) }, s2.label.innerHTML = this.options.label) : (t2 = `${K.namespace} ${K.glass.container}`, e2 = U(["div", { id: q.containerId, classname: t2 }], J.glass), s2 = { container: e2, control: e2.querySelector(`.${K.glass.control}`), button: e2.querySelector(`.${K.glass.button}`), input: e2.querySelector(`.${K.glass.input}`), search: e2.querySelector(`.${K.glass.search}`), result: e2.querySelector(`.${K.glass.result}`) }), s2.input.placeholder = this.options.placeholder, s2;
        }
      }
      function W(e2) {
        return new Promise((t2, s2) => {
          const r2 = function(e3, t3) {
            t3 && "object" == typeof t3 && (e3 += (/\?/u.test(e3) ? "&" : "?") + X(t3));
            return e3;
          }(e2.url, e2.data), n2 = { method: "GET", mode: "cors", credentials: "same-origin" };
          e2.jsonp ? function(e3, t3, s3) {
            const { head: r3 } = document, n3 = document.createElement("script"), o2 = `f${Math.round(Math.random() * Date.now())}`;
            n3.setAttribute("src", `${e3 + (e3.indexOf("?") > 0 ? "&" : "?") + t3}=${o2}`), window[o2] = (e4) => {
              window[o2] = void 0, setTimeout(() => r3.removeChild(n3), 0), s3(e4);
            }, r3.append(n3);
          }(r2, e2.callbackName, t2) : fetch(r2, n2).then((e3) => e3.json()).then(t2).catch(s2);
        });
      }
      function X(e2) {
        return Object.keys(e2).reduce((t2, s2) => (t2.push("object" == typeof e2[s2] ? X(e2[s2]) : `${encodeURIComponent(s2)}=${encodeURIComponent(e2[s2])}`), t2), []).join("&");
      }
      J.glass = `
  <div class="${K.glass.control} ${K.olControl}">
    <button type="button" id="${q.buttonControlId}" class="${K.glass.button}"></button>
    <input type="text" id="${q.inputQueryId}" class="${K.glass.input}" autocomplete="off" placeholder="Search ...">
    <a id="${q.inputSearchId}" class="${K.glass.search} ${K.hidden}"></a>
  </div>
  <ul class="${K.glass.result}"></ul>
`, J.input = `
  <div class="${K.inputText.control}">
    <label type="button" id="${q.inputSearchId}" class="${K.inputText.label}"></label>
    <input type="text" id="${q.inputQueryId}" class="${K.inputText.input}" autocomplete="off" placeholder="Search ...">
    <span class="${K.inputText.icon}"></span>
    <button type="button" id="${q.inputSearchId}" class="${K.inputText.search} ${K.hidden}"></button>
  </div>
  <ul class="${K.inputText.result}"></ul>
`;
      class Y {
        constructor() {
          this.settings = { url: "https://photon.komoot.io/api/", params: { q: "", limit: 10, lang: "en" }, langs: ["de", "it", "fr", "en"] };
        }
        getParameters(e2) {
          return e2.lang = e2.lang.toLowerCase(), { url: this.settings.url, params: { q: e2.query, limit: e2.limit || this.settings.params.limit, lang: this.settings.langs.includes(e2.lang) ? e2.lang : this.settings.params.lang } };
        }
        handleResponse(e2) {
          return 0 === e2.features.length ? [] : e2.features.map((e3) => ({ lon: e3.geometry.coordinates[0], lat: e3.geometry.coordinates[1], address: { name: e3.properties.name, postcode: e3.properties.postcode, city: e3.properties.city, state: e3.properties.state, country: e3.properties.country }, original: { formatted: e3.properties.name, details: e3.properties } }));
        }
      }
      class Z {
        constructor(e2) {
          this.settings = { url: "https://nominatim.openstreetmap.org/search", ...e2, params: { q: "", format: "json", addressdetails: 1, limit: 10, countrycodes: "", viewbox: "", "accept-language": "en-US" } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, format: this.settings.params.format, addressdetails: this.settings.params.addressdetails, limit: e2.limit || this.settings.params.limit, countrycodes: e2.countrycodes || this.settings.params.countrycodes, viewbox: e2.viewbox || this.settings.params.viewbox, "accept-language": e2.lang || this.settings.params["accept-language"] } };
        }
        handleResponse(e2) {
          return 0 === e2.length ? [] : e2.map((e3) => ({ lon: e3.lon, lat: e3.lat, bbox: e3.boundingbox, address: { name: e3.display_name, road: e3.address.road || "", houseNumber: e3.address.house_number || "", postcode: e3.address.postcode, city: e3.address.city || e3.address.town, state: e3.address.state, country: e3.address.country }, original: { formatted: e3.display_name, details: e3.address } }));
        }
      }
      class ee {
        constructor() {
          this.settings = { url: "https://open.mapquestapi.com/nominatim/v1/search.php", params: { q: "", key: "", format: "json", addressdetails: 1, limit: 10, countrycodes: "", "accept-language": "en-US" } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, key: e2.key, format: "json", addressdetails: 1, limit: e2.limit || this.settings.params.limit, countrycodes: e2.countrycodes || this.settings.params.countrycodes, "accept-language": e2.lang || this.settings.params["accept-language"] } };
        }
        handleResponse(e2) {
          return 0 === e2.length ? [] : e2.map((e3) => ({ lon: e3.lon, lat: e3.lat, address: { name: e3.address.neighbourhood || "", road: e3.address.road || "", postcode: e3.address.postcode, city: e3.address.city || e3.address.town, state: e3.address.state, country: e3.address.country }, original: { formatted: e3.display_name, details: e3.address } }));
        }
      }
      class te {
        constructor() {
          this.settings = { url: "https://dev.virtualearth.net/REST/v1/Locations", callbackName: "jsonp", params: { query: "", key: "", includeNeighborhood: 0, maxResults: 10 } };
        }
        getParameters(e2) {
          return { url: this.settings.url, callbackName: this.settings.callbackName, params: { query: e2.query, key: e2.key, includeNeighborhood: e2.includeNeighborhood || this.settings.params.includeNeighborhood, maxResults: e2.maxResults || this.settings.params.maxResults } };
        }
        handleResponse(e2) {
          const { resources: t2 } = e2.resourceSets[0];
          return 0 === t2.length ? [] : t2.map((e3) => ({ lon: e3.point.coordinates[1], lat: e3.point.coordinates[0], address: { name: e3.name }, original: { formatted: e3.address.formattedAddress, details: e3.address } }));
        }
      }
      class se {
        constructor() {
          this.settings = { url: "https://api.opencagedata.com/geocode/v1/json?", params: { q: "", key: "", limit: 10, countrycode: "", pretty: 1, no_annotations: 1 } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, key: e2.key, limit: e2.limit || this.settings.params.limit, countrycode: e2.countrycodes || this.settings.params.countrycodes } };
        }
        handleResponse(e2) {
          return 0 === e2.results.length ? [] : e2.results.map((e3) => ({ lon: e3.geometry.lng, lat: e3.geometry.lat, address: { name: e3.components.house_number || "", road: e3.components.road || "", postcode: e3.components.postcode, city: e3.components.city || e3.components.town, state: e3.components.state, country: e3.components.country }, original: { formatted: e3.formatted, details: e3.components } }));
        }
      }
      const re = q.cssClasses;
      class ne {
        constructor(e2, t2) {
          this.Base = e2, this.layerName = M("geocoder-layer-"), this.layer = new h.default({ name: this.layerName, source: new m.default(), displayInLayerSwitcher: false }), this.options = e2.options, this.options.provider = "string" == typeof this.options.provider ? this.options.provider.toLowerCase() : this.options.provider, this.provider = this.newProvider(), this.els = t2, this.lastQuery = "", this.container = this.els.container, this.registeredListeners = { mapClick: false }, this.setListeners();
        }
        setListeners() {
          const e2 = (e3) => {
            e3.stopPropagation(), Q(this.els.control, re.glass.expanded) ? this.collapse() : this.expand();
          };
          this.els.input.addEventListener("keypress", (e3) => {
            const t2 = e3.target.value.trim();
            (e3.key ? "Enter" === e3.key : e3.which ? 13 === e3.which : !!e3.keyCode && 13 === e3.keyCode) && (e3.preventDefault(), this.query(t2));
          }, false), this.els.input.addEventListener("click", (e3) => e3.stopPropagation(), false), this.els.input.addEventListener("input", (e3) => {
            0 !== e3.target.value.trim().length ? V(this.els.search, re.hidden) : D(this.els.search, re.hidden);
          }, false), this.els.search.addEventListener("click", () => {
            this.els.input.focus(), this.query(this.els.input.value);
          }, false), this.options.targetType === E && this.els.button.addEventListener("click", e2, false);
        }
        query(e2) {
          this.provider || (this.provider = this.newProvider());
          const t2 = this.provider.getParameters({ query: e2, key: this.options.key, lang: this.options.lang, countrycodes: this.options.countrycodes, viewbox: this.options.viewbox, limit: this.options.limit });
          if (this.lastQuery === e2 && this.els.result.firstChild)
            return;
          this.lastQuery = e2, this.clearResults(), D(this.els.search, re.spin);
          const s2 = { url: t2.url, data: t2.params };
          t2.callbackName && (s2.jsonp = true, s2.callbackName = t2.callbackName), W(s2).then((e3) => {
            this.options.debug && console.info(e3), V(this.els.search, re.spin);
            const t3 = this.provider.handleResponse(e3);
            t3 && (this.createList(t3), this.listenMapClick());
          }).catch(() => {
            V(this.els.search, re.spin);
            const e3 = U("li", "<h5>Error! No internet connection?</h5>");
            this.els.result.append(e3);
          });
        }
        createList(e2) {
          const t2 = this.els.result;
          e2.forEach((s2) => {
            let r2;
            if (this.options.provider === I)
              r2 = `<span class="${re.road}">${s2.address.name}</span>`;
            else
              r2 = this.addressTemplate(s2.address);
            if (1 == e2.length)
              this.chosen(s2, r2, s2.address, s2.original);
            else {
              const e3 = U("li", `<a href="#">${r2}</a>`);
              e3.addEventListener("click", (e4) => {
                e4.preventDefault(), this.chosen(s2, r2, s2.address, s2.original);
              }, false), t2.append(e3);
            }
          });
        }
        chosen(e2, t2, s2, r2) {
          const n2 = this.Base.getMap(), o2 = [Number.parseFloat(e2.lon), Number.parseFloat(e2.lat)], a2 = n2.getView().getProjection(), i2 = f.transform(o2, "EPSG:4326", a2);
          let { bbox: l2 } = e2;
          l2 && (l2 = f.transformExtent([parseFloat(l2[2]), parseFloat(l2[0]), parseFloat(l2[3]), parseFloat(l2[1])], "EPSG:4326", a2));
          const c2 = { formatted: t2, details: s2, original: r2 };
          if (false === this.options.keepOpen && this.clearResults(true), true === this.options.preventDefault || true === this.options.preventMarker)
            this.Base.dispatchEvent({ type: L, address: c2, coordinate: i2, bbox: l2, place: e2 });
          else {
            const t3 = this.createFeature(i2, c2);
            this.Base.dispatchEvent({ type: L, address: c2, feature: t3, coordinate: i2, bbox: l2, place: e2 });
          }
          true !== this.options.preventDefault && true !== this.options.preventPanning && (l2 ? n2.getView().fit(l2, { duration: 500 }) : n2.getView().animate({ center: i2, resolution: this.options.defaultFlyResolution, duration: 500 }));
        }
        createFeature(e2) {
          const t2 = new y.default(new g.default(e2));
          return this.addLayer(), t2.setStyle(this.options.featureStyle), t2.setId(M("geocoder-ft-")), this.getSource().addFeature(t2), t2;
        }
        addressTemplate(e2) {
          const t2 = [];
          return e2.name && t2.push(['<span class="', re.road, '">{name}</span>'].join("")), (e2.road || e2.building || e2.house_number) && t2.push(['<span class="', re.road, '">{building} {road} {house_number}</span>'].join("")), (e2.city || e2.town || e2.village) && t2.push(['<span class="', re.city, '">{postcode} {city} {town} {village}</span>'].join("")), (e2.state || e2.country) && t2.push(['<span class="', re.country, '">{state} {country}</span>'].join("")), B(t2.join("<br>"), e2);
        }
        newProvider() {
          switch (this.options.provider) {
            case I:
              return new Z(this.options);
            case N:
              return new ee();
            case P:
              return new Y();
            case A:
              return new te();
            case R:
              return new se();
            default:
              return this.options.provider;
          }
        }
        expand() {
          V(this.els.input, re.spin), D(this.els.control, re.glass.expanded), window.setTimeout(() => this.els.input.focus(), 100), this.listenMapClick();
        }
        collapse() {
          this.els.input.value = "", this.els.input.blur(), D(this.els.search, re.hidden), V(this.els.control, re.glass.expanded), this.clearResults();
        }
        listenMapClick() {
          if (this.registeredListeners.mapClick)
            return;
          const e2 = this, t2 = this.Base.getMap().getTargetElement();
          this.registeredListeners.mapClick = true, t2.addEventListener("click", { handleEvent(s2) {
            e2.clearResults(true), t2.removeEventListener(s2.type, this, false), e2.registeredListeners.mapClick = false;
          } }, false);
        }
        clearResults(e2) {
          e2 && this.options.targetType === E ? this.collapse() : function(e3) {
            for (; e3.firstChild; )
              e3.firstChild.remove();
          }(this.els.result);
        }
        getSource() {
          return this.layer.getSource();
        }
        addLayer() {
          let e2 = false;
          const t2 = this.Base.getMap();
          t2.getLayers().forEach((t3) => {
            t3 === this.layer && (e2 = true);
          }), e2 || t2.addLayer(this.layer);
        }
      }
      class oe extends d.default {
        constructor(e2 = C, t2) {
          _("string" == typeof e2, "@param `type` should be string!"), _(e2 === C || e2 === j, `@param 'type' should be '${C}'
      or '${j}'!`);
          const s2 = { ...F, featureStyle: [new u.default({ image: new p.default({ scale: 0.7, src: "//cdn.rawgit.com/jonataswalker/map-utils/master/images/marker.png" }) })], ...t2 };
          let r2, n2;
          const o2 = new J(s2);
          if (e2 === C && (r2 = o2.els.container), super({ element: r2, ...s2 }), !(this instanceof oe))
            return new oe();
          this.options = s2, this.container = r2, e2 === C && (n2 = new ne(this, o2.els), this.layer = n2.layer);
        }
        getLayer() {
          return this.layer;
        }
        getSource() {
          return this.getLayer().getSource();
        }
        setProvider(e2) {
          this.options.provider = e2;
        }
        setProviderKey(e2) {
          this.options.key = e2;
        }
      }
      return oe;
    });
  }
});

// node_modules/ol/Map.js
init_Object();
init_Collection();
init_CollectionEventType();

// node_modules/ol/renderer/Map.js
init_Disposable();
init_functions();
init_util();
init_transform();
init_extent();
init_IconImageCache();
init_Layer();
init_coordinate();
var MapRenderer = class extends Disposable_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();
    this.map_ = map;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX2(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = (
      /** @type {Array<HitMatch<T>>} */
      []
    );
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates2[0] + offsets[i][0];
            tmpCoord[1] = coordinates2[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback2,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => m.distanceSq += i * order);
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      TRUE,
      this,
      layerFilter,
      thisArg
    );
    return hasFeature !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  flushDeclutterItems(frameState) {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
};
function expireIconCache(map, frameState) {
  shared.expire();
}
var Map_default = MapRenderer;

// node_modules/ol/renderer/Composite.js
init_ObjectEventType();
init_Event2();
init_EventType2();
init_css();
init_canvas();
init_Layer();
init_events();
init_dom();
var CompositeMapRenderer = class extends Map_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(
      checkedFonts,
      ObjectEventType_default.PROPERTYCHANGE,
      map.redrawText.bind(map)
    );
    this.element_ = document.createElement("div");
    const style = this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
    this.declutterLayers_ = [];
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new Event_default2(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(EventType_default2.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
      return a.zIndex - b.zIndex;
    });
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const declutterLayers = this.declutterLayers_;
    declutterLayers.length = 0;
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      if ("getDeclutter" in layer) {
        declutterLayers.push(
          /** @type {import("../layer/BaseVector.js").default} */
          layer
        );
      }
    }
    this.flushDeclutterItems(frameState);
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(EventType_default2.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  flushDeclutterItems(frameState) {
    const layers = this.declutterLayers_;
    for (let i = layers.length - 1; i >= 0; --i) {
      layers[i].renderDeclutter(frameState);
    }
    layers.length = 0;
  }
};
var Composite_default = CompositeMapRenderer;

// node_modules/ol/Map.js
init_EventType();
init_Layer();

// node_modules/ol/layer/Group.js
init_Base();
init_Collection();
init_CollectionEventType();
init_Event();
init_EventType();
init_ObjectEventType();
init_asserts();
init_obj();
init_extent();
init_util();
init_events();
var GroupEvent = class extends Event_default {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
};
var Property2 = {
  LAYERS: "layers"
};
var LayerGroup = class _LayerGroup extends Base_default {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = (
      /** @type {Options} */
      Object.assign({}, options)
    );
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property2.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection_default(layers.slice(), { unique: true });
      } else {
        assert(
          typeof /** @type {?} */
          layers.getArray === "function",
          "Expected `layers` to be an array or a `Collection`"
        );
      }
    } else {
      layers = new Collection_default(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
      listen(layers, CollectionEventType_default.REMOVE, this.handleLayersRemove_, this)
    );
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(
        layer,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof _LayerGroup) {
      listenerKeys.push(
        listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
        listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
      );
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Property2.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
      }
    }
    this.set(Property2.LAYERS, layers);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
};
var Group_default = LayerGroup;

// node_modules/ol/MapEvent.js
init_Event();
var MapEvent = class extends Event_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
};
var MapEvent_default = MapEvent;

// node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent = class extends MapEvent_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
};
var MapBrowserEvent_default = MapBrowserEvent;

// node_modules/ol/MapBrowserEventHandler.js
init_EventType();

// node_modules/ol/MapBrowserEventType.js
init_EventType();
var MapBrowserEventType_default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: EventType_default.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: EventType_default.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/pointer/EventType.js
var EventType_default3 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/MapBrowserEventHandler.js
init_Target();
init_has();
init_events();
var MapBrowserEventHandler = class extends Target_default {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(
      element,
      EventType_default3.POINTERDOWN,
      this.handlePointerDown_,
      this
    );
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(
      element,
      EventType_default3.POINTERMOVE,
      this.relayMoveEvent_,
      this
    );
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_,
      PASSIVE_EVENT_LISTENERS ? { passive: false } : false
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent_default(
          MapBrowserEventType_default.SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERUP,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERDOWN,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, "target", {
      writable: false,
      value: pointerEvent.target
    });
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(
          doc,
          MapBrowserEventType_default.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        listen(
          this.element_,
          MapBrowserEventType_default.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          listen(
            this.element_.getRootNode(),
            MapBrowserEventType_default.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_
    );
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
};
var MapBrowserEventHandler_default = MapBrowserEventHandler;

// node_modules/ol/Map.js
init_MapEventType();

// node_modules/ol/MapProperty.js
var MapProperty_default = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};

// node_modules/ol/Map.js
init_ObjectEventType();
init_EventType2();

// node_modules/ol/TileQueue.js
init_EventType();

// node_modules/ol/structs/PriorityQueue.js
init_asserts();
init_obj();
var DROP = Infinity;
var PriorityQueue = class {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = /** @type {T} */
      elements.pop();
      priorities[0] = /** @type {number} */
      priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    assert(
      !(this.keyFunction_(element) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return index - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;
    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];
    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
};
var PriorityQueue_default = PriorityQueue;

// node_modules/ol/TileState.js
var TileState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/TileQueue.js
var TileQueue = class extends PriorityQueue_default {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (
          /** @type {import("./Tile.js").default} */
          element[0].getKey()
        );
      }
    );
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile = element[0];
      tile.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("./Tile.js").default} */
      event.target
    );
    const state = tile.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
      if (state !== TileState_default.ERROR) {
        tile.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    let state, tile, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile = /** @type {import("./Tile.js").default} */
      this.dequeue()[0];
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
};
var TileQueue_default = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

// node_modules/ol/Map.js
init_View();
init_ViewHint();
init_has();
init_functions();
init_transform();
init_asserts();
init_extent();

// node_modules/ol/control/Attribution.js
init_Control();
init_EventType();
init_css();
init_array();
init_dom();
var Attribution = class extends Control_default {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const visibleAttributions = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((layer) => layer.getAttributions(frameState))
      )
    );
    const collapsible = !this.getMap().getAllLayers().some(
      (layer) => layer.getSource() && layer.getSource().getAttributionsCollapsible() === false
    );
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = this.collectSourceAttributions_(frameState);
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
};
var Attribution_default = Attribution;

// node_modules/ol/control/defaults.js
init_Collection();

// node_modules/ol/control/Rotate.js
init_Control();
init_EventType();
init_css();
init_easing();
var Rotate = class extends Control_default {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "\u21E7";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
};
var Rotate_default = Rotate;

// node_modules/ol/control/Zoom.js
init_Control();
init_EventType();
init_css();
init_easing();
var Zoom = class extends Control_default {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
    );
    inElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, delta),
      false
    );
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );
    outElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
};
var Zoom_default = Zoom;

// node_modules/ol/control/defaults.js
function defaults(options) {
  options = options ? options : {};
  const controls = new Collection_default();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom_default(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate_default(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution_default(options.attributionOptions));
  }
  return controls;
}

// node_modules/ol/interaction/defaults.js
init_Collection();

// node_modules/ol/interaction/Interaction.js
init_Object();

// node_modules/ol/interaction/Property.js
var Property_default2 = {
  ACTIVE: "active"
};

// node_modules/ol/interaction/Interaction.js
init_easing();
var Interaction = class extends Object_default {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Property_default2.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(Property_default2.ACTIVE, active);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
};
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== void 0 ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration !== void 0 ? duration : 250,
    easing: easeOut
  });
}
var Interaction_default = Interaction;

// node_modules/ol/interaction/DoubleClickZoom.js
var DoubleClickZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
      const browserEvent = (
        /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
};
var DoubleClickZoom_default = DoubleClickZoom;

// node_modules/ol/interaction/Pointer.js
var PointerInteraction = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
};
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return { clientX: clientX / length, clientY: clientY / length };
}
var Pointer_default = PointerInteraction;

// node_modules/ol/interaction/DragPan.js
init_functions();

// node_modules/ol/events/condition.js
init_functions();
init_has();
init_asserts();
function all(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
var altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
var focusWithTabindex = function(event) {
  return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
};
var always = TRUE;
var mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
var noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKey = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  const tagName = (
    /** @type {Element} */
    originalEvent.target.tagName
  );
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};
var mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.pointerType == "mouse";
};
var primaryAction = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

// node_modules/ol/interaction/DragPan.js
init_easing();
init_coordinate();
var DragPan = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid2 = map.getEventPixel(centroid(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid2[0], centroid2[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid2[0],
          centroid2[1] - this.lastCentroid[1]
        ];
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        scale(delta, view.getResolution());
        rotate(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid2;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
};
var DragPan_default = DragPan;

// node_modules/ol/interaction/DragRotate.js
init_functions();
init_rotationconstraint();
var DragRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
};
var DragRotate_default = DragRotate;

// node_modules/ol/interaction/DragBox.js
init_Event();

// node_modules/ol/render/Box.js
init_Disposable();
init_Polygon();
var RenderBox = class extends Disposable_default {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon_default([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
};
var Box_default = RenderBox;

// node_modules/ol/interaction/DragBox.js
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
};
var DragBox = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ? options : {};
    this.box_ = new Box_default(options.className || "ol-dragbox");
    this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ? options.condition : mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    this.box_.setMap(null);
    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
  }
};
var DragBox_default = DragBox;

// node_modules/ol/interaction/DragZoom.js
init_easing();
var DragZoom = class extends DragBox_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = (
      /** @type {!import("../View.js").default} */
      map.getView()
    );
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
};
var DragZoom_default = DragZoom;

// node_modules/ol/interaction/KeyboardPan.js
init_EventType();

// node_modules/ol/events/Key.js
var Key_default = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};

// node_modules/ol/interaction/KeyboardPan.js
init_coordinate();
var KeyboardPan = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key == Key_default.DOWN || key == Key_default.LEFT || key == Key_default.RIGHT || key == Key_default.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (key == Key_default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == Key_default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == Key_default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardPan_default = KeyboardPan;

// node_modules/ol/interaction/KeyboardZoom.js
init_EventType();
var KeyboardZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
        const map = mapBrowserEvent.map;
        const delta = key === "+" ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardZoom_default = KeyboardZoom;

// node_modules/ol/Kinetic.js
var Kinetic = class {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
};
var Kinetic_default = Kinetic;

// node_modules/ol/interaction/MouseWheelZoom.js
init_EventType();
init_has();
init_math();
var MouseWheelZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always;
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType_default.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = (
      /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }
    let delta;
    if (mapBrowserEvent.type == EventType_default.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );
    return false;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
};
var MouseWheelZoom_default = MouseWheelZoom;

// node_modules/ol/interaction/PinchRotate.js
init_functions();
init_rotationconstraint();
var PinchRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchRotate_default = PinchRotate;

// node_modules/ol/interaction/PinchZoom.js
init_functions();
var PinchZoom = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchZoom_default = PinchZoom;

// node_modules/ol/interaction/defaults.js
function defaults2(options) {
  options = options ? options : {};
  const interactions = new Collection_default();
  const kinetic = new Kinetic_default(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate_default());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new DoubleClickZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new DragPan_default({
        onFocusOnly: options.onFocusOnly,
        kinetic
      })
    );
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate_default());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new PinchZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan_default());
    interactions.push(
      new KeyboardZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new MouseWheelZoom_default({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      })
    );
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new DragZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  return interactions;
}

// node_modules/ol/Map.js
init_array();
init_proj();
init_util();
init_size();
init_events();
init_dom();
init_console();
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof Group_default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof Group_default) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
var Map = class extends Object_default {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create();
    this.pixelToCoordinateTransform_ = create();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.targetElement_ = null;
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
    this.controls = optionsInternal.controls || defaults();
    this.interactions = optionsInternal.interactions || defaults2({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue_default(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );
    this.addChangeListener(
      MapProperty_default.LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(MapProperty_default.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty_default.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty_default.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View_default)) {
      options.view.then(function(viewOptions) {
        map.setView(new View_default(viewOptions));
      });
    }
    this.controls.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.controls.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );
    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      }
    );
    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      }
    );
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function(feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof Group_default) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in event ? (
        /** @type {TouchEvent} */
        event.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        event
      )
    );
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(MapProperty_default.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(MapProperty_default.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection_default) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(MapProperty_default.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(MapProperty_default.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(
      this.frameState_,
      tile,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = (
      /** @type {PointerEvent} */
      mapBrowserEvent.originalEvent
    );
    const eventType = originalEvent.type;
    if (eventType === EventType_default3.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = (
        /** @type {Node} */
        originalEvent.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(EventType_default2.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            EventType_default2.RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.LOADSTART, this, frameState)
        );
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      removeNode(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(void 0);
    }
    const target = this.getTarget();
    const targetElement = typeof target === "string" ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new Composite_default(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(
        this,
        this.moveTolerance_
      );
      for (const key in MapBrowserEventType_default) {
        this.mapBrowserEventHandler_.addEventListener(
          MapBrowserEventType_default[key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
      const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        listen(
          keyboardEventTarget,
          EventType_default.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        listen(
          keyboardEventTarget,
          EventType_default.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_(this.getSize());
      this.viewPropertyListenerKey_ = listen(
        view,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = listen(
        view,
        EventType_default.CHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      view.resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType_default.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  /**
   * This method is meant to be called in a layer's `prerender` listener. It causes all collected
   * declutter items to be decluttered and rendered on the map immediately. This is useful for
   * layers that need to appear entirely above the decluttered items of layers lower in the layer
   * stack.
   * @api
   */
  flushDeclutterItems() {
    const frameState = this.frameState_;
    if (!frameState) {
      return;
    }
    this.renderer_.flushDeclutterItems(frameState);
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: getForViewAndSize(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty2(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.MOVEEND, this, frameState)
        );
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
    this.renderComplete_ = this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default2.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty_default.LAYERGROUP, layerGroup);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(MapProperty_default.SIZE, size);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(MapProperty_default.TARGET, target);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof View_default) {
      this.set(MapProperty_default.VIEW, view);
      return;
    }
    this.set(MapProperty_default.VIEW, new View_default());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View_default(viewOptions));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          warn(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }
    const oldSize = this.getSize();
    if (size && (!oldSize || !equals(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_(size);
    }
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(size) {
    const view = this.getView();
    if (view) {
      view.setViewportSize(size);
    }
  }
};
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values = {};
  const layerGroup = options.layers && typeof /** @type {?} */
  options.layers.getLayers === "function" ? (
    /** @type {LayerGroup} */
    options.layers
  ) : new Group_default({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      options.layers
    )
  });
  values[MapProperty_default.LAYERGROUP] = layerGroup;
  values[MapProperty_default.TARGET] = options.target;
  values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection_default(options.controls.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.controls.getArray === "function",
        "Expected `controls` to be an array or an `ol/Collection.js`"
      );
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection_default(options.interactions.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.interactions.getArray === "function",
        "Expected `interactions` to be an array or an `ol/Collection.js`"
      );
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection_default(options.overlays.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.overlays.getArray === "function",
        "Expected `overlays` to be an array or an `ol/Collection.js`"
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection_default();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
var Map_default2 = Map;

// node_modules/ol/control/MousePosition.js
init_Control();
init_proj();
init_events();
init_coordinate();
var PROJECTION = "projection";
var COORDINATE_FORMAT = "coordinateFormat";
var MousePosition = class extends Control_default {
  /**
   * @param {Options} [options] Mouse position options.
   */
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
    super({
      element,
      render: options.render,
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);
    if (options.coordinateFormat) {
      this.setCoordinateFormat(options.coordinateFormat);
    }
    if (options.projection) {
      this.setProjection(options.projection);
    }
    this.renderOnMouseOut_ = options.placeholder !== void 0;
    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : "&#160;";
    this.renderedHTML_ = element.innerHTML;
    this.mapProjection_ = null;
    this.transform_ = null;
    this.wrapX_ = options.wrapX === false ? false : true;
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */
  getCoordinateFormat() {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(COORDINATE_FORMAT)
    );
  }
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(PROJECTION)
    );
  }
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */
  handleMouseMove(event) {
    const map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  }
  /**
   * @param {Event} event Browser event.
   * @protected
   */
  handleMouseOut(event) {
    this.updateHTML_(null);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    super.setMap(map);
    if (map) {
      const viewport = map.getViewport();
      this.listenerKeys.push(
        listen(viewport, EventType_default3.POINTERMOVE, this.handleMouseMove, this)
      );
      if (this.renderOnMouseOut_) {
        this.listenerKeys.push(
          listen(viewport, EventType_default3.POINTEROUT, this.handleMouseOut, this)
        );
      }
      this.updateHTML_(null);
    }
  }
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */
  setCoordinateFormat(format2) {
    this.set(COORDINATE_FORMAT, format2);
  }
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  setProjection(projection) {
    this.set(PROJECTION, get3(projection));
  }
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */
  updateHTML_(pixel) {
    let html = this.placeholder_;
    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        const projection = this.getProjection();
        if (projection) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            projection
          );
        } else {
          this.transform_ = identityTransform;
        }
      }
      const map = this.getMap();
      const coordinate = map.getCoordinateFromPixelInternal(pixel);
      if (coordinate) {
        const userProjection2 = getUserProjection();
        if (userProjection2) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            userProjection2
          );
        }
        this.transform_(coordinate, coordinate);
        if (this.wrapX_) {
          const projection = userProjection2 || this.getProjection() || this.mapProjection_;
          wrapX2(coordinate, projection);
        }
        const coordinateFormat = this.getCoordinateFormat();
        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }
    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  }
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  }
};
var MousePosition_default = MousePosition;

// node_modules/ol/source/TileImage.js
init_EventType();

// node_modules/ol/Tile.js
init_Target();
init_EventType();
init_util();
init_easing();
var Tile = class extends Target_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.interimTile = null;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === TileState_default.ERROR) {
      this.setState(TileState_default.EMPTY);
    }
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    let tile = this.interimTile;
    if (!tile) {
      return this;
    }
    do {
      if (tile.getState() == TileState_default.LOADED) {
        this.transition_ = 0;
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    let tile = this.interimTile;
    if (!tile) {
      return;
    }
    let prev = this;
    do {
      if (tile.getState() == TileState_default.LOADED) {
        tile.interimTile = null;
        break;
      }
      if (tile.getState() == TileState_default.LOADING) {
        prev = tile;
      } else if (tile.getState() == TileState_default.IDLE) {
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== TileState_default.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    abstract();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }
    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }
    const delta = time - start + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
};
var Tile_default = Tile;

// node_modules/ol/ImageTile.js
init_dom();
init_Image();
var ImageTile = class extends Tile_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = TileState_default.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = TileState_default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    if (image.naturalWidth && image.naturalHeight) {
      this.state = TileState_default.LOADED;
    } else {
      this.state = TileState_default.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    if (this.state == TileState_default.ERROR) {
      this.state = TileState_default.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
};
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile_default = ImageTile;

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD = 0.5;

// node_modules/ol/reproj/Tile.js
init_EventType();

// node_modules/ol/reproj/Triangulation.js
init_extent();
init_proj();
init_math();
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = class {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c) {
      const key = c[0] + "/" + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
        )
      )
    ) : 0);
    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        ) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = (
      /** @type {number} */
      this.sourceWorldWidth_
    );
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a, b, c, d]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = createEmpty();
    this.triangles_.forEach(function(triangle, i, arr) {
      const src = triangle.source;
      extendCoordinate(extent, src[0]);
      extendCoordinate(extent, src[1]);
      extendCoordinate(extent, src[2]);
    });
    return extent;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
};
var Triangulation_default = Triangulation;

// node_modules/ol/reproj.js
init_extent();
init_dom();
init_proj();
init_math();
var brokenDiagonalRendering_;
var canvasPool = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend2(sourceDataExtent, src.extent);
  });
  let stitchContext;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    const canvasWidthInUnits = getWidth(sourceDataExtent);
    const canvasHeightInUnits = getHeight(sourceDataExtent);
    stitchContext = createCanvasContext2D(
      Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
      Math.round(pixelRatio * canvasHeightInUnits / sourceResolution),
      canvasPool
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    const stitchScale = pixelRatio / sourceResolution;
    sources.forEach(function(src, i, arr) {
      const xPos = src.extent[0] - sourceDataExtent[0];
      const yPos = -(src.extent[3] - sourceDataExtent[3]);
      const srcWidth = getWidth(src.extent);
      const srcHeight = getHeight(src.extent);
      if (src.image.width > 0 && src.image.height > 0) {
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          xPos * stitchScale,
          yPos * stitchScale,
          srcWidth * stitchScale,
          srcHeight * stitchScale
        );
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(
        sourceResolution / pixelRatio,
        -sourceResolution / pixelRatio
      );
    } else {
      const source2 = sources[0];
      const extent = source2.extent;
      image = source2.image;
      context.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}

// node_modules/ol/reproj/Tile.js
init_math();
init_extent();
init_events();
init_dom();
var ReprojTile = class extends Tile_default {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
    super(tileCoord, TileState_default.IDLE, options);
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState_default.EMPTY;
    } else {
      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent,
        this.sourceZ_
      );
      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this.sourceTiles_.push(tile);
          }
        }
      }
      if (this.sourceTiles_.length === 0) {
        this.state = TileState_default.EMPTY;
      }
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((tile) => {
      if (tile && tile.getState() == TileState_default.LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState_default.ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = render(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );
      this.state = TileState_default.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach((tile) => {
        const state = tile.getState();
        if (state == TileState_default.IDLE || state == TileState_default.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(
            tile,
            EventType_default.CHANGE,
            function(e) {
              const state2 = tile.getState();
              if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
                unlistenByKey(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            },
            this
          );
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function(tile, i, arr) {
          const state = tile.getState();
          if (state == TileState_default.IDLE) {
            tile.load();
          }
        });
      }
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    if (this.canvas_) {
      releaseCanvas(this.canvas_.getContext("2d"));
      canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
};
var Tile_default2 = ReprojTile;

// node_modules/ol/structs/LRUCache.js
init_asserts();
var LRUCache = class {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */
      entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(key) {
    return this.entries_[key]?.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */
    entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    assert(
      !(key in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
};
var LRUCache_default = LRUCache;

// node_modules/ol/tilecoord.js
function createOrUpdate2(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function getKey2(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function fromKey(key) {
  return key.split("/").map(Number);
}
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}

// node_modules/ol/TileCache.js
var TileCache = class extends LRUCache_default {
  clear() {
    while (this.getCount() > 0) {
      this.pop().release();
    }
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(usedTiles) {
    while (this.canExpireCache()) {
      const tile = this.peekLast();
      if (tile.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0) {
      return;
    }
    const key = this.peekFirstKey();
    const tileCoord = fromKey(key);
    const z = tileCoord[0];
    this.forEach((tile) => {
      if (tile.tileCoord[0] !== z) {
        this.remove(getKey2(tile.tileCoord));
        tile.release();
      }
    });
  }
};
var TileCache_default = TileCache;

// node_modules/ol/source/TileEventType.js
var TileEventType_default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};

// node_modules/ol/source/Tile.js
init_Event();
init_Source();
init_util();
init_asserts();
init_proj();

// node_modules/ol/TileRange.js
var TileRange = class {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
};
function createOrUpdate3(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange_default = TileRange;

// node_modules/ol/tilegrid/TileGrid.js
init_common();
init_asserts();
init_math();
init_extent();
init_intersectsextent();
init_array();
init_size();
var tmpTileCoord = [0, 0, 0];
var DECIMALS = 5;
var TileGrid = class {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(
      isSorted(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, b) => b - a,
        true
      ),
      "`resolutions` must be sorted in descending order"
    );
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      );
    }
    const extent = options.extent;
    if (extent !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }
    assert(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    );
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      );
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    );
    this.extent_ = extent !== void 0 ? extent : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map((size, z) => {
        const tileRange = new TileRange_default(
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (x !== void 0 && y !== void 0) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = createOrUpdate3(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate3(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z === tileCoordZ) {
      return createOrUpdate3(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return createOrUpdate3(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate3(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return createOrUpdate3(minX, maxX, minY, maxY, tempTileRange);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z = this.getZForResolution(resolution);
    const scale4 = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = scale4 * (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale4 * (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate2(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate2(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    return this.fullTileRanges_[z];
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = linearFindNearest(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return clamp(z, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
};
var TileGrid_default = TileGrid;

// node_modules/ol/tilegrid.js
init_common();
init_proj();
init_extent();
init_size();
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX3(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options) {
  const xyzOptions = options || {};
  const extent = xyzOptions.extent || get3("EPSG:3857").getExtent();
  const gridOptions = {
    extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    )
  };
  return new TileGrid_default(gridOptions);
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get3(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }
  return extent;
}

// node_modules/ol/source/Tile.js
init_size();
var TileSource = class extends Source_default {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tileCache = new TileCache_default(options.cacheSize || 0);
    this.tmpSize = [0, 0];
    this.key_ = options.key || "";
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(projection, z, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }
    let covered = true;
    let tile, tileCoordKey, loaded;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = getKeyZXY(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = /** @type {!import("../Tile.js").default} */
          tileCache.get(tileCoordKey);
          loaded = tile.getState() === TileState_default.LOADED;
          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    assert(
      sourceProjection === null || equivalent(sourceProjection, projection),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    );
    return this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale3(tileSize, tilePixelRatio, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX3(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear();
    super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(z, x, y, projection) {
  }
};
var TileSourceEvent = class extends Event_default {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile) {
    super(type);
    this.tile = tile;
  }
};
var Tile_default3 = TileSource;

// node_modules/ol/tileurlfunction.js
init_math();
function createFromTemplate(template, tileGrid) {
  const zRegEx = /\{z\}/g;
  const xRegEx = /\{x\}/g;
  const yRegEx = /\{y\}/g;
  const dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
        const z = tileCoord[0];
        const range = tileGrid.getFullTileRange(z);
        if (!range) {
          throw new Error(
            "The {-y} placeholder requires a tile grid with extent"
          );
        }
        const y = range.getHeight() - tileCoord[2] - 1;
        return y.toString();
      });
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h = hash(tileCoord);
      const index = modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

// node_modules/ol/source/UrlTile.js
init_util();
var UrlTile = class _UrlTile extends Tile_default3 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === _UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("../Tile.js").default} */
      event.target
    );
    const uid = getUid(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == TileState_default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType_default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile));
    }
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(z, x, y) {
    const tileCoordKey = getKeyZXY(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  }
};
var UrlTile_default = UrlTile;

// node_modules/ol/source/TileImage.js
init_proj();
init_util();
var TileImage = class extends UrlTile_default {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile_default;
    this.tileCacheForProjection = {};
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache()) {
      return true;
    }
    for (const key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(
      this.tileCache == usedTileCache ? usedTiles : {}
    );
    for (const id in this.tileCacheForProjection) {
      const tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return false;
    }
    return super.getOpaque(projection);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new TileCache_default(
        this.tileCache.highWaterMark
      );
    }
    return this.tileCacheForProjection[projKey];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
      tileUrl !== void 0 ? tileUrl : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile.key = key;
    tile.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const cache3 = this.getTileCacheForProjection(projection);
    const tileCoord = [z, x, y];
    let tile;
    const tileCoordKey = getKey2(tileCoord);
    if (cache3.containsKey(tileCoordKey)) {
      tile = cache3.get(tileCoordKey);
    }
    const key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    }
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const newTile = new Tile_default2(
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    newTile.key = key;
    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      cache3.replace(tileCoordKey, newTile);
    } else {
      cache3.set(tileCoordKey, newTile);
    }
    return newTile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    let tile = null;
    const tileCoordKey = getKeyZXY(z, x, y);
    const key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        const interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);
        if (interimTile.getState() == TileState_default.IDLE) {
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = get3(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
  }
};
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage_default = TileImage;

// node_modules/ol/source/XYZ.js
var XYZ = class extends TileImage_default {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};
    const projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
    const tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
      extent: extentFromProjection(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: options.opaque,
      projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
};
var XYZ_default = XYZ;

// node_modules/ol/source/OSM.js
var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
var OSM = class extends XYZ_default {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(options) {
    options = options || {};
    let attributions;
    if (options.attributions !== void 0) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    const crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    const url = options.url !== void 0 ? options.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
      opaque: options.opaque !== void 0 ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });
  }
};
var OSM_default = OSM;

// node_modules/ol/layer/BaseTile.js
init_Layer();

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
var BaseTileLayer = class extends Layer_default {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(TileProperty_default.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(pixel) {
    return super.getData(pixel);
  }
};
var BaseTile_default = BaseTileLayer;

// node_modules/ol/renderer/canvas/TileLayer.js
init_Layer3();
init_transform();
init_array();
init_extent();
init_proj();
init_util();
init_size();
var CanvasTileLayerRenderer = class extends Layer_default3 {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(tileLayer) {
    super(tileLayer);
    this.extentChanged = true;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision;
    this.renderedTiles = [];
    this.newTiles_ = false;
    this.tmpExtent = createEmpty();
    this.tmpTileRange_ = new TileRange_default(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(tile) {
    const tileLayer = this.getLayer();
    const tileState = tile.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState_default.LOADED || tileState == TileState_default.EMPTY || tileState == TileState_default.ERROR && !useInterimTilesOnError;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(z, x, y, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == TileState_default.ERROR) {
      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = source.getTile(
        z,
        tileCoord[1],
        tileCoord[2],
        pixelRatio,
        projection
      );
      if (!(tile instanceof ImageTile_default || tile instanceof Tile_default2) || tile instanceof Tile_default2 && tile.getState() === TileState_default.EMPTY) {
        return null;
      }
      if (tile.getState() !== TileState_default.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = toSize(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);
      const col = Math.floor(
        tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
      );
      const row = Math.floor(
        tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
      );
      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );
      return this.getImageData(tile.getImage(), col + gutter, row + gutter);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return super.loadedTileCallback(tiles, zoom, tile);
    }
    return false;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const rotation = viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    let extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    const width = Math.round(getWidth(extent) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent) / resolution * pixelRatio);
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
    if (layerExtent) {
      extent = getIntersection(
        extent,
        fromUserExtent(layerState.extent, projection)
      );
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    const tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    const findLoadedTiles = this.createLoadedTileFinder(
      tileSource,
      projection,
      tilesToDrawByZ
    );
    const tmpExtent2 = this.tmpExtent;
    const tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    const viewport = rotation ? getRotatedViewport(
      viewState.center,
      resolution,
      rotation,
      frameState.size
    ) : void 0;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
          continue;
        }
        const tile = this.getTile(z, x, y, frameState);
        if (this.isDrawableTile(tile)) {
          const uid = getUid(this);
          if (tile.getState() == TileState_default.LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            let inTransition = tile.inTransition(uid);
            if (inTransition && layerState.opacity !== 1) {
              tile.endTransition(uid);
              inTransition = false;
            }
            if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            continue;
          }
        }
        const childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord,
          tmpTileRange,
          tmpExtent2
        );
        let covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord,
            findLoadedTiles,
            tmpTileRange,
            tmpExtent2
          );
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    compose(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );
    const canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    compose(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    let zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(ascending);
    let clips, clipZs, currentClip;
    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        getTopLeft(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      const tilesToDraw = tilesToDrawByZ[currentZ];
      for (const tileCoordKey in tilesToDraw) {
        const tile = (
          /** @type {import("../../ImageTile.js").default} */
          tilesToDraw[tileCoordKey]
        );
        const tileCoord = tile.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x = Math.round(origin[0] - xIndex * dx2);
        const y = Math.round(origin[1] - yIndex * dy2);
        const w = nextX - x;
        const h = nextY - y;
        const transition = z === currentZ;
        const inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;
        let contextSaved = false;
        if (!inTransition) {
          if (clips) {
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
              if (z !== currentZ && currentZ < clipZs[i2]) {
                const clip = clips[i2];
                if (intersects(
                  [x, y, x + w, y + h],
                  [clip[0], clip[3], clip[4], clip[7]]
                )) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }
        this.drawTileImage(
          tile,
          frameState,
          x,
          y,
          w,
          h,
          tileGutter,
          transition
        );
        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }
          this.renderedTiles.unshift(tile);
        } else {
          this.renderedTiles.push(tile);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(
      frameState,
      tileSource,
      tileGrid,
      pixelRatio,
      projection,
      extent,
      z,
      tileLayer.getPreload()
    );
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    return this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
    const image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    const uid = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );
    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile) {
    return tile.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      const postRenderFunction = function(tileSource2, map, frameState2) {
        const tileSourceKey = getUid(tileSource2);
        if (tileSourceKey in frameState2.usedTiles) {
          tileSource2.expireCache(
            frameState2.viewState.projection,
            frameState2.usedTiles[tileSourceKey]
          );
        }
      }.bind(null, tileSource);
      frameState.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        postRenderFunction
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileQueue = frameState.tileQueue;
    const minZoom = tileGrid.getMinZoom();
    const rotation = frameState.viewState.rotation;
    const viewport = rotation ? getRotatedViewport(
      frameState.viewState.center,
      frameState.viewState.resolution,
      rotation,
      frameState.size
    ) : void 0;
    let tileCount = 0;
    let tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
            continue;
          }
          if (currentZ - z <= preload) {
            ++tileCount;
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == TileState_default.IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([
                  tile,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord),
                  tileResolution
                ]);
              }
            }
            if (tileCallback !== void 0) {
              tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  }
};
var TileLayer_default = CanvasTileLayerRenderer;

// node_modules/ol/layer/Tile.js
var TileLayer = class extends BaseTile_default {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new TileLayer_default(this);
  }
};
var Tile_default4 = TileLayer;

// resources/js/index.ts
init_View();
init_coordinate();

// node_modules/ol/index.js
init_Feature();

// resources/js/index.ts
init_proj();
init_Vector2();
init_Vector();
init_geom();
var import_ol_geocoder = __toESM(require_ol_geocoder(), 1);
init_style2();
var mPoint = class {
  constructor(view, projection) {
    this.view = view;
    this.projection = projection;
    alert("mPoint");
  }
  onChange(callback) {
    this.view.on("change", () => {
      const [lat, lon] = this.getCoordinates();
      callback(lat, lon);
    });
  }
  getCoordinates() {
    return this.view.getCenter();
  }
  setCoordinates(lat, lon) {
    this.view.setCenter(fromLonLat([lat, lon], this.projection));
  }
};
function GetPointMap(id, lat = 0, lon = 0, zoom = 10) {
  const projection = "EPSG:4326";
  const mousePositionControl = new MousePosition_default({
    coordinateFormat: createStringXY(4),
    projection,
    className: `mouse-position-${id}`,
    target: document.getElementById(`OSMap-${id}`)
  });
  let point = new Feature_default({
    projection,
    geometry: new Point_default(fromLonLat([lat, lon], projection))
  });
  const vectorSource = new Vector_default2({
    features: [point]
  });
  const vectorLayer = new Vector_default({
    source: vectorSource
  });
  const MapLayer = new Tile_default4({
    source: new OSM_default()
  });
  const target = document.getElementById(`OSMap-${id}`);
  const view = new View_default({
    projection,
    center: fromLonLat([lat, lon], projection),
    zoom
  });
  const map = new Map_default2({
    controls: defaults().extend([mousePositionControl]),
    layers: [
      MapLayer,
      vectorLayer
    ],
    target,
    view
  });
  const geocoder = new import_ol_geocoder.default("nominatim", {
    provider: "osm",
    limit: 5,
    keepOpen: true
  });
  map.addControl(geocoder);
  geocoder.on("addresschosen", function(evt) {
    console.log(evt);
    const feature = evt.feature;
    const coordinate = evt.coordinate;
    feature.setStyle(new Style_default({
      image: new Icon_default({
        color: "rgba(0, 0, 0, 0)",
        crossOrigin: "anonymous",
        src: "https://openlayers.org/en/latest/examples/data/dot.png",
        scale: 0.01
      })
    }));
    view.setCenter(fromLonLat([coordinate[0], coordinate[1]], projection));
  });
  function updateCenter() {
    const [lat2, lon2] = map.getView().getCenter();
    point.getGeometry().setCoordinates([lat2, lon2]);
  }
  map.on("movestart", updateCenter);
  map.on("moveend", updateCenter);
  target.classList.add("map-done");
  return new mPoint(view, projection);
}
window["traineratwot"] = {};
window["traineratwot"].GetPointMap = GetPointMap;
/*! Bundled license information:

ol-geocoder/dist/ol-geocoder.js:
  (*!
   * ol-geocoder - v4.3.1
   * A geocoder extension compatible with OpenLayers v6.x, v7.x & v8.x
   * https://github.com/Dominique92/ol-geocoder
   * Built: 15/09/2023 16:57:41
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0RXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZnVuY3Rpb25zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9vYmouanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9UYXJnZXQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JzZXJ2YWJsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdXRpbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9oYXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2Fzc2VydHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RyYW5zZm9ybS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9yZ2IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL3h5ei5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3Itc3BhY2UvbHV2LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9sY2h1di5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3ItcGFyc2UvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL2hzbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3ItcmdiYS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbWF0aC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29sb3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Qcm9wZXJ0eS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0V2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVmlld0hpbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL1ZpZXdQcm9wZXJ0eS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQvY29tbW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1Byb2plY3Rpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzM4NTcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzQzMjYuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovcHJvamVjdGlvbnMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovdHJhbnNmb3Jtcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29vcmRpbmF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3BoZXJlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb25zb2xlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jZW50ZXJjb25zdHJhaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZXNvbHV0aW9uY29uc3RyYWludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcm90YXRpb25jb25zdHJhaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9lYXNpbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC90cmFuc2Zvcm0uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vU2ltcGxlR2VvbWV0cnkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jbG9zZXN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2FyZWEuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vTGluZWFyUmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9Qb2ludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2NvbnRhaW5zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NlZ21lbnRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3JldmVyc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9vcmllbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9seWdvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVmlldy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9FdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY3NzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9kb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Db250cm9sLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zaXplLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9JbWFnZVN0YXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9JbWFnZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1NvdXJjZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9MYXllci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvRmVhdHVyZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvRmlsbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVycG9sYXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvbGVuZ3RoLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9TdHJva2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ltYWdlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb2xvcmxpa2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1JlZ3VsYXJTaGFwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvQ2lyY2xlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9TdHlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvVGV4dC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3JidXNoL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uSW1hZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ljb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V4cHIvZXhwcmVzc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXhwci9jcHUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvc3R5bGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0Jhc2VWZWN0b3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW5zdHJ1Y3Rpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9WZWN0b3JDb250ZXh0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0J1aWxkZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW1hZ2VCdWlsZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0xpbmVTdHJpbmdCdWlsZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL1BvbHlnb25CdWlsZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvbGluZWNodW5rLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvc3RyYWlnaHRjaHVuay5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9UZXh0QnVpbGRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC90ZXh0cGF0aC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9FeGVjdXRvci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9FeGVjdXRvckdyb3VwLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvaGl0ZGV0ZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci92ZWN0b3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVmVjdG9yLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1JCdXNoLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvY2VudGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvRmVhdHVyZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1ZlY3RvckV2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbG9hZGluZ3N0cmF0ZWd5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9mZWF0dXJlbG9hZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVmVjdG9yLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9rb25zdGFudHMvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9oZWxwZXJzL21peC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL2hlbHBlcnMvZG9tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvaHRtbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL2hlbHBlcnMvYWpheC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL3Byb3ZpZGVycy9waG90b24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9wcm92aWRlcnMvb3NtLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvcHJvdmlkZXJzL21hcHF1ZXN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvcHJvdmlkZXJzL2JpbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9wcm92aWRlcnMvb3BlbmNhZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9ub21pbmF0aW0uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9iYXNlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL01hcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvQ29tcG9zaXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Hcm91cC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwRXZlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEJyb3dzZXJFdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50SGFuZGxlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9FdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcFByb3BlcnR5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9UaWxlUXVldWUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZVN0YXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL0F0dHJpYnV0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL2RlZmF1bHRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1JvdGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9ab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9kZWZhdWx0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1Byb3BlcnR5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BvaW50ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdQYW4uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9jb25kaXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdCb3guanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9Cb3guanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9LZXlib2FyZFBhbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0tleS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9LaW5ldGljLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vUGluY2hSb3RhdGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BpbmNoWm9vbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Nb3VzZVBvc2l0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUltYWdlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9UaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9JbWFnZVRpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9jb21tb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9UaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVHJpYW5ndWxhdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL0xSVUNhY2hlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC90aWxlY29vcmQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL1RpbGVDYWNoZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVFdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9UaWxlUmFuZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkL1RpbGVHcmlkLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdGlsZXVybGZ1bmN0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVXJsVGlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1hZWi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL09TTS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZVRpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1RpbGVQcm9wZXJ0eS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVGlsZS5qcyIsICIuLi9qcy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFN0cmlwcGVkIGRvd24gaW1wbGVtZW50YXRpb24gb2YgdGhlIFczQyBET00gTGV2ZWwgMiBFdmVudCBpbnRlcmZhY2UuXG4gKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtaW50ZXJmYWNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb25seSBwcm92aWRlcyBgdHlwZWAgYW5kIGB0YXJnZXRgIHByb3BlcnRpZXMsIGFuZFxuICogYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgbWV0aG9kcy4gSXQgaXMgbWVhbnQgYXMgYmFzZSBjbGFzc1xuICogZm9yIGhpZ2hlciBsZXZlbCBldmVudHMgZGVmaW5lZCBpbiB0aGUgbGlicmFyeSwgYW5kIHdvcmtzIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL1RhcmdldH5UYXJnZXR9LlxuICovXG5jbGFzcyBCYXNlRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50IGRlZmF1bHQuIFRoaXMgbWVhbnMgdGhhdCBubyBlbXVsYXRlZCBgY2xpY2tgLCBgc2luZ2xlY2xpY2tgIG9yIGBkb3VibGVjbGlja2AgZXZlbnRzXG4gICAqIHdpbGwgYmUgZmlyZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR8aW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldnQpIHtcbiAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR8aW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2dCkge1xuICBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZUV2ZW50O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9PYmplY3RFdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgcHJvcGVydHkgaXMgY2hhbmdlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9PYmplY3QuT2JqZWN0RXZlbnQjcHJvcGVydHljaGFuZ2VcbiAgICogQGFwaVxuICAgKi9cbiAgUFJPUEVSVFlDSEFOR0U6ICdwcm9wZXJ0eWNoYW5nZScsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHsncHJvcGVydHljaGFuZ2UnfSBUeXBlc1xuICovXG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0Rpc3Bvc2FibGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE9iamVjdHMgdGhhdCBuZWVkIHRvIGNsZWFuIHVwIGFmdGVyIHRoZW1zZWx2ZXMuXG4gKi9cbmNsYXNzIERpc3Bvc2FibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuc2lvbiBwb2ludCBmb3IgZGlzcG9zYWJsZSBvYmplY3RzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaXNwb3NhYmxlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9hcnJheVxuICovXG5cbi8qKlxuICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBwcm92aWRlZCBzb3J0ZWQgbGlzdCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gaWYgZm91bmQuIElmIGl0IGNhbid0IGJlIGZvdW5kIGl0J2xsIHJldHVybiAtMS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL2JpbmFyeS1zZWFyY2hcbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBoYXlzdGFjayBJdGVtcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSB7Kn0gbmVlZGxlIFRoZSBpdGVtIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIENvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZCwgLTEgaWYgbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIGNvbXBhcmF0b3IpIHtcbiAgbGV0IG1pZCwgY21wO1xuICBjb21wYXJhdG9yID0gY29tcGFyYXRvciB8fCBhc2NlbmRpbmc7XG4gIGxldCBsb3cgPSAwO1xuICBsZXQgaGlnaCA9IGhheXN0YWNrLmxlbmd0aDtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAvKiBOb3RlIHRoYXQgXCIobG93ICsgaGlnaCkgPj4+IDFcIiBtYXkgb3ZlcmZsb3csIGFuZCByZXN1bHRzIGluIGEgdHlwZWNhc3RcbiAgICAgKiB0byBkb3VibGUgKHdoaWNoIGdpdmVzIHRoZSB3cm9uZyByZXN1bHRzKS4gKi9cbiAgICBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuICAgIGNtcCA9ICtjb21wYXJhdG9yKGhheXN0YWNrW21pZF0sIG5lZWRsZSk7XG5cbiAgICBpZiAoY21wIDwgMC4wKSB7XG4gICAgICAvKiBUb28gbG93LiAqL1xuICAgICAgbG93ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogS2V5IGZvdW5kIG9yIHRvbyBoaWdoICovXG4gICAgICBoaWdoID0gbWlkO1xuICAgICAgZm91bmQgPSAhY21wO1xuICAgIH1cbiAgfVxuXG4gIC8qIEtleSBub3QgZm91bmQuICovXG4gIHJldHVybiBmb3VuZCA/IGxvdyA6IH5sb3c7XG59XG5cbi8qKlxuICogQ29tcGFyZSBmdW5jdGlvbiBzb3J0aW5nIGFycmF5cyBpbiBhc2NlbmRpbmcgb3JkZXIuICBTYWZlIHRvIHVzZSBmb3IgbnVtZXJpYyB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGFzIHRoZSBmaXJzdFxuICogICAgIGFyZ3VtZW50IGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufVxuXG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gc29ydGluZyBhcnJheXMgaW4gZGVzY2VuZGluZyBvcmRlci4gIFNhZmUgdG8gdXNlIGZvciBudW1lcmljIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHsqfSBiIFRoZSBzZWNvbmQgb2JqZWN0IHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybiB7bnVtYmVyfSBBIG5lZ2F0aXZlIG51bWJlciwgemVybywgb3IgYSBwb3NpdGl2ZSBudW1iZXIgYXMgdGhlIGZpcnN0XG4gKiAgICAgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuLCBlcXVhbCB0bywgb3IgbGVzcyB0aGFuIHRoZSBzZWNvbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xufVxuXG4vKipcbiAqIHtAbGluayBtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR+VGlsZUdyaWQjZ2V0WkZvclJlc29sdXRpb259IGNhbiB1c2UgYSBmdW5jdGlvblxuICogb2YgdGhpcyB0eXBlIHRvIGRldGVybWluZSB3aGljaCBuZWFyZXN0IHJlc29sdXRpb24gdG8gdXNlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBge251bWJlcn1gIHJlcHJlc2VudGluZyBhIHZhbHVlIGJldHdlZW4gdHdvIGFycmF5IGVudHJpZXMsXG4gKiBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGUgbmVhcmVzdCBoaWdoZXIgZW50cnkgYW5kXG4gKiBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGUgbmVhcmVzdCBsb3dlciBlbnRyeVxuICogYXMgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgYHtudW1iZXJ9YC4gSWYgYSBuZWdhdGl2ZSBudW1iZXIgb3IgemVybyBpcyByZXR1cm5lZFxuICogdGhlIGxvd2VyIHZhbHVlIHdpbGwgYmUgdXNlZCwgaWYgYSBwb3NpdGl2ZSBudW1iZXIgaXMgcmV0dXJuZWQgdGhlIGhpZ2hlciB2YWx1ZVxuICogd2lsbCBiZSB1c2VkLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIpOiBudW1iZXJ9IE5lYXJlc3REaXJlY3Rpb25GdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhcnIgQXJyYXkgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ8TmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufSBkaXJlY3Rpb25cbiAqICAgIDAgbWVhbnMgcmV0dXJuIHRoZSBuZWFyZXN0LFxuICogICAgPiAwIG1lYW5zIHJldHVybiB0aGUgbGFyZ2VzdCBuZWFyZXN0LFxuICogICAgPCAwIG1lYW5zIHJldHVybiB0aGUgc21hbGxlc3QgbmVhcmVzdC5cbiAqIEByZXR1cm4ge251bWJlcn0gSW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJGaW5kTmVhcmVzdChhcnIsIHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGlmIChhcnJbMF0gPD0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBuID0gYXJyLmxlbmd0aDtcbiAgaWYgKHRhcmdldCA8PSBhcnJbbiAtIDFdKSB7XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gYXJyW2ldO1xuICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZSA8IHRhcmdldCkge1xuICAgICAgICBpZiAoZGlyZWN0aW9uKHRhcmdldCwgYXJyW2kgLSAxXSwgY2FuZGlkYXRlKSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuIC0gMTtcbiAgfVxuXG4gIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbiAtIDE7XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoYXJyW2ldIDw9IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgIGlmIChhcnJbaSAtIDFdIC0gdGFyZ2V0IDwgdGFyZ2V0IC0gYXJyW2ldKSB7XG4gICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbiAtIDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIEFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luIEJlZ2luIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlU3ViQXJyYXkoYXJyLCBiZWdpbiwgZW5kKSB7XG4gIHdoaWxlIChiZWdpbiA8IGVuZCkge1xuICAgIGNvbnN0IHRtcCA9IGFycltiZWdpbl07XG4gICAgYXJyW2JlZ2luXSA9IGFycltlbmRdO1xuICAgIGFycltlbmRdID0gdG1wO1xuICAgICsrYmVnaW47XG4gICAgLS1lbmQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFZBTFVFPn0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyFBcnJheTxWQUxVRT58VkFMVUV9IGRhdGEgVGhlIGVsZW1lbnRzIG9yIGFycmF5cyBvZiBlbGVtZW50cyB0byBhZGQgdG8gYXJyLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoYXJyLCBkYXRhKSB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xuICBjb25zdCBsZW5ndGggPSBleHRlbnNpb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2Fyci5sZW5ndGhdID0gZXh0ZW5zaW9uW2ldO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtWQUxVRX0gb2JqIFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKG9iaik7XG4gIGNvbnN0IGZvdW5kID0gaSA+IC0xO1xuICBpZiAoZm91bmQpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGFueT58VWludDhDbGFtcGVkQXJyYXl9IGFycjEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5PGFueT58VWludDhDbGFtcGVkQXJyYXl9IGFycjIgVGhlIHNlY29uZCBhcnJheSB0byBjb21wYXJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdHdvIGFycmF5cyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYXJyMSwgYXJyMikge1xuICBjb25zdCBsZW4xID0gYXJyMS5sZW5ndGg7XG4gIGlmIChsZW4xICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFNvcnQgdGhlIHBhc3NlZCBhcnJheSBzdWNoIHRoYXQgdGhlIHJlbGF0aXZlIG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzIGlzIHByZXNlcnZlZC5cbiAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb3J0aW5nX2FsZ29yaXRobSNTdGFiaWxpdHkgZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHNvcnQgKG1vZGlmaWVzIG9yaWdpbmFsKS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCosICopOiBudW1iZXJ9IGNvbXBhcmVGbmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWJsZVNvcnQoYXJyLCBjb21wYXJlRm5jKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IHRtcCA9IEFycmF5KGFyci5sZW5ndGgpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG1wW2ldID0ge2luZGV4OiBpLCB2YWx1ZTogYXJyW2ldfTtcbiAgfVxuICB0bXAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlRm5jKGEudmFsdWUsIGIudmFsdWUpIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KTtcbiAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRtcFtpXS52YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyciBUaGUgYXJyYXkgdG8gdGVzdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmdW5jXSBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0XSBTdHJpY3RseSBzb3J0ZWQgKGRlZmF1bHQgZmFsc2UpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTb3J0ZWQoYXJyLCBmdW5jLCBzdHJpY3QpIHtcbiAgY29uc3QgY29tcGFyZSA9IGZ1bmMgfHwgYXNjZW5kaW5nO1xuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uIChjdXJyZW50VmFsLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmUoYXJyW2luZGV4IC0gMV0sIGN1cnJlbnRWYWwpO1xuICAgIHJldHVybiAhKHJlcyA+IDAgfHwgKHN0cmljdCAmJiByZXMgPT09IDApKTtcbiAgfSk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2Z1bmN0aW9uc1xuICovXG5cbmltcG9ydCB7ZXF1YWxzIGFzIGFycmF5RXF1YWxzfSBmcm9tICcuL2FycmF5LmpzJztcblxuLyoqXG4gKiBBbHdheXMgcmV0dXJucyB0cnVlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRSVUUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gZmFsc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGQUxTRSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgcmV1c2FibGUgZnVuY3Rpb24sIHVzZWQgZS5nLiBhcyBhIGRlZmF1bHQgZm9yIGNhbGxiYWNrcy5cbiAqXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gVk9JRCgpIHt9XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIGluIGFub3RoZXIgZnVuY3Rpb24gdGhhdCByZW1lbWJlcnMgdGhlIGxhc3QgcmV0dXJuLiAgSWYgdGhlXG4gKiByZXR1cm5lZCBmdW5jdGlvbiBpcyBjYWxsZWQgdHdpY2UgaW4gYSByb3cgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYW5kIHRoZSBzYW1lXG4gKiB0aGlzIG9iamVjdCwgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IGNhbGwgaW4gdGhlIHNlY29uZCBjYWxsLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55KTogUmV0dXJuVHlwZX0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5hbnkpOiBSZXR1cm5UeXBlfSBUaGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgUmV0dXJuVHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZU9uZShmbikge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgLyoqIEB0eXBlIHtSZXR1cm5UeXBlfSAqL1xuICBsZXQgbGFzdFJlc3VsdDtcblxuICAvKiogQHR5cGUge0FycmF5PGFueT59ICovXG4gIGxldCBsYXN0QXJncztcblxuICBsZXQgbGFzdFRoaXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBuZXh0QXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKCFjYWxsZWQgfHwgdGhpcyAhPT0gbGFzdFRoaXMgfHwgIWFycmF5RXF1YWxzKG5leHRBcmdzLCBsYXN0QXJncykpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICBsYXN0QXJncyA9IG5leHRBcmdzO1xuICAgICAgbGFzdFJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IChUIHwgUHJvbWlzZTxUPil9IGdldHRlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlIG9yIGEgcHJvbWlzZSBmb3IgYSB2YWx1ZS5cbiAqIEByZXR1cm4ge1Byb21pc2U8VD59IEEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9taXNlKGdldHRlcikge1xuICBmdW5jdGlvbiBwcm9taXNlR2V0dGVyKCkge1xuICAgIGxldCB2YWx1ZTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9taXNlR2V0dGVyKCk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL29ialxuICovXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgdW5rbm93bj59IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIob2JqZWN0KSB7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhbnkgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBvYmplY3QgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuICBsZXQgcHJvcGVydHk7XG4gIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhcHJvcGVydHk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9UYXJnZXRcbiAqL1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9FdmVudC5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFdmVudFRhcmdldHxUYXJnZXR9IEV2ZW50VGFyZ2V0TGlrZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnRUYXJnZXQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1FdmVudHMtMjAwMDExMTMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gaW1wb3J0YW50IHNpbXBsaWZpY2F0aW9ucyBjb21wYXJlZCB0byB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqXG4gKiAxLiBUaGUgaGFuZGxpbmcgb2YgYHVzZUNhcHR1cmVgIGluIGBhZGRFdmVudExpc3RlbmVyYCBhbmRcbiAqICAgIGByZW1vdmVFdmVudExpc3RlbmVyYC4gVGhlcmUgaXMgbm8gcmVhbCBjYXB0dXJlIG1vZGVsLlxuICogMi4gVGhlIGhhbmRsaW5nIG9mIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG9uIGBkaXNwYXRjaEV2ZW50YC5cbiAqICAgIFRoZXJlIGlzIG5vIGV2ZW50IHRhcmdldCBoaWVyYXJjaHkuIFdoZW4gYSBsaXN0ZW5lciBjYWxsc1xuICogICAgYHN0b3BQcm9wYWdhdGlvbmAgb3IgYHByZXZlbnREZWZhdWx0YCBvbiBhbiBldmVudCBvYmplY3QsIGl0IG1lYW5zIHRoYXQgbm9cbiAqICAgIG1vcmUgbGlzdGVuZXJzIGFmdGVyIHRoaXMgb25lIHdpbGwgYmUgY2FsbGVkLiBTYW1lIGFzIHdoZW4gdGhlIGxpc3RlbmVyXG4gKiAgICByZXR1cm5zIGZhbHNlLlxuICovXG5jbGFzcyBUYXJnZXQgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gW3RhcmdldF0gRGVmYXVsdCBldmVudCB0YXJnZXQgZm9yIGRpc3BhdGNoZWQgZXZlbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy5ldmVudFRhcmdldF8gPSB0YXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3BhdGNoaW5nXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXI+PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJzXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXJ9IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdHlwZSB8fCAhbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfIHx8ICh0aGlzLmxpc3RlbmVyc18gPSB7fSk7XG4gICAgY29uc3QgbGlzdGVuZXJzRm9yVHlwZSA9IGxpc3RlbmVyc1t0eXBlXSB8fCAobGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICAgIGlmICghbGlzdGVuZXJzRm9yVHlwZS5pbmNsdWRlcyhsaXN0ZW5lcikpIHtcbiAgICAgIGxpc3RlbmVyc0ZvclR5cGUucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIGNhbGxzIGFsbCBsaXN0ZW5lcnMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICogb2YgdGhpcyB0eXBlLiBUaGUgZXZlbnQgcGFyYW1ldGVyIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYW5cbiAgICogT2JqZWN0IHdpdGggYSBgdHlwZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fHN0cmluZ30gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gYGZhbHNlYCBpZiBhbnlvbmUgY2FsbGVkIHByZXZlbnREZWZhdWx0IG9uIHRoZVxuICAgKiAgICAgZXZlbnQgb2JqZWN0IG9yIGlmIGFueSBvZiB0aGUgbGlzdGVuZXJzIHJldHVybmVkIGZhbHNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0cmluZyA/IGV2ZW50IDogZXZlbnQudHlwZTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc18gJiYgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXZ0ID0gaXNTdHJpbmcgPyBuZXcgRXZlbnQoZXZlbnQpIDogLyoqIEB0eXBlIHtFdmVudH0gKi8gKGV2ZW50KTtcbiAgICBpZiAoIWV2dC50YXJnZXQpIHtcbiAgICAgIGV2dC50YXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0XyB8fCB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBkaXNwYXRjaGluZyA9IHRoaXMuZGlzcGF0Y2hpbmdfIHx8ICh0aGlzLmRpc3BhdGNoaW5nXyA9IHt9KTtcbiAgICBjb25zdCBwZW5kaW5nUmVtb3ZhbHMgPVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfIHx8ICh0aGlzLnBlbmRpbmdSZW1vdmFsc18gPSB7fSk7XG4gICAgaWYgKCEodHlwZSBpbiBkaXNwYXRjaGluZykpIHtcbiAgICAgIGRpc3BhdGNoaW5nW3R5cGVdID0gMDtcbiAgICAgIHBlbmRpbmdSZW1vdmFsc1t0eXBlXSA9IDA7XG4gICAgfVxuICAgICsrZGlzcGF0Y2hpbmdbdHlwZV07XG4gICAgbGV0IHByb3BhZ2F0ZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKCdoYW5kbGVFdmVudCcgaW4gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyT2JqZWN0fSAqLyAoXG4gICAgICAgICAgbGlzdGVuZXJzW2ldXG4gICAgICAgICkuaGFuZGxlRXZlbnQoZXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb259ICovIChcbiAgICAgICAgICBsaXN0ZW5lcnNbaV1cbiAgICAgICAgKS5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcGFnYXRlID09PSBmYWxzZSB8fCBldnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKC0tZGlzcGF0Y2hpbmdbdHlwZV0gPT09IDApIHtcbiAgICAgIGxldCBwciA9IHBlbmRpbmdSZW1vdmFsc1t0eXBlXTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVtb3ZhbHNbdHlwZV07XG4gICAgICB3aGlsZSAocHItLSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgVk9JRCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgZGlzcGF0Y2hpbmdbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiBwcm9wYWdhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnNfICYmIGNsZWFyKHRoaXMubGlzdGVuZXJzXyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuIExpc3RlbmVycyBhcmUgcmV0dXJuZWQgaW4gdGhlXG4gICAqIG9yZGVyIHRoYXQgdGhleSB3aWxsIGJlIGNhbGxlZCBpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyPnx1bmRlZmluZWR9IExpc3RlbmVycy5cbiAgICovXG4gIGdldExpc3RlbmVycyh0eXBlKSB7XG4gICAgcmV0dXJuICh0aGlzLmxpc3RlbmVyc18gJiYgdGhpcy5saXN0ZW5lcnNfW3R5cGVdKSB8fCB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUeXBlLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqICAgICBgdHJ1ZWAgd2lsbCBiZSByZXR1cm5lZCBpZiB0aGlzIGV2ZW50IHRhcmdldCBoYXMgYW55IGxpc3RlbmVycy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGxpc3RlbmVycy5cbiAgICovXG4gIGhhc0xpc3RlbmVyKHR5cGUpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZVxuICAgICAgPyB0eXBlIGluIHRoaXMubGlzdGVuZXJzX1xuICAgICAgOiBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVyc18pLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXJ9IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5saXN0ZW5lcnNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nUmVtb3ZhbHNfICYmIHR5cGUgaW4gdGhpcy5wZW5kaW5nUmVtb3ZhbHNfKSB7XG4gICAgICAgIC8vIG1ha2UgbGlzdGVuZXIgYSBuby1vcCwgYW5kIHJlbW92ZSBsYXRlciBpbiAjZGlzcGF0Y2hFdmVudCgpXG4gICAgICAgIGxpc3RlbmVyc1tpbmRleF0gPSBWT0lEO1xuICAgICAgICArK3RoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFyZ2V0O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEdlbmVyaWMgY2hhbmdlIGV2ZW50LiBUcmlnZ2VyZWQgd2hlbiB0aGUgcmV2aXNpb24gY291bnRlciBpcyBpbmNyZWFzZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkJhc2VFdmVudCNjaGFuZ2VcbiAgICogQGFwaVxuICAgKi9cbiAgQ0hBTkdFOiAnY2hhbmdlJyxcblxuICAvKipcbiAgICogR2VuZXJpYyBlcnJvciBldmVudC4gVHJpZ2dlcmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5CYXNlRXZlbnQjZXJyb3JcbiAgICogQGFwaVxuICAgKi9cbiAgRVJST1I6ICdlcnJvcicsXG5cbiAgQkxVUjogJ2JsdXInLFxuICBDTEVBUjogJ2NsZWFyJyxcbiAgQ09OVEVYVE1FTlU6ICdjb250ZXh0bWVudScsXG4gIENMSUNLOiAnY2xpY2snLFxuICBEQkxDTElDSzogJ2RibGNsaWNrJyxcbiAgRFJBR0VOVEVSOiAnZHJhZ2VudGVyJyxcbiAgRFJBR09WRVI6ICdkcmFnb3ZlcicsXG4gIERST1A6ICdkcm9wJyxcbiAgRk9DVVM6ICdmb2N1cycsXG4gIEtFWURPV046ICdrZXlkb3duJyxcbiAgS0VZUFJFU1M6ICdrZXlwcmVzcycsXG4gIExPQUQ6ICdsb2FkJyxcbiAgUkVTSVpFOiAncmVzaXplJyxcbiAgVE9VQ0hNT1ZFOiAndG91Y2htb3ZlJyxcbiAgV0hFRUw6ICd3aGVlbCcsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHNcbiAqL1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi9vYmouanMnO1xuXG4vKipcbiAqIEtleSB0byB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGUudW5CeUtleX0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudHNLZXlcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUeXBlLlxuICogQGFwaVxuICovXG5cbi8qKlxuICogTGlzdGVuZXIgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYW4gZXZlbnQgb2JqZWN0IGFzIGFyZ3VtZW50LlxuICogV2hlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCBldmVudCBwcm9wYWdhdGlvbiB3aWxsIHN0b3AuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KSk6ICh2b2lkfGJvb2xlYW4pfSBMaXN0ZW5lckZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaXN0ZW5lck9iamVjdFxuICogQHByb3BlcnR5IHtMaXN0ZW5lckZ1bmN0aW9ufSBoYW5kbGVFdmVudCBIYW5kbGVFdmVudCBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtMaXN0ZW5lckZ1bmN0aW9ufExpc3RlbmVyT2JqZWN0fSBMaXN0ZW5lclxuICovXG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIHRvIGEgYHRoaXNgIG9iamVjdCwgYW5kIHJldHVybnNcbiAqIGEga2V5IGZvciB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy51bmxpc3RlbkJ5S2V5fS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHtMaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc0FyZ10gT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29uY2VdIElmIHRydWUsIGFkZCB0aGUgbGlzdGVuZXIgYXMgb25lLW9mZiBsaXN0ZW5lci5cbiAqIEByZXR1cm4ge0V2ZW50c0tleX0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHRoaXNBcmcsIG9uY2UpIHtcbiAgaWYgKHRoaXNBcmcgJiYgdGhpc0FyZyAhPT0gdGFyZ2V0KSB7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5iaW5kKHRoaXNBcmcpO1xuICB9XG4gIGlmIChvbmNlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgb3JpZ2luYWxMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgZXZlbnRzS2V5ID0ge1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICB9O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gIHJldHVybiBldmVudHNLZXk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgb25lLW9mZiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGVmZmljaWVudGx5IGJpbmRzIGEgYGxpc3RlbmVyYCBhcyBzZWxmLXVucmVnaXN0ZXJpbmcgbGlzdGVuZXJcbiAqIHRvIGEgYHRoaXNgIG9iamVjdCwgYW5kIHJldHVybnMgYSBrZXkgZm9yIHVzZSB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy51bmxpc3RlbkJ5S2V5fSBpbiBjYXNlIHRoZSBsaXN0ZW5lciBuZWVkcyB0byBiZVxuICogdW5yZWdpc3RlcmVkIGJlZm9yZSBpdCBpcyBjYWxsZWQuXG4gKlxuICogV2hlbiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy5saXN0ZW59IGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhZnRlciB0aGlzXG4gKiBmdW5jdGlvbiwgdGhlIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lciB3aWxsIGJlIHR1cm5lZCBpbnRvIGEgcGVybWFuZW50XG4gKiBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHtMaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhpc0FyZ10gT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqIEByZXR1cm4ge0V2ZW50c0tleX0gS2V5IGZvciB1bmxpc3RlbkJ5S2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuT25jZSh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB0aGlzQXJnKSB7XG4gIHJldHVybiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgdGhpc0FyZywgdHJ1ZSk7XG59XG5cbi8qKlxuICogVW5yZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBpcyB0aGUga2V5IHJldHVybmVkIGZyb21cbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzLmxpc3Rlbn0gb3Ige0BsaW5rIG1vZHVsZTpvbC9ldmVudHMubGlzdGVuT25jZX0uXG4gKlxuICogQHBhcmFtIHtFdmVudHNLZXl9IGtleSBUaGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5CeUtleShrZXkpIHtcbiAgaWYgKGtleSAmJiBrZXkudGFyZ2V0KSB7XG4gICAga2V5LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGtleS50eXBlLCBrZXkubGlzdGVuZXIpO1xuICAgIGNsZWFyKGtleSk7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvT2JzZXJ2YWJsZVxuICovXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7bGlzdGVuLCBsaXN0ZW5PbmNlLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBUeXBlXG4gKiBAdGVtcGxhdGUge0V2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IEV2ZW50Q2xhc3NcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHsodHlwZTogVHlwZSwgbGlzdGVuZXI6IChldmVudDogRXZlbnRDbGFzcykgPT4gPykgPT4gUmV0dXJufSBPblNpZ25hdHVyZVxuICovXG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBUeXBlXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7KHR5cGU6IFR5cGVbXSwgbGlzdGVuZXI6IChldmVudDogRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkgPT4gPykgPT4gUmV0dXJuIGV4dGVuZHMgdm9pZCA/IHZvaWQgOiBSZXR1cm5bXX0gQ29tYmluZWRPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydjaGFuZ2UnfCdlcnJvcid9IEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7T25TaWduYXR1cmU8RXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmIENvbWJpbmVkT25TaWduYXR1cmU8RXZlbnRUeXBlcywgUmV0dXJuPn0gT2JzZXJ2YWJsZU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBBbiBldmVudCB0YXJnZXQgcHJvdmlkaW5nIGNvbnZlbmllbnQgbWV0aG9kcyBmb3IgbGlzdGVuZXIgcmVnaXN0cmF0aW9uXG4gKiBhbmQgdW5yZWdpc3RyYXRpb24uIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyBhbHdheXMgYXZhaWxhYmxlIHRocm91Z2hcbiAqIHtAbGluayBtb2R1bGU6b2wvT2JzZXJ2YWJsZX5PYnNlcnZhYmxlI2NoYW5nZWR9LlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIE9ic2VydmFibGUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9uID1cbiAgICAgIC8qKiBAdHlwZSB7T2JzZXJ2YWJsZU9uU2lnbmF0dXJlPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59ICovIChcbiAgICAgICAgdGhpcy5vbkludGVybmFsXG4gICAgICApO1xuXG4gICAgdGhpcy5vbmNlID1cbiAgICAgIC8qKiBAdHlwZSB7T2JzZXJ2YWJsZU9uU2lnbmF0dXJlPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59ICovIChcbiAgICAgICAgdGhpcy5vbmNlSW50ZXJuYWxcbiAgICAgICk7XG5cbiAgICB0aGlzLnVuID0gLyoqIEB0eXBlIHtPYnNlcnZhYmxlT25TaWduYXR1cmU8dm9pZD59ICovICh0aGlzLnVuSW50ZXJuYWwpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmV2aXNpb25fID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZWFzZXMgdGhlIHJldmlzaW9uIGNvdW50ZXIgYW5kIGRpc3BhdGNoZXMgYSAnY2hhbmdlJyBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgY2hhbmdlZCgpIHtcbiAgICArK3RoaXMucmV2aXNpb25fO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZlcnNpb24gbnVtYmVyIGZvciB0aGlzIG9iamVjdC4gIEVhY2ggdGltZSB0aGUgb2JqZWN0IGlzIG1vZGlmaWVkLFxuICAgKiBpdHMgdmVyc2lvbiBudW1iZXIgd2lsbCBiZSBpbmNyZW1lbnRlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXZpc2lvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmV2aXNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2aXNpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IEV2ZW50IGtleS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgb25JbnRlcm5hbCh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBjb25zdCBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAga2V5c1tpXSA9IGxpc3Rlbih0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Rlbih0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSk6ID99IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gRXZlbnQga2V5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBvbmNlSW50ZXJuYWwodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBsZXQga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBjb25zdCBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICAgIGtleSA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXlbaV0gPSBsaXN0ZW5PbmNlKHRoaXMsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gbGlzdGVuT25jZSh0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAobGlzdGVuZXIpLm9sX2tleSA9IGtleTtcbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFVubGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSk6ID99IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1bkludGVybmFsKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChsaXN0ZW5lcikub2xfa2V5O1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHVuQnlLZXkoa2V5KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHR5cGUubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuIElmXG4gKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gKiAgICAgd2lsbCBiZSBhbiBhcnJheSBvZiBrZXlzLlxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5vbjtcblxuLyoqXG4gKiBMaXN0ZW4gb25jZSBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuIElmXG4gKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gKiAgICAgd2lsbCBiZSBhbiBhcnJheSBvZiBrZXlzLlxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5vbmNlO1xuXG4vKipcbiAqIFVubGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpKTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5PYnNlcnZhYmxlLnByb3RvdHlwZS51bjtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIHVzaW5nIHRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgIG9yIGBvbmNlKClgLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0ga2V5IFRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgXG4gKiAgICAgb3IgYG9uY2UoKWAgKG9yIGFuIGFycmF5IG9mIGtleXMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5CeUtleShrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGtleS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGtleVtpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVubGlzdGVuQnlLZXkoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9ICovIChrZXkpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYnNlcnZhYmxlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC91dGlsXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtuZXZlcn0gQW55IHJldHVybi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kLicpO1xufVxuXG4vKipcbiAqIENvdW50ZXIgZm9yIGdldFVpZC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5sZXQgdWlkQ291bnRlcl8gPSAwO1xuXG4vKipcbiAqIEdldHMgYSB1bmlxdWUgSUQgZm9yIGFuIG9iamVjdC4gVGhpcyBtdXRhdGVzIHRoZSBvYmplY3Qgc28gdGhhdCBmdXJ0aGVyIGNhbGxzXG4gKiB3aXRoIHRoZSBzYW1lIG9iamVjdCBhcyBhIHBhcmFtZXRlciByZXR1cm5zIHRoZSBzYW1lIHZhbHVlLiBVbmlxdWUgSURzIGFyZSBnZW5lcmF0ZWRcbiAqIGFzIGEgc3RyaWN0bHkgaW5jcmVhc2luZyBzZXF1ZW5jZS4gQWRhcHRlZCBmcm9tIGdvb2cuZ2V0VWlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBnZXQgdGhlIHVuaXF1ZSBJRCBmb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB1bmlxdWUgSUQgZm9yIHRoZSBvYmplY3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaWQob2JqKSB7XG4gIHJldHVybiBvYmoub2xfdWlkIHx8IChvYmoub2xfdWlkID0gU3RyaW5nKCsrdWlkQ291bnRlcl8pKTtcbn1cblxuLyoqXG4gKiBPcGVuTGF5ZXJzIHZlcnNpb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc4LjIuMCc7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL09iamVjdFxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuL09ic2VydmFibGUuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4vb2JqLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgZm9yIGBrZXlgLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwga2V5LCBvbGRWYWx1ZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIGNoYW5naW5nLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0ga2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9sZCB2YWx1ZS4gVG8gZ2V0IHRoZSBuZXcgdmFsdWUgdXNlIGBlLnRhcmdldC5nZXQoZS5rZXkpYCB3aGVyZVxuICAgICAqIGBlYCBpcyB0aGUgZXZlbnQgb2JqZWN0LlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gIH1cbn1cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXMsIE9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzLCBSZXR1cm4+fSBPYmplY3RPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTW9zdCBub24tdHJpdmlhbCBjbGFzc2VzIGluaGVyaXQgZnJvbSB0aGlzLlxuICpcbiAqIFRoaXMgZXh0ZW5kcyB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZX0gd2l0aCBvYnNlcnZhYmxlXG4gKiBwcm9wZXJ0aWVzLCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIG9ic2VydmFibGUgYXMgd2VsbCBhcyB0aGUgb2JqZWN0IGFzIGFcbiAqIHdob2xlLlxuICpcbiAqIENsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyBoYXZlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMsIHRvIHdoaWNoIHlvdSBjYW5cbiAqIGFkZCB5b3VyIG93bnMuIFRoZSBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzIGFyZSBsaXN0ZWQgaW4gdGhpcyBkb2N1bWVudGF0aW9uIGFzXG4gKiAnT2JzZXJ2YWJsZSBQcm9wZXJ0aWVzJywgYW5kIGhhdmUgdGhlaXIgb3duIGFjY2Vzc29yczsgZm9yIGV4YW1wbGUsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGhhcyBhIGB0YXJnZXRgIHByb3BlcnR5LCBhY2Nlc3NlZCB3aXRoXG4gKiBgZ2V0VGFyZ2V0KClgIGFuZCBjaGFuZ2VkIHdpdGggYHNldFRhcmdldCgpYC4gTm90IGFsbCBwcm9wZXJ0aWVzIGFyZSBob3dldmVyXG4gKiBzZXR0YWJsZS4gVGhlcmUgYXJlIGFsc28gZ2VuZXJhbC1wdXJwb3NlIGFjY2Vzc29ycyBgZ2V0KClgIGFuZCBgc2V0KClgLiBGb3JcbiAqIGV4YW1wbGUsIGBnZXQoJ3RhcmdldCcpYCBpcyBlcXVpdmFsZW50IHRvIGBnZXRUYXJnZXQoKWAuXG4gKlxuICogVGhlIGBzZXRgIGFjY2Vzc29ycyB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCBhbmQgeW91IGNhbiBtb25pdG9yIHRoaXMgYnlcbiAqIHJlZ2lzdGVyaW5nIGEgbGlzdGVuZXIuIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL1ZpZXd+Vmlld30gaGFzIGFcbiAqIGBjZW50ZXJgIHByb3BlcnR5LCBzbyBgdmlldy5vbignY2hhbmdlOmNlbnRlcicsIGZ1bmN0aW9uKGV2dCkgey4uLn0pO2Agd291bGRcbiAqIGNhbGwgdGhlIGZ1bmN0aW9uIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgY2VudGVyIHByb3BlcnR5IGNoYW5nZXMuIFdpdGhpblxuICogdGhlIGZ1bmN0aW9uLCBgZXZ0LnRhcmdldGAgd291bGQgYmUgdGhlIHZpZXcsIHNvIGBldnQudGFyZ2V0LmdldENlbnRlcigpYFxuICogd291bGQgcmV0dXJuIHRoZSBuZXcgY2VudGVyLlxuICpcbiAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG9ic2VydmFibGUgcHJvcGVydGllcyB3aXRoXG4gKiBgb2JqZWN0LnNldCgncHJvcCcsICd2YWx1ZScpYCwgYW5kIHJldHJpZXZlIHRoYXQgd2l0aCBgb2JqZWN0LmdldCgncHJvcCcpYC5cbiAqIFlvdSBjYW4gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoYXQgcHJvcGVydHkgdmFsdWUgd2l0aFxuICogYG9iamVjdC5vbignY2hhbmdlOnByb3AnLCBsaXN0ZW5lcilgLiBZb3UgY2FuIGdldCBhIGxpc3Qgb2YgYWxsXG4gKiBwcm9wZXJ0aWVzIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdCNnZXRQcm9wZXJ0aWVzfS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG9ic2VydmFibGUgcHJvcGVydGllcyBhcmUgc2VwYXJhdGUgZnJvbSBzdGFuZGFyZCBKUyBwcm9wZXJ0aWVzLlxuICogWW91IGNhbiwgZm9yIGV4YW1wbGUsIGdpdmUgeW91ciBtYXAgb2JqZWN0IGEgdGl0bGUgd2l0aFxuICogYG1hcC50aXRsZT0nTmV3IHRpdGxlJ2AgYW5kIHdpdGggYG1hcC5zZXQoJ3RpdGxlJywgJ0Fub3RoZXIgdGl0bGUnKWAuIFRoZVxuICogZmlyc3Qgd2lsbCBiZSBhIGBoYXNPd25Qcm9wZXJ0eWA7IHRoZSBzZWNvbmQgd2lsbCBhcHBlYXIgaW5cbiAqIGBnZXRQcm9wZXJ0aWVzKClgLiBPbmx5IHRoZSBzZWNvbmQgaXMgb2JzZXJ2YWJsZS5cbiAqXG4gKiBQcm9wZXJ0aWVzIGNhbiBiZSBkZWxldGVkIGJ5IHVzaW5nIHRoZSB1bnNldCBtZXRob2QuIEUuZy5cbiAqIG9iamVjdC51bnNldCgnZm9vJykuXG4gKlxuICogQGZpcmVzIE9iamVjdEV2ZW50XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEJhc2VPYmplY3QgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj59IFt2YWx1ZXNdIEFuIG9iamVjdCB3aXRoIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge09iamVjdE9uU2lnbmF0dXJlPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0T25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge09iamVjdE9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvLyBDYWxsIHtAbGluayBtb2R1bGU6b2wvdXRpbC5nZXRVaWR9IHRvIGVuc3VyZSB0aGF0IHRoZSBvcmRlciBvZiBvYmplY3RzJyBpZHMgaXNcbiAgICAvLyB0aGUgc2FtZSBhcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGNyZWF0ZWQuICBUaGlzIGFsc28gaGVscHMgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBvYmplY3QgcHJvcGVydGllcyBhcmUgYWx3YXlzIGFkZGVkIGluIHRoZSBzYW1lIG9yZGVyLCB3aGljaFxuICAgIC8vIGhlbHBzIG1hbnkgSmF2YVNjcmlwdCBlbmdpbmVzIGdlbmVyYXRlIGZhc3RlciBjb2RlLlxuICAgIGdldFVpZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNfID0gbnVsbDtcblxuICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHJldHVybiB7Kn0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiB0aGlzLnZhbHVlc18uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2Ygb2JqZWN0IHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBMaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiAodGhpcy52YWx1ZXNfICYmIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzXykpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3Qgb2YgYWxsIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsICo+fSBPYmplY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnZhbHVlc18gJiYgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZXNfKSkgfHwge307XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy5cbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgKj4/fSBPYmplY3QuXG4gICAqL1xuICBnZXRQcm9wZXJ0aWVzSW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGhhcyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgaGFzUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gISF0aGlzLnZhbHVlc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBPbGQgdmFsdWUuXG4gICAqL1xuICBub3RpZnkoa2V5LCBvbGRWYWx1ZSkge1xuICAgIGxldCBldmVudFR5cGU7XG4gICAgZXZlbnRUeXBlID0gYGNoYW5nZToke2tleX1gO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gICAgfVxuICAgIGV2ZW50VHlwZSA9IE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcihldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE9iamVjdEV2ZW50KGV2ZW50VHlwZSwga2V5LCBvbGRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIGFkZENoYW5nZUxpc3RlbmVyKGtleSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYGNoYW5nZToke2tleX1gLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5MaXN0ZW5lcn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcihrZXksIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGBjaGFuZ2U6JHtrZXl9YCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSk7XG4gICAgaWYgKHNpbGVudCkge1xuICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY29sbGVjdGlvbiBvZiBrZXktdmFsdWUgcGFpcnMuICBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIGFueSBleGlzdGluZ1xuICAgKiBwcm9wZXJ0aWVzIGFuZCBhZGRzIG5ldyBvbmVzIChpdCBkb2VzIG5vdCByZW1vdmUgYW55IGV4aXN0aW5nIHByb3BlcnRpZXMpLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnRdIFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFByb3BlcnRpZXModmFsdWVzLCBzaWxlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWVzW2tleV0sIHNpbGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGFueSBwcm9wZXJ0aWVzIGZyb20gYW5vdGhlciBvYmplY3Qgd2l0aG91dCB0cmlnZ2VyaW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIHtCYXNlT2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGFwcGx5UHJvcGVydGllcyhzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZS52YWx1ZXNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSksIHNvdXJjZS52YWx1ZXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNldHMgYSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVbnNldCB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHVuc2V0KGtleSwgc2lsZW50KSB7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiBrZXkgaW4gdGhpcy52YWx1ZXNfKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgZGVsZXRlIHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgaWYgKGlzRW1wdHkodGhpcy52YWx1ZXNfKSkge1xuICAgICAgICB0aGlzLnZhbHVlc18gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0NvbGxlY3Rpb25FdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBldmVudCBtb2R1bGU6b2wvQ29sbGVjdGlvbi5Db2xsZWN0aW9uRXZlbnQjYWRkXG4gICAqIEBhcGlcbiAgICovXG4gIEFERDogJ2FkZCcsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBpdGVtIGlzIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9Db2xsZWN0aW9uLkNvbGxlY3Rpb25FdmVudCNyZW1vdmVcbiAgICogQGFwaVxuICAgKi9cbiAgUkVNT1ZFOiAncmVtb3ZlJyxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0NvbGxlY3Rpb25cbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFByb3BlcnR5ID0ge1xuICBMRU5HVEg6ICdsZW5ndGgnLFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHlwZS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBhZGRlZCBvciByZW1vdmVkIGVsZW1lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBlbGVtZW50LCBpbmRleCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCBpcyBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHR5cGUge1R9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGFkZGVkIG9yIHJlbW92ZWQgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cblxuLyoqKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8J2NoYW5nZTpsZW5ndGgnLCBpbXBvcnQoXCIuL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTwnYWRkJ3wncmVtb3ZlJywgQ29sbGVjdGlvbkV2ZW50PFQ+LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTpsZW5ndGgnfCdhZGQnfCdyZW1vdmUnLFJldHVybj59IENvbGxlY3Rpb25PblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbdW5pcXVlPWZhbHNlXSBEaXNhbGxvdyB0aGUgc2FtZSBpdGVtIGZyb20gYmVpbmcgYWRkZWQgdG9cbiAqIHRoZSBjb2xsZWN0aW9uIHR3aWNlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQW4gZXhwYW5kZWQgdmVyc2lvbiBvZiBzdGFuZGFyZCBKUyBBcnJheSwgYWRkaW5nIGNvbnZlbmllbmNlIG1ldGhvZHMgZm9yXG4gKiBtYW5pcHVsYXRpb24uIEFkZCBhbmQgcmVtb3ZlIGNoYW5nZXMgdG8gdGhlIENvbGxlY3Rpb24gdHJpZ2dlciBhIENvbGxlY3Rpb25cbiAqIGV2ZW50LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBjb3ZlciBjaGFuZ2VzIHRvIHRoZSBvYmplY3RzIF93aXRoaW5fIHRoZVxuICogQ29sbGVjdGlvbjsgdGhleSB0cmlnZ2VyIGV2ZW50cyBvbiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0LCBub3Qgb24gdGhlXG4gKiBDb2xsZWN0aW9uIGFzIGEgd2hvbGUuXG4gKlxuICogQGZpcmVzIENvbGxlY3Rpb25FdmVudFxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IFthcnJheV0gQXJyYXkuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIENvbGxlY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFycmF5LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbk9uU2lnbmF0dXJlPFQsIGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbk9uU2lnbmF0dXJlPFQsIGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uT25TaWduYXR1cmU8VCwgdm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuaXF1ZV8gPSAhIW9wdGlvbnMudW5pcXVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PFQ+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyYXlfID0gYXJyYXkgPyBhcnJheSA6IFtdO1xuXG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0aGlzLmFzc2VydFVuaXF1ZV8odGhpcy5hcnJheV9baV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTGVuZ3RoXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgd2hpbGUgKHRoaXMuZ2V0TGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudHMgdG8gdGhlIGNvbGxlY3Rpb24uICBUaGlzIHB1c2hlcyBlYWNoIGl0ZW0gaW4gdGhlIHByb3ZpZGVkIGFycmF5XG4gICAqIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PFQ+fSBhcnIgQXJyYXkuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248VD59IFRoaXMgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZXh0ZW5kKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGFyci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0aGlzLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggZWxlbWVudCwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCwgbnVtYmVyLCBBcnJheTxUPik6ICp9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogICAgIGZvciBldmVyeSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uIHRha2VzIDMgYXJndW1lbnRzICh0aGUgZWxlbWVudCwgdGhlXG4gICAqICAgICBpbmRleCBhbmQgdGhlIGFycmF5KS4gVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoKGYpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuYXJyYXlfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGYoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5IG9iamVjdC4gV2FybmluZzogaWYgdGhlIGFycmF5XG4gICAqIGlzIG11dGF0ZWQsIG5vIGV2ZW50cyB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGNvbGxlY3Rpb24sIGFuZCB0aGVcbiAgICogY29sbGVjdGlvbidzIFwibGVuZ3RoXCIgcHJvcGVydHkgd29uJ3QgYmUgaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbGVuZ3RoXG4gICAqIG9mIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7IUFycmF5PFQ+fSBBcnJheS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7VH0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgaXRlbShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5X1tpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsZW5ndGggb2YgdGhpcyBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFByb3BlcnR5LkxFTkdUSCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGFuIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBpbnNlcnRBdChpbmRleCwgZWxlbSkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmdldExlbmd0aCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiBib3VuZHM6ICcgKyBpbmRleCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtKTtcbiAgICB9XG4gICAgdGhpcy5hcnJheV8uc3BsaWNlKGluZGV4LCAwLCBlbGVtKTtcbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuQURELCBlbGVtLCBpbmRleClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gaXQuXG4gICAqIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVBdCh0aGlzLmdldExlbmd0aCgpIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBwcm92aWRlZCBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHB1c2goZWxlbSkge1xuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgdGhpcy5pbnNlcnRBdChuLCBlbGVtKTtcbiAgICByZXR1cm4gdGhpcy5nZXRMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIG5vbmUgZm91bmQuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZShlbGVtKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5hcnJheV87XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleCBhbmQgcmV0dXJuIGl0LlxuICAgKiBSZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlIGNvbGxlY3Rpb24gZG9lcyBub3QgY29udGFpbiB0aGlzIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBWYWx1ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlQXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHByZXYgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgdGhpcy5hcnJheV8uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAvKiogQHR5cGUge0NvbGxlY3Rpb25FdmVudDxUPn0gKi8gKFxuICAgICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLCBwcmV2LCBpbmRleClcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBwcmV2O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEF0KGluZGV4LCBlbGVtKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgaWYgKGluZGV4ID49IG4pIHtcbiAgICAgIHRoaXMuaW5zZXJ0QXQoaW5kZXgsIGVsZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiBib3VuZHM6ICcgKyBpbmRleCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtLCBpbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IHByZXYgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgdGhpcy5hcnJheV9baW5kZXhdID0gZWxlbTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAvKiogQHR5cGUge0NvbGxlY3Rpb25FdmVudDxUPn0gKi8gKFxuICAgICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLCBwcmV2LCBpbmRleClcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbkV2ZW50PFQ+fSAqLyAoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsIGVsZW0sIGluZGV4KVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUxlbmd0aF8oKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuTEVOR1RILCB0aGlzLmFycmF5Xy5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2V4Y2VwdF0gT3B0aW9uYWwgaW5kZXggdG8gaWdub3JlLlxuICAgKi9cbiAgYXNzZXJ0VW5pcXVlXyhlbGVtLCBleGNlcHQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAodGhpcy5hcnJheV9baV0gPT09IGVsZW0gJiYgaSAhPT0gZXhjZXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIGl0ZW0gYWRkZWQgdG8gYSB1bmlxdWUgY29sbGVjdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2xsZWN0aW9uO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9oYXNcbiAqL1xuXG5jb25zdCB1YSA9XG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpXG4gICAgOiAnJztcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggRmlyZWZveCBhcyBicm93c2VyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBGSVJFRk9YID0gdWEuaW5jbHVkZXMoJ2ZpcmVmb3gnKTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggU2FmYXJpIGFzIGJyb3dzZXIuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFNBRkFSSSA9IHVhLmluY2x1ZGVzKCdzYWZhcmknKSAmJiAhdWEuaW5jbHVkZXMoJ2Nocm9tJyk7XG5cbi8qKlxuICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIzNzkwNlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBTQUZBUklfQlVHXzIzNzkwNiA9XG4gIFNBRkFSSSAmJlxuICAodWEuaW5jbHVkZXMoJ3ZlcnNpb24vMTUuNCcpIHx8XG4gICAgL2NwdSAob3N8aXBob25lIG9zKSAxNV80IGxpa2UgbWFjIG9zIHgvLnRlc3QodWEpKTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBXZWJLaXQgZW5naW5lLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBXRUJLSVQgPSB1YS5pbmNsdWRlcygnd2Via2l0JykgJiYgIXVhLmluY2x1ZGVzKCdlZGdlJyk7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgTWFjIGFzIHBsYXRmb3JtLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBNQUMgPSB1YS5pbmNsdWRlcygnbWFjaW50b3NoJyk7XG5cbi8qKlxuICogVGhlIHJhdGlvIGJldHdlZW4gcGh5c2ljYWwgcGl4ZWxzIGFuZCBkZXZpY2UtaW5kZXBlbmRlbnQgcGl4ZWxzXG4gKiAoZGlwcykgb24gdGhlIGRldmljZSAoYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYCkuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBERVZJQ0VfUElYRUxfUkFUSU8gPVxuICB0eXBlb2YgZGV2aWNlUGl4ZWxSYXRpbyAhPT0gJ3VuZGVmaW5lZCcgPyBkZXZpY2VQaXhlbFJhdGlvIDogMTtcblxuLyoqXG4gKiBUaGUgZXhlY3V0aW9uIGNvbnRleHQgaXMgYSB3b3JrZXIgd2l0aCBPZmZzY3JlZW5DYW52YXMgYXZhaWxhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFdPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTID1cbiAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJlxuICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGU7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEltYWdlLnByb3RvdHlwZS5kZWNvZGUoKSBpcyBzdXBwb3J0ZWQuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IElNQUdFX0RFQ09ERSA9XG4gIHR5cGVvZiBJbWFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgSW1hZ2UucHJvdG90eXBlLmRlY29kZTtcblxuLyoqXG4gKiBjcmVhdGVJbWFnZUJpdG1hcCgpIGlzIHN1cHBvcnRlZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgQ1JFQVRFX0lNQUdFX0JJVE1BUCA9IHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBBU1NJVkVfRVZFTlRfTElTVEVORVJTID0gKGZ1bmN0aW9uICgpIHtcbiAgbGV0IHBhc3NpdmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBAdHMtaWdub3JlIElnbm9yZSBpbnZhbGlkIGV2ZW50IHR5cGUgJ18nXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ18nLCBudWxsLCBvcHRpb25zKTtcbiAgICAvLyBAdHMtaWdub3JlIElnbm9yZSBpbnZhbGlkIGV2ZW50IHR5cGUgJ18nXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ18nLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBwYXNzaXZlIG5vdCBzdXBwb3J0ZWRcbiAgfVxuICByZXR1cm4gcGFzc2l2ZTtcbn0pKCk7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2Fzc2VydHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYXNzZXJ0aW9uIEFzc2VydGlvbiB3ZSBleHBlY3RlZCB0byBiZSB0cnV0aHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JNZXNzYWdlIEVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoYXNzZXJ0aW9uLCBlcnJvck1lc3NhZ2UpIHtcbiAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC90cmFuc2Zvcm1cbiAqL1xuaW1wb3J0IHtXT1JLRVJfT0ZGU0NSRUVOX0NBTlZBU30gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvdHJhbnNmb3JtfSBmdW5jdGlvbnMuIFRoZSBhcnJheSBoYXMgNiBlbGVtZW50cy5cbiAqIEB0eXBlZGVmIHshQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMuIFRoZSBmdW5jdGlvbnMgd29yayBvbiBhblxuICogYXJyYXkgb2YgNiBlbGVtZW50cy4gVGhlIGVsZW1lbnQgb3JkZXIgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBbU1ZHTWF0cml4XG4gKiBpbnRlcmZhY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdNYXRyaXgpIGFuZCBpc1xuICogYSBzdWJzZXQgKGVsZW1lbnRzIGEgdG8gZikgb2YgYSAzXHUwMEQ3MyBtYXRyaXg6XG4gKiBgYGBcbiAqIFsgYSBjIGUgXVxuICogWyBiIGQgZiBdXG4gKiBbIDAgMCAxIF1cbiAqIGBgYFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtUcmFuc2Zvcm19XG4gKi9cbmNvbnN0IHRtcF8gPSBuZXcgQXJyYXkoNik7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IElkZW50aXR5IHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAxLCAwLCAwXTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIGdpdmVuIHRyYW5zZm9ybSB0byBhbiBpZGVudGl0eSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUcmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldCh0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIHNldCh0cmFuc2Zvcm0sIDEsIDAsIDAsIDEsIDAsIDApO1xufVxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSB1bmRlcmx5aW5nIG1hdHJpY2VzIG9mIHR3byB0cmFuc2Zvcm1zIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBpblxuICogdGhlIGZpcnN0IHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBUcmFuc2Zvcm0gcGFyYW1ldGVycyBvZiBtYXRyaXggMS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMiBUcmFuc2Zvcm0gcGFyYW1ldGVycyBvZiBtYXRyaXggMi5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTEgbXVsdGlwbGllZCB3aXRoIHRyYW5zZm9ybTIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseSh0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gIGNvbnN0IGExID0gdHJhbnNmb3JtMVswXTtcbiAgY29uc3QgYjEgPSB0cmFuc2Zvcm0xWzFdO1xuICBjb25zdCBjMSA9IHRyYW5zZm9ybTFbMl07XG4gIGNvbnN0IGQxID0gdHJhbnNmb3JtMVszXTtcbiAgY29uc3QgZTEgPSB0cmFuc2Zvcm0xWzRdO1xuICBjb25zdCBmMSA9IHRyYW5zZm9ybTFbNV07XG4gIGNvbnN0IGEyID0gdHJhbnNmb3JtMlswXTtcbiAgY29uc3QgYjIgPSB0cmFuc2Zvcm0yWzFdO1xuICBjb25zdCBjMiA9IHRyYW5zZm9ybTJbMl07XG4gIGNvbnN0IGQyID0gdHJhbnNmb3JtMlszXTtcbiAgY29uc3QgZTIgPSB0cmFuc2Zvcm0yWzRdO1xuICBjb25zdCBmMiA9IHRyYW5zZm9ybTJbNV07XG5cbiAgdHJhbnNmb3JtMVswXSA9IGExICogYTIgKyBjMSAqIGIyO1xuICB0cmFuc2Zvcm0xWzFdID0gYjEgKiBhMiArIGQxICogYjI7XG4gIHRyYW5zZm9ybTFbMl0gPSBhMSAqIGMyICsgYzEgKiBkMjtcbiAgdHJhbnNmb3JtMVszXSA9IGIxICogYzIgKyBkMSAqIGQyO1xuICB0cmFuc2Zvcm0xWzRdID0gYTEgKiBlMiArIGMxICogZjIgKyBlMTtcbiAgdHJhbnNmb3JtMVs1XSA9IGIxICogZTIgKyBkMSAqIGYyICsgZjE7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB0cmFuc2Zvcm0gY29tcG9uZW50cyBhLWYgb24gYSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgYSBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBiIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGMgVGhlIGMgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZCBUaGUgZCBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlIFRoZSBlIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGYgVGhlIGYgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBNYXRyaXggd2l0aCB0cmFuc2Zvcm0gYXBwbGllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldCh0cmFuc2Zvcm0sIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdHJhbnNmb3JtWzBdID0gYTtcbiAgdHJhbnNmb3JtWzFdID0gYjtcbiAgdHJhbnNmb3JtWzJdID0gYztcbiAgdHJhbnNmb3JtWzNdID0gZDtcbiAgdHJhbnNmb3JtWzRdID0gZTtcbiAgdHJhbnNmb3JtWzVdID0gZjtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLyoqXG4gKiBTZXQgdHJhbnNmb3JtIG9uIG9uZSBtYXRyaXggZnJvbSBhbm90aGVyIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBNYXRyaXggdG8gc2V0IHRyYW5zZm9ybSB0by5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMiBNYXRyaXggdG8gc2V0IHRyYW5zZm9ybSBmcm9tLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSB3aXRoIHRyYW5zZm9ybSBmcm9tIHRyYW5zZm9ybTIgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZyb21BcnJheSh0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gIHRyYW5zZm9ybTFbMF0gPSB0cmFuc2Zvcm0yWzBdO1xuICB0cmFuc2Zvcm0xWzFdID0gdHJhbnNmb3JtMlsxXTtcbiAgdHJhbnNmb3JtMVsyXSA9IHRyYW5zZm9ybTJbMl07XG4gIHRyYW5zZm9ybTFbM10gPSB0cmFuc2Zvcm0yWzNdO1xuICB0cmFuc2Zvcm0xWzRdID0gdHJhbnNmb3JtMls0XTtcbiAgdHJhbnNmb3JtMVs1XSA9IHRyYW5zZm9ybTJbNV07XG4gIHJldHVybiB0cmFuc2Zvcm0xO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIGNvb3JkaW5hdGUgd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtIHJldHVybmluZyB0aGVcbiAqIHJlc3VsdGluZywgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZS4gVGhlIGNvb3JkaW5hdGUgd2lsbCBiZSBtb2RpZmllZCBpbi1wbGFjZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtIFRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSByZXR1cm4gY29vcmRpbmF0ZSBzbyB0aGF0IG9wZXJhdGlvbnMgY2FuIGJlXG4gKiAgICAgY2hhaW5lZCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5KHRyYW5zZm9ybSwgY29vcmRpbmF0ZSkge1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIGNvb3JkaW5hdGVbMF0gPSB0cmFuc2Zvcm1bMF0gKiB4ICsgdHJhbnNmb3JtWzJdICogeSArIHRyYW5zZm9ybVs0XTtcbiAgY29vcmRpbmF0ZVsxXSA9IHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bM10gKiB5ICsgdHJhbnNmb3JtWzVdO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHJvdGF0aW9uIHRvIHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSByb3RhdGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZSh0cmFuc2Zvcm0sIGFuZ2xlKSB7XG4gIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICByZXR1cm4gbXVsdGlwbHkodHJhbnNmb3JtLCBzZXQodG1wXywgY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMCkpO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgc2NhbGUgdG8gYSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0geCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFNjYWxlIGZhY3RvciB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHNjYWxlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIHgsIDAsIDAsIHksIDAsIDApKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2NhbGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0YXJnZXQgVHJhbnNmb3JtIHRvIG92ZXJ3cml0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjYWxlIGZhY3RvciB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgc2NhbGUgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVNjYWxlKHRhcmdldCwgeCwgeSkge1xuICByZXR1cm4gc2V0KHRhcmdldCwgeCwgMCwgMCwgeSwgMCwgMCk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0cmFuc2xhdGlvbiB0byB0aGUgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4IFRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkgVHJhbnNsYXRpb24geS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSB0cmFuc2xhdGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIGR4LCBkeSkge1xuICByZXR1cm4gbXVsdGlwbHkodHJhbnNmb3JtLCBzZXQodG1wXywgMSwgMCwgMCwgMSwgZHgsIGR5KSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB0cmFuc2Zvcm0gZ2l2ZW4gYW4gaW5pdGlhbCB0cmFuc2xhdGlvbiwgc2NhbGUsIHJvdGF0aW9uLCBhbmRcbiAqIGZpbmFsIHRyYW5zbGF0aW9uIChpbiB0aGF0IG9yZGVyIG9ubHksIG5vdCBjb21tdXRhdGl2ZSkuXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUaGUgdHJhbnNmb3JtICh3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeDEgSW5pdGlhbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MSBJbml0aWFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gKGluIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MiBGaW5hbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MiBGaW5hbCB0cmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIGNvbXBvc2l0ZSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb3NlKHRyYW5zZm9ybSwgZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB0cmFuc2Zvcm1bMF0gPSBzeCAqIGNvcztcbiAgdHJhbnNmb3JtWzFdID0gc3kgKiBzaW47XG4gIHRyYW5zZm9ybVsyXSA9IC1zeCAqIHNpbjtcbiAgdHJhbnNmb3JtWzNdID0gc3kgKiBjb3M7XG4gIHRyYW5zZm9ybVs0XSA9IGR4MiAqIHN4ICogY29zIC0gZHkyICogc3ggKiBzaW4gKyBkeDE7XG4gIHRyYW5zZm9ybVs1XSA9IGR4MiAqIHN5ICogc2luICsgZHkyICogc3kgKiBjb3MgKyBkeTE7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB0cmFuc2Zvcm0gZ2l2ZW4gYW4gaW5pdGlhbCB0cmFuc2xhdGlvbiwgc2NhbGUsIHJvdGF0aW9uLCBhbmRcbiAqIGZpbmFsIHRyYW5zbGF0aW9uIChpbiB0aGF0IG9yZGVyIG9ubHksIG5vdCBjb21tdXRhdGl2ZSkuIFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtXG4gKiBzdHJpbmcgY2FuIGJlIGFwcGxpZWQgYXMgYHRyYW5zZm9ybWAgcHJvcGVydHkgb2YgYW4gSFRNTEVsZW1lbnQncyBzdHlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeDEgSW5pdGlhbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MSBJbml0aWFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gKGluIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MiBGaW5hbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MiBGaW5hbCB0cmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcG9zaXRlIGNzcyB0cmFuc2Zvcm0uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb3NlQ3NzVHJhbnNmb3JtKGR4MSwgZHkxLCBzeCwgc3ksIGFuZ2xlLCBkeDIsIGR5Mikge1xuICByZXR1cm4gdG9TdHJpbmcoY29tcG9zZShjcmVhdGUoKSwgZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKSk7XG59XG5cbi8qKlxuICogSW52ZXJ0IHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHNvdXJjZSBUaGUgc291cmNlIHRyYW5zZm9ybSB0byBpbnZlcnQuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgaW52ZXJ0ZWQgKHNvdXJjZSkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KHNvdXJjZSkge1xuICByZXR1cm4gbWFrZUludmVyc2Uoc291cmNlLCBzb3VyY2UpO1xufVxuXG4vKipcbiAqIEludmVydCB0aGUgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0YXJnZXQgVHJhbnNmb3JtIHRvIGJlIHNldCBhcyB0aGUgaW52ZXJzZSBvZlxuICogICAgIHRoZSBzb3VyY2UgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSBzb3VyY2UgVGhlIHNvdXJjZSB0cmFuc2Zvcm0gdG8gaW52ZXJ0LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIGludmVydGVkICh0YXJnZXQpIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VJbnZlcnNlKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IGRldCA9IGRldGVybWluYW50KHNvdXJjZSk7XG4gIGFzc2VydChkZXQgIT09IDAsICdUcmFuc2Zvcm1hdGlvbiBtYXRyaXggY2Fubm90IGJlIGludmVydGVkJyk7XG5cbiAgY29uc3QgYSA9IHNvdXJjZVswXTtcbiAgY29uc3QgYiA9IHNvdXJjZVsxXTtcbiAgY29uc3QgYyA9IHNvdXJjZVsyXTtcbiAgY29uc3QgZCA9IHNvdXJjZVszXTtcbiAgY29uc3QgZSA9IHNvdXJjZVs0XTtcbiAgY29uc3QgZiA9IHNvdXJjZVs1XTtcblxuICB0YXJnZXRbMF0gPSBkIC8gZGV0O1xuICB0YXJnZXRbMV0gPSAtYiAvIGRldDtcbiAgdGFyZ2V0WzJdID0gLWMgLyBkZXQ7XG4gIHRhcmdldFszXSA9IGEgLyBkZXQ7XG4gIHRhcmdldFs0XSA9IChjICogZiAtIGQgKiBlKSAvIGRldDtcbiAgdGFyZ2V0WzVdID0gLShhICogZiAtIGIgKiBlKSAvIGRldDtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRldGVybWluYW50IG9mIHRoZSBnaXZlbiBtYXRyaXguXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IG1hdCBNYXRyaXguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERldGVybWluYW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQobWF0KSB7XG4gIHJldHVybiBtYXRbMF0gKiBtYXRbM10gLSBtYXRbMV0gKiBtYXRbMl07XG59XG5cbi8qKlxuICogQHR5cGUge0hUTUxFbGVtZW50fVxuICogQHByaXZhdGVcbiAqL1xubGV0IHRyYW5zZm9ybVN0cmluZ0RpdjtcblxuLyoqXG4gKiBBIHJvdW5kZWQgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHRyYW5zZm9ybS4gIFRoaXMgY2FuIGJlIHVzZWRcbiAqIGZvciBDU1MgdHJhbnNmb3Jtcy5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gbWF0IE1hdHJpeC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRyYW5zZm9ybSBhcyBhIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKG1hdCkge1xuICBjb25zdCB0cmFuc2Zvcm1TdHJpbmcgPSAnbWF0cml4KCcgKyBtYXQuam9pbignLCAnKSArICcpJztcbiAgaWYgKFdPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZztcbiAgfVxuICBjb25zdCBub2RlID1cbiAgICB0cmFuc2Zvcm1TdHJpbmdEaXYgfHwgKHRyYW5zZm9ybVN0cmluZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1TdHJpbmc7XG4gIHJldHVybiBub2RlLnN0eWxlLnRyYW5zZm9ybTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50L1JlbGF0aW9uc2hpcFxuICovXG5cbi8qKlxuICogUmVsYXRpb25zaGlwIHRvIGFuIGV4dGVudC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVU5LTk9XTjogMCxcbiAgSU5URVJTRUNUSU5HOiAxLFxuICBBQk9WRTogMixcbiAgUklHSFQ6IDQsXG4gIEJFTE9XOiA4LFxuICBMRUZUOiAxNixcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudFxuICovXG5pbXBvcnQgUmVsYXRpb25zaGlwIGZyb20gJy4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4gZXh0ZW50OiBgW21pbngsIG1pbnksIG1heHgsIG1heHldYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBFeHRlbnRcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEV4dGVudCBjb3JuZXIuXG4gKiBAdHlwZWRlZiB7J2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tcmlnaHQnIHwgJ3RvcC1sZWZ0JyB8ICd0b3AtcmlnaHQnfSBDb3JuZXJcbiAqL1xuXG4vKipcbiAqIEJ1aWxkIGFuIGV4dGVudCB0aGF0IGluY2x1ZGVzIGFsbCBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEJvdW5kaW5nIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5kaW5nRXh0ZW50KGNvb3JkaW5hdGVzKSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4cyBYcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geXMgWXMuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZnVuY3Rpb24gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgZGVzdCkge1xuICBjb25zdCBtaW5YID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeHMpO1xuICBjb25zdCBtaW5ZID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeXMpO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeHMpO1xuICBjb25zdCBtYXhZID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeXMpO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgZGVzdCk7XG59XG5cbi8qKlxuICogUmV0dXJuIGV4dGVudCBpbmNyZWFzZWQgYnkgdGhlIHByb3ZpZGVkIHZhbHVlLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGFtb3VudCBieSB3aGljaCB0aGUgZXh0ZW50IHNob3VsZCBiZSBidWZmZXJlZC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoZXh0ZW50LCB2YWx1ZSwgZGVzdCkge1xuICBpZiAoZGVzdCkge1xuICAgIGRlc3RbMF0gPSBleHRlbnRbMF0gLSB2YWx1ZTtcbiAgICBkZXN0WzFdID0gZXh0ZW50WzFdIC0gdmFsdWU7XG4gICAgZGVzdFsyXSA9IGV4dGVudFsyXSArIHZhbHVlO1xuICAgIGRlc3RbM10gPSBleHRlbnRbM10gKyB2YWx1ZTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICByZXR1cm4gW1xuICAgIGV4dGVudFswXSAtIHZhbHVlLFxuICAgIGV4dGVudFsxXSAtIHZhbHVlLFxuICAgIGV4dGVudFsyXSArIHZhbHVlLFxuICAgIGV4dGVudFszXSArIHZhbHVlLFxuICBdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gVGhlIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoZXh0ZW50LCBkZXN0KSB7XG4gIGlmIChkZXN0KSB7XG4gICAgZGVzdFswXSA9IGV4dGVudFswXTtcbiAgICBkZXN0WzFdID0gZXh0ZW50WzFdO1xuICAgIGRlc3RbMl0gPSBleHRlbnRbMl07XG4gICAgZGVzdFszXSA9IGV4dGVudFszXTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICByZXR1cm4gZXh0ZW50LnNsaWNlKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge251bWJlcn0gQ2xvc2VzdCBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKGV4dGVudCwgeCwgeSkge1xuICBsZXQgZHgsIGR5O1xuICBpZiAoeCA8IGV4dGVudFswXSkge1xuICAgIGR4ID0gZXh0ZW50WzBdIC0geDtcbiAgfSBlbHNlIGlmIChleHRlbnRbMl0gPCB4KSB7XG4gICAgZHggPSB4IC0gZXh0ZW50WzJdO1xuICB9IGVsc2Uge1xuICAgIGR4ID0gMDtcbiAgfVxuICBpZiAoeSA8IGV4dGVudFsxXSkge1xuICAgIGR5ID0gZXh0ZW50WzFdIC0geTtcbiAgfSBlbHNlIGlmIChleHRlbnRbM10gPCB5KSB7XG4gICAgZHkgPSB5IC0gZXh0ZW50WzNdO1xuICB9IGVsc2Uge1xuICAgIGR5ID0gMDtcbiAgfVxuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBvciBvbiB0aGUgZWRnZSBvZiB0aGUgZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Nvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIHJldHVybiBjb250YWluc1hZKGV4dGVudCwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgb25lIGV4dGVudCBjb250YWlucyBhbm90aGVyLlxuICpcbiAqIEFuIGV4dGVudCBpcyBkZWVtZWQgY29udGFpbmVkIGlmIGl0IGxpZXMgY29tcGxldGVseSB3aXRoaW4gdGhlIG90aGVyIGV4dGVudCxcbiAqIGluY2x1ZGluZyBpZiB0aGV5IHNoYXJlIG9uZSBvciBtb3JlIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2Vjb25kIGV4dGVudCBpcyBjb250YWluZWQgYnkgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlXG4gKiAgICAgZmlyc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0V4dGVudChleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiAoXG4gICAgZXh0ZW50MVswXSA8PSBleHRlbnQyWzBdICYmXG4gICAgZXh0ZW50MlsyXSA8PSBleHRlbnQxWzJdICYmXG4gICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzFdICYmXG4gICAgZXh0ZW50MlszXSA8PSBleHRlbnQxWzNdXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBvciBvbiB0aGUgZWRnZSBvZiB0aGUgZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWSBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHgsIHkgdmFsdWVzIGFyZSBjb250YWluZWQgaW4gdGhlIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zWFkoZXh0ZW50LCB4LCB5KSB7XG4gIHJldHVybiBleHRlbnRbMF0gPD0geCAmJiB4IDw9IGV4dGVudFsyXSAmJiBleHRlbnRbMV0gPD0geSAmJiB5IDw9IGV4dGVudFszXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEgY29vcmRpbmF0ZSBhbmQgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qc1wiKS5kZWZhdWx0fSBUaGUgcmVsYXRpb25zaGlwIChiaXR3aXNlIGNvbXBhcmUgd2l0aFxuICogICAgIGltcG9ydChcIi4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qc1wiKS5SZWxhdGlvbnNoaXApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgY29uc3QgbWF4WCA9IGV4dGVudFsyXTtcbiAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgY29uc3QgeCA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdO1xuICBsZXQgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLlVOS05PV047XG4gIGlmICh4IDwgbWluWCkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5MRUZUO1xuICB9IGVsc2UgaWYgKHggPiBtYXhYKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLlJJR0hUO1xuICB9XG4gIGlmICh5IDwgbWluWSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5CRUxPVztcbiAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5BQk9WRTtcbiAgfVxuICBpZiAocmVsYXRpb25zaGlwID09PSBSZWxhdGlvbnNoaXAuVU5LTk9XTikge1xuICAgIHJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkc7XG4gIH1cbiAgcmV0dXJuIHJlbGF0aW9uc2hpcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZW1wdHkgZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFbXB0eSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eSgpIHtcbiAgcmV0dXJuIFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXh0ZW50IG9yIHVwZGF0ZSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gbWluWDtcbiAgICBkZXN0WzFdID0gbWluWTtcbiAgICBkZXN0WzJdID0gbWF4WDtcbiAgICBkZXN0WzNdID0gbWF4WTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICByZXR1cm4gW21pblgsIG1pblksIG1heFgsIG1heFldO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbXB0eSBleHRlbnQgb3IgbWFrZSB0aGUgcHJvdmlkZWQgb25lIGVtcHR5LlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCkge1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSwgZGVzdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZGVzdCkge1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZSh4LCB5LCB4LCB5LCBkZXN0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGRlc3QpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KTtcbiAgcmV0dXJuIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGRlc3Rcbikge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlc3QpO1xuICByZXR1cm4gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbVJpbmdzKHJpbmdzLCBkZXN0KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIHJldHVybiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGFyZSBlcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIChcbiAgICBleHRlbnQxWzBdID09IGV4dGVudDJbMF0gJiZcbiAgICBleHRlbnQxWzJdID09IGV4dGVudDJbMl0gJiZcbiAgICBleHRlbnQxWzFdID09IGV4dGVudDJbMV0gJiZcbiAgICBleHRlbnQxWzNdID09IGV4dGVudDJbM11cbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGFwcHJveGltYXRlbHkgZXF1aXZhbGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZSBpbiBleHRlbnQgY29vcmRpbmF0ZSB1bml0cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBkaWZmZXIgYnkgbGVzcyB0aGFuIHRoZSB0b2xlcmFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHByb3hpbWF0ZWx5RXF1YWxzKGV4dGVudDEsIGV4dGVudDIsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gKFxuICAgIE1hdGguYWJzKGV4dGVudDFbMF0gLSBleHRlbnQyWzBdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbMl0gLSBleHRlbnQyWzJdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbMV0gLSBleHRlbnQyWzFdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbM10gLSBleHRlbnQyWzNdKSA8IHRvbGVyYW5jZVxuICApO1xufVxuXG4vKipcbiAqIE1vZGlmeSBhbiBleHRlbnQgdG8gaW5jbHVkZSBhbm90aGVyIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIFRoZSBleHRlbnQgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBUaGUgZXh0ZW50IHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgZmlyc3QuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCAoZXh0ZW5kZWQpIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChleHRlbnQxLCBleHRlbnQyKSB7XG4gIGlmIChleHRlbnQyWzBdIDwgZXh0ZW50MVswXSkge1xuICAgIGV4dGVudDFbMF0gPSBleHRlbnQyWzBdO1xuICB9XG4gIGlmIChleHRlbnQyWzJdID4gZXh0ZW50MVsyXSkge1xuICAgIGV4dGVudDFbMl0gPSBleHRlbnQyWzJdO1xuICB9XG4gIGlmIChleHRlbnQyWzFdIDwgZXh0ZW50MVsxXSkge1xuICAgIGV4dGVudDFbMV0gPSBleHRlbnQyWzFdO1xuICB9XG4gIGlmIChleHRlbnQyWzNdID4gZXh0ZW50MVszXSkge1xuICAgIGV4dGVudDFbM10gPSBleHRlbnQyWzNdO1xuICB9XG4gIHJldHVybiBleHRlbnQxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgaWYgKGNvb3JkaW5hdGVbMF0gPCBleHRlbnRbMF0pIHtcbiAgICBleHRlbnRbMF0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzBdID4gZXh0ZW50WzJdKSB7XG4gICAgZXh0ZW50WzJdID0gY29vcmRpbmF0ZVswXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA8IGV4dGVudFsxXSkge1xuICAgIGV4dGVudFsxXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMV0gPiBleHRlbnRbM10pIHtcbiAgICBleHRlbnRbM10gPSBjb29yZGluYXRlWzFdO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEZsYXRDb29yZGluYXRlcyhcbiAgZXh0ZW50LFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGVcbikge1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgZXh0ZW5kWFkoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSByaW5ncyBSaW5ncy5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kUmluZ3MoZXh0ZW50LCByaW5ncykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSByaW5ncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCByaW5nc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGV4dGVudFswXSA9IE1hdGgubWluKGV4dGVudFswXSwgeCk7XG4gIGV4dGVudFsxXSA9IE1hdGgubWluKGV4dGVudFsxXSwgeSk7XG4gIGV4dGVudFsyXSA9IE1hdGgubWF4KGV4dGVudFsyXSwgeCk7XG4gIGV4dGVudFszXSA9IE1hdGgubWF4KGV4dGVudFszXSwgeSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50LiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdCB2YWx1ZVxuICogaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogU30gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcmV0dXJuIHtTfGJvb2xlYW59IFZhbHVlLlxuICogQHRlbXBsYXRlIFNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hDb3JuZXIoZXh0ZW50LCBjYWxsYmFjaykge1xuICBsZXQgdmFsO1xuICB2YWwgPSBjYWxsYmFjayhnZXRCb3R0b21MZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjayhnZXRCb3R0b21SaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2soZ2V0VG9wUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrKGdldFRvcExlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGV4dGVudCkge1xuICBsZXQgYXJlYSA9IDA7XG4gIGlmICghaXNFbXB0eShleHRlbnQpKSB7XG4gICAgYXJlYSA9IGdldFdpZHRoKGV4dGVudCkgKiBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbUxlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbMV1dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21SaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFsxXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDZW50ZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDZW50ZXIoZXh0ZW50KSB7XG4gIHJldHVybiBbKGV4dGVudFswXSArIGV4dGVudFsyXSkgLyAyLCAoZXh0ZW50WzFdICsgZXh0ZW50WzNdKSAvIDJdO1xufVxuXG4vKipcbiAqIEdldCBhIGNvcm5lciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBDb3JuZXIuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29ybmVyIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpIHtcbiAgbGV0IGNvb3JkaW5hdGU7XG4gIGlmIChjb3JuZXIgPT09ICdib3R0b20tbGVmdCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gJ2JvdHRvbS1yaWdodCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09ICd0b3AtbGVmdCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gJ3RvcC1yaWdodCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29ybmVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5sYXJnZWQgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVubGFyZ2VkQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbihleHRlbnQxWzBdLCBleHRlbnQyWzBdKTtcbiAgY29uc3QgbWluWSA9IE1hdGgubWluKGV4dGVudDFbMV0sIGV4dGVudDJbMV0pO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXgoZXh0ZW50MVsyXSwgZXh0ZW50MlsyXSk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heChleHRlbnQxWzNdLCBleHRlbnQyWzNdKTtcbiAgcmV0dXJuIChtYXhYIC0gbWluWCkgKiAobWF4WSAtIG1pblkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUsIGRlc3QpIHtcbiAgY29uc3QgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5M10gPSBnZXRSb3RhdGVkVmlld3BvcnQoXG4gICAgY2VudGVyLFxuICAgIHJlc29sdXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgc2l6ZVxuICApO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoXG4gICAgTWF0aC5taW4oeDAsIHgxLCB4MiwgeDMpLFxuICAgIE1hdGgubWluKHkwLCB5MSwgeTIsIHkzKSxcbiAgICBNYXRoLm1heCh4MCwgeDEsIHgyLCB4MyksXG4gICAgTWF0aC5tYXgoeTAsIHkxLCB5MiwgeTMpLFxuICAgIGRlc3RcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IExpbmVhciByaW5nIHJlcHJlc2VudGluZyB0aGUgdmlld3BvcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGVkVmlld3BvcnQoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSkge1xuICBjb25zdCBkeCA9IChyZXNvbHV0aW9uICogc2l6ZVswXSkgLyAyO1xuICBjb25zdCBkeSA9IChyZXNvbHV0aW9uICogc2l6ZVsxXSkgLyAyO1xuICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gIGNvbnN0IHhDb3MgPSBkeCAqIGNvc1JvdGF0aW9uO1xuICBjb25zdCB4U2luID0gZHggKiBzaW5Sb3RhdGlvbjtcbiAgY29uc3QgeUNvcyA9IGR5ICogY29zUm90YXRpb247XG4gIGNvbnN0IHlTaW4gPSBkeSAqIHNpblJvdGF0aW9uO1xuICBjb25zdCB4ID0gY2VudGVyWzBdO1xuICBjb25zdCB5ID0gY2VudGVyWzFdO1xuICByZXR1cm4gW1xuICAgIHggLSB4Q29zICsgeVNpbixcbiAgICB5IC0geFNpbiAtIHlDb3MsXG4gICAgeCAtIHhDb3MgLSB5U2luLFxuICAgIHkgLSB4U2luICsgeUNvcyxcbiAgICB4ICsgeENvcyAtIHlTaW4sXG4gICAgeSArIHhTaW4gKyB5Q29zLFxuICAgIHggKyB4Q29zICsgeVNpbixcbiAgICB5ICsgeFNpbiAtIHlDb3MsXG4gICAgeCAtIHhDb3MgKyB5U2luLFxuICAgIHkgLSB4U2luIC0geUNvcyxcbiAgXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGhlaWdodCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzNdIC0gZXh0ZW50WzFdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVyc2VjdGlvbiBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IGdldEludGVyc2VjdGlvbihleHRlbnQxLCBleHRlbnQyKTtcbiAgcmV0dXJuIGdldEFyZWEoaW50ZXJzZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZXh0ZW50cy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIE9wdGlvbmFsIGV4dGVudCB0byBwb3B1bGF0ZSB3aXRoIGludGVyc2VjdGlvbi5cbiAqIEByZXR1cm4ge0V4dGVudH0gSW50ZXJzZWN0aW5nIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihleHRlbnQxLCBleHRlbnQyLCBkZXN0KSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IGRlc3QgPyBkZXN0IDogY3JlYXRlRW1wdHkoKTtcbiAgaWYgKGludGVyc2VjdHMoZXh0ZW50MSwgZXh0ZW50MikpIHtcbiAgICBpZiAoZXh0ZW50MVswXSA+IGV4dGVudDJbMF0pIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDFbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDJbMF07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzFdID4gZXh0ZW50MlsxXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MlsxXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMl0gPCBleHRlbnQyWzJdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQxWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQyWzJdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVszXSA8IGV4dGVudDJbM10pIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDFbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoaW50ZXJzZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBNYXJnaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJnaW4oZXh0ZW50KSB7XG4gIHJldHVybiBnZXRXaWR0aChleHRlbnQpICsgZ2V0SGVpZ2h0KGV4dGVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplICh3aWR0aCwgaGVpZ2h0KSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gVGhlIGV4dGVudCBzaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZShleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0gLSBleHRlbnRbMF0sIGV4dGVudFszXSAtIGV4dGVudFsxXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BMZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzNdXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbM11dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2lkdGgoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gLSBleHRlbnRbMF07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG9uZSBleHRlbnQgaW50ZXJzZWN0cyBhbm90aGVyLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgaW50ZXJzZWN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiAoXG4gICAgZXh0ZW50MVswXSA8PSBleHRlbnQyWzJdICYmXG4gICAgZXh0ZW50MVsyXSA+PSBleHRlbnQyWzBdICYmXG4gICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzNdICYmXG4gICAgZXh0ZW50MVszXSA+PSBleHRlbnQyWzFdXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGV4dGVudCBpcyBlbXB0eS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzJdIDwgZXh0ZW50WzBdIHx8IGV4dGVudFszXSA8IGV4dGVudFsxXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5PclVwZGF0ZShleHRlbnQsIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gZXh0ZW50WzBdO1xuICAgIGRlc3RbMV0gPSBleHRlbnRbMV07XG4gICAgZGVzdFsyXSA9IGV4dGVudFsyXTtcbiAgICBkZXN0WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUZyb21DZW50ZXIoZXh0ZW50LCB2YWx1ZSkge1xuICBjb25zdCBkZWx0YVggPSAoKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBjb25zdCBkZWx0YVkgPSAoKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBleHRlbnRbMF0gLT0gZGVsdGFYO1xuICBleHRlbnRbMl0gKz0gZGVsdGFYO1xuICBleHRlbnRbMV0gLT0gZGVsdGFZO1xuICBleHRlbnRbM10gKz0gZGVsdGFZO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgc2VnbWVudCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyBpbnRlcnNlY3RzIChjcm9zc2VzLFxuICogdG91Y2hlcywgb3IgaXMgY29udGFpbmVkIGJ5KSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gc3RhcnQgU2VnbWVudCBzdGFydCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZW5kIFNlZ21lbnQgZW5kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzU2VnbWVudChleHRlbnQsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGludGVyc2VjdHMgPSBmYWxzZTtcbiAgY29uc3Qgc3RhcnRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgc3RhcnQpO1xuICBjb25zdCBlbmRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgZW5kKTtcbiAgaWYgKFxuICAgIHN0YXJ0UmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HIHx8XG4gICAgZW5kUmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HXG4gICkge1xuICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gICAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICAgIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gICAgY29uc3Qgc3RhcnRYID0gc3RhcnRbMF07XG4gICAgY29uc3Qgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgY29uc3QgZW5kWCA9IGVuZFswXTtcbiAgICBjb25zdCBlbmRZID0gZW5kWzFdO1xuICAgIGNvbnN0IHNsb3BlID0gKGVuZFkgLSBzdGFydFkpIC8gKGVuZFggLSBzdGFydFgpO1xuICAgIGxldCB4LCB5O1xuICAgIGlmICghIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpICYmICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHRvcFxuICAgICAgeCA9IGVuZFggLSAoZW5kWSAtIG1heFkpIC8gc2xvcGU7XG4gICAgICBpbnRlcnNlY3RzID0geCA+PSBtaW5YICYmIHggPD0gbWF4WDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWludGVyc2VjdHMgJiZcbiAgICAgICEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5SSUdIVCkgJiZcbiAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpXG4gICAgKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHJpZ2h0XG4gICAgICB5ID0gZW5kWSAtIChlbmRYIC0gbWF4WCkgKiBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSAmJlxuICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5CRUxPVylcbiAgICApIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgYm90dG9tXG4gICAgICB4ID0gZW5kWCAtIChlbmRZIC0gbWluWSkgLyBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkxFRlQpICYmXG4gICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkxFRlQpXG4gICAgKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGxlZnRcbiAgICAgIHkgPSBlbmRZIC0gKGVuZFggLSBtaW5YKSAqIHNsb3BlO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcnNlY3RzO1xufVxuXG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBDYWxsZWQgd2l0aCBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBleHRlbnQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcHNdIE51bWJlciBvZiBzdG9wcyBwZXIgc2lkZSB1c2VkIGZvciB0aGUgdHJhbnNmb3JtLlxuICogQnkgZGVmYXVsdCBvbmx5IHRoZSBjb3JuZXJzIGFyZSB1c2VkLlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZuLCBkZXN0LCBzdG9wcykge1xuICBpZiAoaXNFbXB0eShleHRlbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIH1cbiAgbGV0IGNvb3JkaW5hdGVzID0gW107XG4gIGlmIChzdG9wcyA+IDEpIHtcbiAgICBjb25zdCB3aWR0aCA9IGV4dGVudFsyXSAtIGV4dGVudFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSBleHRlbnRbM10gLSBleHRlbnRbMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wczsgKytpKSB7XG4gICAgICBjb29yZGluYXRlcy5wdXNoKFxuICAgICAgICBleHRlbnRbMF0gKyAod2lkdGggKiBpKSAvIHN0b3BzLFxuICAgICAgICBleHRlbnRbMV0sXG4gICAgICAgIGV4dGVudFsyXSxcbiAgICAgICAgZXh0ZW50WzFdICsgKGhlaWdodCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFsyXSAtICh3aWR0aCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFszXSxcbiAgICAgICAgZXh0ZW50WzBdLFxuICAgICAgICBleHRlbnRbM10gLSAoaGVpZ2h0ICogaSkgLyBzdG9wc1xuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29vcmRpbmF0ZXMgPSBbXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbM10sXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbM10sXG4gICAgXTtcbiAgfVxuICB0cmFuc2Zvcm1Gbihjb29yZGluYXRlcywgY29vcmRpbmF0ZXMsIDIpO1xuICBjb25zdCB4cyA9IFtdO1xuICBjb25zdCB5cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHhzLnB1c2goY29vcmRpbmF0ZXNbaV0pO1xuICAgIHlzLnB1c2goY29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgfVxuICByZXR1cm4gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgZGVzdCk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHByb3ZpZGVkIGV4dGVudCBpbi1wbGFjZSB0byBiZSB3aXRoaW4gdGhlIHJlYWwgd29ybGRcbiAqIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uXG4gKiBAcmV0dXJuIHtFeHRlbnR9IFRoZSBleHRlbnQgd2l0aGluIHRoZSByZWFsIHdvcmxkIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKGV4dGVudCwgcHJvamVjdGlvbikge1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgY29uc3QgY2VudGVyID0gZ2V0Q2VudGVyKGV4dGVudCk7XG4gIGlmIChcbiAgICBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAoY2VudGVyWzBdIDwgcHJvamVjdGlvbkV4dGVudFswXSB8fCBjZW50ZXJbMF0gPj0gcHJvamVjdGlvbkV4dGVudFsyXSlcbiAgKSB7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgIGNvbnN0IHdvcmxkc0F3YXkgPSBNYXRoLmZsb29yKFxuICAgICAgKGNlbnRlclswXSAtIHByb2plY3Rpb25FeHRlbnRbMF0pIC8gd29ybGRXaWR0aFxuICAgICk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gd29ybGRzQXdheSAqIHdvcmxkV2lkdGg7XG4gICAgZXh0ZW50WzBdIC09IG9mZnNldDtcbiAgICBleHRlbnRbMl0gLT0gb2Zmc2V0O1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogRml0cyB0aGUgZXh0ZW50IHRvIHRoZSByZWFsIHdvcmxkXG4gKlxuICogSWYgdGhlIGV4dGVudCBkb2VzIG5vdCBjcm9zcyB0aGUgYW50aSBtZXJpZGlhbiwgdGhpcyB3aWxsIHJldHVybiB0aGUgZXh0ZW50IGluIGFuIGFycmF5XG4gKiBJZiB0aGUgZXh0ZW50IGNyb3NzZXMgdGhlIGFudGkgbWVyaWRpYW4sIHRoZSBleHRlbnQgd2lsbCBiZSBzbGljZWQsIHNvIGVhY2ggcGFydCBmaXRzIHdpdGhpbiB0aGVcbiAqIHJlYWwgd29ybGRcbiAqXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvblxuICogQHJldHVybiB7QXJyYXk8RXh0ZW50Pn0gVGhlIGV4dGVudCB3aXRoaW4gdGhlIHJlYWwgd29ybGQgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcEFuZFNsaWNlWChleHRlbnQsIHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSkge1xuICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuXG4gICAgaWYgKCFpc0Zpbml0ZShleHRlbnRbMF0pIHx8ICFpc0Zpbml0ZShleHRlbnRbMl0pKSB7XG4gICAgICByZXR1cm4gW1twcm9qZWN0aW9uRXh0ZW50WzBdLCBleHRlbnRbMV0sIHByb2plY3Rpb25FeHRlbnRbMl0sIGV4dGVudFszXV1dO1xuICAgIH1cblxuICAgIHdyYXBYKGV4dGVudCwgcHJvamVjdGlvbik7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuXG4gICAgaWYgKGdldFdpZHRoKGV4dGVudCkgPiB3b3JsZFdpZHRoKSB7XG4gICAgICAvLyB0aGUgZXh0ZW50IHdyYXBzIGFyb3VuZCBvbiBpdHNlbGZcbiAgICAgIHJldHVybiBbW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXV07XG4gICAgfVxuICAgIGlmIChleHRlbnRbMF0gPCBwcm9qZWN0aW9uRXh0ZW50WzBdKSB7XG4gICAgICAvLyB0aGUgZXh0ZW50IGNyb3NzZXMgdGhlIGFudGkgbWVyaWRpYW4sIHNvIGl0IG5lZWRzIHRvIGJlIHNsaWNlZFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW2V4dGVudFswXSArIHdvcmxkV2lkdGgsIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXSxcbiAgICAgICAgW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgZXh0ZW50WzJdLCBleHRlbnRbM11dLFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudFsyXSA+IHByb2plY3Rpb25FeHRlbnRbMl0pIHtcbiAgICAgIC8vIHRoZSBleHRlbnQgY3Jvc3NlcyB0aGUgYW50aSBtZXJpZGlhbiwgc28gaXQgbmVlZHMgdG8gYmUgc2xpY2VkXG4gICAgICByZXR1cm4gW1xuICAgICAgICBbZXh0ZW50WzBdLCBleHRlbnRbMV0sIHByb2plY3Rpb25FeHRlbnRbMl0sIGV4dGVudFszXV0sXG4gICAgICAgIFtwcm9qZWN0aW9uRXh0ZW50WzBdLCBleHRlbnRbMV0sIGV4dGVudFsyXSAtIHdvcmxkV2lkdGgsIGV4dGVudFszXV0sXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbZXh0ZW50XTtcbn1cbiIsICIvKipcbiAqIFJHQiBzcGFjZS5cbiAqXG4gKiBAbW9kdWxlICBjb2xvci1zcGFjZS9yZ2JcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdG5hbWU6ICdyZ2InLFxuXHRtaW46IFswLDAsMF0sXG5cdG1heDogWzI1NSwyNTUsMjU1XSxcblx0Y2hhbm5lbDogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRhbGlhczogWydSR0InXVxufTtcbiIsICIvKipcbiAqIENJRSBYWVpcbiAqXG4gKiBAbW9kdWxlICBjb2xvci1zcGFjZS94eXpcbiAqL1xuaW1wb3J0IHJnYiBmcm9tICcuL3JnYi5qcyc7XG5cbnZhciB4eXogPSB7XG5cdG5hbWU6ICd4eXonLFxuXHRtaW46IFswLDAsMF0sXG5cdGNoYW5uZWw6IFsnWCcsJ1knLCdaJ10sXG5cdGFsaWFzOiBbJ1hZWicsICdjaWV4eXonLCAnY2llMTkzMSddXG59O1xuXG5cbi8qKlxuICogV2hpdGVwb2ludCByZWZlcmVuY2UgdmFsdWVzIHdpdGggb2JzZXJ2ZXIvaWxsdW1pbmFudFxuICpcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmRhcmRfaWxsdW1pbmFudFxuICovXG54eXoud2hpdGVwb2ludCA9IHtcblx0Ly8xOTMxIDJcdTAwQjBcblx0Mjoge1xuXHRcdC8vaW5jYWRlc2NlbnRcblx0XHRBOlsxMDkuODUsIDEwMCwgMzUuNTg1XSxcblx0XHQvLyBCOltdLFxuXHRcdEM6IFs5OC4wNzQsIDEwMCwgMTE4LjIzMl0sXG5cdFx0RDUwOiBbOTYuNDIyLCAxMDAsIDgyLjUyMV0sXG5cdFx0RDU1OiBbOTUuNjgyLCAxMDAsIDkyLjE0OV0sXG5cdFx0Ly9kYXlsaWdodFxuXHRcdEQ2NTogWzk1LjA0NTU5MjcwNTE2NywgMTAwLCAxMDguOTA1Nzc1MDc1OTg3OF0sXG5cdFx0RDc1OiBbOTQuOTcyLCAxMDAsIDEyMi42MzhdLFxuXHRcdC8vZmxvdXJlc2NlbnRcblx0XHQvLyBGMTogW10sXG5cdFx0RjI6IFs5OS4xODcsIDEwMCwgNjcuMzk1XSxcblx0XHQvLyBGMzogW10sXG5cdFx0Ly8gRjQ6IFtdLFxuXHRcdC8vIEY1OiBbXSxcblx0XHQvLyBGNjpbXSxcblx0XHRGNzogWzk1LjA0NCwgMTAwLCAxMDguNzU1XSxcblx0XHQvLyBGODogW10sXG5cdFx0Ly8gRjk6IFtdLFxuXHRcdC8vIEYxMDogW10sXG5cdFx0RjExOiBbMTAwLjk2NiwgMTAwLCA2NC4zNzBdLFxuXHRcdC8vIEYxMjogW10sXG5cdFx0RTogWzEwMCwxMDAsMTAwXVxuXHR9LFxuXG5cdC8vMTk2NCAgMTBcdTAwQjBcblx0MTA6IHtcblx0XHQvL2luY2FkZXNjZW50XG5cdFx0QTpbMTExLjE0NCwgMTAwLCAzNS4yMDBdLFxuXHRcdEM6IFs5Ny4yODUsIDEwMCwgMTE2LjE0NV0sXG5cdFx0RDUwOiBbOTYuNzIwLCAxMDAsIDgxLjQyN10sXG5cdFx0RDU1OiBbOTUuNzk5LCAxMDAsIDkwLjkyNl0sXG5cdFx0Ly9kYXlsaWdodFxuXHRcdEQ2NTogWzk0LjgxMSwgMTAwLCAxMDcuMzA0XSxcblx0XHRENzU6IFs5NC40MTYsIDEwMCwgMTIwLjY0MV0sXG5cdFx0Ly9mbG91cmVzY2VudFxuXHRcdEYyOiBbMTAzLjI4MCwgMTAwLCA2OS4wMjZdLFxuXHRcdEY3OiBbOTUuNzkyLCAxMDAsIDEwNy42ODddLFxuXHRcdEYxMTogWzEwMy44NjYsIDEwMCwgNjUuNjI3XSxcblx0XHRFOiBbMTAwLDEwMCwxMDBdXG5cdH1cbn07XG5cblxuLyoqXG4gKiBUb3AgdmFsdWVzIGFyZSB0aGUgd2hpdGVwb2ludFx1MjAxOXMgdG9wIHZhbHVlcywgZGVmYXVsdCBhcmUgRDY1XG4gKi9cbnh5ei5tYXggPSB4eXoud2hpdGVwb2ludFsyXS5ENjU7XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0geHl6IHRvIHJnYlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiBBcnJheSBvZiB4eXogdmFsdWVzXG4gKlxuICogQHJldHVybiB7QXJyYXl9IFJHQiB2YWx1ZXNcbiAqL1xueHl6LnJnYiA9IGZ1bmN0aW9uIChfeHl6LCB3aGl0ZSkge1xuXHQvL0ZJWE1FOiBtYWtlIHN1cmUgd2UgaGF2ZSB0byBkaXZpZGUgbGlrZSB0aGlzLiBQcm9iYWJseSB3ZSBoYXZlIHRvIHJlcGxhY2UgbWF0cml4IGFzIHdlbGwgdGhlblxuXHR3aGl0ZSA9IHdoaXRlIHx8IHh5ei53aGl0ZXBvaW50WzJdLkU7XG5cblx0dmFyIHggPSBfeHl6WzBdIC8gd2hpdGVbMF0sXG5cdFx0eSA9IF94eXpbMV0gLyB3aGl0ZVsxXSxcblx0XHR6ID0gX3h5elsyXSAvIHdoaXRlWzJdLFxuXHRcdHIsIGcsIGI7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0Ly8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuXHRyID0gKHggKiAzLjI0MDk2OTk0MTkwNDUyMSkgKyAoeSAqIC0xLjUzNzM4MzE3NzU3MDA5MykgKyAoeiAqIC0wLjQ5ODYxMDc2MDI5Myk7XG5cdGcgPSAoeCAqIC0wLjk2OTI0MzYzNjI4MDg3KSArICh5ICogMS44NzU5Njc1MDE1MDc3MikgKyAoeiAqIDAuMDQxNTU1MDU3NDA3MTc1KTtcblx0YiA9ICh4ICogMC4wNTU2MzAwNzk2OTY5OTMpICsgKHkgKiAtMC4yMDM5NzY5NTg4ODg5NykgKyAoeiAqIDEuMDU2OTcxNTE0MjQyODc4KTtcblxuXHRyID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogciA9IChyICogMTIuOTIpO1xuXG5cdGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBnID0gKGcgKiAxMi45Mik7XG5cblx0YiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGIgPSAoYiAqIDEyLjkyKTtcblxuXHRyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuXHRnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuXHRiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cblxuXG4vKipcbiAqIFJHQiB0byBYWVpcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByZ2IgUkdCIGNoYW5uZWxzXG4gKlxuICogQHJldHVybiB7QXJyYXl9IFhZWiBjaGFubmVsc1xuICovXG5yZ2IueHl6ID0gZnVuY3Rpb24ocmdiLCB3aGl0ZSkge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NSxcblx0XHRcdGcgPSByZ2JbMV0gLyAyNTUsXG5cdFx0XHRiID0gcmdiWzJdIC8gMjU1O1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuXHRnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcblx0YiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cblx0dmFyIHggPSAociAqIDAuNDEyMzkwNzk5MjY1OTUpICsgKGcgKiAwLjM1NzU4NDMzOTM4Mzg3KSArIChiICogMC4xODA0ODA3ODg0MDE4Myk7XG5cdHZhciB5ID0gKHIgKiAwLjIxMjYzOTAwNTg3MTUxKSArIChnICogMC43MTUxNjg2Nzg3Njc3NSkgKyAoYiAqIDAuMDcyMTkyMzE1MzYwNzMzKTtcblx0dmFyIHogPSAociAqIDAuMDE5MzMwODE4NzE1NTkxKSArIChnICogMC4xMTkxOTQ3Nzk3OTQ2MikgKyAoYiAqIDAuOTUwNTMyMTUyMjQ5NjYpO1xuXG5cdHdoaXRlID0gd2hpdGUgfHwgeHl6LndoaXRlcG9pbnRbMl0uRTtcblxuXHRyZXR1cm4gW3ggKiB3aGl0ZVswXSwgeSAqIHdoaXRlWzFdLCB6ICogd2hpdGVbMl1dO1xufTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IHh5ejtcbiIsICIvKipcbiAqIENJRSBMVVYgKEMnZXN0IGxhIHZpZSlcbiAqXG4gKiBAbW9kdWxlIGNvbG9yLXNwYWNlL2x1dlxuICovXG4gaW1wb3J0IHh5eiBmcm9tICcuL3h5ei5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0bmFtZTogJ2x1dicsXG5cdC8vTk9URTogbHV2IGhhcyBubyByaWdpZGx5IGRlZmluZWQgbGltaXRzXG5cdC8vZWFzeXJnYiBmYWlscyB0byBnZXQgcHJvcGVyIGNvb3Jkc1xuXHQvL2Jvcm9uaW5lIHN0YXRlcyBubyByaWdpZCBsaW1pdHNcblx0Ly9jb2xvck1pbmUgcmVmZXJzIHRoaXMgb25lczpcblx0bWluOiBbMCwtMTM0LC0xNDBdLFxuXHRtYXg6IFsxMDAsMjI0LDEyMl0sXG5cdGNoYW5uZWw6IFsnbGlnaHRuZXNzJywgJ3UnLCAndiddLFxuXHRhbGlhczogWydMVVYnLCAnY2llbHV2JywgJ2NpZTE5NzYnXSxcblxuXHR4eXo6IGZ1bmN0aW9uKGFyZywgaSwgbyl7XG5cdFx0dmFyIF91LCBfdiwgbCwgdSwgdiwgeCwgeSwgeiwgeG4sIHluLCB6biwgdW4sIHZuO1xuXHRcdGwgPSBhcmdbMF0sIHUgPSBhcmdbMV0sIHYgPSBhcmdbMl07XG5cblx0XHRpZiAobCA9PT0gMCkgcmV0dXJuIFswLDAsMF07XG5cblx0XHQvL2dldCBjb25zdGFudHNcblx0XHQvL3ZhciBlID0gMC4wMDg4NTY0NTE2NzkwMzU2MzE7IC8vKDYvMjkpXjNcblx0XHR2YXIgayA9IDAuMDAxMTA3MDU2NDU5ODc5NDUzOTsgLy8oMy8yOSleM1xuXG5cdFx0Ly9nZXQgaWxsdW1pbmFudC9vYnNlcnZlclxuXHRcdGkgPSBpIHx8ICdENjUnO1xuXHRcdG8gPSBvIHx8IDI7XG5cblx0XHR4biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzBdO1xuXHRcdHluID0geHl6LndoaXRlcG9pbnRbb11baV1bMV07XG5cdFx0em4gPSB4eXoud2hpdGVwb2ludFtvXVtpXVsyXTtcblxuXHRcdHVuID0gKDQgKiB4bikgLyAoeG4gKyAoMTUgKiB5bikgKyAoMyAqIHpuKSk7XG5cdFx0dm4gPSAoOSAqIHluKSAvICh4biArICgxNSAqIHluKSArICgzICogem4pKTtcblx0XHQvLyB1biA9IDAuMTk3ODMwMDA2NjQyODM7XG5cdFx0Ly8gdm4gPSAwLjQ2ODMxOTk5NDkzODc5O1xuXG5cblx0XHRfdSA9IHUgLyAoMTMgKiBsKSArIHVuIHx8IDA7XG5cdFx0X3YgPSB2IC8gKDEzICogbCkgKyB2biB8fCAwO1xuXG5cdFx0eSA9IGwgPiA4ID8geW4gKiBNYXRoLnBvdyggKGwgKyAxNikgLyAxMTYgLCAzKSA6IHluICogbCAqIGs7XG5cblx0XHQvL3dpa2lwZWRpYSBtZXRob2Rcblx0XHR4ID0geSAqIDkgKiBfdSAvICg0ICogX3YpIHx8IDA7XG5cdFx0eiA9IHkgKiAoMTIgLSAzICogX3UgLSAyMCAqIF92KSAvICg0ICogX3YpIHx8IDA7XG5cblx0XHQvL2Jvcm9uaW5lIG1ldGhvZFxuXHRcdC8vaHR0cHM6Ly9naXRodWIuY29tL2Jvcm9uaW5lL2h1c2wvYmxvYi9tYXN0ZXIvaHVzbC5jb2ZmZWUjTDIwMVxuXHRcdC8vIHggPSAwIC0gKDkgKiB5ICogX3UpIC8gKChfdSAtIDQpICogX3YgLSBfdSAqIF92KTtcblx0XHQvLyB6ID0gKDkgKiB5IC0gKDE1ICogX3YgKiB5KSAtIChfdiAqIHgpKSAvICgzICogX3YpO1xuXG5cdFx0cmV0dXJuIFt4LCB5LCB6XTtcblx0fVxufTtcblxuLy8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcXVhdGlvbnMuaHRtbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jvcm9uaW5lL2h1c2wvYmxvYi9tYXN0ZXIvaHVzbC5jb2ZmZWVcbi8vaSAtIGlsbHVtaW5hbnRcbi8vbyAtIG9ic2VydmVyXG54eXoubHV2ID0gZnVuY3Rpb24oYXJnLCBpLCBvKSB7XG5cdHZhciBfdSwgX3YsIGwsIHUsIHYsIHgsIHksIHosIHhuLCB5biwgem4sIHVuLCB2bjtcblxuXHQvL2dldCBjb25zdGFudHNcblx0dmFyIGUgPSAwLjAwODg1NjQ1MTY3OTAzNTYzMTsgLy8oNi8yOSleM1xuXHR2YXIgayA9IDkwMy4yOTYyOTYyOTYyOTYxOyAvLygyOS8zKV4zXG5cblx0Ly9nZXQgaWxsdW1pbmFudC9vYnNlcnZlciBjb29yZHNcblx0aSA9IGkgfHwgJ0Q2NSc7XG5cdG8gPSBvIHx8IDI7XG5cblx0eG4gPSB4eXoud2hpdGVwb2ludFtvXVtpXVswXTtcblx0eW4gPSB4eXoud2hpdGVwb2ludFtvXVtpXVsxXTtcblx0em4gPSB4eXoud2hpdGVwb2ludFtvXVtpXVsyXTtcblxuXHR1biA9ICg0ICogeG4pIC8gKHhuICsgKDE1ICogeW4pICsgKDMgKiB6bikpO1xuXHR2biA9ICg5ICogeW4pIC8gKHhuICsgKDE1ICogeW4pICsgKDMgKiB6bikpO1xuXG5cblx0eCA9IGFyZ1swXSwgeSA9IGFyZ1sxXSwgeiA9IGFyZ1syXTtcblxuXG5cdF91ID0gKDQgKiB4KSAvICh4ICsgKDE1ICogeSkgKyAoMyAqIHopKSB8fCAwO1xuXHRfdiA9ICg5ICogeSkgLyAoeCArICgxNSAqIHkpICsgKDMgKiB6KSkgfHwgMDtcblxuXHR2YXIgeXIgPSB5L3luO1xuXG5cdGwgPSB5ciA8PSBlID8gayAqIHlyIDogMTE2ICogTWF0aC5wb3coeXIsIDEvMykgLSAxNjtcblxuXHR1ID0gMTMgKiBsICogKF91IC0gdW4pO1xuXHR2ID0gMTMgKiBsICogKF92IC0gdm4pO1xuXG5cdHJldHVybiBbbCwgdSwgdl07XG59O1xuIiwgIi8qKlxuICogQ3lsaW5kcmljYWwgQ0lFIExVVlxuICpcbiAqIEBtb2R1bGUgY29sb3Itc3BhY2UvbGNodXZcbiAqL1xuaW1wb3J0IGx1diBmcm9tICcuL2x1di5qcyc7XG5pbXBvcnQgeHl6IGZyb20gJy4veHl6LmpzJztcblxuLy9jeWxpbmRyaWNhbCBsdXZcbnZhciBsY2h1diA9IHtcblx0bmFtZTogJ2xjaHV2Jyxcblx0Y2hhbm5lbDogWydsaWdodG5lc3MnLCAnY2hyb21hJywgJ2h1ZSddLFxuXHRhbGlhczogWydMQ0h1dicsICdjaWVsY2h1diddLFxuXHRtaW46IFswLDAsMF0sXG5cdG1heDogWzEwMCwxMDAsMzYwXSxcblxuXHRsdXY6IGZ1bmN0aW9uKGx1dil7XG5cdFx0dmFyIGwgPSBsdXZbMF0sXG5cdFx0YyA9IGx1dlsxXSxcblx0XHRoID0gbHV2WzJdLFxuXHRcdHUsIHYsIGhyO1xuXG5cdFx0aHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG5cdFx0dSA9IGMgKiBNYXRoLmNvcyhocik7XG5cdFx0diA9IGMgKiBNYXRoLnNpbihocik7XG5cdFx0cmV0dXJuIFtsLCB1LCB2XTtcblx0fSxcblxuXHR4eXo6IGZ1bmN0aW9uKGFyZykge1xuXHRcdHJldHVybiBsdXYueHl6KGxjaHV2Lmx1dihhcmcpKTtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbGNodXY7XG5cbmx1di5sY2h1diA9IGZ1bmN0aW9uKGx1dil7XG5cdHZhciBsID0gbHV2WzBdLCB1ID0gbHV2WzFdLCB2ID0gbHV2WzJdO1xuXG5cdHZhciBjID0gTWF0aC5zcXJ0KHUqdSArIHYqdik7XG5cdHZhciBociA9IE1hdGguYXRhbjIodix1KTtcblx0dmFyIGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdHJldHVybiBbbCxjLGhdXG59O1xuXG54eXoubGNodXYgPSBmdW5jdGlvbihhcmcpe1xuICByZXR1cm4gbHV2LmxjaHV2KHh5ei5sdXYoYXJnKSk7XG59O1xuIiwgIid1c2Ugc3RyaWN0J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xyXG4iLCAiLyoqXG4gKiBAbW9kdWxlIGNvbG9yLXBhcnNlXG4gKi9cbmltcG9ydCBuYW1lcyBmcm9tICdjb2xvci1uYW1lJ1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZVxuXG4vKipcbiAqIEJhc2UgaHVlc1xuICogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyN0eXBlZGVmLW5hbWVkLWh1ZVxuICovXG4vL0ZJWE1FOiB1c2UgZXh0ZXJuYWwgaHVlIGRldGVjdG9yXG52YXIgYmFzZUh1ZXMgPSB7XG5cdHJlZDogMCxcblx0b3JhbmdlOiA2MCxcblx0eWVsbG93OiAxMjAsXG5cdGdyZWVuOiAxODAsXG5cdGJsdWU6IDI0MCxcblx0cHVycGxlOiAzMDBcbn1cblxuLyoqXG4gKiBQYXJzZSBjb2xvciBmcm9tIHRoZSBzdHJpbmcgcGFzc2VkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBBIHNwYWNlIGluZGljYXRvciBgc3BhY2VgLCBhbiBhcnJheSBgdmFsdWVzYCBhbmQgYGFscGhhYFxuICovXG5mdW5jdGlvbiBwYXJzZShjc3RyKSB7XG5cdHZhciBtLCBwYXJ0cyA9IFtdLCBhbHBoYSA9IDEsIHNwYWNlXG5cblx0Ly9udW1lcmljIGNhc2Vcblx0aWYgKHR5cGVvZiBjc3RyID09PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiB7IHNwYWNlOiAncmdiJywgdmFsdWVzOiBbY3N0ciA+Pj4gMTYsIChjc3RyICYgMHgwMGZmMDApID4+PiA4LCBjc3RyICYgMHgwMDAwZmZdLCBhbHBoYTogMSB9XG5cdH1cblx0aWYgKHR5cGVvZiBjc3RyID09PSAnbnVtYmVyJykgcmV0dXJuIHsgc3BhY2U6ICdyZ2InLCB2YWx1ZXM6IFtjc3RyID4+PiAxNiwgKGNzdHIgJiAweDAwZmYwMCkgPj4+IDgsIGNzdHIgJiAweDAwMDBmZl0sIGFscGhhOiAxIH1cblxuXHRjc3RyID0gU3RyaW5nKGNzdHIpLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly9rZXl3b3JkXG5cdGlmIChuYW1lc1tjc3RyXSkge1xuXHRcdHBhcnRzID0gbmFtZXNbY3N0cl0uc2xpY2UoKVxuXHRcdHNwYWNlID0gJ3JnYidcblx0fVxuXG5cdC8vcmVzZXJ2ZWQgd29yZHNcblx0ZWxzZSBpZiAoY3N0ciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuXHRcdGFscGhhID0gMFxuXHRcdHNwYWNlID0gJ3JnYidcblx0XHRwYXJ0cyA9IFswLCAwLCAwXVxuXHR9XG5cblx0Ly9oZXhcblx0ZWxzZSBpZiAoY3N0clswXSA9PT0gJyMnKSB7XG5cdFx0dmFyIGJhc2UgPSBjc3RyLnNsaWNlKDEpXG5cdFx0dmFyIHNpemUgPSBiYXNlLmxlbmd0aFxuXHRcdHZhciBpc1Nob3J0ID0gc2l6ZSA8PSA0XG5cdFx0YWxwaGEgPSAxXG5cblx0XHRpZiAoaXNTaG9ydCkge1xuXHRcdFx0cGFydHMgPSBbXG5cdFx0XHRcdHBhcnNlSW50KGJhc2VbMF0gKyBiYXNlWzBdLCAxNiksXG5cdFx0XHRcdHBhcnNlSW50KGJhc2VbMV0gKyBiYXNlWzFdLCAxNiksXG5cdFx0XHRcdHBhcnNlSW50KGJhc2VbMl0gKyBiYXNlWzJdLCAxNilcblx0XHRcdF1cblx0XHRcdGlmIChzaXplID09PSA0KSB7XG5cdFx0XHRcdGFscGhhID0gcGFyc2VJbnQoYmFzZVszXSArIGJhc2VbM10sIDE2KSAvIDI1NVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHBhcnRzID0gW1xuXHRcdFx0XHRwYXJzZUludChiYXNlWzBdICsgYmFzZVsxXSwgMTYpLFxuXHRcdFx0XHRwYXJzZUludChiYXNlWzJdICsgYmFzZVszXSwgMTYpLFxuXHRcdFx0XHRwYXJzZUludChiYXNlWzRdICsgYmFzZVs1XSwgMTYpXG5cdFx0XHRdXG5cdFx0XHRpZiAoc2l6ZSA9PT0gOCkge1xuXHRcdFx0XHRhbHBoYSA9IHBhcnNlSW50KGJhc2VbNl0gKyBiYXNlWzddLCAxNikgLyAyNTVcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXBhcnRzWzBdKSBwYXJ0c1swXSA9IDBcblx0XHRpZiAoIXBhcnRzWzFdKSBwYXJ0c1sxXSA9IDBcblx0XHRpZiAoIXBhcnRzWzJdKSBwYXJ0c1syXSA9IDBcblxuXHRcdHNwYWNlID0gJ3JnYidcblx0fVxuXG5cdC8vIGNvbG9yIHNwYWNlXG5cdGVsc2UgaWYgKG0gPSAvXigoPzpyZ2JhP3xoc1tsdmJdYT98aHdiYT98Y215az98eHlbenldfGdyYXl8bGFifGxjaHU/dj98W2x5XXV2fGxtc3xva2xjaHxva2xhYnxjb2xvcikpXFxzKlxcKChbXlxcKV0qKVxcKS8uZXhlYyhjc3RyKSkge1xuXHRcdHZhciBuYW1lID0gbVsxXVxuXHRcdHNwYWNlID0gbmFtZS5yZXBsYWNlKC9hJC8sICcnKVxuXHRcdHZhciBkaW1zID0gc3BhY2UgPT09ICdjbXlrJyA/IDQgOiBzcGFjZSA9PT0gJ2dyYXknID8gMSA6IDNcblx0XHRwYXJ0cyA9IG1bMl0udHJpbSgpLnNwbGl0KC9cXHMqWyxcXC9dXFxzKnxcXHMrLylcblxuXHRcdC8vIGNvbG9yKHNyZ2ItbGluZWFyIHggeCB4KSAtPiBzcmdiLWxpbmVhcih4IHggeClcblx0XHRpZiAoc3BhY2UgPT09ICdjb2xvcicpIHNwYWNlID0gcGFydHMuc2hpZnQoKVxuXG5cdFx0cGFydHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcblx0XHRcdC8vPHBlcmNlbnRhZ2U+XG5cdFx0XHRpZiAoeFt4Lmxlbmd0aCAtIDFdID09PSAnJScpIHtcblx0XHRcdFx0eCA9IHBhcnNlRmxvYXQoeCkgLyAxMDBcblx0XHRcdFx0Ly8gYWxwaGEgLT4gMC4uMVxuXHRcdFx0XHRpZiAoaSA9PT0gMykgcmV0dXJuIHhcblx0XHRcdFx0Ly8gcmdiIC0+IDAuLjI1NVxuXHRcdFx0XHRpZiAoc3BhY2UgPT09ICdyZ2InKSByZXR1cm4geCAqIDI1NVxuXHRcdFx0XHQvLyBoc2wsIGh3YiBIIC0+IDAuLjEwMFxuXHRcdFx0XHRpZiAoc3BhY2VbMF0gPT09ICdoJykgcmV0dXJuIHggKiAxMDBcblx0XHRcdFx0Ly8gbGNoLCBsYWIgTCAtPiAwLi4xMDBcblx0XHRcdFx0aWYgKHNwYWNlWzBdID09PSAnbCcgJiYgIWkpIHJldHVybiB4ICogMTAwXG5cdFx0XHRcdC8vIGxhYiBBIEIgLT4gLTEyNS4uMTI1XG5cdFx0XHRcdGlmIChzcGFjZSA9PT0gJ2xhYicpIHJldHVybiB4ICogMTI1XG5cdFx0XHRcdC8vIGxjaCBDIC0+IDAuLjE1MCwgSCAtPiAwLi4zNjBcblx0XHRcdFx0aWYgKHNwYWNlID09PSAnbGNoJykgcmV0dXJuIGkgPCAyID8geCAqIDE1MCA6IHggKiAzNjBcblx0XHRcdFx0Ly8gb2tsY2gvb2tsYWIgTCAtPiAwLi4xXG5cdFx0XHRcdGlmIChzcGFjZVswXSA9PT0gJ28nICYmICFpKSByZXR1cm4geFxuXHRcdFx0XHQvLyBva2xhYiBBIEIgLT4gLTAuNC4uMC40XG5cdFx0XHRcdGlmIChzcGFjZSA9PT0gJ29rbGFiJykgcmV0dXJuIHggKiAwLjRcblx0XHRcdFx0Ly8gb2tsY2ggQyAtPiAwLi4wLjQsIEggLT4gMC4uMzYwXG5cdFx0XHRcdGlmIChzcGFjZSA9PT0gJ29rbGNoJykgcmV0dXJuIGkgPCAyID8geCAqIDAuNCA6IHggKiAzNjBcblx0XHRcdFx0Ly8gY29sb3IoeHh4KSAtPiAwLi4xXG5cdFx0XHRcdHJldHVybiB4XG5cdFx0XHR9XG5cblx0XHRcdC8vaHVlXG5cdFx0XHRpZiAoc3BhY2VbaV0gPT09ICdoJyB8fCAoaSA9PT0gMiAmJiBzcGFjZVtzcGFjZS5sZW5ndGggLSAxXSA9PT0gJ2gnKSkge1xuXHRcdFx0XHQvLzxiYXNlLWh1ZT5cblx0XHRcdFx0aWYgKGJhc2VIdWVzW3hdICE9PSB1bmRlZmluZWQpIHJldHVybiBiYXNlSHVlc1t4XVxuXHRcdFx0XHQvLzxkZWc+XG5cdFx0XHRcdGlmICh4LmVuZHNXaXRoKCdkZWcnKSkgcmV0dXJuIHBhcnNlRmxvYXQoeClcblx0XHRcdFx0Ly88dHVybj5cblx0XHRcdFx0aWYgKHguZW5kc1dpdGgoJ3R1cm4nKSkgcmV0dXJuIHBhcnNlRmxvYXQoeCkgKiAzNjBcblx0XHRcdFx0aWYgKHguZW5kc1dpdGgoJ2dyYWQnKSkgcmV0dXJuIHBhcnNlRmxvYXQoeCkgKiAzNjAgLyA0MDBcblx0XHRcdFx0aWYgKHguZW5kc1dpdGgoJ3JhZCcpKSByZXR1cm4gcGFyc2VGbG9hdCh4KSAqIDE4MCAvIE1hdGguUElcblx0XHRcdH1cblx0XHRcdGlmICh4ID09PSAnbm9uZScpIHJldHVybiAwXG5cdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh4KVxuXHRcdH0pO1xuXG5cdFx0YWxwaGEgPSBwYXJ0cy5sZW5ndGggPiBkaW1zID8gcGFydHMucG9wKCkgOiAxXG5cdH1cblxuXHQvL25hbWVkIGNoYW5uZWxzIGNhc2Vcblx0ZWxzZSBpZiAoL1swLTldKD86XFxzfFxcL3wsKS8udGVzdChjc3RyKSkge1xuXHRcdHBhcnRzID0gY3N0ci5tYXRjaCgvKFswLTldKykvZykubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpXG5cdFx0fSlcblxuXHRcdHNwYWNlID0gY3N0ci5tYXRjaCgvKFthLXpdKS9pZyk/LmpvaW4oJycpPy50b0xvd2VyQ2FzZSgpIHx8ICdyZ2InXG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNwYWNlLFxuXHRcdHZhbHVlczogcGFydHMsXG5cdFx0YWxwaGFcblx0fVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBjb2xvci1zcGFjZS9oc2xcbiAqL1xuaW1wb3J0IHJnYiBmcm9tICcuL3JnYi5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0bmFtZTogJ2hzbCcsXG5cdG1pbjogWzAsMCwwXSxcblx0bWF4OiBbMzYwLDEwMCwxMDBdLFxuXHRjaGFubmVsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRhbGlhczogWydIU0wnXSxcblxuXHRyZ2I6IGZ1bmN0aW9uKGhzbCkge1xuXHRcdHZhciBoID0gaHNsWzBdLzM2MCwgcyA9IGhzbFsxXS8xMDAsIGwgPSBoc2xbMl0vMTAwLCB0MSwgdDIsIHQzLCByZ2IsIHZhbCwgaT0wO1xuXG5cdFx0aWYgKHMgPT09IDApIHJldHVybiB2YWwgPSBsICogMjU1LCBbdmFsLCB2YWwsIHZhbF07XG5cblx0XHR0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG5cdFx0dDEgPSAyICogbCAtIHQyO1xuXG5cdFx0cmdiID0gWzAsIDAsIDBdO1xuXHRcdGZvciAoO2k8MzspIHtcblx0XHRcdHQzID0gaCArIDEgLyAzICogLSAoaSAtIDEpO1xuXHRcdFx0dDMgPCAwID8gdDMrKyA6IHQzID4gMSAmJiB0My0tO1xuXHRcdFx0dmFsID0gNiAqIHQzIDwgMSA/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzIDpcblx0XHRcdDIgKiB0MyA8IDEgPyB0MiA6XG5cdFx0XHQzICogdDMgPCAyID8gIHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNiA6XG5cdFx0XHR0MTtcblx0XHRcdHJnYltpKytdID0gdmFsICogMjU1O1xuXHRcdH1cblxuXHRcdHJldHVybiByZ2I7XG5cdH1cbn07XG5cblxuLy9leHRlbmQgcmdiXG5yZ2IuaHNsID0gZnVuY3Rpb24ocmdiKSB7XG5cdHZhciByID0gcmdiWzBdLzI1NSxcblx0XHRcdGcgPSByZ2JbMV0vMjU1LFxuXHRcdFx0YiA9IHJnYlsyXS8yNTUsXG5cdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRoLCBzLCBsO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSAwO1xuXHR9XG5cdGVsc2UgaWYgKHIgPT09IG1heCkge1xuXHRcdGggPSAoZyAtIGIpIC8gZGVsdGE7XG5cdH1cblx0ZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG5cdFx0aCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG5cdH1cblx0ZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG5cdFx0aCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRsID0gKG1pbiArIG1heCkgLyAyO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdHMgPSAwO1xuXHR9XG5cdGVsc2UgaWYgKGwgPD0gMC41KSB7XG5cdFx0cyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHR9XG5cblx0cmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn07XG4iLCAiLyoqIEBtb2R1bGUgIGNvbG9yLXJnYmEgKi9cbmltcG9ydCBwYXJzZSBmcm9tICdjb2xvci1wYXJzZSdcbmltcG9ydCByZ2IgZnJvbSAnY29sb3Itc3BhY2UvcmdiLmpzJ1xuaW1wb3J0IGhzbCBmcm9tICdjb2xvci1zcGFjZS9oc2wuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJnYmEoY29sb3IpIHtcblx0Ly8gdGVtcGxhdGUgbGl0ZXJhbHNcblx0aWYgKEFycmF5LmlzQXJyYXkoY29sb3IpICYmIGNvbG9yLnJhdykgY29sb3IgPSBTdHJpbmcucmF3KC4uLmFyZ3VtZW50cylcblx0aWYgKGNvbG9yIGluc3RhbmNlb2YgTnVtYmVyKSBjb2xvciA9ICtjb2xvclxuXG5cdHZhciB2YWx1ZXMsIGksIGxcblxuXHQvL2F0dGVtcHQgdG8gcGFyc2Ugbm9uLWFycmF5IGFyZ3VtZW50c1xuXHR2YXIgcGFyc2VkID0gcGFyc2UoY29sb3IpXG5cblx0aWYgKCFwYXJzZWQuc3BhY2UpIHJldHVybiBbXVxuXG5cdGNvbnN0IG1pbiA9IHBhcnNlZC5zcGFjZVswXSA9PT0gJ2gnID8gaHNsLm1pbiA6IHJnYi5taW5cblx0Y29uc3QgbWF4ID0gcGFyc2VkLnNwYWNlWzBdID09PSAnaCcgPyBoc2wubWF4IDogcmdiLm1heFxuXG5cdHZhbHVlcyA9IEFycmF5KDMpXG5cdHZhbHVlc1swXSA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlZC52YWx1ZXNbMF0sIG1pblswXSksIG1heFswXSlcblx0dmFsdWVzWzFdID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VkLnZhbHVlc1sxXSwgbWluWzFdKSwgbWF4WzFdKVxuXHR2YWx1ZXNbMl0gPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZWQudmFsdWVzWzJdLCBtaW5bMl0pLCBtYXhbMl0pXG5cblx0aWYgKHBhcnNlZC5zcGFjZVswXSA9PT0gJ2gnKSB7XG5cdFx0dmFsdWVzID0gaHNsLnJnYih2YWx1ZXMpXG5cdH1cblxuXHR2YWx1ZXMucHVzaChNYXRoLm1pbihNYXRoLm1heChwYXJzZWQuYWxwaGEsIDApLCAxKSlcblxuXHRyZXR1cm4gdmFsdWVzXG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL21hdGhcbiAqL1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCAoeCwgeSkgYW5kIHRoZVxuICogbGluZSBzZWdtZW50ICh4MSwgeTEpIHRvICh4MiwgeTIpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkU2VnbWVudERpc3RhbmNlKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICBjb25zdCB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoeCwgeSwgeDEsIHkxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBTb2x2ZXMgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgdXNpbmcgR2F1c3NpYW4gZWxpbWluYXRpb24gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdCBBdWdtZW50ZWQgbWF0cml4IChuIHggbiArIDEgY29sdW1uKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gcm93LW1ham9yIG9yZGVyLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBUaGUgcmVzdWx0aW5nIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvbHZlTGluZWFyU3lzdGVtKG1hdCkge1xuICBjb25zdCBuID0gbWF0Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIC8vIEZpbmQgbWF4IGluIHRoZSBpLXRoIGNvbHVtbiAoaWdub3JpbmcgaSAtIDEgZmlyc3Qgcm93cylcbiAgICBsZXQgbWF4Um93ID0gaTtcbiAgICBsZXQgbWF4RWwgPSBNYXRoLmFicyhtYXRbaV1baV0pO1xuICAgIGZvciAobGV0IHIgPSBpICsgMTsgciA8IG47IHIrKykge1xuICAgICAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhtYXRbcl1baV0pO1xuICAgICAgaWYgKGFic1ZhbHVlID4gbWF4RWwpIHtcbiAgICAgICAgbWF4RWwgPSBhYnNWYWx1ZTtcbiAgICAgICAgbWF4Um93ID0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4RWwgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBtYXRyaXggaXMgc2luZ3VsYXJcbiAgICB9XG5cbiAgICAvLyBTd2FwIG1heCByb3cgd2l0aCBpLXRoIChjdXJyZW50KSByb3dcbiAgICBjb25zdCB0bXAgPSBtYXRbbWF4Um93XTtcbiAgICBtYXRbbWF4Um93XSA9IG1hdFtpXTtcbiAgICBtYXRbaV0gPSB0bXA7XG5cbiAgICAvLyBTdWJ0cmFjdCB0aGUgaS10aCByb3cgdG8gbWFrZSBhbGwgdGhlIHJlbWFpbmluZyByb3dzIDAgaW4gdGhlIGktdGggY29sdW1uXG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICBjb25zdCBjb2VmID0gLW1hdFtqXVtpXSAvIG1hdFtpXVtpXTtcbiAgICAgIGZvciAobGV0IGsgPSBpOyBrIDwgbiArIDE7IGsrKykge1xuICAgICAgICBpZiAoaSA9PSBrKSB7XG4gICAgICAgICAgbWF0W2pdW2tdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRbal1ba10gKz0gY29lZiAqIG1hdFtpXVtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbHZlIEF4PWIgZm9yIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IEEgKG1hdClcbiAgY29uc3QgeCA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgbCA9IG4gLSAxOyBsID49IDA7IGwtLSkge1xuICAgIHhbbF0gPSBtYXRbbF1bbl0gLyBtYXRbbF1bbF07XG4gICAgZm9yIChsZXQgbSA9IGwgLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgbWF0W21dW25dIC09IG1hdFttXVtsXSAqIHhbbF07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHJhZGlhbnMgdG8gdG8gZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgQW5nbGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhhbmdsZUluUmFkaWFucykge1xuICByZXR1cm4gKGFuZ2xlSW5SYWRpYW5zICogMTgwKSAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluRGVncmVlcyBBbmdsZSBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiByYWRpYW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW5zKGFuZ2xlSW5EZWdyZWVzKSB7XG4gIHJldHVybiAoYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb2R1bG8gb2YgYSAvIGIsIGRlcGVuZGluZyBvbiB0aGUgc2lnbiBvZiBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIERpdmlkZW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgRGl2aXNvci5cbiAqIEByZXR1cm4ge251bWJlcn0gTW9kdWxvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxvKGEsIGIpIHtcbiAgY29uc3QgciA9IGEgJSBiO1xuICByZXR1cm4gciAqIGIgPCAwID8gciArIGIgOiByO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxpbmVhcmx5IGludGVycG9sYXRlZCB2YWx1ZSBvZiB4IGJldHdlZW4gYSBhbmQgYi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IHggVmFsdWUgdG8gYmUgaW50ZXJwb2xhdGVkLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKGEsIGIsIHgpIHtcbiAgcmV0dXJuIGEgKyB4ICogKGIgLSBhKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIHdpdGggYSBsaW1pdGVkIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5wdXQgbnVtYmVyIHdpdGggYSBsaW1pdGVkIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRml4ZWQobiwgZGVjaW1hbHMpIHtcbiAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQobiAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5cbi8qKlxuICogUm91bmRzIGEgbnVtYmVyIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgdmFsdWUgY29uc2lkZXJpbmcgb25seSB0aGUgZ2l2ZW4gbnVtYmVyXG4gKiBvZiBkZWNpbWFsIGRpZ2l0cyAod2l0aCByb3VuZGluZyBvbiB0aGUgZmluYWwgZGlnaXQpLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZWFyZXN0IGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChuLCBkZWNpbWFscykge1xuICByZXR1cm4gTWF0aC5yb3VuZCh0b0ZpeGVkKG4sIGRlY2ltYWxzKSk7XG59XG5cbi8qKlxuICogUm91bmRzIGEgbnVtYmVyIHRvIHRoZSBuZXh0IHNtYWxsZXIgaW50ZWdlciBjb25zaWRlcmluZyBvbmx5IHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGRlY2ltYWwgZGlnaXRzICh3aXRoIHJvdW5kaW5nIG9uIHRoZSBmaW5hbCBkaWdpdCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5leHQgc21hbGxlciBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3IobiwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodG9GaXhlZChuLCBkZWNpbWFscykpO1xufVxuXG4vKipcbiAqIFJvdW5kcyBhIG51bWJlciB0byB0aGUgbmV4dCBiaWdnZXIgaW50ZWdlciBjb25zaWRlcmluZyBvbmx5IHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGRlY2ltYWwgZGlnaXRzICh3aXRoIHJvdW5kaW5nIG9uIHRoZSBmaW5hbCBkaWdpdCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5leHQgYmlnZ2VyIGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG4sIGRlY2ltYWxzKSB7XG4gIHJldHVybiBNYXRoLmNlaWwodG9GaXhlZChuLCBkZWNpbWFscykpO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb2xvclxuICovXG5pbXBvcnQgbGNodXYgZnJvbSAnY29sb3Itc3BhY2UvbGNodXYuanMnO1xuaW1wb3J0IHBhcnNlUmdiYSBmcm9tICdjb2xvci1yZ2JhJztcbmltcG9ydCByZ2IgZnJvbSAnY29sb3Itc3BhY2UvcmdiLmpzJztcbmltcG9ydCB4eXogZnJvbSAnY29sb3Itc3BhY2UveHl6LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogQSBjb2xvciByZXByZXNlbnRlZCBhcyBhIHNob3J0IGFycmF5IFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV0uXG4gKiByZWQsIGdyZWVuLCBhbmQgYmx1ZSBzaG91bGQgYmUgaW50ZWdlcnMgaW4gdGhlIHJhbmdlIDAuLjI1NSBpbmNsdXNpdmUuXG4gKiBhbHBoYSBzaG91bGQgYmUgYSBmbG9hdCBpbiB0aGUgcmFuZ2UgMC4uMSBpbmNsdXNpdmUuIElmIG5vIGFscGhhIHZhbHVlIGlzXG4gKiBnaXZlbiB0aGVuIGAxYCB3aWxsIGJlIHVzZWQuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gQ29sb3JcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0NvbG9yfHN0cmluZ30gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJnYmEgc3RyaW5nLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgcmV0dXJuIHRvU3RyaW5nKGNvbG9yKTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfQ0FDSEVfU0laRSA9IDEwMjQ7XG5cbi8qKlxuICogV2UgbWFpbnRhaW4gYSBzbWFsbCBjYWNoZSBvZiBwYXJzZWQgc3RyaW5ncy4gIFdoZW5ldmVyIHRoZSBjYWNoZSBncm93cyB0b28gbGFyZ2UsXG4gKiB3ZSBkZWxldGUgYW4gYXJiaXRyYXJ5IHNldCBvZiB0aGUgZW50cmllcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQ29sb3I+fVxuICovXG5jb25zdCBjYWNoZSA9IHt9O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBjYWNoZVNpemUgPSAwO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIEEgY29sb3IgdGhhdCBtYXkgb3IgbWF5IG5vdCBoYXZlIGFuIGFscGhhIGNoYW5uZWwuXG4gKiBAcmV0dXJuIHtDb2xvcn0gVGhlIGlucHV0IGNvbG9yIHdpdGggYW4gYWxwaGEgY2hhbm5lbC4gIElmIHRoZSBpbnB1dCBjb2xvciBoYXNcbiAqIGFuIGFscGhhIGNoYW5uZWwsIHRoZSBpbnB1dCBjb2xvciB3aWxsIGJlIHJldHVybmVkIHVuY2hhbmdlZC4gIE90aGVyd2lzZSwgYSBuZXdcbiAqIGFycmF5IHdpbGwgYmUgcmV0dXJuZWQgd2l0aCB0aGUgaW5wdXQgY29sb3IgYW5kIGFuIGFscGhhIGNoYW5uZWwgb2YgMS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhBbHBoYShjb2xvcikge1xuICBpZiAoY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IGNvbG9yLnNsaWNlKCk7XG4gIG91dHB1dFszXSA9IDE7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgUkdCQSBjb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBMQ0h1diBjb2xvciB3aXRoIGFscGhhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiYVRvTGNoYShjb2xvcikge1xuICBjb25zdCBvdXRwdXQgPSB4eXoubGNodXYocmdiLnh5eihjb2xvcikpO1xuICBvdXRwdXRbM10gPSBjb2xvclszXTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBMQ0h1diBjb2xvciB3aXRoIGFscGhhLlxuICogQHJldHVybiB7Q29sb3J9IFJHQkEgY29sb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsY2hhVG9SZ2JhKGNvbG9yKSB7XG4gIGNvbnN0IG91dHB1dCA9IHh5ei5yZ2IobGNodXYueHl6KGNvbG9yKSk7XG4gIG91dHB1dFszXSA9IGNvbG9yWzNdO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZy5cbiAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcocykge1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICByZXR1cm4gY2FjaGVbc107XG4gIH1cbiAgaWYgKGNhY2hlU2l6ZSA+PSBNQVhfQ0FDSEVfU0laRSkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICAgICAgLS1jYWNoZVNpemU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29sb3IgPSBwYXJzZVJnYmEocyk7XG4gIGlmIChjb2xvci5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBcIicgKyBzICsgJ1wiIGFzIGNvbG9yJyk7XG4gIH1cbiAgZm9yIChjb25zdCBjIG9mIGNvbG9yKSB7XG4gICAgaWYgKGlzTmFOKGMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBcIicgKyBzICsgJ1wiIGFzIGNvbG9yJyk7XG4gICAgfVxuICB9XG4gIG5vcm1hbGl6ZShjb2xvcik7XG4gIGNhY2hlW3NdID0gY29sb3I7XG4gICsrY2FjaGVTaXplO1xuICByZXR1cm4gY29sb3I7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb2xvciBhcyBhbiBhcnJheS4gVGhpcyBmdW5jdGlvbiBtYWludGFpbnMgYSBjYWNoZSBvZiBjYWxjdWxhdGVkXG4gKiBhcnJheXMgd2hpY2ggbWVhbnMgdGhlIHJlc3VsdCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHtDb2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheShjb2xvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcoY29sb3IpO1xufVxuXG4vKipcbiAqIEV4cG9ydGVkIGZvciB0aGUgdGVzdHMuXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBDbGFtcGVkIGNvbG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKGNvbG9yKSB7XG4gIGNvbG9yWzBdID0gY2xhbXAoKGNvbG9yWzBdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzFdID0gY2xhbXAoKGNvbG9yWzFdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzJdID0gY2xhbXAoKGNvbG9yWzJdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzNdID0gY2xhbXAoY29sb3JbM10sIDAsIDEpO1xuICByZXR1cm4gY29sb3I7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbG9yKSB7XG4gIGxldCByID0gY29sb3JbMF07XG4gIGlmIChyICE9IChyIHwgMCkpIHtcbiAgICByID0gKHIgKyAwLjUpIHwgMDtcbiAgfVxuICBsZXQgZyA9IGNvbG9yWzFdO1xuICBpZiAoZyAhPSAoZyB8IDApKSB7XG4gICAgZyA9IChnICsgMC41KSB8IDA7XG4gIH1cbiAgbGV0IGIgPSBjb2xvclsyXTtcbiAgaWYgKGIgIT0gKGIgfCAwKSkge1xuICAgIGIgPSAoYiArIDAuNSkgfCAwO1xuICB9XG4gIGNvbnN0IGEgPSBjb2xvclszXSA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGgucm91bmQoY29sb3JbM10gKiAxMDApIC8gMTAwO1xuICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3RyaW5nIGlzIGFjdHVhbGx5IGEgdmFsaWQgY29sb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nQ29sb3Iocykge1xuICB0cnkge1xuICAgIGZyb21TdHJpbmcocyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGVcbiAqL1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNpbmdsZXRvbiBjbGFzcy4gQXZhaWxhYmxlIHRocm91Z2gge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZS5zaGFyZWR9LlxuICovXG5jbGFzcyBJY29uSW1hZ2VDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gMzI7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlU2l6ZV8gPiB0aGlzLm1heENhY2hlU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBleHBpcmUoKSB7XG4gICAgaWYgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZV8pIHtcbiAgICAgICAgY29uc3QgaWNvbkltYWdlID0gdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCAmJiAhaWNvbkltYWdlLmhhc0xpc3RlbmVyKCkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgICAtLXRoaXMuY2FjaGVTaXplXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IGNvbG9yIENvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBJY29uIGltYWdlLlxuICAgKi9cbiAgZ2V0KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMuY2FjaGVfID8gdGhpcy5jYWNoZV9ba2V5XSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBpY29uSW1hZ2UgSWNvbiBpbWFnZS5cbiAgICovXG4gIHNldChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICB0aGlzLmNhY2hlX1trZXldID0gaWNvbkltYWdlO1xuICAgICsrdGhpcy5jYWNoZVNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FjaGUgc2l6ZSBvZiB0aGUgaWNvbiBjYWNoZS4gRGVmYXVsdCBpcyBgMzJgLiBDaGFuZ2UgdGhpcyB2YWx1ZSB3aGVuXG4gICAqIHlvdXIgbWFwIHVzZXMgbW9yZSB0aGFuIDMyIGRpZmZlcmVudCBpY29uIGltYWdlcyBhbmQgeW91IGFyZSBub3QgY2FjaGluZyBpY29uXG4gICAqIHN0eWxlcyBvbiB0aGUgYXBwbGljYXRpb24gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDYWNoZVNpemUgQ2FjaGUgbWF4IHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNpemUobWF4Q2FjaGVTaXplKSB7XG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gbWF4Q2FjaGVTaXplO1xuICAgIHRoaXMuZXhwaXJlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gIGNvbnN0IGNvbG9yU3RyaW5nID0gY29sb3IgPyBhc1N0cmluZyhjb2xvcikgOiAnbnVsbCc7XG4gIHJldHVybiBjcm9zc09yaWdpbiArICc6JyArIHNyYyArICc6JyArIGNvbG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJY29uSW1hZ2VDYWNoZTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZX5JY29uSW1hZ2VDYWNoZX0gZm9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0gaW1hZ2VzLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgc2hhcmVkID0gbmV3IEljb25JbWFnZUNhY2hlKCk7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIE9QQUNJVFk6ICdvcGFjaXR5JyxcbiAgVklTSUJMRTogJ3Zpc2libGUnLFxuICBFWFRFTlQ6ICdleHRlbnQnLFxuICBaX0lOREVYOiAnekluZGV4JyxcbiAgTUFYX1JFU09MVVRJT046ICdtYXhSZXNvbHV0aW9uJyxcbiAgTUlOX1JFU09MVVRJT046ICdtaW5SZXNvbHV0aW9uJyxcbiAgTUFYX1pPT006ICdtYXhab29tJyxcbiAgTUlOX1pPT006ICdtaW5ab29tJyxcbiAgU09VUkNFOiAnc291cmNlJyxcbiAgTUFQOiAnbWFwJyxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0Jhc2VcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCBMYXllclByb3BlcnR5IGZyb20gJy4vUHJvcGVydHkuanMnO1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcblxuLyoqXG4gKiBBIGNzcyBjb2xvciwgb3IgYSBmdW5jdGlvbiBjYWxsZWQgd2l0aCBhIHZpZXcgcmVzb2x1dGlvbiByZXR1cm5pbmcgYSBjc3MgY29sb3IuXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xmdW5jdGlvbihudW1iZXIpOnN0cmluZ30gQmFja2dyb3VuZENvbG9yXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfCdjaGFuZ2U6ZXh0ZW50J3wnY2hhbmdlOm1heFJlc29sdXRpb24nfCdjaGFuZ2U6bWF4Wm9vbSd8XG4gKiAgICAnY2hhbmdlOm1pblJlc29sdXRpb24nfCdjaGFuZ2U6bWluWm9vbSd8J2NoYW5nZTpvcGFjaXR5J3wnY2hhbmdlOnZpc2libGUnfCdjaGFuZ2U6ekluZGV4J30gQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc1xuICovXG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPEJhc2VMYXllck9iamVjdEV2ZW50VHlwZXMsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8QmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlcywgUmV0dXJuPn0gQmFzZUxheWVyT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1sYXllciddIEEgQ1NTIGNsYXNzIG5hbWUgdG8gc2V0IHRvIHRoZSBsYXllciBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlciB8IHVuZGVmaW5lZH0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIFRoZSBtaW5pbXVtIHZpZXcgem9vbSBsZXZlbCAoZXhjbHVzaXZlKSBhYm92ZSB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIFRoZSBtYXhpbXVtIHZpZXcgem9vbSBsZXZlbCAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge0JhY2tncm91bmRDb2xvcn0gW2JhY2tncm91bmRdIEJhY2tncm91bmQgY29sb3IgZm9yIHRoZSBsYXllci4gSWYgbm90IHNwZWNpZmllZCwgbm8gYmFja2dyb3VuZFxuICogd2lsbCBiZSByZW5kZXJlZC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBOb3RlIHRoYXQgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyfSBhbmQgYWxsIGl0cyBzdWJjbGFzc2VzLCBhbnkgcHJvcGVydHkgc2V0IGluXG4gKiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fSBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0LCBzb1xuICogaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEJhc2VMYXllciBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIExheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZUxheWVyT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZUxheWVyT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtCYXNlTGF5ZXJPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0JhY2tncm91bmRDb2xvcnxmYWxzZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYmFja2dyb3VuZF8gPSBvcHRpb25zLmJhY2tncm91bmQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAgICovXG4gICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgZGVsZXRlIHByb3BlcnRpZXMucHJvcGVydGllcztcbiAgICAgIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgb3B0aW9ucy5wcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuT1BBQ0lUWV0gPVxuICAgICAgb3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYWNpdHkgOiAxO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuT1BBQ0lUWV0gPT09ICdudW1iZXInLFxuICAgICAgJ0xheWVyIG9wYWNpdHkgbXVzdCBiZSBhIG51bWJlcidcbiAgICApO1xuXG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5LlZJU0lCTEVdID1cbiAgICAgIG9wdGlvbnMudmlzaWJsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy52aXNpYmxlIDogdHJ1ZTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuWl9JTkRFWF0gPSBvcHRpb25zLnpJbmRleDtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUFYX1JFU09MVVRJT05dID1cbiAgICAgIG9wdGlvbnMubWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhSZXNvbHV0aW9uIDogSW5maW5pdHk7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OXSA9XG4gICAgICBvcHRpb25zLm1pblJlc29sdXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluUmVzb2x1dGlvbiA6IDA7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk1JTl9aT09NXSA9XG4gICAgICBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IC1JbmZpbml0eTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUFYX1pPT01dID1cbiAgICAgIG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhab29tIDogSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jbGFzc05hbWVfID1cbiAgICAgIHByb3BlcnRpZXMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBwcm9wZXJ0aWVzLmNsYXNzTmFtZSA6ICdvbC1sYXllcic7XG4gICAgZGVsZXRlIHByb3BlcnRpZXMuY2xhc3NOYW1lO1xuXG4gICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBiYWNrZ3JvdW5kIGZvciB0aGlzIGxheWVyLlxuICAgKiBAcmV0dXJuIHtCYWNrZ3JvdW5kQ29sb3J8ZmFsc2V9IExheWVyIGJhY2tncm91bmQuXG4gICAqL1xuICBnZXRCYWNrZ3JvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ1NTIGNsYXNzIG5hbWUuXG4gICAqL1xuICBnZXRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lXztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGxheWVycyBvciBsYXllciByZW5kZXJlcnMgYmVjYXVzZSB0aGUgc3RhdGVcbiAgICogaXMgaW5jb3JyZWN0IGlmIHRoZSBsYXllciBpcyBpbmNsdWRlZCBpbiBhIGxheWVyIGdyb3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYW5hZ2VkXSBMYXllciBpcyBtYW5hZ2VkLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfSBMYXllciBzdGF0ZS5cbiAgICovXG4gIGdldExheWVyU3RhdGUobWFuYWdlZCkge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZX0gKi9cbiAgICBjb25zdCBzdGF0ZSA9XG4gICAgICB0aGlzLnN0YXRlXyB8fFxuICAgICAgLyoqIEB0eXBlIHs/fSAqLyAoe1xuICAgICAgICBsYXllcjogdGhpcyxcbiAgICAgICAgbWFuYWdlZDogbWFuYWdlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG1hbmFnZWQsXG4gICAgICB9KTtcbiAgICBjb25zdCB6SW5kZXggPSB0aGlzLmdldFpJbmRleCgpO1xuICAgIHN0YXRlLm9wYWNpdHkgPSBjbGFtcChNYXRoLnJvdW5kKHRoaXMuZ2V0T3BhY2l0eSgpICogMTAwKSAvIDEwMCwgMCwgMSk7XG4gICAgc3RhdGUudmlzaWJsZSA9IHRoaXMuZ2V0VmlzaWJsZSgpO1xuICAgIHN0YXRlLmV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgc3RhdGUuekluZGV4ID0gekluZGV4ID09PSB1bmRlZmluZWQgJiYgIXN0YXRlLm1hbmFnZWQgPyBJbmZpbml0eSA6IHpJbmRleDtcbiAgICBzdGF0ZS5tYXhSZXNvbHV0aW9uID0gdGhpcy5nZXRNYXhSZXNvbHV0aW9uKCk7XG4gICAgc3RhdGUubWluUmVzb2x1dGlvbiA9IE1hdGgubWF4KHRoaXMuZ2V0TWluUmVzb2x1dGlvbigpLCAwKTtcbiAgICBzdGF0ZS5taW5ab29tID0gdGhpcy5nZXRNaW5ab29tKCk7XG4gICAgc3RhdGUubWF4Wm9vbSA9IHRoaXMuZ2V0TWF4Wm9vbSgpO1xuICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gW2FycmF5XSBBcnJheSBvZiBsYXllcnMgKHRvIGJlXG4gICAqICAgICBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IEFycmF5IG9mIGxheWVycy5cbiAgICovXG4gIGdldExheWVyc0FycmF5KGFycmF5KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IFtzdGF0ZXNdIE9wdGlvbmFsIGxpc3Qgb2YgbGF5ZXJcbiAgICogICAgIHN0YXRlcyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gTGlzdCBvZiBsYXllciBzdGF0ZXMuXG4gICAqL1xuICBnZXRMYXllclN0YXRlc0FycmF5KHN0YXRlcykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50IGV4dGVudH0gb2YgdGhlIGxheWVyIG9yIGB1bmRlZmluZWRgIGlmIGl0XG4gICAqIHdpbGwgYmUgdmlzaWJsZSByZWdhcmRsZXNzIG9mIGV4dGVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IFRoZSBsYXllciBleHRlbnQuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV4dGVudCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5FWFRFTlQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuIFJldHVybnMgSW5maW5pdHkgaWZcbiAgICogdGhlIGxheWVyIGhhcyBubyBtYXhpbXVtIHJlc29sdXRpb24gc2V0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuTUFYX1JFU09MVVRJT04pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuIFJldHVybnMgMCBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1pbmltdW0gcmVzb2x1dGlvbiBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fUkVTT0xVVElPTikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBsYXllci4gUmV0dXJucyAtSW5maW5pdHkgaWZcbiAgICogdGhlIGxheWVyIGhhcyBubyBtaW5pbXVtIHpvb20gc2V0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNaW5ab29tKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuTUlOX1pPT00pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbGF5ZXIuIFJldHVybnMgSW5maW5pdHkgaWZcbiAgICogdGhlIGxheWVyIGhhcyBubyBtYXhpbXVtIHpvb20gc2V0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhab29tKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuTUFYX1pPT00pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyIChiZXR3ZWVuIDAgYW5kIDEpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk9QQUNJVFkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5TdGF0ZX0gU291cmNlIHN0YXRlLlxuICAgKi9cbiAgZ2V0U291cmNlU3RhdGUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIGxheWVyJ3MgYHZpc2libGVgIHByb3BlcnR5LiBUbyBmaW5kIG91dCB3aGV0aGVyIHRoZSBsYXllclxuICAgKiBpcyB2aXNpYmxlIG9uIGEgbWFwLCB1c2UgYGlzVmlzaWJsZSgpYCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmFsdWUgb2YgdGhlIGB2aXNpYmxlYCBwcm9wZXJ0eSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFZpc2libGUoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuVklTSUJMRSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgWi1pbmRleCBvZiB0aGUgbGF5ZXIsIHdoaWNoIGlzIHVzZWQgdG8gb3JkZXIgbGF5ZXJzIGJlZm9yZVxuICAgKiByZW5kZXJpbmcuIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBsYXllciBpcyB1bm1hbmFnZWQuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSBaLWluZGV4IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0WkluZGV4KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5LlpfSU5ERVgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKiBAcGFyYW0ge0JhY2tncm91bmRDb2xvcn0gW2JhY2tncm91bmRdIEJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kKGJhY2tncm91bmQpIHtcbiAgICB0aGlzLmJhY2tncm91bmRfID0gYmFja2dyb3VuZDtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGV4dGVudCBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS4gIElmIGB1bmRlZmluZWRgLCB0aGUgbGF5ZXJcbiAgICogd2lsbCBiZSB2aXNpYmxlIGF0IGFsbCBleHRlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSBleHRlbnQgVGhlIGV4dGVudCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEV4dGVudChleHRlbnQpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LkVYVEVOVCwgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gcmVzb2x1dGlvbiBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1heFJlc29sdXRpb24obWF4UmVzb2x1dGlvbikge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUFYX1JFU09MVVRJT04sIG1heFJlc29sdXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWluaW11bSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWluUmVzb2x1dGlvbihtaW5SZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fUkVTT0xVVElPTiwgbWluUmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtYXhpbXVtIHpvb20gKGV4Y2x1c2l2ZSkgYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqIE5vdGUgdGhhdCB0aGUgem9vbSBsZXZlbHMgZm9yIGxheWVyIHZpc2liaWxpdHkgYXJlIGJhc2VkIG9uIHRoZVxuICAgKiB2aWV3IHpvb20gbGV2ZWwsIHdoaWNoIG1heSBiZSBkaWZmZXJlbnQgZnJvbSBhIHRpbGUgc291cmNlIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhab29tIFRoZSBtYXhpbXVtIHpvb20gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXhab29tKG1heFpvb20pIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1BWF9aT09NLCBtYXhab29tKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1pbmltdW0gem9vbSAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICogTm90ZSB0aGF0IHRoZSB6b29tIGxldmVscyBmb3IgbGF5ZXIgdmlzaWJpbGl0eSBhcmUgYmFzZWQgb24gdGhlXG4gICAqIHZpZXcgem9vbSBsZXZlbCwgd2hpY2ggbWF5IGJlIGRpZmZlcmVudCBmcm9tIGEgdGlsZSBzb3VyY2Ugem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblpvb20gVGhlIG1pbmltdW0gem9vbSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1pblpvb20obWluWm9vbSkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUlOX1pPT00sIG1pblpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIsIGFsbG93ZWQgdmFsdWVzIHJhbmdlIGZyb20gMCB0byAxLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBUaGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9wYWNpdHkob3BhY2l0eSkge1xuICAgIGFzc2VydCh0eXBlb2Ygb3BhY2l0eSA9PT0gJ251bWJlcicsICdMYXllciBvcGFjaXR5IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk9QQUNJVFksIG9wYWNpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbGF5ZXIgKGB0cnVlYCBvciBgZmFsc2VgKS5cbiAgICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFLCB2aXNpYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgWi1pbmRleCBvZiB0aGUgbGF5ZXIsIHdoaWNoIGlzIHVzZWQgdG8gb3JkZXIgbGF5ZXJzIGJlZm9yZSByZW5kZXJpbmcuXG4gICAqIFRoZSBkZWZhdWx0IFotaW5kZXggaXMgMC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHppbmRleCBUaGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFpJbmRleCh6aW5kZXgpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlpfSU5ERVgsIHppbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVfKSB7XG4gICAgICB0aGlzLnN0YXRlXy5sYXllciA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRlXyA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VMYXllcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGJlZm9yZSBhIGxheWVyIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwcmVyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUFJFUkVOREVSOiAncHJlcmVuZGVyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbGF5ZXIgaXMgcmVuZGVyZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYmVmb3JlIGxheWVycyBhcmUgY29tcG9zZWQuICBXaGVuIGRpc3BhdGNoZWQgYnkgdGhlIG1hcCwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIG5vdCBoYXZlXG4gICAqIGEgYGNvbnRleHRgIHNldC4gIFdoZW4gZGlzcGF0Y2hlZCBieSBhIGxheWVyLCB0aGUgZXZlbnQgb2JqZWN0IHdpbGwgaGF2ZSBhIGBjb250ZXh0YCBzZXQuICBPbmx5XG4gICAqIFdlYkdMIGxheWVycyBjdXJyZW50bHkgZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUkVDT01QT1NFOiAncHJlY29tcG9zZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciBsYXllcnMgYXJlIGNvbXBvc2VkLiAgV2hlbiBkaXNwYXRjaGVkIGJ5IHRoZSBtYXAsIHRoZSBldmVudCBvYmplY3Qgd2lsbCBub3QgaGF2ZVxuICAgKiBhIGBjb250ZXh0YCBzZXQuICBXaGVuIGRpc3BhdGNoZWQgYnkgYSBsYXllciwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIGhhdmUgYSBgY29udGV4dGAgc2V0LiAgT25seVxuICAgKiBXZWJHTCBsYXllcnMgY3VycmVudGx5IGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3Rjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RDT01QT1NFOiAncG9zdGNvbXBvc2UnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiByZW5kZXJpbmcgaXMgY29tcGxldGUsIGkuZS4gYWxsIHNvdXJjZXMgYW5kIHRpbGVzIGhhdmVcbiAgICogZmluaXNoZWQgbG9hZGluZyBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQsIGFuZCBhbGwgdGlsZXMgYXJlIGZhZGVkIGluLlxuICAgKiBUaGUgZXZlbnQgb2JqZWN0IHdpbGwgbm90IGhhdmUgYSBgY29udGV4dGAgc2V0LlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNyZW5kZXJjb21wbGV0ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU5ERVJDT01QTEVURTogJ3JlbmRlcmNvbXBsZXRlJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeydwb3N0cmVuZGVyJ3wncHJlY29tcG9zZSd8J3Bvc3Rjb21wb3NlJ3wncmVuZGVyY29tcGxldGUnfSBNYXBSZW5kZXJFdmVudFR5cGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3Bvc3RyZW5kZXInfCdwcmVyZW5kZXInfSBMYXllclJlbmRlckV2ZW50VHlwZXNcbiAqL1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9WaWV3SGludFxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBBTklNQVRJTkc6IDAsXG4gIElOVEVSQUNUSU5HOiAxLFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvVmlld1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIENFTlRFUjogJ2NlbnRlcicsXG4gIFJFU09MVVRJT046ICdyZXNvbHV0aW9uJyxcbiAgUk9UQVRJT046ICdyb3RhdGlvbicsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9jb21tb25cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSB6b29tIGZvciBkZWZhdWx0IHRpbGUgZ3JpZHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfWk9PTSA9IDQyO1xuXG4vKipcbiAqIERlZmF1bHQgdGlsZSBzaXplLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElMRV9TSVpFID0gMjU2O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1VuaXRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3JhZGlhbnMnIHwgJ2RlZ3JlZXMnIHwgJ2Z0JyB8ICdtJyB8ICdwaXhlbHMnIHwgJ3RpbGUtcGl4ZWxzJyB8ICd1cy1mdCd9IFVuaXRzXG4gKiBQcm9qZWN0aW9uIHVuaXRzLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHA6Ly9kdWZmLmVzcy53YXNoaW5ndG9uLmVkdS9kYXRhL3Jhc3Rlci9kcmcvZG9jcy9nZW90aWZmLnR4dFxuICogQHR5cGUge09iamVjdDxudW1iZXIsIFVuaXRzPn1cbiAqL1xuY29uc3QgdW5pdEJ5Q29kZSA9IHtcbiAgJzkwMDEnOiAnbScsXG4gICc5MDAyJzogJ2Z0JyxcbiAgJzkwMDMnOiAndXMtZnQnLFxuICAnOTEwMSc6ICdyYWRpYW5zJyxcbiAgJzkxMDInOiAnZGVncmVlcycsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIFVuaXQgY29kZS5cbiAqIEByZXR1cm4ge1VuaXRzfSBVbml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Db2RlKGNvZGUpIHtcbiAgcmV0dXJuIHVuaXRCeUNvZGVbY29kZV07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0ZXJzUGVyVW5pdExvb2t1cFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGlhbnMgUmFkaWFuc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZ0ICBGZWV0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBNZXRlcnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cy1mdCBVUyBmZWV0XG4gKi9cblxuLyoqXG4gKiBNZXRlcnMgcGVyIHVuaXQgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7TWV0ZXJzUGVyVW5pdExvb2t1cH1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IHtcbiAgLy8gdXNlIHRoZSByYWRpdXMgb2YgdGhlIE5vcm1hbCBzcGhlcmVcbiAgJ3JhZGlhbnMnOiA2MzcwOTk3IC8gKDIgKiBNYXRoLlBJKSxcbiAgJ2RlZ3JlZXMnOiAoMiAqIE1hdGguUEkgKiA2MzcwOTk3KSAvIDM2MCxcbiAgJ2Z0JzogMC4zMDQ4LFxuICAnbSc6IDEsXG4gICd1cy1mdCc6IDEyMDAgLyAzOTM3LFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9Qcm9qZWN0aW9uXG4gKi9cbmltcG9ydCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL1VuaXRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29kZSBUaGUgU1JTIGlkZW50aWZpZXIgY29kZSwgZS5nLiBgRVBTRzo0MzI2YC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c30gW3VuaXRzXSBVbml0cy4gUmVxdWlyZWQgdW5sZXNzIGFcbiAqIHByb2o0IHByb2plY3Rpb24gaXMgZGVmaW5lZCBmb3IgYGNvZGVgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtheGlzT3JpZW50YXRpb249J2VudSddIFRoZSBheGlzIG9yaWVudGF0aW9uIGFzIHNwZWNpZmllZCBpbiBQcm9qNC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dsb2JhbD1mYWxzZV0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZCBmb3IgdGhlIHdob2xlIGdsb2JlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttZXRlcnNQZXJVbml0XSBUaGUgbWV0ZXJzIHBlciB1bml0IGZvciB0aGUgU1JTLlxuICogSWYgbm90IHByb3ZpZGVkLCB0aGUgYHVuaXRzYCBhcmUgdXNlZCB0byBnZXQgdGhlIG1ldGVycyBwZXIgdW5pdCBmcm9tIHRoZSB7QGxpbmsgTUVURVJTX1BFUl9VTklUfVxuICogbG9va3VwIHRhYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbd29ybGRFeHRlbnRdIFRoZSB3b3JsZCBleHRlbnQgZm9yIHRoZSBTUlMuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ9IFtnZXRQb2ludFJlc29sdXRpb25dXG4gKiBGdW5jdGlvbiB0byBkZXRlcm1pbmUgcmVzb2x1dGlvbiBhdCBhIHBvaW50LiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICogYG51bWJlcmAgdmlldyByZXNvbHV0aW9uIGFuZCBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zXG4gKiB0aGUgYG51bWJlcmAgcmVzb2x1dGlvbiBpbiBwcm9qZWN0aW9uIHVuaXRzIGF0IHRoZSBwYXNzZWQgY29vcmRpbmF0ZS4gSWYgdGhpcyBpcyBgdW5kZWZpbmVkYCxcbiAqIHRoZSBkZWZhdWx0IHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXRQb2ludFJlc29sdXRpb259IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gZGVmaW5pdGlvbiBjbGFzcy4gT25lIG9mIHRoZXNlIGlzIGNyZWF0ZWQgZm9yIGVhY2ggcHJvamVjdGlvblxuICogc3VwcG9ydGVkIGluIHRoZSBhcHBsaWNhdGlvbiBhbmQgc3RvcmVkIGluIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p9IG5hbWVzcGFjZS5cbiAqIFlvdSBjYW4gdXNlIHRoZXNlIGluIGFwcGxpY2F0aW9ucywgYnV0IHRoaXMgaXMgbm90IHJlcXVpcmVkLCBhcyBBUEkgcGFyYW1zXG4gKiBhbmQgb3B0aW9ucyB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSB3aGljaCBtZWFucyB0aGUgc2ltcGxlIHN0cmluZ1xuICogY29kZSB3aWxsIHN1ZmZpY2UuXG4gKlxuICogWW91IGNhbiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmdldH0gdG8gcmV0cmlldmUgdGhlIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyXG4gKiBwcm9qZWN0aW9uLlxuICpcbiAqIFRoZSBsaWJyYXJ5IGluY2x1ZGVzIGRlZmluaXRpb25zIGZvciBgRVBTRzo0MzI2YCBhbmQgYEVQU0c6Mzg1N2AsIHRvZ2V0aGVyXG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgYWxpYXNlczpcbiAqICogYEVQU0c6NDMyNmA6IENSUzo4NCwgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni42OjQzMjYsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQsIHVybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCxcbiAqICAgICBodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNixcbiAqICAgICB1cm46eC1vZ2M6ZGVmOmNyczpFUFNHOjQzMjZcbiAqICogYEVQU0c6Mzg1N2A6IEVQU0c6MTAyMTAwLCBFUFNHOjEwMjExMywgRVBTRzo5MDA5MTMsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni4xODozOjM4NTcsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTdcbiAqXG4gKiBJZiB5b3UgdXNlIFtwcm9qNGpzXShodHRwczovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzKSwgYWxpYXNlcyBjYW5cbiAqIGJlIGFkZGVkIHVzaW5nIGBwcm9qNC5kZWZzKClgLiBBZnRlciBhbGwgcmVxdWlyZWQgcHJvamVjdGlvbiBkZWZpbml0aW9ucyBhcmVcbiAqIGFkZGVkLCBjYWxsIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovcHJvajQucmVnaXN0ZXJ9IGZ1bmN0aW9uLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgUHJvamVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvZGVfID0gb3B0aW9ucy5jb2RlO1xuXG4gICAgLyoqXG4gICAgICogVW5pdHMgb2YgcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBXaGVuIHNldCB0byBgVElMRV9QSVhFTFNgLCBhXG4gICAgICogYHRoaXMuZXh0ZW50X2AgYW5kIGB0aGlzLndvcmxkRXh0ZW50X2AgbXVzdCBiZSBjb25maWd1cmVkIHByb3Blcmx5IGZvciBlYWNoXG4gICAgICogdGlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMudW5pdHNfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfSAqLyAob3B0aW9ucy51bml0cyk7XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGl0eSBleHRlbnQgb2YgdGhlIHByb2plY3Rpb24gaW4gcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBGb3IgcHJvamVjdGlvbnNcbiAgICAgKiB3aXRoIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgICAqIHRpbGUgcGl4ZWwgc3BhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBvcHRpb25zLmV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRlbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW50IG9mIHRoZSB3b3JsZCBpbiBFUFNHOjQzMjYuIEZvciBwcm9qZWN0aW9ucyB3aXRoXG4gICAgICogYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAgICogcHJvamVjdGVkIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkRXh0ZW50XyA9XG4gICAgICBvcHRpb25zLndvcmxkRXh0ZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndvcmxkRXh0ZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNPcmllbnRhdGlvbl8gPVxuICAgICAgb3B0aW9ucy5heGlzT3JpZW50YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXhpc09yaWVudGF0aW9uIDogJ2VudSc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsXyA9IG9wdGlvbnMuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdsb2JhbCA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiB0aGlzLmV4dGVudF8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IG9wdGlvbnMuZ2V0UG9pbnRSZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGVyc1BlclVuaXRfID0gb3B0aW9ucy5tZXRlcnNQZXJVbml0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBwcm9qZWN0aW9uIGlzIHN1aXRhYmxlIGZvciB3cmFwcGluZyB0aGUgeC1heGlzXG4gICAqL1xuICBjYW5XcmFwWCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5XcmFwWF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb2RlIGZvciB0aGlzIHByb2plY3Rpb24sIGUuZy4gJ0VQU0c6NDMyNicuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29kZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV4dGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5pdHMgb2YgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfSBVbml0cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VW5pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pdHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW1vdW50IG9mIG1ldGVycyBwZXIgdW5pdCBvZiB0aGlzIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBpc1xuICAgKiBub3QgY29uZmlndXJlZCB3aXRoIGBtZXRlcnNQZXJVbml0YCBvciBhIHVuaXRzIGlkZW50aWZpZXIsIHRoZSByZXR1cm4gaXNcbiAgICogYHVuZGVmaW5lZGAuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1ldGVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWV0ZXJzUGVyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRlcnNQZXJVbml0XyB8fCBNRVRFUlNfUEVSX1VOSVRbdGhpcy51bml0c19dO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd29ybGQgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0V29ybGRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud29ybGRFeHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXhpcyBvcmllbnRhdGlvbiBvZiB0aGlzIHByb2plY3Rpb24uXG4gICAqIEV4YW1wbGUgdmFsdWVzIGFyZTpcbiAgICogZW51IC0gdGhlIGRlZmF1bHQgZWFzdGluZywgbm9ydGhpbmcsIGVsZXZhdGlvbi5cbiAgICogbmV1IC0gbm9ydGhpbmcsIGVhc3RpbmcsIHVwIC0gdXNlZnVsIGZvciBcImxhdC9sb25nXCIgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyxcbiAgICogICAgIG9yIHNvdXRoIG9yaWVudGF0ZWQgdHJhbnN2ZXJzZSBtZXJjYXRvci5cbiAgICogd251IC0gd2VzdGluZywgbm9ydGhpbmcsIHVwIC0gc29tZSBwbGFuZXRhcnkgY29vcmRpbmF0ZSBzeXN0ZW1zIGhhdmVcbiAgICogICAgIFwid2VzdCBwb3NpdGl2ZVwiIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEF4aXMgb3JpZW50YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF4aXNPcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzT3JpZW50YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgcHJvamVjdGlvbiBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZD9cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGlzR2xvYmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGlmIHRoZSBwcm9qZWN0aW9uIGlzIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2xvYmFsIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHbG9iYWwoZ2xvYmFsKSB7XG4gICAgdGhpcy5nbG9iYWxfID0gZ2xvYmFsO1xuICAgIHRoaXMuY2FuV3JhcFhfID0gISEoZ2xvYmFsICYmIHRoaXMuZXh0ZW50Xyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRUaWxlR3JpZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gICAqL1xuICBzZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpIHtcbiAgICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSB0aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEV4dGVudChleHRlbnQpIHtcbiAgICB0aGlzLmV4dGVudF8gPSBleHRlbnQ7XG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IHdvcmxkRXh0ZW50IFdvcmxkIGV4dGVudFxuICAgKiAgICAgW21pbmxvbiwgbWlubGF0LCBtYXhsb24sIG1heGxhdF0uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFdvcmxkRXh0ZW50KHdvcmxkRXh0ZW50KSB7XG4gICAgdGhpcy53b3JsZEV4dGVudF8gPSB3b3JsZEV4dGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGdldFBvaW50UmVzb2x1dGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXRQb2ludFJlc29sdXRpb259XG4gICAqIGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcn0gZnVuYyBGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZXRQb2ludFJlc29sdXRpb24oZnVuYykge1xuICAgIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBmdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHBvaW50IHJlc29sdXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgcHJvamVjdGlvbiAoaWYgc2V0KS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9IFRoZSBjdXN0b20gcG9pbnRcbiAgICogcmVzb2x1dGlvbiBmdW5jdGlvbiAoaWYgc2V0KS5cbiAgICovXG4gIGdldFBvaW50UmVzb2x1dGlvbkZ1bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvamVjdGlvbjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnMzg1N1xuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL1Byb2plY3Rpb24uanMnO1xuXG4vKipcbiAqIFJhZGl1cyBvZiBXR1M4NCBzcGhlcmVcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEhBTEZfU0laRSA9IE1hdGguUEkgKiBSQURJVVM7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVYVEVOVCA9IFstSEFMRl9TSVpFLCAtSEFMRl9TSVpFLCBIQUxGX1NJWkUsIEhBTEZfU0laRV07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IFdPUkxEX0VYVEVOVCA9IFstMTgwLCAtODUsIDE4MCwgODVdO1xuXG4vKipcbiAqIE1heGltdW0gc2FmZSB2YWx1ZSBpbiB5IGRpcmVjdGlvblxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfWSA9IFJBRElVUyAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyAyKSk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIHdlYi9zcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKi9cbmNsYXNzIEVQU0czODU3UHJvamVjdGlvbiBleHRlbmRzIFByb2plY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgQ29kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICBzdXBlcih7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgdW5pdHM6ICdtJyxcbiAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgd29ybGRFeHRlbnQ6IFdPUkxEX0VYVEVOVCxcbiAgICAgIGdldFBvaW50UmVzb2x1dGlvbjogZnVuY3Rpb24gKHJlc29sdXRpb24sIHBvaW50KSB7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uIC8gTWF0aC5jb3NoKHBvaW50WzFdIC8gUkFESVVTKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjM4NTcuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgY29uc3QgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjEwMCcpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjExMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjkwMDkxMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvRVBTRy8wLzM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTcnKSxcbl07XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjQzMjYgdG8gRVBTRzozODU3LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FUFNHNDMyNihpbnB1dCwgb3V0cHV0LCBkaW1lbnNpb24pIHtcbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBkaW1lbnNpb24gPSBkaW1lbnNpb24gPiAxID8gZGltZW5zaW9uIDogMjtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgIG91dHB1dFtpXSA9IChIQUxGX1NJWkUgKiBpbnB1dFtpXSkgLyAxODA7XG4gICAgbGV0IHkgPSBSQURJVVMgKiBNYXRoLmxvZyhNYXRoLnRhbigoTWF0aC5QSSAqICgraW5wdXRbaSArIDFdICsgOTApKSAvIDM2MCkpO1xuICAgIGlmICh5ID4gTUFYX1NBRkVfWSkge1xuICAgICAgeSA9IE1BWF9TQUZFX1k7XG4gICAgfSBlbHNlIGlmICh5IDwgLU1BWF9TQUZFX1kpIHtcbiAgICAgIHkgPSAtTUFYX1NBRkVfWTtcbiAgICB9XG4gICAgb3V0cHV0W2kgKyAxXSA9IHk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBmcm9tIEVQU0c6Mzg1NyB0byBFUFNHOjQzMjYuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb25dIERpbWVuc2lvbiAoZGVmYXVsdCBpcyBgMmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9FUFNHNDMyNihpbnB1dCwgb3V0cHV0LCBkaW1lbnNpb24pIHtcbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBkaW1lbnNpb24gPSBkaW1lbnNpb24gPiAxID8gZGltZW5zaW9uIDogMjtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgIG91dHB1dFtpXSA9ICgxODAgKiBpbnB1dFtpXSkgLyBIQUxGX1NJWkU7XG4gICAgb3V0cHV0W2kgKyAxXSA9XG4gICAgICAoMzYwICogTWF0aC5hdGFuKE1hdGguZXhwKGlucHV0W2kgKyAxXSAvIFJBRElVUykpKSAvIE1hdGguUEkgLSA5MDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2c0MzI2XG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vUHJvamVjdGlvbi5qcyc7XG5cbi8qKlxuICogU2VtaS1tYWpvciByYWRpdXMgb2YgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG4vKipcbiAqIEV4dGVudCBvZiB0aGUgRVBTRzo0MzI2IHByb2plY3Rpb24gd2hpY2ggaXMgdGhlIHdob2xlIHdvcmxkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbLTE4MCwgLTkwLCAxODAsIDkwXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRFUlNfUEVSX1VOSVQgPSAoTWF0aC5QSSAqIFJBRElVUykgLyAxODA7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIFdHUzg0IGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKEVQU0c6NDMyNikuXG4gKlxuICogTm90ZSB0aGF0IE9wZW5MYXllcnMgZG9lcyBub3Qgc3RyaWN0bHkgY29tcGx5IHdpdGggdGhlIEVQU0cgZGVmaW5pdGlvbi5cbiAqIFRoZSBFUFNHIHJlZ2lzdHJ5IGRlZmluZXMgNDMyNiBhcyBhIENSUyBmb3IgTGF0aXR1ZGUsTG9uZ2l0dWRlICh5LHgpLlxuICogT3BlbkxheWVycyB0cmVhdHMgRVBTRzo0MzI2IGFzIGEgcHNldWRvLXByb2plY3Rpb24sIHdpdGggeCx5IGNvb3JkaW5hdGVzLlxuICovXG5jbGFzcyBFUFNHNDMyNlByb2plY3Rpb24gZXh0ZW5kcyBQcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIENvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uXSBBeGlzIG9yaWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgYXhpc09yaWVudGF0aW9uKSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHVuaXRzOiAnZGVncmVlcycsXG4gICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgIGF4aXNPcmllbnRhdGlvbjogYXhpc09yaWVudGF0aW9uLFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgbWV0ZXJzUGVyVW5pdDogTUVURVJTX1BFUl9VTklULFxuICAgICAgd29ybGRFeHRlbnQ6IEVYVEVOVCxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignQ1JTOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0VQU0c6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoyOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2Nycy9PR0MvMS4zL0NSUzg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCM0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvRVBTRy8wLzQzMjYnLCAnbmV1JyksXG5dO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3Byb2plY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5sZXQgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcHJvamVjdGlvbnMgY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgY2FjaGUgPSB7fTtcbn1cblxuLyoqXG4gKiBHZXQgYSBjYWNoZWQgcHJvamVjdGlvbiBieSBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFRoZSBwcm9qZWN0aW9uIChpZiBjYWNoZWQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBjYWNoZVtjb2RlXSB8fFxuICAgIGNhY2hlW2NvZGUucmVwbGFjZSgvdXJuOih4LSk/b2djOmRlZjpjcnM6RVBTRzooLio6KT8oXFx3KykkLywgJ0VQU0c6JDMnKV0gfHxcbiAgICBudWxsXG4gICk7XG59XG5cbi8qKlxuICogQWRkIGEgcHJvamVjdGlvbiB0byB0aGUgY2FjaGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBUaGUgcHJvamVjdGlvbiBjb2RlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbiB0byBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChjb2RlLCBwcm9qZWN0aW9uKSB7XG4gIGNhY2hlW2NvZGVdID0gcHJvamVjdGlvbjtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai90cmFuc2Zvcm1zXG4gKi9cbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vb2JqLmpzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9uPj59XG4gKi9cbmxldCB0cmFuc2Zvcm1zID0ge307XG5cbi8qKlxuICogQ2xlYXIgdGhlIHRyYW5zZm9ybSBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICB0cmFuc2Zvcm1zID0ge307XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgY29udmVyc2lvbiBmdW5jdGlvbiB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZVxuICogcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChzb3VyY2UsIGRlc3RpbmF0aW9uLCB0cmFuc2Zvcm1Gbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgY29uc3QgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICBpZiAoIShzb3VyY2VDb2RlIGluIHRyYW5zZm9ybXMpKSB7XG4gICAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSA9IHt9O1xuICB9XG4gIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXSA9IHRyYW5zZm9ybUZuO1xufVxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLiAgVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjbGVhbiB1cFxuICogY2FjaGVkIHRyYW5zZm9ybXMgZHVyaW5nIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRoZSB1bnJlZ2lzdGVyZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3Qgc291cmNlQ29kZSA9IHNvdXJjZS5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uLmdldENvZGUoKTtcbiAgY29uc3QgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdO1xuICBkZWxldGUgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdO1xuICBpZiAoaXNFbXB0eSh0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdKSkge1xuICAgIGRlbGV0ZSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbi8qKlxuICogR2V0IGEgdHJhbnNmb3JtIGdpdmVuIGEgc291cmNlIGNvZGUgYW5kIGEgZGVzdGluYXRpb24gY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VDb2RlIFRoZSBjb2RlIGZvciB0aGUgc291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25Db2RlIFRoZSBjb2RlIGZvciB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb258dW5kZWZpbmVkfSBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIChpZiBmb3VuZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoc291cmNlQ29kZSwgZGVzdGluYXRpb25Db2RlKSB7XG4gIGxldCB0cmFuc2Zvcm07XG4gIGlmIChzb3VyY2VDb2RlIGluIHRyYW5zZm9ybXMgJiYgZGVzdGluYXRpb25Db2RlIGluIHRyYW5zZm9ybXNbc291cmNlQ29kZV0pIHtcbiAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvY29vcmRpbmF0ZVxuICovXG5pbXBvcnQge2dldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsbywgdG9GaXhlZH0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7cGFkTnVtYmVyfSBmcm9tICcuL3N0cmluZy5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4gYHh5YCwgYHh5emAgb3IgYHh5em1gIGNvb3JkaW5hdGUuXG4gKiBFeGFtcGxlOiBgWzE2LCA0OF1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IENvb3JkaW5hdGVcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmRcbiAqIHRyYW5zZm9ybXMgaXQgaW50byBhIGB7c3RyaW5nfWAuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChDb29yZGluYXRlfHVuZGVmaW5lZCkpOiBzdHJpbmd9IENvb3JkaW5hdGVGb3JtYXRcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEFkZCBgZGVsdGFgIHRvIGBjb29yZGluYXRlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7YWRkfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBhZGQoY29vcmQsIFstMiwgNF0pO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbNS44NSwgNTEuOTgzMzMzXVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBpbnB1dCBjb29yZGluYXRlIGFkanVzdGVkIGJ5XG4gKiB0aGUgZ2l2ZW4gZGVsdGEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29vcmRpbmF0ZSwgZGVsdGEpIHtcbiAgY29vcmRpbmF0ZVswXSArPSArZGVsdGFbMF07XG4gIGNvb3JkaW5hdGVbMV0gKz0gK2RlbHRhWzFdO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gY2lyY2xlIFRoZSBjaXJjbGUuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDbG9zZXN0IHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uQ2lyY2xlKGNvb3JkaW5hdGUsIGNpcmNsZSkge1xuICBjb25zdCByID0gY2lyY2xlLmdldFJhZGl1cygpO1xuICBjb25zdCBjZW50ZXIgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XG4gIGNvbnN0IHgwID0gY2VudGVyWzBdO1xuICBjb25zdCB5MCA9IGNlbnRlclsxXTtcbiAgY29uc3QgeDEgPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5MSA9IGNvb3JkaW5hdGVbMV07XG5cbiAgbGV0IGR4ID0geDEgLSB4MDtcbiAgY29uc3QgZHkgPSB5MSAtIHkwO1xuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICBkeCA9IDE7XG4gIH1cbiAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgY29uc3QgeCA9IHgwICsgKHIgKiBkeCkgLyBkO1xuICBjb25zdCB5ID0geTAgKyAociAqIGR5KSAvIGQ7XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIHNlZ21lbnQuXG4gKiBUaGlzIGlzIHRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50IHdoZW5cbiAqIHRoZSBmb290IGlzIG9uIHRoZSBzZWdtZW50LCBvciB0aGUgY2xvc2VzdCBzZWdtZW50IGNvb3JkaW5hdGUgd2hlbiB0aGUgZm9vdFxuICogaXMgb3V0c2lkZSB0aGUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBzZWdtZW50IFRoZSB0d28gY29vcmRpbmF0ZXNcbiAqIG9mIHRoZSBzZWdtZW50LlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGZvb3Qgb2YgdGhlIHBlcnBlbmRpY3VsYXIgb2ZcbiAqIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSB7XG4gIGNvbnN0IHgwID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeTAgPSBjb29yZGluYXRlWzFdO1xuICBjb25zdCBzdGFydCA9IHNlZ21lbnRbMF07XG4gIGNvbnN0IGVuZCA9IHNlZ21lbnRbMV07XG4gIGNvbnN0IHgxID0gc3RhcnRbMF07XG4gIGNvbnN0IHkxID0gc3RhcnRbMV07XG4gIGNvbnN0IHgyID0gZW5kWzBdO1xuICBjb25zdCB5MiA9IGVuZFsxXTtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIGNvbnN0IGFsb25nID1cbiAgICBkeCA9PT0gMCAmJiBkeSA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IChkeCAqICh4MCAtIHgxKSArIGR5ICogKHkwIC0geTEpKSAvIChkeCAqIGR4ICsgZHkgKiBkeSB8fCAwKTtcbiAgbGV0IHgsIHk7XG4gIGlmIChhbG9uZyA8PSAwKSB7XG4gICAgeCA9IHgxO1xuICAgIHkgPSB5MTtcbiAgfSBlbHNlIGlmIChhbG9uZyA+PSAxKSB7XG4gICAgeCA9IHgyO1xuICAgIHkgPSB5MjtcbiAgfSBlbHNlIHtcbiAgICB4ID0geDEgKyBhbG9uZyAqIGR4O1xuICAgIHkgPSB5MSArIGFsb25nICogZHk7XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGVGb3JtYXR9IGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiB1c2VkIHRvIGZvcm1hdFxuICogYSB7Q29vcmRpbmF0ZX0gdG8gYSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2NyZWF0ZVN0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBzdHJpbmdpZnlGdW5jID0gY3JlYXRlU3RyaW5nWFkoKTtcbiAqICAgICBjb25zdCBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIHdpdGggZXhwbGljaXRseSBzcGVjaWZ5aW5nIDIgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Y3JlYXRlU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHN0cmluZ2lmeUZ1bmMgPSBjcmVhdGVTdHJpbmdYWSgyKTtcbiAqICAgICBjb25zdCBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc3Ljg1LCA0Ny45OCdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlRm9ybWF0fSBDb29yZGluYXRlIGZvcm1hdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1hZKGZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgWFkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIGZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhlbWlzcGhlcmVzIEhlbWlzcGhlcmVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlc1RvU3RyaW5nSERNUyhoZW1pc3BoZXJlcywgZGVncmVlcywgZnJhY3Rpb25EaWdpdHMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZERlZ3JlZXMgPSBtb2R1bG8oZGVncmVlcyArIDE4MCwgMzYwKSAtIDE4MDtcbiAgY29uc3QgeCA9IE1hdGguYWJzKDM2MDAgKiBub3JtYWxpemVkRGVncmVlcyk7XG4gIGNvbnN0IGRlY2ltYWxzID0gZnJhY3Rpb25EaWdpdHMgfHwgMDtcblxuICBsZXQgZGVnID0gTWF0aC5mbG9vcih4IC8gMzYwMCk7XG4gIGxldCBtaW4gPSBNYXRoLmZsb29yKCh4IC0gZGVnICogMzYwMCkgLyA2MCk7XG4gIGxldCBzZWMgPSB0b0ZpeGVkKHggLSBkZWcgKiAzNjAwIC0gbWluICogNjAsIGRlY2ltYWxzKTtcblxuICBpZiAoc2VjID49IDYwKSB7XG4gICAgc2VjID0gMDtcbiAgICBtaW4gKz0gMTtcbiAgfVxuXG4gIGlmIChtaW4gPj0gNjApIHtcbiAgICBtaW4gPSAwO1xuICAgIGRlZyArPSAxO1xuICB9XG5cbiAgbGV0IGhkbXMgPSBkZWcgKyAnXFx1MDBiMCc7XG4gIGlmIChtaW4gIT09IDAgfHwgc2VjICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBwYWROdW1iZXIobWluLCAyKSArICdcXHUyMDMyJztcbiAgfVxuICBpZiAoc2VjICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBwYWROdW1iZXIoc2VjLCAyLCBkZWNpbWFscykgKyAnXFx1MjAzMyc7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWREZWdyZWVzICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBoZW1pc3BoZXJlcy5jaGFyQXQobm9ybWFsaXplZERlZ3JlZXMgPCAwID8gMSA6IDApO1xuICB9XG5cbiAgcmV0dXJuIGhkbXM7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHRvIGEgc3RyaW5nXG4gKiB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIHRlbXBsYXRlLiBUaGUgc3RyaW5ncyBge3h9YCBhbmQgYHt5fWAgaW4gdGhlIHRlbXBsYXRlXG4gKiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgY29vcmRpbmF0ZSB2YWx1ZXMgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgY29uc3Qgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoOHw0OCkuJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgY29uc3Qgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSwgMik7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoNy44NXw0Ny45OCkuJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIEEgdGVtcGxhdGUgc3RyaW5nIHdpdGggYHt4fWAgYW5kIGB7eX1gIHBsYWNlaG9sZGVyc1xuICogICAgIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSBmaXJzdCBhbmQgc2Vjb25kIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChjb29yZGluYXRlLCB0ZW1wbGF0ZSwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgaWYgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVcbiAgICAgIC5yZXBsYWNlKCd7eH0nLCBjb29yZGluYXRlWzBdLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKVxuICAgICAgLnJlcGxhY2UoJ3t5fScsIGNvb3JkaW5hdGVbMV0udG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBjb29yZGluYXRlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoY29vcmRpbmF0ZTEsIGNvb3JkaW5hdGUyKSB7XG4gIGxldCBlcXVhbHMgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gY29vcmRpbmF0ZTEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAoY29vcmRpbmF0ZTFbaV0gIT0gY29vcmRpbmF0ZTJbaV0pIHtcbiAgICAgIGVxdWFscyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcXVhbHM7XG59XG5cbi8qKlxuICogUm90YXRlIGBjb29yZGluYXRlYCBieSBgYW5nbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kXG4gKiByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtyb3RhdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHJvdGF0ZVJhZGlhbnMgPSBNYXRoLlBJIC8gMjsgLy8gOTAgZGVncmVlc1xuICogICAgIHJvdGF0ZShjb29yZCwgcm90YXRlUmFkaWFucyk7XG4gKiAgICAgLy8gY29vcmQgaXMgbm93IFstNDcuOTgzMzMzLCA3Ljg1XVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIHJhZGlhbi5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoY29vcmRpbmF0ZSwgYW5nbGUpIHtcbiAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXSAqIGNvc0FuZ2xlIC0gY29vcmRpbmF0ZVsxXSAqIHNpbkFuZ2xlO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXSAqIGNvc0FuZ2xlICsgY29vcmRpbmF0ZVswXSAqIHNpbkFuZ2xlO1xuICBjb29yZGluYXRlWzBdID0geDtcbiAgY29vcmRpbmF0ZVsxXSA9IHk7XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIFNjYWxlIGBjb29yZGluYXRlYCBieSBgc2NhbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkXG4gKiBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtzY2FsZSBhcyBzY2FsZUNvb3JkaW5hdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHNjYWxlID0gMS4yO1xuICogICAgIHNjYWxlQ29vcmRpbmF0ZShjb29yZCwgc2NhbGUpO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbOS40MiwgNTcuNTc5OTk5Nl1cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZSBmYWN0b3IuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoY29vcmRpbmF0ZSwgc2NhbGUpIHtcbiAgY29vcmRpbmF0ZVswXSAqPSBzY2FsZTtcbiAgY29vcmRpbmF0ZVsxXSAqPSBzY2FsZTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gY29vcmQxIGFuZCBjb29yZDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgY29uc3QgZHggPSBjb29yZDFbMF0gLSBjb29yZDJbMF07XG4gIGNvbnN0IGR5ID0gY29vcmQxWzFdIC0gY29vcmQyWzFdO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIGNvb3JkMSBhbmQgY29vcmQyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSBhIGNvb3JkaW5hdGUgdG8gYSBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gc2VnbWVudCBMaW5lIHNlZ21lbnQgKDJcbiAqIGNvb3JkaW5hdGVzKS5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZShjb29yZGluYXRlLCBjbG9zZXN0T25TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBnZW9ncmFwaGljIGNvb3JkaW5hdGUgd2l0aCB0aGUgaGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcywgYW5kXG4gKiBzZWNvbmRzLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nSERNU30gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdIRE1TKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc0N1x1MDBCMCA1OFx1MjAzMiA2MFx1MjAzMyBOIDdcdTAwQjAgNTBcdTIwMzIgNjBcdTIwMzMgRSdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdIRE1TfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ0hETVMoY29vcmQsIDEpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzQ3XHUwMEIwIDU4XHUyMDMyIDYwLjBcdTIwMzMgTiA3XHUwMEIwIDUwXHUyMDMyIDYwLjBcdTIwMzMgRSdcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcyBhbmQgc2Vjb25kcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nSERNUyhjb29yZGluYXRlLCBmcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBkZWdyZWVzVG9TdHJpbmdIRE1TKCdOUycsIGNvb3JkaW5hdGVbMV0sIGZyYWN0aW9uRGlnaXRzKSArXG4gICAgICAnICcgK1xuICAgICAgZGVncmVlc1RvU3RyaW5nSERNUygnRVcnLCBjb29yZGluYXRlWzBdLCBmcmFjdGlvbkRpZ2l0cylcbiAgICApO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBjb29yZGluYXRlIGFzIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ1hZKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdYWShjb29yZCwgMSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNy44LCA0OC4wJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBYWS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nWFkoY29vcmRpbmF0ZSwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgcmV0dXJuIGZvcm1hdChjb29yZGluYXRlLCAne3h9LCB7eX0nLCBmcmFjdGlvbkRpZ2l0cyk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGUgaW4tcGxhY2UgdG8gYmUgd2l0aGluIHRoZSByZWFsIHdvcmxkXG4gKiBleHRlbnQuIFRoZSBsb3dlciBwcm9qZWN0aW9uIGV4dGVudCBib3VuZGFyeSBpcyBpbmNsdXNpdmUsIHRoZSB1cHBlciBvbmVcbiAqIGV4Y2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgd2l0aGluIHRoZSByZWFsIHdvcmxkIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKGNvb3JkaW5hdGUsIHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSkge1xuICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uLmdldEV4dGVudCgpKTtcbiAgICBjb25zdCB3b3JsZHNBd2F5ID0gZ2V0V29ybGRzQXdheShjb29yZGluYXRlLCBwcm9qZWN0aW9uLCB3b3JsZFdpZHRoKTtcbiAgICBpZiAod29ybGRzQXdheSkge1xuICAgICAgY29vcmRpbmF0ZVswXSAtPSB3b3JsZHNBd2F5ICogd29ybGRXaWR0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW3NvdXJjZUV4dGVudFdpZHRoXSBXaWR0aCBvZiB0aGUgc291cmNlIGV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gT2Zmc2V0IGluIHdvcmxkIHdpZHRocy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmxkc0F3YXkoY29vcmRpbmF0ZSwgcHJvamVjdGlvbiwgc291cmNlRXh0ZW50V2lkdGgpIHtcbiAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGxldCB3b3JsZHNBd2F5ID0gMDtcbiAgaWYgKFxuICAgIHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgIChjb29yZGluYXRlWzBdIDwgcHJvamVjdGlvbkV4dGVudFswXSB8fCBjb29yZGluYXRlWzBdID4gcHJvamVjdGlvbkV4dGVudFsyXSlcbiAgKSB7XG4gICAgc291cmNlRXh0ZW50V2lkdGggPSBzb3VyY2VFeHRlbnRXaWR0aCB8fCBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICB3b3JsZHNBd2F5ID0gTWF0aC5mbG9vcihcbiAgICAgIChjb29yZGluYXRlWzBdIC0gcHJvamVjdGlvbkV4dGVudFswXSkgLyBzb3VyY2VFeHRlbnRXaWR0aFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHdvcmxkc0F3YXk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NwaGVyZVxuICovXG5pbXBvcnQge3RvRGVncmVlcywgdG9SYWRpYW5zfSBmcm9tICcuL21hdGguanMnO1xuXG4vKipcbiAqIE9iamVjdCBsaXRlcmFsIHdpdGggb3B0aW9ucyBmb3IgdGhlIHtAbGluayBnZXRMZW5ndGh9IG9yIHtAbGluayBnZXRBcmVhfVxuICogZnVuY3Rpb25zLlxuICogQHR5cGVkZWYge09iamVjdH0gU3BoZXJlTWV0cmljT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXVxuICogUHJvamVjdGlvbiBvZiB0aGUgIGdlb21ldHJ5LiAgQnkgZGVmYXVsdCwgdGhlIGdlb21ldHJ5IGlzIGFzc3VtZWQgdG8gYmUgaW5cbiAqIFdlYiBNZXJjYXRvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzPTYzNzEwMDguOF0gU3BoZXJlIHJhZGl1cy4gIEJ5IGRlZmF1bHQsIHRoZVxuICogW21lYW4gRWFydGggcmFkaXVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FYXJ0aF9yYWRpdXMjTWVhbl9yYWRpdXMpXG4gKiBmb3IgdGhlIFdHUzg0IGVsbGlwc29pZCBpcyB1c2VkLlxuICovXG5cbi8qKlxuICogVGhlIG1lYW4gRWFydGggcmFkaXVzICgxLzMgKiAoMmEgKyBiKSkgZm9yIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FYXJ0aF9yYWRpdXMjTWVhbl9yYWRpdXNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JBRElVUyA9IDYzNzEwMDguODtcblxuLyoqXG4gKiBHZXQgdGhlIGdyZWF0IGNpcmNsZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheX0gYzEgU3RhcnRpbmcgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGMyIEVuZGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNdIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS4gIERlZmF1bHRzIHRvIHRoZSBFYXJ0aCdzXG4gKiAgICAgbWVhbiByYWRpdXMgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdyZWF0IGNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgKGluIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZShjMSwgYzIsIHJhZGl1cykge1xuICByYWRpdXMgPSByYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIGNvbnN0IGxhdDEgPSB0b1JhZGlhbnMoYzFbMV0pO1xuICBjb25zdCBsYXQyID0gdG9SYWRpYW5zKGMyWzFdKTtcbiAgY29uc3QgZGVsdGFMYXRCeTIgPSAobGF0MiAtIGxhdDEpIC8gMjtcbiAgY29uc3QgZGVsdGFMb25CeTIgPSB0b1JhZGlhbnMoYzJbMF0gLSBjMVswXSkgLyAyO1xuICBjb25zdCBhID1cbiAgICBNYXRoLnNpbihkZWx0YUxhdEJ5MikgKiBNYXRoLnNpbihkZWx0YUxhdEJ5MikgK1xuICAgIE1hdGguc2luKGRlbHRhTG9uQnkyKSAqXG4gICAgICBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKlxuICAgICAgTWF0aC5jb3MobGF0MSkgKlxuICAgICAgTWF0aC5jb3MobGF0Mik7XG4gIHJldHVybiAyICogcmFkaXVzICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VtdWxhdGl2ZSBncmVhdCBjaXJjbGUgbGVuZ3RoIG9mIGxpbmVzdHJpbmcgY29vcmRpbmF0ZXMgKGdlb2dyYXBoaWMpLlxuICogQHBhcmFtIHtBcnJheX0gY29vcmRpbmF0ZXMgTGluZXN0cmluZyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICovXG5mdW5jdGlvbiBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKSB7XG4gIGxldCBsZW5ndGggPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaSAtIDE7ICsraSkge1xuICAgIGxlbmd0aCArPSBnZXREaXN0YW5jZShjb29yZGluYXRlc1tpXSwgY29vcmRpbmF0ZXNbaSArIDFdLCByYWRpdXMpO1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgbGVuZ3RoIG9mIGEgZ2VvbWV0cnkuICBUaGlzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZVxuICogZ3JlYXQgY2lyY2xlIGRpc3RhbmNlcyBiZXR3ZWVuIGNvb3JkaW5hdGVzLiAgRm9yIHBvbHlnb25zLCB0aGUgbGVuZ3RoIGlzXG4gKiB0aGUgc3VtIG9mIGFsbCByaW5ncy4gIEZvciBwb2ludHMsIHRoZSBsZW5ndGggaXMgemVyby4gIEZvciBtdWx0aS1wYXJ0XG4gKiBnZW9tZXRyaWVzLCB0aGUgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIGxlbmd0aCBvZiBlYWNoIHBhcnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBBIGdlb21ldHJ5LlxuICogQHBhcmFtIHtTcGhlcmVNZXRyaWNPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlXG4gKiBsZW5ndGggY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBwcm92aWRpbmcgYSBgcHJvamVjdGlvbmAgb3B0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3BoZXJpY2FsIGxlbmd0aCAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlbmd0aChnZW9tZXRyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIGNvbnN0IHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gfHwgJ0VQU0c6Mzg1Nyc7XG4gIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gIGlmICh0eXBlICE9PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKS50cmFuc2Zvcm0ocHJvamVjdGlvbiwgJ0VQU0c6NDMyNicpO1xuICB9XG4gIGxldCBsZW5ndGggPSAwO1xuICBsZXQgY29vcmRpbmF0ZXMsIGNvb3JkcywgaSwgaWksIGosIGpqO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6IHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdMaW5lYXJSaW5nJzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBsZW5ndGggPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ1BvbHlnb24nOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXNbaV0sIHJhZGl1cyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRzW2pdLCByYWRpdXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzoge1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgKS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoKGdlb21ldHJpZXNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNwaGVyaWNhbCBhcmVhIGZvciBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMuXG4gKlxuICogW1JlZmVyZW5jZV0oaHR0cHM6Ly90cnMuanBsLm5hc2EuZ292L2hhbmRsZS8yMDE0LzQwNDA5KVxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yXG4gKiBQb2x5Z29ucyBvbiBhIFNwaGVyZVwiLCBKUEwgUHVibGljYXRpb24gMDctMDMsIEpldCBQcm9wdWxzaW9uXG4gKiBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwN1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBMaXN0IG9mIGNvb3JkaW5hdGVzIG9mIGEgbGluZWFyXG4gKiByaW5nLiBJZiB0aGUgcmluZyBpcyBvcmllbnRlZCBjbG9ja3dpc2UsIHRoZSBhcmVhIHdpbGwgYmUgcG9zaXRpdmUsXG4gKiBvdGhlcndpc2UgaXQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKGluIHNxdWFyZSBtZXRlcnMpLlxuICovXG5mdW5jdGlvbiBnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cykge1xuICBsZXQgYXJlYSA9IDA7XG4gIGNvbnN0IGxlbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgbGV0IHgxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMF07XG4gIGxldCB5MSA9IGNvb3JkaW5hdGVzW2xlbiAtIDFdWzFdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgeDIgPSBjb29yZGluYXRlc1tpXVswXTtcbiAgICBjb25zdCB5MiA9IGNvb3JkaW5hdGVzW2ldWzFdO1xuICAgIGFyZWEgKz1cbiAgICAgIHRvUmFkaWFucyh4MiAtIHgxKSAqXG4gICAgICAoMiArIE1hdGguc2luKHRvUmFkaWFucyh5MSkpICsgTWF0aC5zaW4odG9SYWRpYW5zKHkyKSkpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gKGFyZWEgKiByYWRpdXMgKiByYWRpdXMpIC8gMi4wO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3BoZXJpY2FsIGFyZWEgb2YgYSBnZW9tZXRyeS4gIFRoaXMgaXMgdGhlIGFyZWEgKGluIG1ldGVycykgYXNzdW1pbmdcbiAqIHRoYXQgcG9seWdvbiBlZGdlcyBhcmUgc2VnbWVudHMgb2YgZ3JlYXQgY2lyY2xlcyBvbiBhIHNwaGVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEEgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1NwaGVyZU1ldHJpY09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgYXJlYVxuICogICAgIGNhbGN1bGF0aW9uLiAgQnkgZGVmYXVsdCwgZ2VvbWV0cmllcyBhcmUgYXNzdW1lZCB0byBiZSBpbiAnRVBTRzozODU3Jy5cbiAqICAgICBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgYXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiB8fCAnRVBTRzozODU3JztcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgbGV0IGFyZWEgPSAwO1xuICBsZXQgY29vcmRpbmF0ZXMsIGNvb3JkcywgaSwgaWksIGosIGpqO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdMaW5lYXJSaW5nJzoge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ1BvbHlnb24nOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgYXJlYSA9IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlc1swXSwgcmFkaXVzKSk7XG4gICAgICBmb3IgKGkgPSAxLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXNbaV0sIHJhZGl1cykpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ011bHRpUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBhcmVhICs9IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZHNbMF0sIHJhZGl1cykpO1xuICAgICAgICBmb3IgKGogPSAxLCBqaiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRzW2pdLCByYWRpdXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IHtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPVxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICkuZ2V0R2VvbWV0cmllcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgYXJlYSArPSBnZXRBcmVhKGdlb21ldHJpZXNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGF0IHRoZSBnaXZlbiBkaXN0YW5jZSBhbmQgYmVhcmluZyBmcm9tIGBjMWAuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYzEgVGhlIG9yaWdpbiBwb2ludCAoYFtsb24sIGxhdF1gIGluIGRlZ3JlZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIFRoZSBncmVhdC1jaXJjbGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgb3JpZ2luXG4gKiAgICAgcG9pbnQgYW5kIHRoZSB0YXJnZXQgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZyBUaGUgYmVhcmluZyAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1c10gVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSB0YXJnZXQgcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXQoYzEsIGRpc3RhbmNlLCBiZWFyaW5nLCByYWRpdXMpIHtcbiAgcmFkaXVzID0gcmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgY29uc3QgbG9uMSA9IHRvUmFkaWFucyhjMVswXSk7XG4gIGNvbnN0IGRCeVIgPSBkaXN0YW5jZSAvIHJhZGl1cztcbiAgY29uc3QgbGF0ID0gTWF0aC5hc2luKFxuICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MoZEJ5UikgK1xuICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGJlYXJpbmcpXG4gICk7XG4gIGNvbnN0IGxvbiA9XG4gICAgbG9uMSArXG4gICAgTWF0aC5hdGFuMihcbiAgICAgIE1hdGguc2luKGJlYXJpbmcpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhsYXQxKSxcbiAgICAgIE1hdGguY29zKGRCeVIpIC0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQpXG4gICAgKTtcbiAgcmV0dXJuIFt0b0RlZ3JlZXMobG9uKSwgdG9EZWdyZWVzKGxhdCldO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb25zb2xlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2luZm8nfCd3YXJuJ3wnZXJyb3InfCdub25lJ30gTGV2ZWxcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8TGV2ZWwsIG51bWJlcj59XG4gKi9cbmNvbnN0IGxldmVscyA9IHtcbiAgaW5mbzogMSxcbiAgd2FybjogMixcbiAgZXJyb3I6IDMsXG4gIG5vbmU6IDQsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBsZXZlbCA9IGxldmVscy5pbmZvO1xuXG4vKipcbiAqIFNldCB0aGUgbG9nZ2luZyBsZXZlbC4gIEJ5IGRlZmF1bHQsIHRoZSBsZXZlbCBpcyBzZXQgdG8gJ2luZm8nIGFuZCBhbGxcbiAqIG1lc3NhZ2VzIHdpbGwgYmUgbG9nZ2VkLiAgU2V0IHRvICd3YXJuJyB0byBvbmx5IGRpc3BsYXkgd2FybmluZ3MgYW5kIGVycm9ycy5cbiAqIFNldCB0byAnZXJyb3InIHRvIG9ubHkgZGlzcGxheSBlcnJvcnMuICBTZXQgdG8gJ25vbmUnIHRvIHNpbGVuY2UgYWxsIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7TGV2ZWx9IGwgVGhlIG5ldyBsZXZlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExldmVsKGwpIHtcbiAgbGV2ZWwgPSBsZXZlbHNbbF07XG59XG5cbi8qKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFyZ3VtZW50cyB0byBsb2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gIGlmIChsZXZlbCA+IGxldmVscy5pbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKC4uLmFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgQXJndW1lbnRzIHRvIGxvZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2FybiguLi5hcmdzKSB7XG4gIGlmIChsZXZlbCA+IGxldmVscy53YXJuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybiguLi5hcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5cbi8qKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFyZ3VtZW50cyB0byBsb2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKC4uLmFyZ3MpIHtcbiAgaWYgKGxldmVsID4gbGV2ZWxzLmVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qXG4gKi9cblxuLyoqXG4gKiBUaGUgb2wvcHJvaiBtb2R1bGUgc3RvcmVzOlxuICogKiBhIGxpc3Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn1cbiAqIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBwcm9qZWN0aW9uIHN1cHBvcnRlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqICogYSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgbmVlZGVkIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gb25lIHByb2plY3Rpb25cbiAqIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgc3RhdGljIGZ1bmN0aW9ucyBhcmUgdGhlIG1ldGhvZHMgdXNlZCB0byBtYWludGFpbiB0aGVzZS5cbiAqIEVhY2ggdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiBoYW5kbGUgbm90IG9ubHkgc2ltcGxlIGNvb3JkaW5hdGUgcGFpcnMsIGJ1dCBhbHNvXG4gKiBsYXJnZSBhcnJheXMgb2YgY29vcmRpbmF0ZXMgc3VjaCBhcyB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBXaGVuIGxvYWRlZCwgdGhlIGxpYnJhcnkgYWRkcyBwcm9qZWN0aW9uIG9iamVjdHMgZm9yIEVQU0c6NDMyNiAoV0dTODRcbiAqIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMpIGFuZCBFUFNHOjM4NTcgKFdlYiBvciBTcGhlcmljYWwgTWVyY2F0b3IsIGFzIHVzZWRcbiAqIGZvciBleGFtcGxlIGJ5IEJpbmcgTWFwcyBvciBPcGVuU3RyZWV0TWFwKSwgdG9nZXRoZXIgd2l0aCB0aGUgcmVsZXZhbnRcbiAqIHRyYW5zZm9ybSBmdW5jdGlvbnMuXG4gKlxuICogQWRkaXRpb25hbCB0cmFuc2Zvcm1zIG1heSBiZSBhZGRlZCBieSB1c2luZyB0aGUgaHR0cDovL3Byb2o0anMub3JnL1xuICogbGlicmFyeSAodmVyc2lvbiAyLjIgb3IgbGF0ZXIpLiBZb3UgY2FuIHVzZSB0aGUgZnVsbCBidWlsZCBzdXBwbGllZCBieVxuICogUHJvajRqcywgb3IgY3JlYXRlIGEgY3VzdG9tIGJ1aWxkIHRvIHN1cHBvcnQgdGhvc2UgcHJvamVjdGlvbnMgeW91IG5lZWQ7IHNlZVxuICogdGhlIFByb2o0anMgd2Vic2l0ZSBmb3IgaG93IHRvIGRvIHRoaXMuIFlvdSBhbHNvIG5lZWQgdGhlIFByb2o0anMgZGVmaW5pdGlvbnNcbiAqIGZvciB0aGUgcmVxdWlyZWQgcHJvamVjdGlvbnMuIFRoZXNlIGRlZmluaXRpb25zIGNhbiBiZSBvYnRhaW5lZCBmcm9tXG4gKiBodHRwczovL2Vwc2cuaW8vLCBhbmQgYXJlIGEgSlMgZnVuY3Rpb24sIHNvIGNhbiBiZSBsb2FkZWQgaW4gYSBzY3JpcHRcbiAqIHRhZyAoYXMgaW4gdGhlIGV4YW1wbGVzKSBvciBwYXN0ZWQgaW50byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZSBhZGRlZCB0byBwcm9qNCdzIHJlZ2lzdHJ5IChieVxuICogdXNpbmcgYHByb2o0LmRlZnMoKWApLCBzaW1wbHkgY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBmcm9tIHRoZSBgb2wvcHJvai9wcm9qNGBcbiAqIHBhY2thZ2UuIEV4aXN0aW5nIHRyYW5zZm9ybXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IHRoaXMgZnVuY3Rpb24uIFNlZVxuICogZXhhbXBsZXMvd21zLWltYWdlLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogQWRkaXRpb25hbCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGNhbiBiZSByZWdpc3RlcmVkIHdpdGggYHByb2o0LmRlZnMoKWAgYW55XG4gKiB0aW1lLiBKdXN0IG1ha2Ugc3VyZSB0byBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGFnYWluOyBmb3IgZXhhbXBsZSwgd2l0aCB1c2VyLXN1cHBsaWVkIGRhdGEgd2hlcmUgeW91IGRvbid0XG4gKiBrbm93IGluIGFkdmFuY2Ugd2hhdCBwcm9qZWN0aW9ucyBhcmUgbmVlZGVkLCB5b3UgY2FuIGluaXRpYWxseSBsb2FkIG1pbmltYWxcbiAqIHN1cHBvcnQgYW5kIHRoZW4gbG9hZCB3aGljaGV2ZXIgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBOb3RlIHRoYXQgUHJvajRqcyBkb2VzIG5vdCBzdXBwb3J0IHByb2plY3Rpb24gZXh0ZW50cy4gSWYgeW91IHdhbnQgdG8gYWRkXG4gKiBvbmUgZm9yIGNyZWF0aW5nIGRlZmF1bHQgdGlsZSBncmlkcywgeW91IGNhbiBhZGQgaXQgYWZ0ZXIgdGhlIFByb2plY3Rpb25cbiAqIG9iamVjdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYHNldEV4dGVudGAsIGZvciBleGFtcGxlLFxuICogYGdldCgnRVBTRzoxMjM0Jykuc2V0RXh0ZW50KGV4dGVudClgLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIFByb2o0anMgc3VwcG9ydCwgYW55IHRyYW5zZm9ybSBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFRvIHVzZSB0aGlzLCB5b3UgbXVzdCBmaXJzdCBjcmVhdGVcbiAqIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0IGZvciB0aGUgbmV3IHByb2plY3Rpb24gYW5kIGFkZCBpdCB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouYWRkUHJvamVjdGlvbn0uIFlvdSBjYW4gdGhlbiBhZGQgdGhlIGZvcndhcmQgYW5kIGludmVyc2VcbiAqIGZ1bmN0aW9ucyB3aXRoIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFNlZVxuICogZXhhbXBsZXMvd21zLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogTm90ZSB0aGF0IGlmIG5vIHRyYW5zZm9ybXMgYXJlIG5lZWRlZCBhbmQgeW91IG9ubHkgbmVlZCB0byBkZWZpbmUgdGhlXG4gKiBwcm9qZWN0aW9uLCBqdXN0IGFkZCBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRQcm9qZWN0aW9ufS4gU2VlIGV4YW1wbGVzL3dtcy1uby1wcm9qIGZvciBhbiBleGFtcGxlIG9mXG4gKiB0aGlzLlxuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL3Byb2ovUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQge1xuICBQUk9KRUNUSU9OUyBhcyBFUFNHMzg1N19QUk9KRUNUSU9OUyxcbiAgZnJvbUVQU0c0MzI2LFxuICB0b0VQU0c0MzI2LFxufSBmcm9tICcuL3Byb2ovZXBzZzM4NTcuanMnO1xuaW1wb3J0IHtQUk9KRUNUSU9OUyBhcyBFUFNHNDMyNl9QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2c0MzI2LmpzJztcbmltcG9ydCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IHtcbiAgYWRkIGFzIGFkZFByb2osXG4gIGNsZWFyIGFzIGNsZWFyUHJvaixcbiAgZ2V0IGFzIGdldFByb2osXG59IGZyb20gJy4vcHJvai9wcm9qZWN0aW9ucy5qcyc7XG5pbXBvcnQge1xuICBhZGQgYXMgYWRkVHJhbnNmb3JtRnVuYyxcbiAgY2xlYXIgYXMgY2xlYXJUcmFuc2Zvcm1GdW5jcyxcbiAgZ2V0IGFzIGdldFRyYW5zZm9ybUZ1bmMsXG59IGZyb20gJy4vcHJvai90cmFuc2Zvcm1zLmpzJztcbmltcG9ydCB7YXBwbHlUcmFuc2Zvcm0sIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wLCBtb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2VxdWFscywgZ2V0V29ybGRzQXdheX0gZnJvbSAnLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCB7Z2V0RGlzdGFuY2V9IGZyb20gJy4vc3BoZXJlLmpzJztcbmltcG9ydCB7d2Fybn0gZnJvbSAnLi9jb25zb2xlLmpzJztcblxuLyoqXG4gKiBBIHByb2plY3Rpb24gYXMge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0sIFNSUyBpZGVudGlmaWVyXG4gKiBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICogQHR5cGVkZWYge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gUHJvamVjdGlvbkxpa2VcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIGFjY2VwdHMgYW4gYXJyYXkgb2YgaW5wdXQgY29vcmRpbmF0ZSB2YWx1ZXMsIGFuIG9wdGlvbmFsXG4gKiBvdXRwdXQgYXJyYXksIGFuZCBhbiBvcHRpb25hbCBkaW1lbnNpb24gKGRlZmF1bHQgc2hvdWxkIGJlIDIpLiAgVGhlIGZ1bmN0aW9uXG4gKiB0cmFuc2Zvcm1zIHRoZSBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgcG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXksIGFuZFxuICogcmV0dXJucyB0aGUgb3V0cHV0IGFycmF5LlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihBcnJheTxudW1iZXI+LCBBcnJheTxudW1iZXI+PSwgbnVtYmVyPSk6IEFycmF5PG51bWJlcj59IFRyYW5zZm9ybUZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuZXhwb3J0IHtNRVRFUlNfUEVSX1VOSVR9O1xuXG5leHBvcnQge1Byb2plY3Rpb259O1xuXG5sZXQgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nID0gdHJ1ZTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkaXNhYmxlID0gdHJ1ZV0gRGlzYWJsZSBjb25zb2xlIGluZm8gYWJvdXQgYHVzZUdlb2dyYXBoaWMoKWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDb29yZGluYXRlV2FybmluZyhkaXNhYmxlKSB7XG4gIGNvbnN0IGhpZGUgPSBkaXNhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogZGlzYWJsZTtcbiAgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nID0gIWhpZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBjb29yZGluYXRlIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgY29vcmRpbmF0ZSBhcnJheSAobmV3IGFycmF5LCBzYW1lIGNvb3JkaW5hdGVcbiAqICAgICB2YWx1ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVUcmFuc2Zvcm0oaW5wdXQsIG91dHB1dCkge1xuICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvdXRwdXRbaV0gPSBpbnB1dFtpXTtcbiAgICB9XG4gICAgb3V0cHV0ID0gb3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IElucHV0IGNvb3JkaW5hdGUgYXJyYXkgKHNhbWUgYXJyYXkgYXMgaW5wdXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHlUcmFuc2Zvcm0oaW5wdXQsIG91dHB1dCkge1xuICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQgJiYgaW5wdXQgIT09IG91dHB1dCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBpbnB1dCA9IG91dHB1dDtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogQWRkIGEgUHJvamVjdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHByb2plY3Rpb25zIHRoYXQgY2FuIGJlXG4gKiBsb29rZWQgdXAgYnkgdGhlaXIgY29kZS5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbiBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBhZGRQcm9qKHByb2plY3Rpb24uZ2V0Q29kZSgpLCBwcm9qZWN0aW9uKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uLCBwcm9qZWN0aW9uLCBjbG9uZVRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGFkZFByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIEZldGNoZXMgYSBQcm9qZWN0aW9uIG9iamVjdCBmb3IgdGhlIGNvZGUgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb25MaWtlIEVpdGhlciBhIGNvZGUgc3RyaW5nIHdoaWNoIGlzXG4gKiAgICAgYSBjb21iaW5hdGlvbiBvZiBhdXRob3JpdHkgYW5kIGlkZW50aWZpZXIgc3VjaCBhcyBcIkVQU0c6NDMyNlwiLCBvciBhblxuICogICAgIGV4aXN0aW5nIHByb2plY3Rpb24gb2JqZWN0LCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJuIHtQcm9qZWN0aW9ufG51bGx9IFByb2plY3Rpb24gb2JqZWN0LCBvciBudWxsIGlmIG5vdCBpbiBsaXN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHByb2plY3Rpb25MaWtlKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvamVjdGlvbkxpa2UgPT09ICdzdHJpbmcnXG4gICAgPyBnZXRQcm9qKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocHJvamVjdGlvbkxpa2UpKVxuICAgIDogLyoqIEB0eXBlIHtQcm9qZWN0aW9ufSAqLyAocHJvamVjdGlvbkxpa2UpIHx8IG51bGw7XG59XG5cbi8qKlxuICogR2V0IHRoZSByZXNvbHV0aW9uIG9mIHRoZSBwb2ludCBpbiBkZWdyZWVzIG9yIGRpc3RhbmNlIHVuaXRzLlxuICogRm9yIHByb2plY3Rpb25zIHdpdGggZGVncmVlcyBhcyB0aGUgdW5pdCB0aGlzIHdpbGwgc2ltcGx5IHJldHVybiB0aGVcbiAqIHByb3ZpZGVkIHJlc29sdXRpb24uIEZvciBvdGhlciBwcm9qZWN0aW9ucyB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpc1xuICogYnkgZGVmYXVsdCBlc3RpbWF0ZWQgYnkgdHJhbnNmb3JtaW5nIHRoZSBgcG9pbnRgIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAqIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSxcbiAqIGFuZCB0YWtpbmcgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gKiBBIGN1c3RvbSBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQgZm9yIGEgc3BlY2lmaWMgcHJvamVjdGlvbiwgZWl0aGVyXG4gKiBieSBzZXR0aW5nIHRoZSBgZ2V0UG9pbnRSZXNvbHV0aW9uYCBvcHRpb24gaW4gdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBjb25zdHJ1Y3RvciBvciBieSB1c2luZ1xuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbiNzZXRHZXRQb2ludFJlc29sdXRpb259IHRvIGNoYW5nZSBhbiBleGlzdGluZ1xuICogcHJvamVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gTm9taW5hbCByZXNvbHV0aW9uIGluIHByb2plY3Rpb24gdW5pdHMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludCB0byBmaW5kIGFkanVzdGVkIHJlc29sdXRpb24gYXQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Vbml0cy5qc1wiKS5Vbml0c30gW3VuaXRzXSBVbml0cyB0byBnZXQgdGhlIHBvaW50IHJlc29sdXRpb24gaW4uXG4gKiBEZWZhdWx0IGlzIHRoZSBwcm9qZWN0aW9uJ3MgdW5pdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBvaW50IHJlc29sdXRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludFJlc29sdXRpb24ocHJvamVjdGlvbiwgcmVzb2x1dGlvbiwgcG9pbnQsIHVuaXRzKSB7XG4gIHByb2plY3Rpb24gPSBnZXQocHJvamVjdGlvbik7XG4gIGxldCBwb2ludFJlc29sdXRpb247XG4gIGNvbnN0IGdldHRlciA9IHByb2plY3Rpb24uZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYygpO1xuICBpZiAoZ2V0dGVyKSB7XG4gICAgcG9pbnRSZXNvbHV0aW9uID0gZ2V0dGVyKHJlc29sdXRpb24sIHBvaW50KTtcbiAgICBpZiAodW5pdHMgJiYgdW5pdHMgIT09IHByb2plY3Rpb24uZ2V0VW5pdHMoKSkge1xuICAgICAgY29uc3QgbWV0ZXJzUGVyVW5pdCA9IHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgICAgaWYgKG1ldGVyc1BlclVuaXQpIHtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uID1cbiAgICAgICAgICAocG9pbnRSZXNvbHV0aW9uICogbWV0ZXJzUGVyVW5pdCkgLyBNRVRFUlNfUEVSX1VOSVRbdW5pdHNdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcm9qVW5pdHMgPSBwcm9qZWN0aW9uLmdldFVuaXRzKCk7XG4gICAgaWYgKChwcm9qVW5pdHMgPT0gJ2RlZ3JlZXMnICYmICF1bml0cykgfHwgdW5pdHMgPT0gJ2RlZ3JlZXMnKSB7XG4gICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFc3RpbWF0ZSBwb2ludCByZXNvbHV0aW9uIGJ5IHRyYW5zZm9ybWluZyB0aGUgY2VudGVyIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAgICAgIC8vIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSwgYW5kIHRha2luZyB0aGVcbiAgICAgIC8vIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICBjb25zdCB0b0VQU0c0MzI2ID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKFxuICAgICAgICBwcm9qZWN0aW9uLFxuICAgICAgICBnZXQoJ0VQU0c6NDMyNicpXG4gICAgICApO1xuICAgICAgaWYgKHRvRVBTRzQzMjYgPT09IGlkZW50aXR5VHJhbnNmb3JtICYmIHByb2pVbml0cyAhPT0gJ2RlZ3JlZXMnKSB7XG4gICAgICAgIC8vIG5vIHRyYW5zZm9ybSBpcyBhdmFpbGFibGVcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uID0gcmVzb2x1dGlvbiAqIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHZlcnRpY2VzID0gW1xuICAgICAgICAgIHBvaW50WzBdIC0gcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgICAgcG9pbnRbMV0sXG4gICAgICAgICAgcG9pbnRbMF0gKyByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgICBwb2ludFsxXSxcbiAgICAgICAgICBwb2ludFswXSxcbiAgICAgICAgICBwb2ludFsxXSAtIHJlc29sdXRpb24gLyAyLFxuICAgICAgICAgIHBvaW50WzBdLFxuICAgICAgICAgIHBvaW50WzFdICsgcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgIF07XG4gICAgICAgIHZlcnRpY2VzID0gdG9FUFNHNDMyNih2ZXJ0aWNlcywgdmVydGljZXMsIDIpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldERpc3RhbmNlKHZlcnRpY2VzLnNsaWNlKDAsIDIpLCB2ZXJ0aWNlcy5zbGljZSgyLCA0KSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGdldERpc3RhbmNlKHZlcnRpY2VzLnNsaWNlKDQsIDYpLCB2ZXJ0aWNlcy5zbGljZSg2LCA4KSk7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0ZXJzUGVyVW5pdCA9IHVuaXRzXG4gICAgICAgID8gTUVURVJTX1BFUl9VTklUW3VuaXRzXVxuICAgICAgICA6IHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgICAgaWYgKG1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludFJlc29sdXRpb24gLz0gbWV0ZXJzUGVyVW5pdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvaW50UmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRoYXQgZG9uJ3QgYWx0ZXIgY29vcmRpbmF0ZXMuIFRob3NlIGFsbG93XG4gKiB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMocHJvamVjdGlvbnMpIHtcbiAgYWRkUHJvamVjdGlvbnMocHJvamVjdGlvbnMpO1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBwcm9qZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKHNvdXJjZSAhPT0gZGVzdGluYXRpb24pIHtcbiAgICAgICAgYWRkVHJhbnNmb3JtRnVuYyhzb3VyY2UsIGRlc3RpbmF0aW9uLCBjbG9uZVRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBhbnkgcHJvamVjdGlvblxuICogaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMxIFByb2plY3Rpb25zIHdpdGggZXF1YWxcbiAqICAgICBtZWFuaW5nLlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMyIFByb2plY3Rpb25zIHdpdGggZXF1YWxcbiAqICAgICBtZWFuaW5nLlxuICogQHBhcmFtIHtUcmFuc2Zvcm1GdW5jdGlvbn0gZm9yd2FyZFRyYW5zZm9ybSBUcmFuc2Zvcm1hdGlvbiBmcm9tIGFueVxuICogICBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24yLlxuICogQHBhcmFtIHtUcmFuc2Zvcm1GdW5jdGlvbn0gaW52ZXJzZVRyYW5zZm9ybSBUcmFuc2Zvcm0gZnJvbSBhbnkgcHJvamVjdGlvblxuICogICBpbiBwcm9qZWN0aW9uMiB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMS4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFcXVpdmFsZW50VHJhbnNmb3JtcyhcbiAgcHJvamVjdGlvbnMxLFxuICBwcm9qZWN0aW9uczIsXG4gIGZvcndhcmRUcmFuc2Zvcm0sXG4gIGludmVyc2VUcmFuc2Zvcm1cbikge1xuICBwcm9qZWN0aW9uczEuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdGlvbjEpIHtcbiAgICBwcm9qZWN0aW9uczIuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdGlvbjIpIHtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yLCBmb3J3YXJkVHJhbnNmb3JtKTtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjIsIHByb2plY3Rpb24xLCBpbnZlcnNlVHJhbnNmb3JtKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2xlYXIgYWxsIGNhY2hlZCBwcm9qZWN0aW9ucyBhbmQgdHJhbnNmb3Jtcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQWxsUHJvamVjdGlvbnMoKSB7XG4gIGNsZWFyUHJvaigpO1xuICBjbGVhclRyYW5zZm9ybUZ1bmNzKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufHN0cmluZ3x1bmRlZmluZWR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0Q29kZSBEZWZhdWx0IGNvZGUuXG4gKiBAcmV0dXJuIHtQcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uLCBkZWZhdWx0Q29kZSkge1xuICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZ2V0KGRlZmF1bHRDb2RlKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb2plY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGdldChwcm9qZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtQcm9qZWN0aW9ufSAqLyAocHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBtb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gZnJvbSBhIHNpbXBsZSAyRCBjb29yZGluYXRlIHRyYW5zZm9ybVxuICogZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkVHJhbnNmb3JtIENvb3JkaW5hdGVcbiAqICAgICB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oY29vcmRUcmFuc2Zvcm0pIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb24uXG4gICAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0LCBkaW1lbnNpb24pIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiAhPT0gdW5kZWZpbmVkID8gZGltZW5zaW9uIDogMjtcbiAgICAgIG91dHB1dCA9IG91dHB1dCAhPT0gdW5kZWZpbmVkID8gb3V0cHV0IDogbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBjb29yZFRyYW5zZm9ybShpbnB1dC5zbGljZShpLCBpICsgZGltZW5zaW9uKSk7XG4gICAgICAgIGNvbnN0IHBvaW50TGVuZ3RoID0gcG9pbnQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgamogPSBkaW1lbnNpb247IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgb3V0cHV0W2kgKyBqXSA9IGogPj0gcG9pbnRMZW5ndGggPyBpbnB1dFtpICsgal0gOiBwb2ludFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGNvb3JkaW5hdGUgdHJhbnNmb3JtIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGJldHdlZW4gdGhlXG4gKiBzb3VyY2UgcHJvamVjdGlvbiBhbmQgdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBUaGUgZm9yd2FyZCBhbmQgaW52ZXJzZSBmdW5jdGlvbnMgY29udmVydCBjb29yZGluYXRlIHBhaXJzOyB0aGlzIGZ1bmN0aW9uXG4gKiBjb252ZXJ0cyB0aGVzZSBpbnRvIHRoZSBmdW5jdGlvbnMgdXNlZCBpbnRlcm5hbGx5IHdoaWNoIGFsc28gaGFuZGxlXG4gKiBleHRlbnRzIGFuZCBjb29yZGluYXRlIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBmb3J3YXJkIFRoZSBmb3J3YXJkIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb25cbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gaW52ZXJzZSBUaGUgaW52ZXJzZSB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbiB0byB0aGUgc291cmNlXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIG9ubHlcbiAqICAgICB0cmFuc2Zvcm0gbGVzcyBkaW1lbnNpb25zIHRoYW4gdGhlIGlucHV0IGNvb3JkaW5hdGUsIGl0IGlzIHN1cHBvc2VlZCB0byByZXR1cm4gYSBjb29yZGluYXRlXG4gKiAgICAgd2l0aCBvbmx5IHRoZSBsZW5ndGggaXQgY2FuIHRyYW5zZm9ybS4gVGhlIG90aGVyIGRpbWVuc2lvbnMgd2lsbCBiZSB0YWtlbiB1bmNoYW5nZWQgZnJvbSB0aGVcbiAqICAgICBzb3VyY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb29yZGluYXRlVHJhbnNmb3Jtcyhzb3VyY2UsIGRlc3RpbmF0aW9uLCBmb3J3YXJkLCBpbnZlcnNlKSB7XG4gIGNvbnN0IHNvdXJjZVByb2ogPSBnZXQoc291cmNlKTtcbiAgY29uc3QgZGVzdFByb2ogPSBnZXQoZGVzdGluYXRpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKFxuICAgIHNvdXJjZVByb2osXG4gICAgZGVzdFByb2osXG4gICAgY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oZm9yd2FyZClcbiAgKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhcbiAgICBkZXN0UHJvaixcbiAgICBzb3VyY2VQcm9qLFxuICAgIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGludmVyc2UpXG4gICk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgZnJvbSBsb25naXR1ZGUvbGF0aXR1ZGUgdG8gYSBkaWZmZXJlbnQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuXG4gKiAgICAgYW4gYXJyYXkgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBUYXJnZXQgcHJvamVjdGlvbi4gVGhlXG4gKiAgICAgZGVmYXVsdCBpcyBXZWIgTWVyY2F0b3IsIGkuZS4gJ0VQU0c6Mzg1NycuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBwcm9qZWN0ZWQgdG8gdGhlIHRhcmdldCBwcm9qZWN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUxvbkxhdChjb29yZGluYXRlLCBwcm9qZWN0aW9uKSB7XG4gIGRpc2FibGVDb29yZGluYXRlV2FybmluZygpO1xuICByZXR1cm4gdHJhbnNmb3JtKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgJ0VQU0c6NDMyNicsXG4gICAgcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gcHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnXG4gICk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgdG8gbG9uZ2l0dWRlL2xhdGl0dWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBQcm9qZWN0ZWQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uIG9mIHRoZSBjb29yZGluYXRlLlxuICogICAgIFRoZSBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS4gYW4gYXJyYXlcbiAqICAgICB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Mb25MYXQoY29vcmRpbmF0ZSwgcHJvamVjdGlvbikge1xuICBjb25zdCBsb25MYXQgPSB0cmFuc2Zvcm0oXG4gICAgY29vcmRpbmF0ZSxcbiAgICBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycsXG4gICAgJ0VQU0c6NDMyNidcbiAgKTtcbiAgY29uc3QgbG9uID0gbG9uTGF0WzBdO1xuICBpZiAobG9uIDwgLTE4MCB8fCBsb24gPiAxODApIHtcbiAgICBsb25MYXRbMF0gPSBtb2R1bG8obG9uICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIHJldHVybiBsb25MYXQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBwcm9qZWN0aW9ucyBhcmUgdGhlIHNhbWUsIHRoYXQgaXMgZXZlcnkgY29vcmRpbmF0ZSBpbiBvbmVcbiAqIHByb2plY3Rpb24gZG9lcyByZXByZXNlbnQgdGhlIHNhbWUgZ2VvZ3JhcGhpYyBwb2ludCBhcyB0aGUgc2FtZSBjb29yZGluYXRlIGluXG4gKiB0aGUgb3RoZXIgcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24xIFByb2plY3Rpb24gMS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbjIgUHJvamVjdGlvbiAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRXF1aXZhbGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWl2YWxlbnQocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKSB7XG4gIGlmIChwcm9qZWN0aW9uMSA9PT0gcHJvamVjdGlvbjIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBlcXVhbFVuaXRzID0gcHJvamVjdGlvbjEuZ2V0VW5pdHMoKSA9PT0gcHJvamVjdGlvbjIuZ2V0VW5pdHMoKTtcbiAgaWYgKHByb2plY3Rpb24xLmdldENvZGUoKSA9PT0gcHJvamVjdGlvbjIuZ2V0Q29kZSgpKSB7XG4gICAgcmV0dXJuIGVxdWFsVW5pdHM7XG4gIH1cbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpO1xuICByZXR1cm4gdHJhbnNmb3JtRnVuYyA9PT0gY2xvbmVUcmFuc2Zvcm0gJiYgZXF1YWxVbml0cztcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBpbiB0aGUgbGlzdCBvZiB0cmFuc2Zvcm0gZnVuY3Rpb25zIGZvciB0aGUgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvamVjdGlvbiBTb3VyY2UgUHJvamVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IGRlc3RpbmF0aW9uUHJvamVjdGlvbiBEZXN0aW5hdGlvbiBQcm9qZWN0aW9uXG4gKiAgICAgb2JqZWN0LlxuICogQHJldHVybiB7VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgc291cmNlUHJvamVjdGlvbixcbiAgZGVzdGluYXRpb25Qcm9qZWN0aW9uXG4pIHtcbiAgY29uc3Qgc291cmNlQ29kZSA9IHNvdXJjZVByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvblByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICBsZXQgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZ1bmMoc291cmNlQ29kZSwgZGVzdGluYXRpb25Db2RlKTtcbiAgaWYgKCF0cmFuc2Zvcm1GdW5jKSB7XG4gICAgdHJhbnNmb3JtRnVuYyA9IGlkZW50aXR5VHJhbnNmb3JtO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBwcm9qZWN0aW9uLWxpa2Ugb2JqZWN0cywgc2VhcmNoZXMgZm9yIGEgdHJhbnNmb3JtYXRpb25cbiAqIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBjb29yZGluYXRlcyBhcnJheSBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGVcbiAqIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHNvdXJjZVByb2plY3Rpb24gPSBnZXQoc291cmNlKTtcbiAgY29uc3QgZGVzdGluYXRpb25Qcm9qZWN0aW9uID0gZ2V0KGRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhzb3VyY2VQcm9qZWN0aW9uLCBkZXN0aW5hdGlvblByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoaXMgcmV0dXJucyBhIG5ldyBjb29yZGluYXRlIChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvcHJvai50cmFuc2Zvcm1FeHRlbnR9IGZvciBleHRlbnQgdHJhbnNmb3JtYXRpb24uXG4gKiBTZWUgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBhbmQgaXRzXG4gKiBzdWJjbGFzc2VzIGZvciBnZW9tZXRyeSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gdHJhbnNmb3JtRnVuYyhjb29yZGluYXRlLCB1bmRlZmluZWQsIGNvb3JkaW5hdGUubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGV4dGVudCBmcm9tIHNvdXJjZSBwcm9qZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzXG4gKiByZXR1cm5zIGEgbmV3IGV4dGVudCAoYW5kIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudCB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24tbGlrZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24tbGlrZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcHNdIE51bWJlciBvZiBzdG9wcyBwZXIgc2lkZSB1c2VkIGZvciB0aGUgdHJhbnNmb3JtLlxuICogQnkgZGVmYXVsdCBvbmx5IHRoZSBjb3JuZXJzIGFyZSB1c2VkLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBUaGUgdHJhbnNmb3JtZWQgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRXh0ZW50KGV4dGVudCwgc291cmNlLCBkZXN0aW5hdGlvbiwgc3RvcHMpIHtcbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGV4dGVudCwgdHJhbnNmb3JtRnVuYywgdW5kZWZpbmVkLCBzdG9wcyk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gcG9pbnQgdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHNvdXJjZVByb2plY3Rpb24gU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IGRlc3RpbmF0aW9uUHJvamVjdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtV2l0aFByb2plY3Rpb25zKFxuICBwb2ludCxcbiAgc291cmNlUHJvamVjdGlvbixcbiAgZGVzdGluYXRpb25Qcm9qZWN0aW9uXG4pIHtcbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgICBzb3VyY2VQcm9qZWN0aW9uLFxuICAgIGRlc3RpbmF0aW9uUHJvamVjdGlvblxuICApO1xuICByZXR1cm4gdHJhbnNmb3JtRnVuYyhwb2ludCk7XG59XG5cbi8qKlxuICogQHR5cGUge1Byb2plY3Rpb258bnVsbH1cbiAqL1xubGV0IHVzZXJQcm9qZWN0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBTZXQgdGhlIHByb2plY3Rpb24gZm9yIGNvb3JkaW5hdGVzIHN1cHBsaWVkIGZyb20gYW5kIHJldHVybmVkIGJ5IEFQSSBtZXRob2RzLlxuICogVGhpcyBpbmNsdWRlcyBhbGwgQVBJIG1ldGhvZHMgZXhjZXB0IGZvciB0aG9zZSBpbnRlcmFjdGluZyB3aXRoIHRpbGUgZ3JpZHMsXG4gKiBwbHVzIHtAbGluayBpbXBvcnQoXCIuL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBhbmQge0BsaW5rIGltcG9ydChcIi4vVmlldy5qc1wiKS5TdGF0ZX0uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFRoZSB1c2VyIHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRVc2VyUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHVzZXJQcm9qZWN0aW9uID0gZ2V0KHByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyIHByb2plY3Rpb24gaWYgc2V0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJVc2VyUHJvamVjdGlvbigpIHtcbiAgdXNlclByb2plY3Rpb24gPSBudWxsO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvamVjdGlvbiBmb3IgY29vcmRpbmF0ZXMgc3VwcGxpZWQgZnJvbSBhbmQgcmV0dXJuZWQgYnkgQVBJIG1ldGhvZHMuXG4gKiBAcmV0dXJuIHtQcm9qZWN0aW9ufG51bGx9IFRoZSB1c2VyIHByb2plY3Rpb24gKG9yIG51bGwgaWYgbm90IHNldCkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyUHJvamVjdGlvbigpIHtcbiAgcmV0dXJuIHVzZXJQcm9qZWN0aW9uO1xufVxuXG4vKipcbiAqIFVzZSBnZW9ncmFwaGljIGNvb3JkaW5hdGVzIChXR1MtODQgZGF0dW0pIGluIEFQSSBtZXRob2RzLlxuICogVGhpcyBpbmNsdWRlcyBhbGwgQVBJIG1ldGhvZHMgZXhjZXB0IGZvciB0aG9zZSBpbnRlcmFjdGluZyB3aXRoIHRpbGUgZ3JpZHMsXG4gKiBwbHVzIHtAbGluayBpbXBvcnQoXCIuL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBhbmQge0BsaW5rIGltcG9ydChcIi4vVmlldy5qc1wiKS5TdGF0ZX0uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VHZW9ncmFwaGljKCkge1xuICBzZXRVc2VyUHJvamVjdGlvbignRVBTRzo0MzI2Jyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGUgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGUgSW5wdXQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZVByb2plY3Rpb24gVGhlIGlucHV0IGNvb3JkaW5hdGUgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBpbnB1dCBjb29yZGluYXRlIGluIHRoZSB1c2VyIHByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1VzZXJDb29yZGluYXRlKGNvb3JkaW5hdGUsIHNvdXJjZVByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBjb29yZGluYXRlO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgc291cmNlUHJvamVjdGlvbiwgdXNlclByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGNvb3JkaW5hdGUgdHJhbnNmb3JtZWQgZnJvbSB0aGUgdXNlciBwcm9qZWN0aW9uLiAgSWYgbm8gdXNlciBwcm9qZWN0aW9uXG4gKiBpcyBzZXQsIHRoZSBvcmlnaW5hbCBjb29yZGluYXRlIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlIElucHV0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBpbnB1dCBjb29yZGluYXRlIHRyYW5zZm9ybWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVVzZXJDb29yZGluYXRlKGNvb3JkaW5hdGUsIGRlc3RQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICBpZiAoXG4gICAgICBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgJiZcbiAgICAgICFlcXVhbHMoY29vcmRpbmF0ZSwgWzAsIDBdKSAmJlxuICAgICAgY29vcmRpbmF0ZVswXSA+PSAtMTgwICYmXG4gICAgICBjb29yZGluYXRlWzBdIDw9IDE4MCAmJlxuICAgICAgY29vcmRpbmF0ZVsxXSA+PSAtOTAgJiZcbiAgICAgIGNvb3JkaW5hdGVbMV0gPD0gOTBcbiAgICApIHtcbiAgICAgIHNob3dDb29yZGluYXRlV2FybmluZyA9IGZhbHNlO1xuICAgICAgd2FybihcbiAgICAgICAgJ0NhbGwgdXNlR2VvZ3JhcGhpYygpIGZyb20gb2wvcHJvaiBvbmNlIHRvIHdvcmsgd2l0aCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gY29vcmRpbmF0ZXMuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybShjb29yZGluYXRlLCB1c2VyUHJvamVjdGlvbiwgZGVzdFByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBleHRlbnQgdHJhbnNmb3JtZWQgaW50byB0aGUgdXNlciBwcm9qZWN0aW9uLiAgSWYgbm8gdXNlciBwcm9qZWN0aW9uXG4gKiBpcyBzZXQsIHRoZSBvcmlnaW5hbCBleHRlbnQgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IElucHV0IGV4dGVudC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZVByb2plY3Rpb24gVGhlIGlucHV0IGV4dGVudCBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBUaGUgaW5wdXQgZXh0ZW50IGluIHRoZSB1c2VyIHByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1VzZXJFeHRlbnQoZXh0ZW50LCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBzb3VyY2VQcm9qZWN0aW9uLCB1c2VyUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGV4dGVudCB0cmFuc2Zvcm1lZCBmcm9tIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGV4dGVudCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgSW5wdXQgZXh0ZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdFByb2plY3Rpb24gVGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBpbnB1dCBleHRlbnQgdHJhbnNmb3JtZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVXNlckV4dGVudChleHRlbnQsIGRlc3RQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCB1c2VyUHJvamVjdGlvbiwgZGVzdFByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLiBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgb3Igc291cmNlIG9yIHVzZXIgcHJvamVjdGlvbiBhcmUgbWlzc2luZyB1bml0cywgdGhlIG9yaWdpbmFsIHJlc29sdXRpb25cbiAqIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbiBpbiBpbnB1dCBwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZVByb2plY3Rpb24gVGhlIGlucHV0IHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24gaW4gdXNlciBwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlclJlc29sdXRpb24ocmVzb2x1dGlvbiwgc291cmNlUHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc29sdXRpb247XG4gIH1cbiAgY29uc3Qgc291cmNlTWV0ZXJzUGVyVW5pdCA9IGdldChzb3VyY2VQcm9qZWN0aW9uKS5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGNvbnN0IHVzZXJNZXRlcnNQZXJVbml0ID0gdXNlclByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICByZXR1cm4gc291cmNlTWV0ZXJzUGVyVW5pdCAmJiB1c2VyTWV0ZXJzUGVyVW5pdFxuICAgID8gKHJlc29sdXRpb24gKiBzb3VyY2VNZXRlcnNQZXJVbml0KSAvIHVzZXJNZXRlcnNQZXJVbml0XG4gICAgOiByZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLiBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgb3Igc291cmNlIG9yIHVzZXIgcHJvamVjdGlvbiBhcmUgbWlzc2luZyB1bml0cywgdGhlIG9yaWdpbmFsIHJlc29sdXRpb25cbiAqIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdFByb2plY3Rpb24gVGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24gaW4gZGVzdGluYXRpb24gcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVXNlclJlc29sdXRpb24ocmVzb2x1dGlvbiwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiByZXNvbHV0aW9uO1xuICB9XG4gIGNvbnN0IGRlc3RNZXRlcnNQZXJVbml0ID0gZ2V0KGRlc3RQcm9qZWN0aW9uKS5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGNvbnN0IHVzZXJNZXRlcnNQZXJVbml0ID0gdXNlclByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICByZXR1cm4gZGVzdE1ldGVyc1BlclVuaXQgJiYgdXNlck1ldGVyc1BlclVuaXRcbiAgICA/IChyZXNvbHV0aW9uICogdXNlck1ldGVyc1BlclVuaXQpIC8gZGVzdE1ldGVyc1BlclVuaXRcbiAgICA6IHJlc29sdXRpb247XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNhZmUgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb24gZnJvbSBhIGNvb3JkaW5hdGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogXCJTYWZlXCIgbWVhbnMgdGhhdCBpdCBjYW4gaGFuZGxlIHdyYXBwaW5nIG9mIHgtY29vcmRpbmF0ZXMgZm9yIGdsb2JhbCBwcm9qZWN0aW9ucyxcbiAqIGFuZCB0aGF0IGNvb3JkaW5hdGVzIGV4Y2VlZGluZyB0aGUgc291cmNlIHByb2plY3Rpb24gdmFsaWRpdHkgZXh0ZW50J3MgcmFuZ2Ugd2lsbCBiZVxuICogY2xhbXBlZCB0byB0aGUgdmFsaWRpdHkgcmFuZ2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IGRlc3RQcm9qIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRyYW5zZm9ybSBUcmFuc2Zvcm0gZnVuY3Rpb24gKHNvdXJjZSB0byBkZXN0aW5hdGlvbikuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBTYWZlIHRyYW5zZm9ybSBmdW5jdGlvbiAoc291cmNlIHRvIGRlc3RpbmF0aW9uKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNhZmVDb29yZGluYXRlVHJhbnNmb3JtKHNvdXJjZVByb2osIGRlc3RQcm9qLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb29yZCkge1xuICAgIGxldCB0cmFuc2Zvcm1lZCwgd29ybGRzQXdheTtcbiAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICBjb25zdCBzb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgICAgY29uc3Qgc291cmNlRXh0ZW50V2lkdGggPSBnZXRXaWR0aChzb3VyY2VFeHRlbnQpO1xuICAgICAgY29vcmQgPSBjb29yZC5zbGljZSgwKTtcbiAgICAgIHdvcmxkc0F3YXkgPSBnZXRXb3JsZHNBd2F5KGNvb3JkLCBzb3VyY2VQcm9qLCBzb3VyY2VFeHRlbnRXaWR0aCk7XG4gICAgICBpZiAod29ybGRzQXdheSkge1xuICAgICAgICAvLyBNb3ZlIHggdG8gdGhlIHJlYWwgd29ybGRcbiAgICAgICAgY29vcmRbMF0gPSBjb29yZFswXSAtIHdvcmxkc0F3YXkgKiBzb3VyY2VFeHRlbnRXaWR0aDtcbiAgICAgIH1cbiAgICAgIGNvb3JkWzBdID0gY2xhbXAoY29vcmRbMF0sIHNvdXJjZUV4dGVudFswXSwgc291cmNlRXh0ZW50WzJdKTtcbiAgICAgIGNvb3JkWzFdID0gY2xhbXAoY29vcmRbMV0sIHNvdXJjZUV4dGVudFsxXSwgc291cmNlRXh0ZW50WzNdKTtcbiAgICAgIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtKGNvb3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0oY29vcmQpO1xuICAgIH1cbiAgICBpZiAod29ybGRzQXdheSAmJiBkZXN0UHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAvLyBNb3ZlIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGUgYmFjayB0byB0aGUgb2Zmc2V0IHdvcmxkXG4gICAgICB0cmFuc2Zvcm1lZFswXSArPSB3b3JsZHNBd2F5ICogZ2V0V2lkdGgoZGVzdFByb2ouZ2V0RXh0ZW50KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH07XG59XG5cbi8qKlxuICogQWRkIHRyYW5zZm9ybXMgdG8gYW5kIGZyb20gRVBTRzo0MzI2IGFuZCBFUFNHOjM4NTcuICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICogYnkgd2hlbiB0aGlzIG1vZHVsZSBpcyBleGVjdXRlZCBhbmQgc2hvdWxkIG9ubHkgbmVlZCB0byBiZSBjYWxsZWQgYWdhaW4gYWZ0ZXJcbiAqIGBjbGVhckFsbFByb2plY3Rpb25zKClgIGlzIGNhbGxlZCAoZS5nLiBpbiB0ZXN0cykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb21tb24oKSB7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcyB0byBjb252ZXJ0IHdpdGhpbiBzZXQgb2ZcbiAgLy8gcHJvamVjdGlvbnMgd2l0aCBlcXVhbCBtZWFuaW5nLlxuICBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMoRVBTRzM4NTdfUFJPSkVDVElPTlMpO1xuICBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMoRVBTRzQzMjZfUFJPSkVDVElPTlMpO1xuICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zIHRvIGNvbnZlcnQgRVBTRzo0MzI2IGxpa2UgY29vcmRpbmF0ZXMgdG8gRVBTRzozODU3IGxpa2VcbiAgLy8gY29vcmRpbmF0ZXMgYW5kIGJhY2suXG4gIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKFxuICAgIEVQU0c0MzI2X1BST0pFQ1RJT05TLFxuICAgIEVQU0czODU3X1BST0pFQ1RJT05TLFxuICAgIGZyb21FUFNHNDMyNixcbiAgICB0b0VQU0c0MzI2XG4gICk7XG59XG5cbmFkZENvbW1vbigpO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jZW50ZXJjb25zdHJhaW50XG4gKi9cbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWQpLCBudW1iZXIsIGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplLCBib29sZWFuPSwgQXJyYXk8bnVtYmVyPj0pOiAoaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9ubHlDZW50ZXIgSWYgdHJ1ZSwgdGhlIGNvbnN0cmFpbnQgd2lsbCBvbmx5IGFwcGx5IHRvIHRoZSB2aWV3IGNlbnRlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc21vb3RoIElmIHRydWUsIHRoZSB2aWV3IHdpbGwgYmUgYWJsZSB0byBnbyBzbGlnaHRseSBvdXQgb2YgdGhlIGdpdmVuIGV4dGVudFxuICogKG9ubHkgZHVyaW5nIGludGVyYWN0aW9uIGFuZCBhbmltYXRpb24pLlxuICogQHJldHVybiB7VHlwZX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnQoZXh0ZW50LCBvbmx5Q2VudGVyLCBzbW9vdGgpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gY2VudGVyIENlbnRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFZpZXdwb3J0IHNpemU7IHVudXNlZCBpZiBgb25seUNlbnRlcmAgd2FzIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gVHJ1ZSBpZiBhbiBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbY2VudGVyU2hpZnRdIFNoaWZ0IGJldHdlZW4gbWFwIGNlbnRlciBhbmQgdmlld3BvcnQgY2VudGVyLlxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjZW50ZXIsIHJlc29sdXRpb24sIHNpemUsIGlzTW92aW5nLCBjZW50ZXJTaGlmdCkge1xuICAgICAgaWYgKCFjZW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzb2x1dGlvbiAmJiAhb25seUNlbnRlcikge1xuICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgfVxuICAgICAgY29uc3Qgdmlld1dpZHRoID0gb25seUNlbnRlciA/IDAgOiBzaXplWzBdICogcmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHZpZXdIZWlnaHQgPSBvbmx5Q2VudGVyID8gMCA6IHNpemVbMV0gKiByZXNvbHV0aW9uO1xuICAgICAgY29uc3Qgc2hpZnRYID0gY2VudGVyU2hpZnQgPyBjZW50ZXJTaGlmdFswXSA6IDA7XG4gICAgICBjb25zdCBzaGlmdFkgPSBjZW50ZXJTaGlmdCA/IGNlbnRlclNoaWZ0WzFdIDogMDtcbiAgICAgIGxldCBtaW5YID0gZXh0ZW50WzBdICsgdmlld1dpZHRoIC8gMiArIHNoaWZ0WDtcbiAgICAgIGxldCBtYXhYID0gZXh0ZW50WzJdIC0gdmlld1dpZHRoIC8gMiArIHNoaWZ0WDtcbiAgICAgIGxldCBtaW5ZID0gZXh0ZW50WzFdICsgdmlld0hlaWdodCAvIDIgKyBzaGlmdFk7XG4gICAgICBsZXQgbWF4WSA9IGV4dGVudFszXSAtIHZpZXdIZWlnaHQgLyAyICsgc2hpZnRZO1xuXG4gICAgICAvLyBub3RlOiB3aGVuIHpvb21pbmcgb3V0IG9mIGJvdW5kcywgbWluIGFuZCBtYXggdmFsdWVzIGZvciB4IGFuZCB5IG1heVxuICAgICAgLy8gZW5kIHVwIGludmVydGVkIChtaW4gPiBtYXgpOyB0aGlzIGhhcyB0byBiZSBhY2NvdW50ZWQgZm9yXG4gICAgICBpZiAobWluWCA+IG1heFgpIHtcbiAgICAgICAgbWluWCA9IChtYXhYICsgbWluWCkgLyAyO1xuICAgICAgICBtYXhYID0gbWluWDtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5ZID4gbWF4WSkge1xuICAgICAgICBtaW5ZID0gKG1heFkgKyBtaW5ZKSAvIDI7XG4gICAgICAgIG1heFkgPSBtaW5ZO1xuICAgICAgfVxuXG4gICAgICBsZXQgeCA9IGNsYW1wKGNlbnRlclswXSwgbWluWCwgbWF4WCk7XG4gICAgICBsZXQgeSA9IGNsYW1wKGNlbnRlclsxXSwgbWluWSwgbWF4WSk7XG5cbiAgICAgIC8vIGR1cmluZyBhbiBpbnRlcmFjdGlvbiwgYWxsb3cgc29tZSBvdmVyc2Nyb2xsXG4gICAgICBpZiAoaXNNb3ZpbmcgJiYgc21vb3RoICYmIHJlc29sdXRpb24pIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSAzMCAqIHJlc29sdXRpb247XG4gICAgICAgIHggKz1cbiAgICAgICAgICAtcmF0aW8gKiBNYXRoLmxvZygxICsgTWF0aC5tYXgoMCwgbWluWCAtIGNlbnRlclswXSkgLyByYXRpbykgK1xuICAgICAgICAgIHJhdGlvICogTWF0aC5sb2coMSArIE1hdGgubWF4KDAsIGNlbnRlclswXSAtIG1heFgpIC8gcmF0aW8pO1xuICAgICAgICB5ICs9XG4gICAgICAgICAgLXJhdGlvICogTWF0aC5sb2coMSArIE1hdGgubWF4KDAsIG1pblkgLSBjZW50ZXJbMV0pIC8gcmF0aW8pICtcbiAgICAgICAgICByYXRpbyAqIE1hdGgubG9nKDEgKyBNYXRoLm1heCgwLCBjZW50ZXJbMV0gLSBtYXhZKSAvIHJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gQ2VudGVyLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25lKGNlbnRlcikge1xuICByZXR1cm4gY2VudGVyO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZXNvbHV0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtnZXRIZWlnaHQsIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBudW1iZXIsIGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplLCBib29sZWFuPSk6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG1vZGlmaWVkIHJlc29sdXRpb24gdGFraW5nIGludG8gYWNjb3VudCB0aGUgdmlld3BvcnQgc2l6ZSBhbmQgbWF4aW11bVxuICogYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSB2aWV3cG9ydFNpemUgVmlld3BvcnQgc2l6ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd0Z1bGxFeHRlbnQgV2hldGhlciB0byBzaG93IHRoZSBmdWxsIGV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gQ2FwcGVkIHJlc29sdXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFZpZXdwb3J0Q2xhbXBlZFJlc29sdXRpb24oXG4gIHJlc29sdXRpb24sXG4gIG1heEV4dGVudCxcbiAgdmlld3BvcnRTaXplLFxuICBzaG93RnVsbEV4dGVudFxuKSB7XG4gIGNvbnN0IHhSZXNvbHV0aW9uID0gZ2V0V2lkdGgobWF4RXh0ZW50KSAvIHZpZXdwb3J0U2l6ZVswXTtcbiAgY29uc3QgeVJlc29sdXRpb24gPSBnZXRIZWlnaHQobWF4RXh0ZW50KSAvIHZpZXdwb3J0U2l6ZVsxXTtcblxuICBpZiAoc2hvd0Z1bGxFeHRlbnQpIHtcbiAgICByZXR1cm4gTWF0aC5taW4ocmVzb2x1dGlvbiwgTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJlc29sdXRpb24sIE1hdGgubWluKHhSZXNvbHV0aW9uLCB5UmVzb2x1dGlvbikpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBtb2RpZmllZCByZXNvbHV0aW9uIHRvIGJlIGJldHdlZW4gbWF4UmVzb2x1dGlvbiBhbmQgbWluUmVzb2x1dGlvbiB3aGlsZVxuICogc3RpbGwgYWxsb3dpbmcgdGhlIHZhbHVlIHRvIGJlIHNsaWdodGx5IG91dCBvZiBib3VuZHMuXG4gKiBOb3RlOiB0aGUgY29tcHV0YXRpb24gaXMgYmFzZWQgb24gdGhlIGxvZ2FyaXRobSBmdW5jdGlvbiAobG4pOlxuICogIC0gYXQgMSwgbG4oeCkgaXMgMFxuICogIC0gYWJvdmUgMSwgbG4oeCkga2VlcHMgaW5jcmVhc2luZyBidXQgYXQgYSBtdWNoIHNsb3dlciBwYWNlIHRoYW4geFxuICogVGhlIGZpbmFsIHJlc3VsdCBpcyBjbGFtcGVkIHRvIHByZXZlbnQgZ2V0dGluZyB0b28gZmFyIGF3YXkgZnJvbSBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBNaW4gcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gU21vb3RoZWQgcmVzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U21vb3RoQ2xhbXBlZFJlc29sdXRpb24ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbikge1xuICBsZXQgcmVzdWx0ID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbik7XG4gIGNvbnN0IHJhdGlvID0gNTA7XG5cbiAgcmVzdWx0ICo9XG4gICAgTWF0aC5sb2coMSArIHJhdGlvICogTWF0aC5tYXgoMCwgcmVzb2x1dGlvbiAvIG1heFJlc29sdXRpb24gLSAxKSkgLyByYXRpbyArXG4gICAgMTtcbiAgaWYgKG1pblJlc29sdXRpb24pIHtcbiAgICByZXN1bHQgPSBNYXRoLm1heChyZXN1bHQsIG1pblJlc29sdXRpb24pO1xuICAgIHJlc3VsdCAvPVxuICAgICAgTWF0aC5sb2coMSArIHJhdGlvICogTWF0aC5tYXgoMCwgbWluUmVzb2x1dGlvbiAvIHJlc29sdXRpb24gLSAxKSkgL1xuICAgICAgICByYXRpbyArXG4gICAgICAxO1xuICB9XG4gIHJldHVybiBjbGFtcChyZXN1bHQsIG1pblJlc29sdXRpb24gLyAyLCBtYXhSZXNvbHV0aW9uICogMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Ntb290aF0gSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIHNsaWdodGx5IGV4Y2VlZCByZXNvbHV0aW9uIGxpbWl0cy4gRGVmYXVsdDogdHJ1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbWF4RXh0ZW50XSBNYXhpbXVtIGFsbG93ZWQgZXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd0Z1bGxFeHRlbnRdIElmIHRydWUsIGFsbG93cyB1cyB0byBzaG93IHRoZSBmdWxsIGV4dGVudC4gRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvUmVzb2x1dGlvbnMoXG4gIHJlc29sdXRpb25zLFxuICBzbW9vdGgsXG4gIG1heEV4dGVudCxcbiAgc2hvd0Z1bGxFeHRlbnRcbikge1xuICBzbW9vdGggPSBzbW9vdGggIT09IHVuZGVmaW5lZCA/IHNtb290aCA6IHRydWU7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUsIGlzTW92aW5nKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG1heFJlc29sdXRpb24gPSByZXNvbHV0aW9uc1swXTtcbiAgICAgICAgY29uc3QgbWluUmVzb2x1dGlvbiA9IHJlc29sdXRpb25zW3Jlc29sdXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBjYXBwZWRNYXhSZXMgPSBtYXhFeHRlbnRcbiAgICAgICAgICA/IGdldFZpZXdwb3J0Q2xhbXBlZFJlc29sdXRpb24oXG4gICAgICAgICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgICAgICAgIG1heEV4dGVudCxcbiAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgc2hvd0Z1bGxFeHRlbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG1heFJlc29sdXRpb247XG5cbiAgICAgICAgLy8gZHVyaW5nIGludGVyYWN0aW5nIG9yIGFuaW1hdGluZywgYWxsb3cgaW50ZXJtZWRpYXJ5IHZhbHVlc1xuICAgICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wKHJlc29sdXRpb24sIG1pblJlc29sdXRpb24sIGNhcHBlZE1heFJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRTbW9vdGhDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgICBjYXBwZWRNYXhSZXMsXG4gICAgICAgICAgICBtaW5SZXNvbHV0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhcHBlZCA9IE1hdGgubWluKGNhcHBlZE1heFJlcywgcmVzb2x1dGlvbik7XG4gICAgICAgIGNvbnN0IHogPSBNYXRoLmZsb29yKGxpbmVhckZpbmROZWFyZXN0KHJlc29sdXRpb25zLCBjYXBwZWQsIGRpcmVjdGlvbikpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbnNbel0gPiBjYXBwZWRNYXhSZXMgJiYgeiA8IHJlc29sdXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnNbeiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uc1t6XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3dlciBQb3dlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIE1heGltdW0gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gTWluaW11bSByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbc21vb3RoXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGJlIGFibGUgdG8gc2xpZ2h0bHkgZXhjZWVkIHJlc29sdXRpb24gbGltaXRzLiBEZWZhdWx0OiB0cnVlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFttYXhFeHRlbnRdIE1heGltdW0gYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG93RnVsbEV4dGVudF0gSWYgdHJ1ZSwgYWxsb3dzIHVzIHRvIHNob3cgdGhlIGZ1bGwgZXh0ZW50LiBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge1R5cGV9IFpvb20gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFwVG9Qb3dlcihcbiAgcG93ZXIsXG4gIG1heFJlc29sdXRpb24sXG4gIG1pblJlc29sdXRpb24sXG4gIHNtb290aCxcbiAgbWF4RXh0ZW50LFxuICBzaG93RnVsbEV4dGVudFxuKSB7XG4gIHNtb290aCA9IHNtb290aCAhPT0gdW5kZWZpbmVkID8gc21vb3RoIDogdHJ1ZTtcbiAgbWluUmVzb2x1dGlvbiA9IG1pblJlc29sdXRpb24gIT09IHVuZGVmaW5lZCA/IG1pblJlc29sdXRpb24gOiAwO1xuXG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUsIGlzTW92aW5nKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNhcHBlZE1heFJlcyA9IG1heEV4dGVudFxuICAgICAgICAgID8gZ2V0Vmlld3BvcnRDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgbWF4RXh0ZW50LFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICBzaG93RnVsbEV4dGVudFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbWF4UmVzb2x1dGlvbjtcblxuICAgICAgICAvLyBkdXJpbmcgaW50ZXJhY3Rpbmcgb3IgYW5pbWF0aW5nLCBhbGxvdyBpbnRlcm1lZGlhcnkgdmFsdWVzXG4gICAgICAgIGlmIChpc01vdmluZykge1xuICAgICAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXAocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiwgY2FwcGVkTWF4UmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldFNtb290aENsYW1wZWRSZXNvbHV0aW9uKFxuICAgICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICAgIGNhcHBlZE1heFJlcyxcbiAgICAgICAgICAgIG1pblJlc29sdXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gMWUtOTtcbiAgICAgICAgY29uc3QgbWluWm9vbUxldmVsID0gTWF0aC5jZWlsKFxuICAgICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBjYXBwZWRNYXhSZXMpIC8gTWF0aC5sb2cocG93ZXIpIC0gdG9sZXJhbmNlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IC1kaXJlY3Rpb24gKiAoMC41IC0gdG9sZXJhbmNlKSArIDAuNTtcbiAgICAgICAgY29uc3QgY2FwcGVkID0gTWF0aC5taW4oY2FwcGVkTWF4UmVzLCByZXNvbHV0aW9uKTtcbiAgICAgICAgY29uc3QgY2FwcGVkWm9vbUxldmVsID0gTWF0aC5mbG9vcihcbiAgICAgICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gY2FwcGVkKSAvIE1hdGgubG9nKHBvd2VyKSArIG9mZnNldFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBNYXRoLm1heChtaW5ab29tTGV2ZWwsIGNhcHBlZFpvb21MZXZlbCk7XG4gICAgICAgIGNvbnN0IG5ld1Jlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3cocG93ZXIsIHpvb21MZXZlbCk7XG4gICAgICAgIHJldHVybiBjbGFtcChuZXdSZXNvbHV0aW9uLCBtaW5SZXNvbHV0aW9uLCBjYXBwZWRNYXhSZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBNaW4gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Ntb290aF0gSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIHNsaWdodGx5IGV4Y2VlZCByZXNvbHV0aW9uIGxpbWl0cy4gRGVmYXVsdDogdHJ1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbWF4RXh0ZW50XSBNYXhpbXVtIGFsbG93ZWQgZXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd0Z1bGxFeHRlbnRdIElmIHRydWUsIGFsbG93cyB1cyB0byBzaG93IHRoZSBmdWxsIGV4dGVudC4gRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWluTWF4UmVzb2x1dGlvbihcbiAgbWF4UmVzb2x1dGlvbixcbiAgbWluUmVzb2x1dGlvbixcbiAgc21vb3RoLFxuICBtYXhFeHRlbnQsXG4gIHNob3dGdWxsRXh0ZW50XG4pIHtcbiAgc21vb3RoID0gc21vb3RoICE9PSB1bmRlZmluZWQgPyBzbW9vdGggOiB0cnVlO1xuXG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUsIGlzTW92aW5nKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNhcHBlZE1heFJlcyA9IG1heEV4dGVudFxuICAgICAgICAgID8gZ2V0Vmlld3BvcnRDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgbWF4RXh0ZW50LFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICBzaG93RnVsbEV4dGVudFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbWF4UmVzb2x1dGlvbjtcblxuICAgICAgICBpZiAoIXNtb290aCB8fCAhaXNNb3ZpbmcpIHtcbiAgICAgICAgICByZXR1cm4gY2xhbXAocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiwgY2FwcGVkTWF4UmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U21vb3RoQ2xhbXBlZFJlc29sdXRpb24oXG4gICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICBjYXBwZWRNYXhSZXMsXG4gICAgICAgICAgbWluUmVzb2x1dGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JvdGF0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBib29sZWFuPSk6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZShyb3RhdGlvbikge1xuICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uZShyb3RhdGlvbikge1xuICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIE4uXG4gKiBAcmV0dXJuIHtUeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvTihuKSB7XG4gIGNvbnN0IHRoZXRhID0gKDIgKiBNYXRoLlBJKSAvIG47XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gVHJ1ZSBpZiBhbiBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJvdGF0aW9uLCBpc01vdmluZykge1xuICAgICAgaWYgKGlzTW92aW5nKSB7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm90YXRpb24gPSBNYXRoLmZsb29yKHJvdGF0aW9uIC8gdGhldGEgKyAwLjUpICogdGhldGE7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdG9sZXJhbmNlXSBUb2xlcmFuY2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvWmVybyh0b2xlcmFuY2UpIHtcbiAgY29uc3QgdCA9IHRvbGVyYW5jZSA9PT0gdW5kZWZpbmVkID8gdG9SYWRpYW5zKDUpIDogdG9sZXJhbmNlO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb3ZpbmddIFRydWUgaWYgYW4gaW50ZXJhY3Rpb24gb3IgYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb3RhdGlvbiwgaXNNb3ZpbmcpIHtcbiAgICAgIGlmIChpc01vdmluZyB8fCByb3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uKSA8PSB0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgIH1cbiAgKTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZWFzaW5nXG4gKi9cblxuLyoqXG4gKiBTdGFydCBzbG93IGFuZCBzcGVlZCB1cC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhc2VJbih0KSB7XG4gIHJldHVybiBNYXRoLnBvdyh0LCAzKTtcbn1cblxuLyoqXG4gKiBTdGFydCBmYXN0IGFuZCBzbG93IGRvd24uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYXNlT3V0KHQpIHtcbiAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHQpO1xufVxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgdGhlbiBzbG93IGRvd24gYWdhaW4uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbkFuZE91dCh0KSB7XG4gIHJldHVybiAzICogdCAqIHQgLSAyICogdCAqIHQgKiB0O1xufVxuXG4vKipcbiAqIE1haW50YWluIGEgY29uc3RhbnQgc3BlZWQgb3ZlciB0aW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuIHQ7XG59XG5cbi8qKlxuICogU3RhcnQgc2xvdywgc3BlZWQgdXAsIGFuZCBhdCB0aGUgdmVyeSBlbmQgc2xvdyBkb3duIGFnYWluLiAgVGhpcyBoYXMgdGhlXG4gKiBzYW1lIGdlbmVyYWwgYmVoYXZpb3IgYXMge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmcuaW5BbmRPdXR9LCBidXQgdGhlIGZpbmFsXG4gKiBzbG93ZG93biBpcyBkZWxheWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBBbmREb3duKHQpIHtcbiAgaWYgKHQgPCAwLjUpIHtcbiAgICByZXR1cm4gaW5BbmRPdXQoMiAqIHQpO1xuICB9XG4gIHJldHVybiAxIC0gaW5BbmRPdXQoMiAqICh0IC0gMC41KSk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC90cmFuc2Zvcm1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtMkQoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgdHJhbnNmb3JtLFxuICBkZXN0XG4pIHtcbiAgZGVzdCA9IGRlc3QgPyBkZXN0IDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4ID0gZmxhdENvb3JkaW5hdGVzW2pdO1xuICAgIGNvbnN0IHkgPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdO1xuICAgIGRlc3RbaSsrXSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdO1xuICAgIGRlc3RbaSsrXSA9IHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bM10gKiB5ICsgdHJhbnNmb3JtWzVdO1xuICB9XG4gIGlmIChkZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYW5jaG9yIFJvdGF0aW9uIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgYW5nbGUsXG4gIGFuY2hvcixcbiAgZGVzdFxuKSB7XG4gIGRlc3QgPSBkZXN0ID8gZGVzdCA6IFtdO1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgY29uc3QgYW5jaG9yWCA9IGFuY2hvclswXTtcbiAgY29uc3QgYW5jaG9yWSA9IGFuY2hvclsxXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IGRlbHRhWCA9IGZsYXRDb29yZGluYXRlc1tqXSAtIGFuY2hvclg7XG4gICAgY29uc3QgZGVsdGFZID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSAtIGFuY2hvclk7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWCArIGRlbHRhWCAqIGNvcyAtIGRlbHRhWSAqIHNpbjtcbiAgICBkZXN0W2krK10gPSBhbmNob3JZICsgZGVsdGFYICogc2luICsgZGVsdGFZICogY29zO1xuICAgIGZvciAobGV0IGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIFNjYWxlIHRoZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggU2NhbGUgZmFjdG9yIGluIHRoZSB4LWRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgaW4gdGhlIHktZGlyZWN0aW9uLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgU2NhbGUgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHN4LFxuICBzeSxcbiAgYW5jaG9yLFxuICBkZXN0XG4pIHtcbiAgZGVzdCA9IGRlc3QgPyBkZXN0IDogW107XG4gIGNvbnN0IGFuY2hvclggPSBhbmNob3JbMF07XG4gIGNvbnN0IGFuY2hvclkgPSBhbmNob3JbMV07XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb25zdCBkZWx0YVggPSBmbGF0Q29vcmRpbmF0ZXNbal0gLSBhbmNob3JYO1xuICAgIGNvbnN0IGRlbHRhWSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gLSBhbmNob3JZO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclggKyBzeCAqIGRlbHRhWDtcbiAgICBkZXN0W2krK10gPSBhbmNob3JZICsgc3kgKiBkZWx0YVk7XG4gICAgZm9yIChsZXQgayA9IGogKyAyOyBrIDwgaiArIHN0cmlkZTsgKytrKSB7XG4gICAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNba107XG4gICAgfVxuICB9XG4gIGlmIChkZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggRGVsdGEgWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVkgRGVsdGEgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgZGVsdGFYLFxuICBkZWx0YVksXG4gIGRlc3Rcbikge1xuICBkZXN0ID0gZGVzdCA/IGRlc3QgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1tqXSArIGRlbHRhWDtcbiAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdICsgZGVsdGFZO1xuICAgIGZvciAobGV0IGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5XG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7XG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZUVtcHR5LFxuICBjcmVhdGVPclVwZGF0ZUVtcHR5LFxuICBnZXRIZWlnaHQsXG4gIHJldHVybk9yVXBkYXRlLFxufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbiwgZ2V0VHJhbnNmb3JtfSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7bWVtb2l6ZU9uZX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4vZmxhdC90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnWFknIHwgJ1hZWicgfCAnWFlNJyB8ICdYWVpNJ30gR2VvbWV0cnlMYXlvdXRcbiAqIFRoZSBjb29yZGluYXRlIGxheW91dCBmb3IgZ2VvbWV0cmllcywgaW5kaWNhdGluZyB3aGV0aGVyIGEgM3JkIG9yIDR0aCB6ICgnWicpXG4gKiBvciBtZWFzdXJlICgnTScpIGNvb3JkaW5hdGUgaXMgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydQb2ludCcgfCAnTGluZVN0cmluZycgfCAnTGluZWFyUmluZycgfCAnUG9seWdvbicgfCAnTXVsdGlQb2ludCcgfCAnTXVsdGlMaW5lU3RyaW5nJyB8ICdNdWx0aVBvbHlnb24nIHwgJ0dlb21ldHJ5Q29sbGVjdGlvbicgfCAnQ2lyY2xlJ30gVHlwZVxuICogVGhlIGdlb21ldHJ5IHR5cGUuICBPbmUgb2YgYCdQb2ludCdgLCBgJ0xpbmVTdHJpbmcnYCwgYCdMaW5lYXJSaW5nJ2AsXG4gKiBgJ1BvbHlnb24nYCwgYCdNdWx0aVBvaW50J2AsIGAnTXVsdGlMaW5lU3RyaW5nJ2AsIGAnTXVsdGlQb2x5Z29uJ2AsXG4gKiBgJ0dlb21ldHJ5Q29sbGVjdGlvbidgLCBvciBgJ0NpcmNsZSdgLlxuICovXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gKi9cbmNvbnN0IHRtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFRvIGdldCBub3RpZmllZCBvZiBjaGFuZ2VzIHRvIHRoZSBnZW9tZXRyeSwgcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgdGhlXG4gKiBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IG9uIHlvdXIgZ2VvbWV0cnkgaW5zdGFuY2UuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEdlb21ldHJ5IGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHRyYW5zZm9ybWVkIGFuZCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhlIGdlb21ldHJ5LlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXZpc2lvbiBUaGUgZ2VvbWV0cnkgcmV2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdHJhbnNmb3JtXSBPcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAgICovXG4gICAgdGhpcy5zaW1wbGlmeVRyYW5zZm9ybWVkSW50ZXJuYWwgPSBtZW1vaXplT25lKFxuICAgICAgKHJldmlzaW9uLCBzcXVhcmVkVG9sZXJhbmNlLCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGNsb25lLmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJldHVybiBjbG9uZS5nZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2Zvcm1lZCBhbmQgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IFt0cmFuc2Zvcm1dIE9wdGlvbmFsIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBzaW1wbGlmeVRyYW5zZm9ybWVkKHNxdWFyZWRUb2xlcmFuY2UsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0aGlzLnNpbXBsaWZ5VHJhbnNmb3JtZWRJbnRlcm5hbChcbiAgICAgIHRoaXMuZ2V0UmV2aXNpb24oKSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICB0cmFuc2Zvcm1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4geyFHZW9tZXRyeX0gQ2xvbmUuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICovXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xuICAgIGNvbnN0IGNvb3JkID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoW3gsIHldKTtcbiAgICByZXR1cm4gY29vcmRbMF0gPT09IHggJiYgY29vcmRbMV0gPT09IHk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjbG9zZXN0IHBvaW50IG9mIHRoZSBnZW9tZXRyeSB0byB0aGUgcGFzc2VkIHBvaW50IGFzXG4gICAqIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbY2xvc2VzdFBvaW50XSBDbG9zZXN0IHBvaW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENsb3Nlc3RQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KSB7XG4gICAgY2xvc2VzdFBvaW50ID0gY2xvc2VzdFBvaW50ID8gY2xvc2VzdFBvaW50IDogW05hTiwgTmFOXTtcbiAgICB0aGlzLmNsb3Nlc3RQb2ludFhZKHBvaW50WzBdLCBwb2ludFsxXSwgY2xvc2VzdFBvaW50LCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBnZW9tZXRyeSBpbmNsdWRlcyB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUuIElmIHRoZVxuICAgKiBjb29yZGluYXRlIGlzIG9uIHRoZSBib3VuZGFyeSBvZiB0aGUgZ2VvbWV0cnksIHJldHVybnMgZmFsc2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNDb29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1hZKGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICovXG4gIGNvbXB1dGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KGV4dGVudCkge1xuICAgIGlmICh0aGlzLmV4dGVudFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IHRoaXMuY29tcHV0ZUV4dGVudCh0aGlzLmV4dGVudF8pO1xuICAgICAgaWYgKGlzTmFOKGV4dGVudFswXSkgfHwgaXNOYU4oZXh0ZW50WzFdKSkge1xuICAgICAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KGV4dGVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4dGVudFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybk9yVXBkYXRlKHRoaXMuZXh0ZW50XywgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIGdlb21ldHJ5IGFyb3VuZCBhIGdpdmVuIGNvb3JkaW5hdGUuIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5XG4gICAqIGNvb3JkaW5hdGVzIGluIHBsYWNlLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgVGhlIHJvdGF0aW9uIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgcm90YXRlKGFuZ2xlLCBhbmNob3IpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBnZW9tZXRyeSAod2l0aCBhbiBvcHRpb25hbCBvcmlnaW4pLiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3ggVGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB4LWRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzeV0gVGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB5LWRpcmVjdGlvbiAoZGVmYXVsdHMgdG8gc3gpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIHNjYWxlIG9yaWdpbiAoZGVmYXVsdHMgdG8gdGhlIGNlbnRlclxuICAgKiAgICAgb2YgdGhlIGdlb21ldHJ5IGV4dGVudCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNjYWxlKHN4LCBzeSwgYW5jaG9yKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeS4gIEZvciBsaW5lc3RyaW5ncywgdGhpcyB1c2VzXG4gICAqIHRoZSBbRG91Z2xhcyBQZXVja2VyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKVxuICAgKiBhbGdvcml0aG0uICBGb3IgcG9seWdvbnMsIGEgcXVhbnRpemF0aW9uLWJhc2VkXG4gICAqIHNpbXBsaWZpY2F0aW9uIGlzIHVzZWQgdG8gcHJlc2VydmUgdG9wb2xvZ3kuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZSBkaXN0YW5jZSBmb3Igc2ltcGxpZmljYXRpb24uXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBBIG5ldywgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBvcmlnaW5hbCBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2ltcGxpZnkodG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHRvbGVyYW5jZSAqIHRvbGVyYW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoaXMgZ2VvbWV0cnkgdXNpbmcgdGhlIERvdWdsYXMgUGV1Y2tlclxuICAgKiBhbGdvcml0aG0uXG4gICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1R5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRoZSBnZW9tZXRyeSBtb2RpZmllZCBpbiBwbGFjZSwgZmlyc3QgYGNsb25lKClgIGl0IGFuZFxuICAgKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgKiBDYWxsZWQgd2l0aCBhIGZsYXQgYXJyYXkgb2YgZ2VvbWV0cnkgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSB0aGUgZ2VvbWV0cnkuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeSBjb29yZGluYXRlcyBpbiBwbGFjZS4gIElmXG4gICAqIGluc3RlYWQgeW91IHdhbnQgYSBuZXcgZ2VvbWV0cnksIGZpcnN0IGBjbG9uZSgpYCB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gICAqIEBhcGlcbiAgICovXG4gIHRyYW5zbGF0ZShkZWx0YVgsIGRlbHRhWSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkgZnJvbSBvbmUgY29vcmRpbmF0ZSByZWZlcmVuY2VcbiAgICogc3lzdGVtIHRvIGFub3RoZXIuIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogRm9yIGV4YW1wbGUsIGEgbGluZSB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIGEgbGluZSBhbmQgYSBjaXJjbGUgdG8gYSBjaXJjbGUuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gc291cmNlIFRoZSBjdXJyZW50IHByb2plY3Rpb24uICBDYW4gYmUgYVxuICAgKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gVGhlIGRlc2lyZWQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gICAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovXG4gICAgY29uc3Qgc291cmNlUHJvaiA9IGdldFByb2plY3Rpb24oc291cmNlKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9XG4gICAgICBzb3VyY2VQcm9qLmdldFVuaXRzKCkgPT0gJ3RpbGUtcGl4ZWxzJ1xuICAgICAgICA/IGZ1bmN0aW9uIChpbkNvb3JkaW5hdGVzLCBvdXRDb29yZGluYXRlcywgc3RyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbEV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ZWRFeHRlbnQgPSBzb3VyY2VQcm9qLmdldFdvcmxkRXh0ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IGdldEhlaWdodChwcm9qZWN0ZWRFeHRlbnQpIC8gZ2V0SGVpZ2h0KHBpeGVsRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgIHRtcFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgcHJvamVjdGVkRXh0ZW50WzBdLFxuICAgICAgICAgICAgICBwcm9qZWN0ZWRFeHRlbnRbM10sXG4gICAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgICAtc2NhbGUsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0yRChcbiAgICAgICAgICAgICAgaW5Db29yZGluYXRlcyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgaW5Db29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgICAgdG1wVHJhbnNmb3JtLFxuICAgICAgICAgICAgICBvdXRDb29yZGluYXRlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdGluYXRpb24pKFxuICAgICAgICAgICAgICBpbkNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICBvdXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgc3RyaWRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBnZXRUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb21ldHJ5O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1NpbXBsZUdlb21ldHJ5XG4gKi9cbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuL0dlb21ldHJ5LmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMsIGdldENlbnRlcn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7cm90YXRlLCBzY2FsZSwgdHJhbnNmb3JtMkQsIHRyYW5zbGF0ZX0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzOyBkbyBub3QgaW5zdGFudGlhdGVcbiAqIGluIGFwcHMsIGFzIGNhbm5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU2ltcGxlR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9XG4gICAgICovXG4gICAgdGhpcy5sYXlvdXQgPSAnWFknO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdHJpZGUgPSAyO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKi9cbiAgY29tcHV0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBleHRlbnRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTwqPiB8IG51bGx9IENvb3JkaW5hdGVzLlxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBmaXJzdCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBGaXJzdCBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGaXJzdENvb3JkaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKDAsIHRoaXMuc3RyaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgZ2V0RmxhdENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxhc3QgY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gTGFzdCBwb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGFzdENvb3JkaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC0gdGhpcy5zdHJpZGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIGltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXQgbGF5b3V0fSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeSB1c2luZyB0aGUgRG91Z2xhcyBQZXVja2VyIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1NpbXBsZUdlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICBpZiAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlSZXZpc2lvbiAhPT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSAwO1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlSZXZpc2lvbiA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgLy8gSWYgc3F1YXJlZFRvbGVyYW5jZSBpcyBuZWdhdGl2ZSBvciBpZiB3ZSBrbm93IHRoYXQgc2ltcGxpZmljYXRpb24gd2lsbCBub3RcbiAgICAvLyBoYXZlIGFueSBlZmZlY3QgdGhlbiBqdXN0IHJldHVybiB0aGlzLlxuICAgIGlmIChcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UgPCAwIHx8XG4gICAgICAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlICE9PSAwICYmXG4gICAgICAgIHNxdWFyZWRUb2xlcmFuY2UgPD0gdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3Qgc2ltcGxpZmllZEdlb21ldHJ5ID1cbiAgICAgIHRoaXMuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSk7XG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IHNpbXBsaWZpZWRHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzaW1wbGlmaWVkR2VvbWV0cnk7XG4gICAgfVxuICAgIC8vIFNpbXBsaWZpY2F0aW9uIGRpZCBub3QgYWN0dWFsbHkgcmVtb3ZlIGFueSBjb29yZGluYXRlcy4gIFdlIG5vdyBrbm93XG4gICAgLy8gdGhhdCBhbnkgY2FsbHMgdG8gZ2V0U2ltcGxpZmllZEdlb21ldHJ5IHdpdGggYSBzcXVhcmVkVG9sZXJhbmNlIGxlc3NcbiAgICAvLyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IHNxdWFyZWRUb2xlcmFuY2Ugd2lsbCBhbHNvIG5vdCBoYXZlIGFueVxuICAgIC8vIGVmZmVjdC4gIFRoaXMgYWxsb3dzIHVzIHRvIHNob3J0IGNpcmN1aXQgc2ltcGxpZmljYXRpb24gKHNhdmluZyBDUFVcbiAgICAvLyBjeWNsZXMpIGFuZCBwcmV2ZW50cyB0aGUgY2FjaGUgb2Ygc2ltcGxpZmllZCBnZW9tZXRyaWVzIGZyb20gZmlsbGluZ1xuICAgIC8vIHVwIHdpdGggdXNlbGVzcyBpZGVudGljYWwgY29waWVzIG9mIHRoaXMgZ2VvbWV0cnkgKHNhdmluZyBtZW1vcnkpLlxuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IHNxdWFyZWRUb2xlcmFuY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1NpbXBsZUdlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBTdHJpZGUuXG4gICAqL1xuICBnZXRTdHJpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIHNldEZsYXRDb29yZGluYXRlcyhsYXlvdXQsIGZsYXRDb29yZGluYXRlcykge1xuICAgIHRoaXMuc3RyaWRlID0gZ2V0U3RyaWRlRm9yTGF5b3V0KGxheW91dCk7XG4gICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBmbGF0Q29vcmRpbmF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR8dW5kZWZpbmVkfSBsYXlvdXQgTGF5b3V0LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5lc3RpbmcgTmVzdGluZy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0TGF5b3V0KGxheW91dCwgY29vcmRpbmF0ZXMsIG5lc3RpbmcpIHtcbiAgICBsZXQgc3RyaWRlO1xuICAgIGlmIChsYXlvdXQpIHtcbiAgICAgIHN0cmlkZSA9IGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lc3Rpbmc7ICsraSkge1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5sYXlvdXQgPSAnWFknO1xuICAgICAgICAgIHRoaXMuc3RyaWRlID0gMjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge0FycmF5PHVua25vd24+fSAqLyAoY29vcmRpbmF0ZXNbMF0pO1xuICAgICAgfVxuICAgICAgc3RyaWRlID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgbGF5b3V0ID0gZ2V0TGF5b3V0Rm9yU3RyaWRlKHN0cmlkZSk7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRoZSBnZW9tZXRyeSBtb2RpZmllZCBpbiBwbGFjZSwgZmlyc3QgYGNsb25lKClgIGl0IGFuZFxuICAgKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAqIENhbGxlZCB3aXRoIGEgZmxhdCBhcnJheSBvZiBnZW9tZXRyeSBjb29yZGluYXRlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pIHtcbiAgICBpZiAodGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRyYW5zZm9ybUZuKHRoaXMuZmxhdENvb3JkaW5hdGVzLCB0aGlzLmZsYXRDb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiBhbmdsZSBpbiBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIHJvdGF0ZShhbmdsZSwgYW5jaG9yKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgcm90YXRlKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIDAsXG4gICAgICAgIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzXG4gICAgICApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBnZW9tZXRyeSAod2l0aCBhbiBvcHRpb25hbCBvcmlnaW4pLiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHgtZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N5XSBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHktZGlyZWN0aW9uIChkZWZhdWx0cyB0byBzeCkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgc2NhbGUgb3JpZ2luIChkZWZhdWx0cyB0byB0aGUgY2VudGVyXG4gICAqICAgICBvZiB0aGUgZ2VvbWV0cnkgZXh0ZW50KS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2NhbGUoc3gsIHN5LCBhbmNob3IpIHtcbiAgICBpZiAoc3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3kgPSBzeDtcbiAgICB9XG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIGFuY2hvciA9IGdldENlbnRlcih0aGlzLmdldEV4dGVudCgpKTtcbiAgICB9XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgc2NhbGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBzeCxcbiAgICAgICAgc3ksXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzXG4gICAgICApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSB0aGUgZ2VvbWV0cnkuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeSBjb29yZGluYXRlcyBpbiBwbGFjZS4gIElmXG4gICAqIGluc3RlYWQgeW91IHdhbnQgYSBuZXcgZ2VvbWV0cnksIGZpcnN0IGBjbG9uZSgpYCB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIERlbHRhIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVkgRGVsdGEgWS5cbiAgICogQGFwaVxuICAgKi9cbiAgdHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgdHJhbnNsYXRlKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIDAsXG4gICAgICAgIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgZGVsdGFYLFxuICAgICAgICBkZWx0YVksXG4gICAgICAgIGZsYXRDb29yZGluYXRlc1xuICAgICAgKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExheW91dEZvclN0cmlkZShzdHJpZGUpIHtcbiAgbGV0IGxheW91dDtcbiAgaWYgKHN0cmlkZSA9PSAyKSB7XG4gICAgbGF5b3V0ID0gJ1hZJztcbiAgfSBlbHNlIGlmIChzdHJpZGUgPT0gMykge1xuICAgIGxheW91dCA9ICdYWVonO1xuICB9IGVsc2UgaWYgKHN0cmlkZSA9PSA0KSB7XG4gICAgbGF5b3V0ID0gJ1hZWk0nO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9ICovIChsYXlvdXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqIEByZXR1cm4ge251bWJlcn0gU3RyaWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaWRlRm9yTGF5b3V0KGxheW91dCkge1xuICBsZXQgc3RyaWRlO1xuICBpZiAobGF5b3V0ID09ICdYWScpIHtcbiAgICBzdHJpZGUgPSAyO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PSAnWFlaJyB8fCBsYXlvdXQgPT0gJ1hZTScpIHtcbiAgICBzdHJpZGUgPSAzO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PSAnWFlaTScpIHtcbiAgICBzdHJpZGUgPSA0O1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHN0cmlkZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaW1wbGVHZW9tZXRyeX0gc2ltcGxlR2VvbWV0cnkgU2ltcGxlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBmbGF0IGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtR2VvbTJEKHNpbXBsZUdlb21ldHJ5LCB0cmFuc2Zvcm0sIGRlc3QpIHtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gc2ltcGxlR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gIGlmICghZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RyaWRlID0gc2ltcGxlR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gIHJldHVybiB0cmFuc2Zvcm0yRChcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgMCxcbiAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgIHN0cmlkZSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgZGVzdFxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTaW1wbGVHZW9tZXRyeTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2Nsb3Nlc3RcbiAqL1xuaW1wb3J0IHtsZXJwLCBzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZER4fSBmcm9tICcuLi8uLi9tYXRoLmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgMkQgbGluZSBzZWdtZW50IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXSB0b1xuICogZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcG9pbnQgKHgsIHkpLiAgRXh0cmFcbiAqIGRpbWVuc2lvbnMgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0MSBPZmZzZXQgMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQyIE9mZnNldCAyLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3QoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0MSxcbiAgb2Zmc2V0MixcbiAgc3RyaWRlLFxuICB4LFxuICB5LFxuICBjbG9zZXN0UG9pbnRcbikge1xuICBjb25zdCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXTtcbiAgY29uc3QgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MSArIDFdO1xuICBjb25zdCBkeCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQyXSAtIHgxO1xuICBjb25zdCBkeSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQyICsgMV0gLSB5MTtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0MTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQyO1xuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gbGVycChcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MSArIGldLFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQyICsgaV0sXG4gICAgICAgICAgdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0MTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgfVxuICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3F1YXJlZCBvZiB0aGUgbGFyZ2VzdCBkaXN0YW5jZSBiZXR3ZWVuIGFueSBwYWlyIG9mIGNvbnNlY3V0aXZlXG4gKiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG1heCkge1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBmb3IgKG9mZnNldCArPSBzdHJpZGU7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgY29uc3Qgc3F1YXJlZERlbHRhID0gc3F1YXJlZER4KHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoc3F1YXJlZERlbHRhID4gbWF4KSB7XG4gICAgICBtYXggPSBzcXVhcmVkRGVsdGE7XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBtYXhcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIG1heCA9IG1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG1heCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlBcnJheU1heFNxdWFyZWREZWx0YShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIG1heFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgbWF4ID0gYXJyYXlNYXhTcXVhcmVkRGVsdGEoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgbWF4KTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3RtcFBvaW50XSBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0UG9pbnQoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgbWF4RGVsdGEsXG4gIGlzUmluZyxcbiAgeCxcbiAgeSxcbiAgY2xvc2VzdFBvaW50LFxuICBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gIHRtcFBvaW50XG4pIHtcbiAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG4gIGxldCBpLCBzcXVhcmVkRGlzdGFuY2U7XG4gIGlmIChtYXhEZWx0YSA9PT0gMCkge1xuICAgIC8vIEFsbCBwb2ludHMgYXJlIGlkZW50aWNhbCwgc28ganVzdCB0ZXN0IHRoZSBmaXJzdCBwb2ludC5cbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLFxuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdXG4gICAgKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybiBzcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cbiAgdG1wUG9pbnQgPSB0bXBQb2ludCA/IHRtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgbGV0IGluZGV4ID0gb2Zmc2V0ICsgc3RyaWRlO1xuICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICBhc3NpZ25DbG9zZXN0KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgaW5kZXggLSBzdHJpZGUsXG4gICAgICBpbmRleCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdG1wUG9pbnRcbiAgICApO1xuICAgIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeCh4LCB5LCB0bXBQb2ludFswXSwgdG1wUG9pbnRbMV0pO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSB0bXBQb2ludFtpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICBpbmRleCArPSBzdHJpZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNraXAgYWhlYWQgbXVsdGlwbGUgcG9pbnRzLCBiZWNhdXNlIHdlIGtub3cgdGhhdCBhbGwgdGhlIHNraXBwZWRcbiAgICAgIC8vIHBvaW50cyBjYW5ub3QgYmUgYW55IGNsb3NlciB0aGFuIHRoZSBjbG9zZXN0IHBvaW50IHdlIGhhdmUgZm91bmQgc29cbiAgICAgIC8vIGZhci4gIFdlIGtub3cgdGhpcyBiZWNhdXNlIHdlIGtub3cgaG93IGNsb3NlIHRoZSBjdXJyZW50IHBvaW50IGlzLCBob3dcbiAgICAgIC8vIGNsb3NlIHRoZSBjbG9zZXN0IHBvaW50IHdlIGhhdmUgZm91bmQgc28gZmFyIGlzLCBhbmQgdGhlIG1heGltdW1cbiAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgcG9pbnRzLiAgRm9yIGV4YW1wbGUsIGlmIHdlJ3JlIGN1cnJlbnRseVxuICAgICAgLy8gYXQgZGlzdGFuY2UgMTAsIHRoZSBiZXN0IHdlJ3ZlIGZvdW5kIHNvIGZhciBpcyAzLCBhbmQgdGhhdCB0aGUgbWF4aW11bVxuICAgICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBwb2ludHMgaXMgMiwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNraXAgYXRcbiAgICAgIC8vIGxlYXN0ICgxMCAtIDMpIC8gMiA9PSAzIChyb3VuZGVkIGRvd24pIHBvaW50cyB0byBoYXZlIGFueSBjaGFuY2Ugb2ZcbiAgICAgIC8vIGZpbmRpbmcgYSBjbG9zZXIgcG9pbnQuICBXZSB1c2UgTWF0aC5tYXgoLi4uLCAxKSB0byBlbnN1cmUgdGhhdCB3ZVxuICAgICAgLy8gYWx3YXlzIGFkdmFuY2UgYXQgbGVhc3Qgb25lIHBvaW50LCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgaW5kZXggKz1cbiAgICAgICAgc3RyaWRlICpcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgKChNYXRoLnNxcnQoc3F1YXJlZERpc3RhbmNlKSAtIE1hdGguc3FydChtaW5TcXVhcmVkRGlzdGFuY2UpKSAvXG4gICAgICAgICAgICBtYXhEZWx0YSkgfFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChpc1JpbmcpIHtcbiAgICAvLyBDaGVjayB0aGUgY2xvc2luZyBzZWdtZW50LlxuICAgIGFzc2lnbkNsb3Nlc3QoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBlbmQgLSBzdHJpZGUsXG4gICAgICBvZmZzZXQsXG4gICAgICBzdHJpZGUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHRtcFBvaW50XG4gICAgKTtcbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoeCwgeSwgdG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gdG1wUG9pbnRbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbdG1wUG9pbnRdIFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBtYXhEZWx0YSxcbiAgaXNSaW5nLFxuICB4LFxuICB5LFxuICBjbG9zZXN0UG9pbnQsXG4gIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgdG1wUG9pbnRcbikge1xuICB0bXBQb2ludCA9IHRtcFBvaW50ID8gdG1wUG9pbnQgOiBbTmFOLCBOYU5dO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIG1heERlbHRhLFxuICAgICAgaXNSaW5nLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gICAgICB0bXBQb2ludFxuICAgICk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEZWx0YSBNYXggZGVsdGEuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmluZyBJcyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFt0bXBQb2ludF0gVGVtcG9yYXJ5IHBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduQ2xvc2VzdE11bHRpQXJyYXlQb2ludChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIG1heERlbHRhLFxuICBpc1JpbmcsXG4gIHgsXG4gIHksXG4gIGNsb3Nlc3RQb2ludCxcbiAgbWluU3F1YXJlZERpc3RhbmNlLFxuICB0bXBQb2ludFxuKSB7XG4gIHRtcFBvaW50ID0gdG1wUG9pbnQgPyB0bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgbWluU3F1YXJlZERpc3RhbmNlID0gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzLFxuICAgICAgc3RyaWRlLFxuICAgICAgbWF4RGVsdGEsXG4gICAgICBpc1JpbmcsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgICAgIHRtcFBvaW50XG4gICAgKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2RlZmxhdGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlLCBzdHJpZGUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGNvb3JkaW5hdGVbaV07XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXMoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBjb29yZGluYXRlcyxcbiAgc3RyaWRlXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cmlkZTsgKytqKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0KytdID0gY29vcmRpbmF0ZVtqXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlc3MgQ29vcmRpbmF0ZXNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbmRzXSBFbmRzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgY29vcmRpbmF0ZXNzLFxuICBzdHJpZGUsXG4gIGVuZHNcbikge1xuICBlbmRzID0gZW5kcyA/IGVuZHMgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gMCwgamogPSBjb29yZGluYXRlc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIGNvbnN0IGVuZCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNvb3JkaW5hdGVzc1tqXSxcbiAgICAgIHN0cmlkZVxuICAgICk7XG4gICAgZW5kc1tpKytdID0gZW5kO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICBlbmRzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBjb29yZGluYXRlc3NzIENvb3JkaW5hdGVzc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtlbmRzc10gRW5kc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gRW5kc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgY29vcmRpbmF0ZXNzcyxcbiAgc3RyaWRlLFxuICBlbmRzc1xuKSB7XG4gIGVuZHNzID0gZW5kc3MgPyBlbmRzcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIGNvbnN0IGVuZHMgPSBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNvb3JkaW5hdGVzc3Nbal0sXG4gICAgICBzdHJpZGUsXG4gICAgICBlbmRzc1tpXVxuICAgICk7XG4gICAgaWYgKGVuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBlbmRzWzBdID0gb2Zmc2V0O1xuICAgIH1cbiAgICBlbmRzc1tpKytdID0gZW5kcztcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgZW5kc3MubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGVuZHNzO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc2ltcGxpZnlcbiAqL1xuLy8gQmFzZWQgb24gc2ltcGxpZnktanMgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvc2ltcGxpZnktanNcbi8vIENvcHlyaWdodCAoYykgMjAxMiwgVmxhZGltaXIgQWdhZm9ua2luXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vL1xuLy8gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuLy8gICAgICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vXG4vLyAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuLy8gQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuLy8gSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0Vcbi8vIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbi8vIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1Jcbi8vIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4vLyBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1Ncbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4vLyBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuLy8gQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbi8vIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSwgc3F1YXJlZFNlZ21lbnREaXN0YW5jZX0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtib29sZWFufSBoaWdoUXVhbGl0eSBIaWdoZXN0IHF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzXSBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFNpbXBsaWZpZWQgbGluZSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeUxpbmVTdHJpbmcoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgaGlnaFF1YWxpdHksXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNcbikge1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID1cbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQgPyBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIDogW107XG4gIGlmICghaGlnaFF1YWxpdHkpIHtcbiAgICBlbmQgPSByYWRpYWxEaXN0YW5jZShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgMFxuICAgICk7XG4gICAgZmxhdENvb3JkaW5hdGVzID0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcztcbiAgICBvZmZzZXQgPSAwO1xuICAgIHN0cmlkZSA9IDI7XG4gIH1cbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlcihcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgb2Zmc2V0LFxuICAgIGVuZCxcbiAgICBzdHJpZGUsXG4gICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgIDBcbiAgKTtcbiAgcmV0dXJuIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXIoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldFxuKSB7XG4gIGNvbnN0IG4gPSAoZW5kIC0gb2Zmc2V0KSAvIHN0cmlkZTtcbiAgaWYgKG4gPCAzKSB7XG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgbWFya2VycyA9IG5ldyBBcnJheShuKTtcbiAgbWFya2Vyc1swXSA9IDE7XG4gIG1hcmtlcnNbbiAtIDFdID0gMTtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBzdGFjayA9IFtvZmZzZXQsIGVuZCAtIHN0cmlkZV07XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGZpcnN0ID0gc3RhY2sucG9wKCk7XG4gICAgbGV0IG1heFNxdWFyZWREaXN0YW5jZSA9IDA7XG4gICAgY29uc3QgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZmlyc3RdO1xuICAgIGNvbnN0IHkxID0gZmxhdENvb3JkaW5hdGVzW2ZpcnN0ICsgMV07XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbbGFzdF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbbGFzdCArIDFdO1xuICAgIGZvciAobGV0IGkgPSBmaXJzdCArIHN0cmlkZTsgaSA8IGxhc3Q7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCB4ID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgY29uc3QgeSA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkU2VnbWVudERpc3RhbmNlKHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPiBtYXhTcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBtYXhTcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXhTcXVhcmVkRGlzdGFuY2UgPiBzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgICBtYXJrZXJzWyhpbmRleCAtIG9mZnNldCkgLyBzdHJpZGVdID0gMTtcbiAgICAgIGlmIChmaXJzdCArIHN0cmlkZSA8IGluZGV4KSB7XG4gICAgICAgIHN0YWNrLnB1c2goZmlyc3QsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCArIHN0cmlkZSA8IGxhc3QpIHtcbiAgICAgICAgc3RhY2sucHVzaChpbmRleCwgbGFzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKG1hcmtlcnNbaV0pIHtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpICogc3RyaWRlXTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpICogc3RyaWRlICsgMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRW5kcyBTaW1wbGlmaWVkIGVuZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXJBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbiAgc2ltcGxpZmllZEVuZHNcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBkb3VnbGFzUGV1Y2tlcihcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgc2ltcGxpZmllZE9mZnNldFxuICAgICk7XG4gICAgc2ltcGxpZmllZEVuZHMucHVzaChzaW1wbGlmaWVkT2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBzaW1wbGlmaWVkRW5kc3MgU2ltcGxpZmllZCBlbmRzcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3VnbGFzUGV1Y2tlck11bHRpQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICBzcXVhcmVkVG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kc3Ncbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCBzaW1wbGlmaWVkRW5kcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kcyxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgc2ltcGxpZmllZE9mZnNldCxcbiAgICAgIHNpbXBsaWZpZWRFbmRzXG4gICAgKTtcbiAgICBzaW1wbGlmaWVkRW5kc3MucHVzaChzaW1wbGlmaWVkRW5kcyk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbERpc3RhbmNlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXRcbikge1xuICBpZiAoZW5kIDw9IG9mZnNldCArIHN0cmlkZSkge1xuICAgIC8vIHplcm8gb3Igb25lIHBvaW50LCBubyBzaW1wbGlmaWNhdGlvbiBwb3NzaWJsZSwgc28gY29weSBhbmQgcmV0dXJuXG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIC8vIGNvcHkgZmlyc3QgcG9pbnRcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDE7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkxO1xuICBsZXQgeDIgPSB4MTtcbiAgbGV0IHkyID0geTE7XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSA+IHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICAgIC8vIGNvcHkgcG9pbnQgYXQgb2Zmc2V0XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfVxuICB9XG4gIGlmICh4MiAhPSB4MSB8fCB5MiAhPSB5MSkge1xuICAgIC8vIGNvcHkgbGFzdCBwb2ludFxuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHJldHVybiB7bnVtYmVyfSBSb3VuZGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcCh2YWx1ZSwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiB0b2xlcmFuY2UgKiBNYXRoLnJvdW5kKHZhbHVlIC8gdG9sZXJhbmNlKTtcbn1cblxuLyoqXG4gKiBTaW1wbGlmaWVzIGEgbGluZSBzdHJpbmcgdXNpbmcgYW4gYWxnb3JpdGhtIGRlc2lnbmVkIGJ5IFRpbSBTY2hhdWIuXG4gKiBDb29yZGluYXRlcyBhcmUgc25hcHBlZCB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhIHZpcnR1YWwgZ3JpZCBhbmRcbiAqIGNvbnNlY3V0aXZlIGR1cGxpY2F0ZSBjb29yZGluYXRlcyBhcmUgZGlzY2FyZGVkLiAgVGhpcyBlZmZlY3RpdmVseSBwcmVzZXJ2ZXNcbiAqIHRvcG9sb2d5IGFzIHRoZSBzaW1wbGlmaWNhdGlvbiBvZiBhbnkgc3Vic2VjdGlvbiBvZiBhIGxpbmUgc3RyaW5nIGlzXG4gKiBpbmRlcGVuZGVudCBvZiB0aGUgcmVzdCBvZiB0aGUgbGluZSBzdHJpbmcuICBUaGlzIG1lYW5zIHRoYXQsIGZvciBleGFtcGxlcyxcbiAqIHRoZSBjb21tb24gZWRnZSBiZXR3ZWVuIHR3byBwb2x5Z29ucyB3aWxsIGJlIHNpbXBsaWZpZWQgdG8gdGhlIHNhbWUgbGluZVxuICogc3RyaW5nIGluZGVwZW5kZW50bHkgaW4gYm90aCBwb2x5Z29ucy4gIFRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyBhIHNpbmdsZVxuICogcGFzcyBvdmVyIHRoZSBjb29yZGluYXRlcyBhbmQgZWxpbWluYXRlcyBpbnRlcm1lZGlhdGUgY29sbGluZWFyIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldFxuKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgdGhlIGxpbmUgaXMgZW1wdHlcbiAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvLyBzbmFwIHRoZSBmaXJzdCBjb29yZGluYXRlIChQMSlcbiAgbGV0IHgxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgbGV0IHkxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIC8vIGFkZCB0aGUgZmlyc3QgY29vcmRpbmF0ZSB0byB0aGUgb3V0cHV0XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgxO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MTtcbiAgLy8gZmluZCB0aGUgbmV4dCBjb29yZGluYXRlIHRoYXQgZG9lcyBub3Qgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZmlyc3RcbiAgLy8gY29vcmRpbmF0ZSAoUDIpXG4gIGxldCB4MiwgeTI7XG4gIGRvIHtcbiAgICB4MiA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gICAgeTIgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgICAvLyBhbGwgY29vcmRpbmF0ZXMgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSwgdGhlIGxpbmUgY29sbGFwc2VzIHRvIGEgcG9pbnRcbiAgICAgIC8vIHB1c2ggdGhlIGxhc3Qgc25hcHBlZCB2YWx1ZSBhbnl3YXkgdG8gZW5zdXJlIHRoYXQgdGhlIG91dHB1dCBjb250YWluc1xuICAgICAgLy8gYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgICAgLy8gRklYTUUgc2hvdWxkIHdlIHJlYWxseSByZXR1cm4gYXQgbGVhc3QgdHdvIHBvaW50cyBhbnl3YXk/XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gICAgfVxuICB9IHdoaWxlICh4MiA9PSB4MSAmJiB5MiA9PSB5MSk7XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICAvLyBzbmFwIHRoZSBuZXh0IGNvb3JkaW5hdGUgKFAzKVxuICAgIGNvbnN0IHgzID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgICBjb25zdCB5MyA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgLy8gc2tpcCBQMyBpZiBpdCBpcyBlcXVhbCB0byBQMlxuICAgIGlmICh4MyA9PSB4MiAmJiB5MyA9PSB5Mikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiBQMSBhbmQgUDJcbiAgICBjb25zdCBkeDEgPSB4MiAtIHgxO1xuICAgIGNvbnN0IGR5MSA9IHkyIC0geTE7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIFAzIGFuZCBQMVxuICAgIGNvbnN0IGR4MiA9IHgzIC0geDE7XG4gICAgY29uc3QgZHkyID0geTMgLSB5MTtcbiAgICAvLyBpZiBQMSwgUDIsIGFuZCBQMyBhcmUgY29saW5lYXIgYW5kIFAzIGlzIGZ1cnRoZXIgZnJvbSBQMSB0aGFuIFAyIGlzIGZyb21cbiAgICAvLyBQMSBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gdGhlbiBQMiBpcyBvbiB0aGUgc3RyYWlnaHQgbGluZSBiZXR3ZWVuIFAxIGFuZFxuICAgIC8vIFAzXG4gICAgaWYgKFxuICAgICAgZHgxICogZHkyID09IGR5MSAqIGR4MiAmJlxuICAgICAgKChkeDEgPCAwICYmIGR4MiA8IGR4MSkgfHwgZHgxID09IGR4MiB8fCAoZHgxID4gMCAmJiBkeDIgPiBkeDEpKSAmJlxuICAgICAgKChkeTEgPCAwICYmIGR5MiA8IGR5MSkgfHwgZHkxID09IGR5MiB8fCAoZHkxID4gMCAmJiBkeTIgPiBkeTEpKVxuICAgICkge1xuICAgICAgLy8gZGlzY2FyZCBQMiBhbmQgc2V0IFAyID0gUDNcbiAgICAgIHgyID0geDM7XG4gICAgICB5MiA9IHkzO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGVpdGhlciBQMSwgUDIsIGFuZCBQMyBhcmUgbm90IGNvbGluZWFyLCBvciB0aGV5IGFyZSBjb2xpbmVhciBidXQgUDMgaXNcbiAgICAvLyBiZXR3ZWVuIFAzIGFuZCBQMSBvciBvbiB0aGUgb3Bwb3NpdGUgaGFsZiBvZiB0aGUgbGluZSB0byBQMi4gIGFkZCBQMixcbiAgICAvLyBhbmQgY29udGludWUgd2l0aCBQMSA9IFAyIGFuZCBQMiA9IFAzXG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHgyID0geDM7XG4gICAgeTIgPSB5MztcbiAgfVxuICAvLyBhZGQgdGhlIGxhc3QgcG9pbnQgKFAyKVxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRW5kcyBTaW1wbGlmaWVkIGVuZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kc1xuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IHF1YW50aXplKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgdG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNpbXBsaWZpZWRPZmZzZXRcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kc3Ncbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCBzaW1wbGlmaWVkRW5kcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBxdWFudGl6ZUFycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kcyxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBzaW1wbGlmaWVkT2Zmc2V0LFxuICAgICAgc2ltcGxpZmllZEVuZHNcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzcy5wdXNoKHNpbXBsaWZpZWRFbmRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbmZsYXRlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBbY29vcmRpbmF0ZXNdIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgY29vcmRpbmF0ZXNcbikge1xuICBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQgPyBjb29yZGluYXRlcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgY29vcmRpbmF0ZXNbaSsrXSA9IGZsYXRDb29yZGluYXRlcy5zbGljZShqLCBqICsgc3RyaWRlKTtcbiAgfVxuICBjb29yZGluYXRlcy5sZW5ndGggPSBpO1xuICByZXR1cm4gY29vcmRpbmF0ZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IFtjb29yZGluYXRlc3NdIENvb3JkaW5hdGVzcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgY29vcmRpbmF0ZXNzXG4pIHtcbiAgY29vcmRpbmF0ZXNzID0gY29vcmRpbmF0ZXNzICE9PSB1bmRlZmluZWQgPyBjb29yZGluYXRlc3MgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gMCwgamogPSBlbmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2pdO1xuICAgIGNvb3JkaW5hdGVzc1tpKytdID0gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgY29vcmRpbmF0ZXNzW2ldXG4gICAgKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgY29vcmRpbmF0ZXNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBbY29vcmRpbmF0ZXNzc11cbiAqICAgICBDb29yZGluYXRlc3NzLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBDb29yZGluYXRlc3NzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIGNvb3JkaW5hdGVzc3Ncbikge1xuICBjb29yZGluYXRlc3NzID0gY29vcmRpbmF0ZXNzcyAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXNzcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSAwLCBqaiA9IGVuZHNzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3Nbal07XG4gICAgY29vcmRpbmF0ZXNzc1tpKytdID1cbiAgICAgIGVuZHMubGVuZ3RoID09PSAxICYmIGVuZHNbMF0gPT09IG9mZnNldFxuICAgICAgICA/IFtdXG4gICAgICAgIDogaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBlbmRzLFxuICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXNzc1tpXVxuICAgICAgICAgICk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGNvb3JkaW5hdGVzc3MubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGNvb3JkaW5hdGVzc3M7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9hcmVhXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgbGV0IHR3aWNlQXJlYSA9IDA7XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIHR3aWNlQXJlYSArPSB5MSAqIHgyIC0geDEgKiB5MjtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIHR3aWNlQXJlYSAvIDI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpIHtcbiAgbGV0IGFyZWEgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIGFyZWEgKz0gbGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBhcmVhICs9IGxpbmVhclJpbmdzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9MaW5lYXJSaW5nXG4gKi9cbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdFBvaW50LCBtYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7ZG91Z2xhc1BldWNrZXJ9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nIGFzIGxpbmVhclJpbmdBcmVhfSBmcm9tICcuL2ZsYXQvYXJlYS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGluZWFyIHJpbmcgZ2VvbWV0cnkuIE9ubHkgdXNlZCBhcyBwYXJ0IG9mIHBvbHlnb247IGNhbm5vdCBiZSByZW5kZXJlZFxuICogb24gaXRzIG93bi5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIExpbmVhclJpbmcgZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqICAgICBGb3IgaW50ZXJuYWwgdXNlLCBmbGF0IGNvb3JkaW5hdGVzIGluIGNvbWJpbmF0aW9uIHdpdGggYGxheW91dGAgYXJlIGFsc28gYWNjZXB0ZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAobGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gKi8gKFxuICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICksXG4gICAgICAgIGxheW91dFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTGluZWFyUmluZ30gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoXG4gICAgICAgIG1heFNxdWFyZWREZWx0YShcbiAgICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgICB0aGlzLnN0cmlkZSxcbiAgICAgICAgICAwXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXyxcbiAgICAgIHRydWUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhcmVhIG9mIHRoZSBsaW5lYXIgcmluZyBvbiBwcm9qZWN0ZWQgcGxhbmUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAob24gcHJvamVjdGVkIHBsYW5lKS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXJlYSgpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ0FyZWEoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZWFyIHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtMaW5lYXJSaW5nfSBTaW1wbGlmaWVkIExpbmVhclJpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsICdYWScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLlR5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdMaW5lYXJSaW5nJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIHBhc3NlZCBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAYXBpXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHBhcmFtIHshQXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluZWFyUmluZztcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2ludFxuICovXG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zWFksIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGV9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkRHh9IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFBvaW50IGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFQb2ludH0gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICBwb2ludC5hcHBseVByb3BlcnRpZXModGhpcyk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1swXSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1sxXVxuICAgICk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKi9cbiAgY29tcHV0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZSh0aGlzLmZsYXRDb29yZGluYXRlcywgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnUG9pbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCB0aGlzLmZsYXRDb29yZGluYXRlc1swXSwgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCAwKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkZWZsYXRlQ29vcmRpbmF0ZShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgdGhpcy5zdHJpZGVcbiAgICApO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvY29udGFpbnNcbiAqL1xuaW1wb3J0IHtmb3JFYWNoQ29ybmVyfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nQ29udGFpbnNFeHRlbnQoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgZXh0ZW50XG4pIHtcbiAgY29uc3Qgb3V0c2lkZSA9IGZvckVhY2hDb3JuZXIoXG4gICAgZXh0ZW50LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb29yZGluYXRlKSB7XG4gICAgICByZXR1cm4gIWxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGNvb3JkaW5hdGVbMF0sXG4gICAgICAgIGNvb3JkaW5hdGVbMV1cbiAgICAgICk7XG4gICAgfVxuICApO1xuICByZXR1cm4gIW91dHNpZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgeCxcbiAgeVxuKSB7XG4gIC8vIGh0dHBzOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwMy1faW5jbHVzaW9uLmh0bWxcbiAgLy8gQ29weXJpZ2h0IDIwMDAgc29mdFN1cmZlciwgMjAxMiBEYW4gU3VuZGF5XG4gIC8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IHVzZWQgYW5kIG1vZGlmaWVkIGZvciBhbnkgcHVycG9zZVxuICAvLyBwcm92aWRpbmcgdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgaW5jbHVkZWQgd2l0aCBpdC5cbiAgLy8gU29mdFN1cmZlciBtYWtlcyBubyB3YXJyYW50eSBmb3IgdGhpcyBjb2RlLCBhbmQgY2Fubm90IGJlIGhlbGRcbiAgLy8gbGlhYmxlIGZvciBhbnkgcmVhbCBvciBpbWFnaW5lZCBkYW1hZ2UgcmVzdWx0aW5nIGZyb20gaXRzIHVzZS5cbiAgLy8gVXNlcnMgb2YgdGhpcyBjb2RlIG11c3QgdmVyaWZ5IGNvcnJlY3RuZXNzIGZvciB0aGVpciBhcHBsaWNhdGlvbi5cbiAgbGV0IHduID0gMDtcbiAgbGV0IHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIGxldCB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgaWYgKHkxIDw9IHkpIHtcbiAgICAgIGlmICh5MiA+IHkgJiYgKHgyIC0geDEpICogKHkgLSB5MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSA+IDApIHtcbiAgICAgICAgd24rKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHkyIDw9IHkgJiYgKHgyIC0geDEpICogKHkgLSB5MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSA8IDApIHtcbiAgICAgIHduLS07XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gd24gIT09IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NDb250YWluc1hZKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICB4LFxuICB5XG4pIHtcbiAgaWYgKGVuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghbGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbMF0sIHN0cmlkZSwgeCwgeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDEsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKFxuICAgICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBlbmRzW2kgLSAxXSwgZW5kc1tpXSwgc3RyaWRlLCB4LCB5KVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3NDb250YWluc1hZKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgeCxcbiAgeVxuKSB7XG4gIGlmIChlbmRzcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpZiAobGluZWFyUmluZ3NDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHgsIHkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ludGVyaW9ycG9pbnRcbiAqL1xuaW1wb3J0IHthc2NlbmRpbmd9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NDb250YWluc1hZfSBmcm9tICcuL2NvbnRhaW5zLmpzJztcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgcG9pbnQgdGhhdCBpcyBsaWtlbHkgdG8gbGllIGluIHRoZSBpbnRlcmlvciBvZiB0aGUgbGluZWFyIHJpbmdzLlxuICogSW5zcGlyZWQgYnkgSlRTJ3MgY29tLnZpdmlkc29sdXRpb25zLmp0cy5nZW9tLkdlb21ldHJ5I2dldEludGVyaW9yUG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q2VudGVycyBGbGF0IGNlbnRlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhdENlbnRlcnNPZmZzZXQgRmxhdCBjZW50ZXIgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBEZXN0aW5hdGlvbiBwb2ludCBhcyBYWU0gY29vcmRpbmF0ZSwgd2hlcmUgTSBpcyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgaG9yaXpvbnRhbCBpbnRlcnNlY3Rpb24gdGhhdCB0aGUgcG9pbnQgYmVsb25ncyB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyaW9yUG9pbnRPZkFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBmbGF0Q2VudGVycyxcbiAgZmxhdENlbnRlcnNPZmZzZXQsXG4gIGRlc3Rcbikge1xuICBsZXQgaSwgaWksIHgsIHgxLCB4MiwgeTEsIHkyO1xuICBjb25zdCB5ID0gZmxhdENlbnRlcnNbZmxhdENlbnRlcnNPZmZzZXQgKyAxXTtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIGhvcml6b250YWwgbGluZVxuICBmb3IgKGxldCByID0gMCwgcnIgPSBlbmRzLmxlbmd0aDsgciA8IHJyOyArK3IpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW3JdO1xuICAgIHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gICAgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBpZiAoKHkgPD0geTEgJiYgeTIgPD0geSkgfHwgKHkxIDw9IHkgJiYgeSA8PSB5MikpIHtcbiAgICAgICAgeCA9ICgoeSAtIHkxKSAvICh5MiAtIHkxKSkgKiAoeDIgLSB4MSkgKyB4MTtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKHgpO1xuICAgICAgfVxuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfVxuICB9XG4gIC8vIEZpbmQgdGhlIGxvbmdlc3Qgc2VnbWVudCBvZiB0aGUgaG9yaXpvbnRhbCBsaW5lIHRoYXQgaGFzIGl0cyBjZW50ZXIgcG9pbnRcbiAgLy8gaW5zaWRlIHRoZSBsaW5lYXIgcmluZy5cbiAgbGV0IHBvaW50WCA9IE5hTjtcbiAgbGV0IG1heFNlZ21lbnRMZW5ndGggPSAtSW5maW5pdHk7XG4gIGludGVyc2VjdGlvbnMuc29ydChhc2NlbmRpbmcpO1xuICB4MSA9IGludGVyc2VjdGlvbnNbMF07XG4gIGZvciAoaSA9IDEsIGlpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgeDIgPSBpbnRlcnNlY3Rpb25zW2ldO1xuICAgIGNvbnN0IHNlZ21lbnRMZW5ndGggPSBNYXRoLmFicyh4MiAtIHgxKTtcbiAgICBpZiAoc2VnbWVudExlbmd0aCA+IG1heFNlZ21lbnRMZW5ndGgpIHtcbiAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgaWYgKGxpbmVhclJpbmdzQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCB4LCB5KSkge1xuICAgICAgICBwb2ludFggPSB4O1xuICAgICAgICBtYXhTZWdtZW50TGVuZ3RoID0gc2VnbWVudExlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgfVxuICBpZiAoaXNOYU4ocG9pbnRYKSkge1xuICAgIC8vIFRoZXJlIGlzIG5vIGhvcml6b250YWwgbGluZSB0aGF0IGhhcyBpdHMgY2VudGVyIHBvaW50IGluc2lkZSB0aGUgbGluZWFyXG4gICAgLy8gcmluZy4gIFVzZSB0aGUgY2VudGVyIG9mIHRoZSB0aGUgbGluZWFyIHJpbmcncyBleHRlbnQuXG4gICAgcG9pbnRYID0gZmxhdENlbnRlcnNbZmxhdENlbnRlcnNPZmZzZXRdO1xuICB9XG4gIGlmIChkZXN0KSB7XG4gICAgZGVzdC5wdXNoKHBvaW50WCwgeSwgbWF4U2VnbWVudExlbmd0aCk7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgcmV0dXJuIFtwb2ludFgsIHksIG1heFNlZ21lbnRMZW5ndGhdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDZW50ZXJzIEZsYXQgY2VudGVycy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEludGVyaW9yIHBvaW50cyBhcyBYWU0gY29vcmRpbmF0ZXMsIHdoZXJlIE0gaXMgdGhlXG4gKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmlvclBvaW50c09mTXVsdGlBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIGZsYXRDZW50ZXJzXG4pIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBsZXQgaW50ZXJpb3JQb2ludHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpbnRlcmlvclBvaW50cyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kcyxcbiAgICAgIHN0cmlkZSxcbiAgICAgIGZsYXRDZW50ZXJzLFxuICAgICAgMiAqIGksXG4gICAgICBpbnRlcmlvclBvaW50c1xuICAgICk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBpbnRlcmlvclBvaW50cztcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3NlZ21lbnRzXG4gKi9cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBjYWxsYmFja2AgZm9yIGVhY2ggc2VnbWVudCBvZiB0aGUgZmxhdCBjb29yZGluYXRlc1xuICogYXJyYXkuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXRcbiAqIHZhbHVlIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgaW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogVH0gY2FsbGJhY2sgRnVuY3Rpb25cbiAqICAgICBjYWxsZWQgZm9yIGVhY2ggc2VnbWVudC5cbiAqIEByZXR1cm4ge1R8Ym9vbGVhbn0gVmFsdWUuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXQ7XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICByZXQgPSBjYWxsYmFjayhcbiAgICAgIGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQgLSBzdHJpZGUsIG9mZnNldCksXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdHJpZGUpXG4gICAgKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50XG4gKi9cbmltcG9ydCB7XG4gIGNvbnRhaW5zRXh0ZW50LFxuICBjcmVhdGVFbXB0eSxcbiAgZXh0ZW5kRmxhdENvb3JkaW5hdGVzLFxuICBpbnRlcnNlY3RzLFxuICBpbnRlcnNlY3RzU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Zm9yRWFjaCBhcyBmb3JFYWNoU2VnbWVudH0gZnJvbSAnLi9zZWdtZW50cy5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdDb250YWluc0V4dGVudCwgbGluZWFyUmluZ0NvbnRhaW5zWFl9IGZyb20gJy4vY29udGFpbnMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBleHRlbnRcbikge1xuICBjb25zdCBjb29yZGluYXRlc0V4dGVudCA9IGV4dGVuZEZsYXRDb29yZGluYXRlcyhcbiAgICBjcmVhdGVFbXB0eSgpLFxuICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICBvZmZzZXQsXG4gICAgZW5kLFxuICAgIHN0cmlkZVxuICApO1xuICBpZiAoIWludGVyc2VjdHMoZXh0ZW50LCBjb29yZGluYXRlc0V4dGVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvbnRhaW5zRXh0ZW50KGV4dGVudCwgY29vcmRpbmF0ZXNFeHRlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVzRXh0ZW50WzBdID49IGV4dGVudFswXSAmJiBjb29yZGluYXRlc0V4dGVudFsyXSA8PSBleHRlbnRbMl0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZXNFeHRlbnRbMV0gPj0gZXh0ZW50WzFdICYmIGNvb3JkaW5hdGVzRXh0ZW50WzNdIDw9IGV4dGVudFszXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmb3JFYWNoU2VnbWVudChcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgb2Zmc2V0LFxuICAgIGVuZCxcbiAgICBzdHJpZGUsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50MSBTdGFydCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQyIEVuZCBwb2ludC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHNlZ21lbnQgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LFxuICAgICAqICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIpIHtcbiAgICAgIHJldHVybiBpbnRlcnNlY3RzU2VnbWVudChleHRlbnQsIHBvaW50MSwgcG9pbnQyKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIGV4dGVudFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChcbiAgICAgIGludGVyc2VjdHNMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIGV4dGVudClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2ldO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVhclJpbmcoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgZXh0ZW50XG4pIHtcbiAgaWYgKGludGVyc2VjdHNMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBsaW5lYXJSaW5nQ29udGFpbnNYWShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIGV4dGVudFswXSxcbiAgICAgIGV4dGVudFsxXVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgZXh0ZW50WzBdLFxuICAgICAgZXh0ZW50WzNdXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbMV1cbiAgICApXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBsaW5lYXJSaW5nQ29udGFpbnNYWShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIGV4dGVudFsyXSxcbiAgICAgIGV4dGVudFszXVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBleHRlbnRcbikge1xuICBpZiAoIWludGVyc2VjdHNMaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzWzBdLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDEsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKFxuICAgICAgbGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50KFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIGVuZHNbaSAtIDFdLFxuICAgICAgICBlbmRzW2ldLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGV4dGVudFxuICAgICAgKVxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICAhaW50ZXJzZWN0c0xpbmVTdHJpbmcoXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIGVuZHNbaSAtIDFdLFxuICAgICAgICAgIGVuZHNbaV0sXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIGV4dGVudFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVhclJpbmdNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgZXh0ZW50XG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpZiAoXG4gICAgICBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIGV4dGVudClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvcmV2ZXJzZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICB3aGlsZSAob2Zmc2V0IDwgZW5kIC0gc3RyaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgY29uc3QgdG1wID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldO1xuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIGldO1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIGldID0gdG1wO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIGVuZCAtPSBzdHJpZGU7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L29yaWVudFxuICovXG5pbXBvcnQge2Nvb3JkaW5hdGVzIGFzIHJldmVyc2VDb29yZGluYXRlc30gZnJvbSAnLi9yZXZlcnNlLmpzJztcblxuLyoqXG4gKiBJcyB0aGUgbGluZWFyIHJpbmcgb3JpZW50ZWQgY2xvY2t3aXNlIGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2l0aCBhIGJvdHRvbS1sZWZ0XG4gKiBjb29yZGluYXRlIG9yaWdpbj8gRm9yIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2l0aCBhIHRvcC1sZWZ0IGNvb3JkaW5hdGUgb3JpZ2luLFxuICogdGhlIHJpbmcncyBvcmllbnRhdGlvbiBpcyBjbG9ja3dpc2Ugd2hlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IElzIGNsb2Nrd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzExNjU2NDcvY2xvY2t3aXNlLW1ldGhvZCMxMTY1OTQzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9PU0dlby9nZGFsL2Jsb2IvbWFzdGVyL2dkYWwvb2dyL29ncmxpbmVhcnJpbmcuY3BwXG4gIGxldCBlZGdlID0gMDtcbiAgbGV0IHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIGxldCB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgZWRnZSArPSAoeDIgLSB4MSkgKiAoeTIgKyB5MSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBlZGdlID09PSAwID8gdW5kZWZpbmVkIDogZWRnZSA+IDA7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBsaW5lYXIgcmluZ3MgYXJlIG9yaWVudGVkLiAgQnkgZGVmYXVsdCwgbGVmdC1oYW5kIG9yaWVudGF0aW9uXG4gKiBpcyB0ZXN0ZWQgKGZpcnN0IHJpbmcgbXVzdCBiZSBjbG9ja3dpc2UsIHJlbWFpbmluZyByaW5ncyBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKiBUbyB0ZXN0IGZvciByaWdodC1oYW5kIG9yaWVudGF0aW9uLCB1c2UgdGhlIGByaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEFycmF5IG9mIGVuZCBpbmRleGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyaWdodF0gVGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvblxuICogICAgIChjb3VudGVyLWNsb2Nrd2lzZSBleHRlcmlvciByaW5nIGFuZCBjbG9ja3dpc2UgaW50ZXJpb3IgcmluZ3MpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmluZ3MgYXJlIGNvcnJlY3RseSBvcmllbnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzQXJlT3JpZW50ZWQoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIHJpZ2h0XG4pIHtcbiAgcmlnaHQgPSByaWdodCAhPT0gdW5kZWZpbmVkID8gcmlnaHQgOiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBjb25zdCBpc0Nsb2Nrd2lzZSA9IGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZVxuICAgICk7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGlmICgocmlnaHQgJiYgaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGxpbmVhciByaW5ncyBhcmUgb3JpZW50ZWQuICBCeSBkZWZhdWx0LCBsZWZ0LWhhbmQgb3JpZW50YXRpb25cbiAqIGlzIHRlc3RlZCAoZmlyc3QgcmluZyBtdXN0IGJlIGNsb2Nrd2lzZSwgcmVtYWluaW5nIHJpbmdzIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqIFRvIHRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb24sIHVzZSB0aGUgYHJpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBBcnJheSBvZiBhcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3NBcmVPcmllbnRlZChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIHJpZ2h0XG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpZiAoIWxpbmVhclJpbmdzQXJlT3JpZW50ZWQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgcmlnaHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlbmRzLmxlbmd0aCkge1xuICAgICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBPcmllbnQgY29vcmRpbmF0ZXMgaW4gYSBmbGF0IGFycmF5IG9mIGxpbmVhciByaW5ncy4gIEJ5IGRlZmF1bHQsIHJpbmdzXG4gKiBhcmUgb3JpZW50ZWQgZm9sbG93aW5nIHRoZSBsZWZ0LWhhbmQgcnVsZSAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmRcbiAqIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuICBUbyBvcmllbnQgYWNjb3JkaW5nIHRvIHRoZVxuICogcmlnaHQtaGFuZCBydWxlLCB1c2UgdGhlIGByaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0XSBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICByaWdodFxuKSB7XG4gIHJpZ2h0ID0gcmlnaHQgIT09IHVuZGVmaW5lZCA/IHJpZ2h0IDogZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgY29uc3QgaXNDbG9ja3dpc2UgPSBsaW5lYXJSaW5nSXNDbG9ja3dpc2UoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGVcbiAgICApO1xuICAgIGNvbnN0IHJldmVyc2UgPVxuICAgICAgaSA9PT0gMFxuICAgICAgICA/IChyaWdodCAmJiBpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiAhaXNDbG9ja3dpc2UpXG4gICAgICAgIDogKHJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiBpc0Nsb2Nrd2lzZSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldmVyc2VDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBPcmllbnQgY29vcmRpbmF0ZXMgaW4gYSBmbGF0IGFycmF5IG9mIGxpbmVhciByaW5ncy4gIEJ5IGRlZmF1bHQsIHJpbmdzXG4gKiBhcmUgb3JpZW50ZWQgZm9sbG93aW5nIHRoZSBsZWZ0LWhhbmQgcnVsZSAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmRcbiAqIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuICBUbyBvcmllbnQgYWNjb3JkaW5nIHRvIHRoZVxuICogcmlnaHQtaGFuZCBydWxlLCB1c2UgdGhlIGByaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgQXJyYXkgb2YgYXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0XSBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICByaWdodFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBvZmZzZXQgPSBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZHNzW2ldLFxuICAgICAgc3RyaWRlLFxuICAgICAgcmlnaHRcbiAgICApO1xuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgdHdvLWRpbWVuc2lvbmFsIGVuZHNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgTGluZWFyIHJpbmcgZW5kIGluZGV4ZXNcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUd28gZGltZW5zaW9uYWwgZW5kc3MgYXJyYXkgdGhhdCBjYW5cbiAqIGJlIHVzZWQgdG8gY29uc3RydWN0IGEgTXVsdGlQb2x5Z29uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlRW5kcyhmbGF0Q29vcmRpbmF0ZXMsIGVuZHMpIHtcbiAgY29uc3QgZW5kc3MgPSBbXTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGxldCBwcmV2RW5kSW5kZXggPSAwO1xuICBsZXQgc3RhcnRPcmllbnRhdGlvbjtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICAvLyBjbGFzc2lmaWVzIGFuIGFycmF5IG9mIHJpbmdzIGludG8gcG9seWdvbnMgd2l0aCBvdXRlciByaW5ncyBhbmQgaG9sZXNcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCAyKTtcbiAgICBpZiAoc3RhcnRPcmllbnRhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGFydE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgfVxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gc3RhcnRPcmllbnRhdGlvbikge1xuICAgICAgZW5kc3MucHVzaChlbmRzLnNsaWNlKHByZXZFbmRJbmRleCwgaSArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZHNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGVuZHNzW2VuZHNzLmxlbmd0aCAtIDFdLnB1c2goZW5kc1twcmV2RW5kSW5kZXhdKTtcbiAgICB9XG4gICAgcHJldkVuZEluZGV4ID0gaSArIDE7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBlbmRzcztcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2x5Z29uXG4gKi9cbmltcG9ydCBMaW5lYXJSaW5nIGZyb20gJy4vTGluZWFyUmluZy5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2FycmF5TWF4U3F1YXJlZERlbHRhLCBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludH0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFksIGdldENlbnRlciwgaXNFbXB0eX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXl9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2dldEludGVyaW9yUG9pbnRPZkFycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NBcmVPcmllbnRlZCwgb3JpZW50TGluZWFyUmluZ3N9IGZyb20gJy4vZmxhdC9vcmllbnQuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5ncyBhcyBsaW5lYXJSaW5nc0FyZWF9IGZyb20gJy4vZmxhdC9hcmVhLmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NDb250YWluc1hZfSBmcm9tICcuL2ZsYXQvY29udGFpbnMuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtxdWFudGl6ZUFycmF5fSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuaW1wb3J0IHtvZmZzZXQgYXMgc3BoZXJlT2Zmc2V0fSBmcm9tICcuLi9zcGhlcmUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFBvbHlnb24gZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBQb2x5Z29uIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHshQXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj58IUFycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXG4gICAqICAgICBBcnJheSBvZiBsaW5lYXIgcmluZ3MgdGhhdCBkZWZpbmUgdGhlIHBvbHlnb24uIFRoZSBmaXJzdCBsaW5lYXIgcmluZyBvZiB0aGVcbiAgICogICAgIGFycmF5IGRlZmluZXMgdGhlIG91dGVyLWJvdW5kYXJ5IG9yIHN1cmZhY2Ugb2YgdGhlIHBvbHlnb24uIEVhY2ggc3Vic2VxdWVudFxuICAgKiAgICAgbGluZWFyIHJpbmcgZGVmaW5lcyBhIGhvbGUgaW4gdGhlIHN1cmZhY2Ugb2YgdGhlIHBvbHlnb24uIEEgbGluZWFyIHJpbmcgaXNcbiAgICogICAgIGFuIGFycmF5IG9mIHZlcnRpY2VzJyBjb29yZGluYXRlcyB3aGVyZSB0aGUgZmlyc3QgY29vcmRpbmF0ZSBhbmQgdGhlIGxhc3QgYXJlXG4gICAqICAgICBlcXVpdmFsZW50LiAoRm9yIGludGVybmFsIHVzZSwgZmxhdCBjb29yZGluYXRlcyBpbiBjb21iaW5hdGlvbiB3aXRoXG4gICAqICAgICBgbGF5b3V0YCBhbmQgYGVuZHNgIGFyZSBhbHNvIGFjY2VwdGVkLilcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2VuZHNdIEVuZHMgKGZvciBpbnRlcm5hbCB1c2Ugd2l0aCBmbGF0IGNvb3JkaW5hdGVzKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBsYXlvdXQsIGVuZHMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVuZHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICBpZiAobGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgZW5kcykge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpXG4gICAgICApO1xuICAgICAgdGhpcy5lbmRzXyA9IGVuZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59ICovIChcbiAgICAgICAgICBjb29yZGluYXRlc1xuICAgICAgICApLFxuICAgICAgICBsYXlvdXRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIGxpbmVhciByaW5nIHRvIHRoaXMgcG9seWdvbi5cbiAgICogQHBhcmFtIHtMaW5lYXJSaW5nfSBsaW5lYXJSaW5nIExpbmVhciByaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBlbmRMaW5lYXJSaW5nKGxpbmVhclJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGxpbmVhclJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBsaW5lYXJSaW5nLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICB9XG4gICAgdGhpcy5lbmRzXy5wdXNoKHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshUG9seWdvbn0gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbihcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksXG4gICAgICB0aGlzLmxheW91dCxcbiAgICAgIHRoaXMuZW5kc18uc2xpY2UoKVxuICAgICk7XG4gICAgcG9seWdvbi5hcHBseVByb3BlcnRpZXModGhpcyk7XG4gICAgcmV0dXJuIHBvbHlnb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoXG4gICAgICAgIGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5lbmRzXyxcbiAgICAgICAgICB0aGlzLnN0cmlkZSxcbiAgICAgICAgICAwXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXyxcbiAgICAgIHRydWUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICAgKi9cbiAgY29udGFpbnNYWSh4LCB5KSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzQ29udGFpbnNYWShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICB4LFxuICAgICAgeVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhcmVhIG9mIHRoZSBwb2x5Z29uIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBcmVhKCkge1xuICAgIHJldHVybiBsaW5lYXJSaW5nc0FyZWEoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgYXJyYXkgZm9yIHRoaXMgZ2VvbWV0cnkuICBUaGlzIGFycmF5IGhhcyB0aGUgc3RydWN0dXJlXG4gICAqIG9mIGEgR2VvSlNPTiBjb29yZGluYXRlIGFycmF5IGZvciBwb2x5Z29ucy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIE9yaWVudCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0LWhhbmRcbiAgICogICAgIHJ1bGUgKGNvdW50ZXItY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBJZiBgZmFsc2VgLCBjb29yZGluYXRlcyB3aWxsIGJlIG9yaWVudGVkIGFjY29yZGluZyB0byB0aGUgbGVmdC1oYW5kIHJ1bGVcbiAgICogICAgIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgQnkgZGVmYXVsdCwgY29vcmRpbmF0ZSBvcmllbnRhdGlvbiB3aWxsIGRlcGVuZCBvbiBob3cgdGhlIGdlb21ldHJ5IHdhc1xuICAgKiAgICAgY29uc3RydWN0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZXMocmlnaHQpIHtcbiAgICBsZXQgZmxhdENvb3JkaW5hdGVzO1xuICAgIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIG9yaWVudExpbmVhclJpbmdzKGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlc0FycmF5KGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEVuZHMuXG4gICAqL1xuICBnZXRFbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEludGVyaW9yIHBvaW50LlxuICAgKi9cbiAgZ2V0RmxhdEludGVyaW9yUG9pbnQoKSB7XG4gICAgaWYgKHRoaXMuZmxhdEludGVyaW9yUG9pbnRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICBjb25zdCBmbGF0Q2VudGVyID0gZ2V0Q2VudGVyKHRoaXMuZ2V0RXh0ZW50KCkpO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludF8gPSBnZXRJbnRlcmlvclBvaW50T2ZBcnJheShcbiAgICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmVuZHNfLFxuICAgICAgICB0aGlzLnN0cmlkZSxcbiAgICAgICAgZmxhdENlbnRlcixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludF9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbnRlcmlvciBwb2ludCBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7UG9pbnR9IEludGVyaW9yIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICAgKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEludGVyaW9yUG9pbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50KCksICdYWU0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiByaW5ncyBvZiB0aGUgcG9seWdvbiwgIHRoaXMgaW5jbHVkZXMgdGhlIGV4dGVyaW9yXG4gICAqIHJpbmcgYW5kIGFueSBpbnRlcmlvciByaW5ncy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgcmluZ3MuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVhclJpbmdDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBOdGggbGluZWFyIHJpbmcgb2YgdGhlIHBvbHlnb24gZ2VvbWV0cnkuIFJldHVybiBgbnVsbGAgaWYgdGhlXG4gICAqIGdpdmVuIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICogVGhlIGV4dGVyaW9yIGxpbmVhciByaW5nIGlzIGF2YWlsYWJsZSBhdCBpbmRleCBgMGAgYW5kIHRoZSBpbnRlcmlvciByaW5nc1xuICAgKiBhdCBpbmRleCBgMWAgYW5kIGJleW9uZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtMaW5lYXJSaW5nfG51bGx9IExpbmVhciByaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lYXJSaW5nKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmVuZHNfLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgICBpbmRleCA9PT0gMCA/IDAgOiB0aGlzLmVuZHNfW2luZGV4IC0gMV0sXG4gICAgICAgIHRoaXMuZW5kc19baW5kZXhdXG4gICAgICApLFxuICAgICAgdGhpcy5sYXlvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGluZWFyIHJpbmdzIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxMaW5lYXJSaW5nPn0gTGluZWFyIHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lYXJSaW5ncygpIHtcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBlbmRzID0gdGhpcy5lbmRzXztcbiAgICBjb25zdCBsaW5lYXJSaW5ncyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICAgIGNvbnN0IGxpbmVhclJpbmcgPSBuZXcgTGluZWFyUmluZyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSxcbiAgICAgICAgbGF5b3V0XG4gICAgICApO1xuICAgICAgbGluZWFyUmluZ3MucHVzaChsaW5lYXJSaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWVudGVkIGZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpIHtcbiAgICBpZiAodGhpcy5vcmllbnRlZFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgICAgaWYgKGxpbmVhclJpbmdzQXJlT3JpZW50ZWQoZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSkpIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXy5sZW5ndGggPSBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuZW5kc18sXG4gICAgICAgICAgdGhpcy5zdHJpZGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovICh0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1BvbHlnb259IFNpbXBsaWZpZWQgUG9seWdvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBxdWFudGl6ZUFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgTWF0aC5zcXJ0KHNxdWFyZWRUb2xlcmFuY2UpLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBzaW1wbGlmaWVkRW5kc1xuICAgICk7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsICdYWScsIHNpbXBsaWZpZWRFbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnUG9seWdvbic7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBleHRlbnRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBjb29yZGluYXRlcyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5lbmRzX1xuICAgICk7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZW5kcy5sZW5ndGggPT09IDAgPyAwIDogZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbHlnb247XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFwcHJveGltYXRpb24gb2YgYSBjaXJjbGUgb24gdGhlIHN1cmZhY2Ugb2YgYSBzcGhlcmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoYFtsb24sIGxhdF1gIGluIGRlZ3JlZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgZ3JlYXQtY2lyY2xlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0b1xuICogICAgIHRoZSBwb2x5Z29uIHZlcnRpY2VzIGluIG1ldGVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gT3B0aW9uYWwgbnVtYmVyIG9mIHZlcnRpY2VzIGZvciB0aGUgcmVzdWx0aW5nXG4gKiAgICAgcG9seWdvbi4gRGVmYXVsdCBpcyBgMzJgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzcGhlcmVSYWRpdXNdIE9wdGlvbmFsIHJhZGl1cyBmb3IgdGhlIHNwaGVyZSAoZGVmYXVsdHMgdG9cbiAqICAgICB0aGUgRWFydGgncyBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkKS5cbiAqIEByZXR1cm4ge1BvbHlnb259IFRoZSBcImNpcmN1bGFyXCIgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmN1bGFyKGNlbnRlciwgcmFkaXVzLCBuLCBzcGhlcmVSYWRpdXMpIHtcbiAgbiA9IG4gPyBuIDogMzI7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZXh0ZW5kKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgc3BoZXJlT2Zmc2V0KGNlbnRlciwgcmFkaXVzLCAoMiAqIE1hdGguUEkgKiBpKSAvIG4sIHNwaGVyZVJhZGl1cylcbiAgICApO1xuICB9XG4gIGZsYXRDb29yZGluYXRlcy5wdXNoKGZsYXRDb29yZGluYXRlc1swXSwgZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgJ1hZJywgW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwb2x5Z29uIGZyb20gYW4gZXh0ZW50LiBUaGUgbGF5b3V0IHVzZWQgaXMgYFhZYC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBUaGUgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FeHRlbnQoZXh0ZW50KSB7XG4gIGlmIChpc0VtcHR5KGV4dGVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcG9seWdvbiBmcm9tIGVtcHR5IGV4dGVudCcpO1xuICB9XG4gIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gIGNvbnN0IG1pblkgPSBleHRlbnRbMV07XG4gIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IFtcbiAgICBtaW5YLFxuICAgIG1pblksXG4gICAgbWluWCxcbiAgICBtYXhZLFxuICAgIG1heFgsXG4gICAgbWF4WSxcbiAgICBtYXhYLFxuICAgIG1pblksXG4gICAgbWluWCxcbiAgICBtaW5ZLFxuICBdO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCAnWFknLCBbZmxhdENvb3JkaW5hdGVzLmxlbmd0aF0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgcG9seWdvbiBmcm9tIGEgY2lyY2xlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBjaXJjbGUgQ2lyY2xlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWRlc10gTnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBEZWZhdWx0IGlzIDMyLlxuICogQHBhcmFtIHtudW1iZXJ9IFthbmdsZV0gU3RhcnQgYW5nbGUgZm9yIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gaW5cbiAqICAgICBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zLiAwIG1lYW5zIEVhc3QuIERlZmF1bHQgaXMgMC5cbiAqIEByZXR1cm4ge1BvbHlnb259IFBvbHlnb24gZ2VvbWV0cnkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ2lyY2xlKGNpcmNsZSwgc2lkZXMsIGFuZ2xlKSB7XG4gIHNpZGVzID0gc2lkZXMgPyBzaWRlcyA6IDMyO1xuICBjb25zdCBzdHJpZGUgPSBjaXJjbGUuZ2V0U3RyaWRlKCk7XG4gIGNvbnN0IGxheW91dCA9IGNpcmNsZS5nZXRMYXlvdXQoKTtcbiAgY29uc3QgY2VudGVyID0gY2lyY2xlLmdldENlbnRlcigpO1xuICBjb25zdCBhcnJheUxlbmd0aCA9IHN0cmlkZSAqIChzaWRlcyArIDEpO1xuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoYXJyYXlMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyBpICs9IHN0cmlkZSkge1xuICAgIGZsYXRDb29yZGluYXRlc1tpXSA9IDA7XG4gICAgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDI7IGogPCBzdHJpZGU7IGorKykge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2kgKyBqXSA9IGNlbnRlcltqXTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgbGF5b3V0LCBlbmRzKTtcbiAgbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCBjaXJjbGUuZ2V0UmFkaXVzKCksIGFuZ2xlKTtcbiAgcmV0dXJuIHBvbHlnb247XG59XG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb29yZGluYXRlcyBvZiBhIHBvbHlnb24gdG8gbWFrZSBpdCBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvbiBQb2x5Z29uIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FuZ2xlXSBTdGFydCBhbmdsZSBmb3IgdGhlIGZpcnN0IHZlcnRleCBvZiB0aGUgcG9seWdvbiBpblxuICogICAgIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMuIDAgbWVhbnMgRWFzdC4gRGVmYXVsdCBpcyAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCByYWRpdXMsIGFuZ2xlKSB7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gIGNvbnN0IHN0cmlkZSA9IHBvbHlnb24uZ2V0U3RyaWRlKCk7XG4gIGNvbnN0IHNpZGVzID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHN0cmlkZSAtIDE7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBhbmdsZSA/IGFuZ2xlIDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2lkZXM7ICsraSkge1xuICAgIGNvbnN0IG9mZnNldCA9IGkgKiBzdHJpZGU7XG4gICAgY29uc3QgYW5nbGUgPSBzdGFydEFuZ2xlICsgKG1vZHVsbyhpLCBzaWRlcykgKiAyICogTWF0aC5QSSkgLyBzaWRlcztcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSA9IGNlbnRlclswXSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gPSBjZW50ZXJbMV0gKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gIH1cbiAgcG9seWdvbi5jaGFuZ2VkKCk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IFZpZXdQcm9wZXJ0eSBmcm9tICcuL1ZpZXdQcm9wZXJ0eS5qcyc7XG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL3RpbGVncmlkL2NvbW1vbi5qcyc7XG5pbXBvcnQge1xuICBNRVRFUlNfUEVSX1VOSVQsXG4gIGNyZWF0ZVByb2plY3Rpb24sXG4gIGRpc2FibGVDb29yZGluYXRlV2FybmluZyxcbiAgZnJvbVVzZXJDb29yZGluYXRlLFxuICBmcm9tVXNlckV4dGVudCxcbiAgZ2V0VXNlclByb2plY3Rpb24sXG4gIHRvVXNlckNvb3JkaW5hdGUsXG4gIHRvVXNlckV4dGVudCxcbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYWRkIGFzIGFkZENvb3JkaW5hdGUsXG4gIGVxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsLFxuICBlcXVhbHMsXG4gIHJvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlLFxufSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge25vbmUgYXMgY2VudGVyTm9uZSwgY3JlYXRlRXh0ZW50fSBmcm9tICcuL2NlbnRlcmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IHtjbGFtcCwgbW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTWluTWF4UmVzb2x1dGlvbixcbiAgY3JlYXRlU25hcFRvUG93ZXIsXG4gIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zLFxufSBmcm9tICcuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVNuYXBUb04sXG4gIGNyZWF0ZVNuYXBUb1plcm8sXG4gIGRpc2FibGUsXG4gIG5vbmUgYXMgcm90YXRpb25Ob25lLFxufSBmcm9tICcuL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQge2Vhc2VPdXQsIGluQW5kT3V0fSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQge1xuICBnZXRDZW50ZXIsXG4gIGdldEZvclZpZXdBbmRTaXplLFxuICBnZXRIZWlnaHQsXG4gIGdldFdpZHRoLFxuICBpc0VtcHR5LFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7ZnJvbUV4dGVudCBhcyBwb2x5Z29uRnJvbUV4dGVudH0gZnJvbSAnLi9nZW9tL1BvbHlnb24uanMnO1xuXG4vKipcbiAqIEFuIGFuaW1hdGlvbiBjb25maWd1cmF0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbc291cmNlQ2VudGVyXSBTb3VyY2UgY2VudGVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW3RhcmdldENlbnRlcl0gVGFyZ2V0IGNlbnRlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUmVzb2x1dGlvbl0gU291cmNlIHJlc29sdXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldFJlc29sdXRpb25dIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSb3RhdGlvbl0gU291cmNlIHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRSb3RhdGlvbl0gVGFyZ2V0IHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gQW5jaG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IFN0YXJ0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb21wbGV0ZSBDb21wbGV0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IGVhc2luZyBFYXNpbmcuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IGNhbGxiYWNrIENhbGxiYWNrLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RyYWludHNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jZW50ZXJjb25zdHJhaW50LmpzXCIpLlR5cGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3JvdGF0aW9uY29uc3RyYWludC5qc1wiKS5UeXBlfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpdE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGJveCB0b1xuICogZml0IHRoZSBleHRlbnQgaW50by4gRGVmYXVsdHMgdG8gdGhlIHNpemUgb2YgdGhlIG1hcCB0aGUgdmlldyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiBJZiBubyBtYXAgb3IgbXVsdGlwbGUgbWFwcyBhcmUgY29ubmVjdGVkIHRvIHRoZSB2aWV3LCBwcm92aWRlIHRoZSBkZXNpcmVkIGJveCBzaXplXG4gKiAoZS5nLiBgbWFwLmdldFNpemUoKWApLlxuICogQHByb3BlcnR5IHshQXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIChpbiBwaXhlbHMpIHRvIGJlXG4gKiBjbGVhcmVkIGluc2lkZSB0aGUgdmlldy4gVmFsdWVzIGluIHRoZSBhcnJheSBhcmUgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0XG4gKiBwYWRkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbmVhcmVzdD1mYWxzZV0gSWYgdGhlIHZpZXcgYGNvbnN0cmFpblJlc29sdXRpb25gIG9wdGlvbiBpcyBgdHJ1ZWAsXG4gKiBnZXQgdGhlIG5lYXJlc3QgZXh0ZW50IGluc3RlYWQgb2YgdGhlIGNsb3Nlc3QgdGhhdCBhY3R1YWxseSBmaXRzIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uPTBdIE1pbmltdW0gcmVzb2x1dGlvbiB0aGF0IHdlIHpvb20gdG8uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCB0aGF0IHdlIHpvb20gdG8uIElmXG4gKiBgbWluUmVzb2x1dGlvbmAgaXMgZ2l2ZW4sIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiB0byB0aGUgdGFyZ2V0IGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZCBkdXJpbmdcbiAqIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IFtjYWxsYmFja10gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgaW5cbiAqIGl0cyBmaW5hbCBwb3NpdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYHRydWVgIGlmIHRoZSBhbmltYXRpb25cbiAqIHNlcmllcyBjb21wbGV0ZWQgb24gaXRzIG93biBvciBgZmFsc2VgIGlmIGl0IHdhcyBjYW5jZWxsZWQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGluaXRpYWwgY2VudGVyIGZvclxuICogdGhlIHZpZXcuIElmIGEgdXNlciBwcm9qZWN0aW9uIGlzIG5vdCBzZXQsIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdGhlIGNlbnRlciBpc1xuICogc3BlY2lmaWVkIHdpdGggdGhlIGBwcm9qZWN0aW9uYCBvcHRpb24uIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmUgZmV0Y2hlZCBpZiB0aGlzXG4gKiBpcyBub3Qgc2V0LCBidXQgdGhlIGNlbnRlciBjYW4gYmUgc2V0IGxhdGVyIHdpdGgge0BsaW5rICNzZXRDZW50ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufG51bWJlcn0gW2NvbnN0cmFpblJvdGF0aW9uPXRydWVdIFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKiBgZmFsc2VgIG1lYW5zIG5vIGNvbnN0cmFpbnQuIGB0cnVlYCBtZWFucyBubyBjb25zdHJhaW50LCBidXQgc25hcCB0byB6ZXJvXG4gKiBuZWFyIHplcm8uIEEgbnVtYmVyIGNvbnN0cmFpbnMgdGhlIHJvdGF0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHZhbHVlcy4gRm9yXG4gKiBleGFtcGxlLCBgNGAgd2lsbCBjb25zdHJhaW4gdGhlIHJvdGF0aW9uIHRvIDAsIDkwLCAxODAsIGFuZCAyNzAgZGVncmVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZVJvdGF0aW9uPXRydWVdIEVuYWJsZSByb3RhdGlvbi5cbiAqIElmIGBmYWxzZWAsIGEgcm90YXRpb24gY29uc3RyYWludCB0aGF0IGFsd2F5cyBzZXRzIHRoZSByb3RhdGlvbiB0byB6ZXJvIGlzXG4gKiB1c2VkLiBUaGUgYGNvbnN0cmFpblJvdGF0aW9uYCBvcHRpb24gaGFzIG5vIGVmZmVjdCBpZiBgZW5hYmxlUm90YXRpb25gIGlzXG4gKiBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBleHRlbnQgdGhhdCBjb25zdHJhaW5zIHRoZVxuICogdmlldywgaW4gb3RoZXIgd29yZHMsIG5vdGhpbmcgb3V0c2lkZSBvZiB0aGlzIGV4dGVudCBjYW4gYmUgdmlzaWJsZSBvbiB0aGUgbWFwLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluT25seUNlbnRlcj1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIG9ubHkgYXBwbHkgdG8gdGhlIHZpZXcgY2VudGVyIGFuZCBub3QgdGhlIHdob2xlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Ntb290aEV4dGVudENvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIGJlIGFwcGxpZWQgc21vb3RobHksIGkuZS4gYWxsb3cgdGhlIHZpZXcgdG8gZ28gc2xpZ2h0bHkgb3V0c2lkZVxuICogb2YgdGhlIGdpdmVuIGBleHRlbnRgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1pblJlc29sdXRpb25gIChvclxuICogYG1heFpvb21gKSBhbmQgYHpvb21GYWN0b3JgLiBJZiB1bnNwZWNpZmllZCBpdCBpcyBjYWxjdWxhdGVkIGluIHN1Y2ggYSB3YXlcbiAqIHRoYXQgdGhlIHByb2plY3Rpb24ncyB2YWxpZGl0eSBleHRlbnQgZml0cyBpbiBhIDI1NngyNTYgcHggdGlsZS4gSWYgdGhlXG4gKiBwcm9qZWN0aW9uIGlzIFNwaGVyaWNhbCBNZXJjYXRvciAodGhlIGRlZmF1bHQpIHRoZW4gYG1heFJlc29sdXRpb25gIGRlZmF1bHRzXG4gKiB0byBgNDAwNzUwMTYuNjg1NTc4NDkgLyAyNTYgPSAxNTY1NDMuMDMzOTI4MDQwOTdgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiAgSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtYXhSZXNvbHV0aW9uYCAob3JcbiAqIGBtaW5ab29tYCkgYW5kIGB6b29tRmFjdG9yYC4gIElmIHVuc3BlY2lmaWVkIGl0IGlzIGNhbGN1bGF0ZWQgYXNzdW1pbmcgMjlcbiAqIHpvb20gbGV2ZWxzICh3aXRoIGEgZmFjdG9yIG9mIDIpLiBJZiB0aGUgcHJvamVjdGlvbiBpcyBTcGhlcmljYWwgTWVyY2F0b3JcbiAqICh0aGUgZGVmYXVsdCkgdGhlbiBgbWluUmVzb2x1dGlvbmAgZGVmYXVsdHMgdG9cbiAqIGA0MDA3NTAxNi42ODU1Nzg0OSAvIDI1NiAvIE1hdGgucG93KDIsIDI4KSA9IDAuMDAwNTgzMTY4MjQ1NTgzOTI1M2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MjhdIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWluWm9vbWAgKG9yXG4gKiBgbWF4UmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1pblJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1heFpvb21gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWF4Wm9vbWAgKG9yXG4gKiBgbWluUmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1heFJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1pblpvb21gLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlXb3JsZD1mYWxzZV0gSWYgYGZhbHNlYCB0aGUgdmlldyBpcyBjb25zdHJhaW5lZCBzb1xuICogb25seSBvbmUgd29ybGQgaXMgdmlzaWJsZSwgYW5kIHlvdSBjYW5ub3QgcGFuIG9mZiB0aGUgZWRnZS4gIElmIGB0cnVlYCB0aGUgbWFwXG4gKiBtYXkgc2hvdyBtdWx0aXBsZSB3b3JsZHMgYXQgbG93IHpvb20gbGV2ZWxzLiAgT25seSB1c2VkIGlmIHRoZSBgcHJvamVjdGlvbmAgaXNcbiAqIGdsb2JhbC4gIE5vdGUgdGhhdCBpZiBgZXh0ZW50YCBpcyBhbHNvIHByb3ZpZGVkIGl0IGlzIGdpdmVuIHByZWNlZGVuY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGFsd2F5c1xuICogYW5pbWF0ZSB0byB0aGUgY2xvc2VzdCB6b29tIGxldmVsIGFmdGVyIGFuIGludGVyYWN0aW9uOyBmYWxzZSBtZWFuc1xuICogaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbGxvd2VkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIHJlc29sdXRpb25cbiAqIG1pbi9tYXggdmFsdWVzIHdpbGwgYmUgYXBwbGllZCBzbW9vdGhseSwgaS4gZS4gYWxsb3cgdGhlIHZpZXcgdG8gZXhjZWVkIHNsaWdodGx5XG4gKiB0aGUgZ2l2ZW4gcmVzb2x1dGlvbiBvciB6b29tIGJvdW5kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dGdWxsRXh0ZW50PWZhbHNlXSBBbGxvdyB0aGUgdmlldyB0byBiZSB6b29tZWQgb3V0IHRvXG4gKiBzaG93IHRoZSBmdWxsIGNvbmZpZ3VyZWQgZXh0ZW50LiBCeSBkZWZhdWx0LCB3aGVuIGEgdmlldyBpcyBjb25maWd1cmVkIHdpdGggYW5cbiAqIGV4dGVudCwgdXNlcnMgd2lsbCBub3QgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGUgdmlld3BvcnQgZXhjZWVkcyB0aGUgZXh0ZW50IGluXG4gKiBlaXRoZXIgZGltZW5zaW9uLiBUaGlzIG1lYW5zIHRoZSBmdWxsIGV4dGVudCBtYXkgbm90IGJlIHZpc2libGUgaWYgdGhlIHZpZXdwb3J0XG4gKiBpcyB0YWxsZXIgb3Igd2lkZXIgdGhhbiB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudC4gSWZcbiAqIHNob3dGdWxsRXh0ZW50IGlzIHRydWUsIHRoZSB1c2VyIHdpbGwgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGF0IHRoZSB2aWV3cG9ydFxuICogZXhjZWVkcyB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudCwgYnV0IG5vdCBib3RoLCBhbGxvd2luZyB0aGVcbiAqIGZ1bGwgZXh0ZW50IHRvIGJlIHNob3duLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXSBUaGVcbiAqIHByb2plY3Rpb24uIFRoZSBkZWZhdWx0IGlzIFNwaGVyaWNhbCBNZXJjYXRvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzb2x1dGlvbl0gVGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuIFRoZVxuICogdW5pdHMgYXJlIGBwcm9qZWN0aW9uYCB1bml0cyBwZXIgcGl4ZWwgKGUuZy4gbWV0ZXJzIHBlciBwaXhlbCkuIEFuXG4gKiBhbHRlcm5hdGl2ZSB0byBzZXR0aW5nIHRoaXMgaXMgdG8gc2V0IGB6b29tYC4gTGF5ZXIgc291cmNlcyB3aWxsIG5vdCBiZVxuICogZmV0Y2hlZCBpZiBuZWl0aGVyIHRoaXMgbm9yIGB6b29tYCBhcmUgZGVmaW5lZCwgYnV0IHRoZXkgY2FuIGJlIHNldCBsYXRlclxuICogd2l0aCB7QGxpbmsgI3NldFpvb219IG9yIHtAbGluayAjc2V0UmVzb2x1dGlvbn0uXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9uc10gUmVzb2x1dGlvbnMgdGhhdCBkZXRlcm1pbmUgdGhlXG4gKiB6b29tIGxldmVscyBpZiBzcGVjaWZpZWQuIFRoZSBpbmRleCBpbiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gdGhlIHpvb20gbGV2ZWwsXG4gKiB0aGVyZWZvcmUgdGhlIHJlc29sdXRpb24gdmFsdWVzIGhhdmUgdG8gYmUgaW4gZGVzY2VuZGluZyBvcmRlci4gSXQgYWxzbyBjb25zdHJhaW5zXG4gKiB0aGUgcmVzb2x1dGlvbiBieSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgc2V0IHRoZSBgbWF4UmVzb2x1dGlvbmAsXG4gKiBgbWluUmVzb2x1dGlvbmAsIGBtaW5ab29tYCwgYG1heFpvb21gLCBhbmQgYHpvb21GYWN0b3JgIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSBpbml0aWFsIHJvdGF0aW9uIGZvciB0aGUgdmlldyBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCAwIG1lYW5zIE5vcnRoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gT25seSB1c2VkIGlmIGByZXNvbHV0aW9uYCBpcyBub3QgZGVmaW5lZC4gWm9vbVxuICogbGV2ZWwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21GYWN0b3I9Ml0gVGhlIHpvb20gZmFjdG9yIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5PG51bWJlcj59IFtwYWRkaW5nPVswLCAwLCAwLCAwXV0gUGFkZGluZyAoaW4gY3NzIHBpeGVscykuXG4gKiBJZiB0aGUgbWFwIHZpZXdwb3J0IGlzIHBhcnRpYWxseSBjb3ZlcmVkIHdpdGggb3RoZXIgY29udGVudCAob3ZlcmxheXMpIGFsb25nXG4gKiBpdHMgZWRnZXMsIHRoaXMgc2V0dGluZyBhbGxvd3MgdG8gc2hpZnQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgYXdheSBmcm9tXG4gKiB0aGF0IGNvbnRlbnQuIFRoZSBvcmRlciBvZiB0aGUgdmFsdWVzIGlzIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjZW50ZXJdIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZlxuICogdGhlIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGFuaW1hdGlvbi4gVGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHJlc29sdXRpb25gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kXG4gKiBvZiB0aGUgYW5pbWF0aW9uLiAgSWYgYHpvb21gIGlzIGFsc28gcHJvdmlkZWQsIHRoaXMgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb25dIFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mXG4gKiB0aGUgYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gT3B0aW9uYWwgYW5jaG9yIHRvIHJlbWFpbiBmaXhlZFxuICogZHVyaW5nIGEgcm90YXRpb24gb3IgcmVzb2x1dGlvbiBhbmltYXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMDBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZFxuICogZHVyaW5nIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoaW4gdmlldyBwcm9qZWN0aW9uIGNvb3JkaW5hdGVzKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtuZXh0Q2VudGVyXSBUaGUgbmV4dCBjZW50ZXIgZHVyaW5nIGFuIGFuaW1hdGlvbiBzZXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW25leHRSZXNvbHV0aW9uXSBUaGUgbmV4dCByZXNvbHV0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtuZXh0Um90YXRpb25dIFRoZSBuZXh0IHJvdGF0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb20gWm9vbS5cbiAqL1xuXG4vKipcbiAqIExpa2Uge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LCBidXQganVzdCBgdmlld1N0YXRlYCBhbmQgYGV4dGVudGAuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50XG4gKiBAcHJvcGVydHkge1N0YXRlfSB2aWV3U3RhdGUgVmlldyBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50IChpbiB1c2VyIHByb2plY3Rpb24gY29vcmRpbmF0ZXMpLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlPn0gW2xheWVyU3RhdGVzQXJyYXldIExheWVyIHN0YXRlcy5cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWluIHpvb20gbGV2ZWwgZm9yIHRoZSBtYXAgdmlldy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IERFRkFVTFRfTUlOX1pPT00gPSAwO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmNlbnRlcid8J2NoYW5nZTpyZXNvbHV0aW9uJ3wnY2hhbmdlOnJvdGF0aW9uJ30gVmlld09iamVjdEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPFZpZXdPYmplY3RFdmVudFR5cGVzLCBpbXBvcnQoXCIuL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfFZpZXdPYmplY3RFdmVudFR5cGVzLCBSZXR1cm4+fSBWaWV3T25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgVmlldyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbXBsZSAyRCB2aWV3IG9mIHRoZSBtYXAuXG4gKlxuICogVGhpcyBpcyB0aGUgb2JqZWN0IHRvIGFjdCB1cG9uIHRvIGNoYW5nZSB0aGUgY2VudGVyLCByZXNvbHV0aW9uLFxuICogYW5kIHJvdGF0aW9uIG9mIHRoZSBtYXAuXG4gKlxuICogQSBWaWV3IGhhcyBhIGBwcm9qZWN0aW9uYC4gVGhlIHByb2plY3Rpb24gZGV0ZXJtaW5lcyB0aGVcbiAqIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjZW50ZXIsIGFuZCBpdHMgdW5pdHMgZGV0ZXJtaW5lIHRoZSB1bml0cyBvZiB0aGVcbiAqIHJlc29sdXRpb24gKHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsKS4gVGhlIGRlZmF1bHQgcHJvamVjdGlvbiBpc1xuICogV2ViIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICpcbiAqICMjIyBUaGUgdmlldyBzdGF0ZXNcbiAqXG4gKiBBIFZpZXcgaXMgZGV0ZXJtaW5lZCBieSB0aHJlZSBzdGF0ZXM6IGBjZW50ZXJgLCBgcmVzb2x1dGlvbmAsXG4gKiBhbmQgYHJvdGF0aW9uYC4gRWFjaCBzdGF0ZSBoYXMgYSBjb3JyZXNwb25kaW5nIGdldHRlciBhbmQgc2V0dGVyLCBlLmcuXG4gKiBgZ2V0Q2VudGVyYCBhbmQgYHNldENlbnRlcmAgZm9yIHRoZSBgY2VudGVyYCBzdGF0ZS5cbiAqXG4gKiBUaGUgYHpvb21gIHN0YXRlIGlzIGFjdHVhbGx5IG5vdCBzYXZlZCBvbiB0aGUgdmlldzogYWxsIGNvbXB1dGF0aW9uc1xuICogaW50ZXJuYWxseSB1c2UgdGhlIGByZXNvbHV0aW9uYCBzdGF0ZS4gU3RpbGwsIHRoZSBgc2V0Wm9vbWAgYW5kIGBnZXRab29tYFxuICogbWV0aG9kcyBhcmUgYXZhaWxhYmxlLCBhcyB3ZWxsIGFzIGBnZXRSZXNvbHV0aW9uRm9yWm9vbWAgYW5kXG4gKiBgZ2V0Wm9vbUZvclJlc29sdXRpb25gIHRvIHN3aXRjaCBmcm9tIG9uZSBzeXN0ZW0gdG8gdGhlIG90aGVyLlxuICpcbiAqICMjIyBUaGUgY29uc3RyYWludHNcbiAqXG4gKiBgc2V0Q2VudGVyYCwgYHNldFJlc29sdXRpb25gIGFuZCBgc2V0Um90YXRpb25gIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGVcbiAqIHN0YXRlcyBvZiB0aGUgdmlldywgYnV0IGFueSBjb25zdHJhaW50IGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdpbGxcbiAqIGJlIGFwcGxpZWQgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBBIFZpZXcgb2JqZWN0IGNhbiBoYXZlIGEgKnJlc29sdXRpb24gY29uc3RyYWludCosIGEgKnJvdGF0aW9uIGNvbnN0cmFpbnQqXG4gKiBhbmQgYSAqY2VudGVyIGNvbnN0cmFpbnQqLlxuICpcbiAqIFRoZSAqcmVzb2x1dGlvbiBjb25zdHJhaW50KiB0eXBpY2FsbHkgcmVzdHJpY3RzIG1pbi9tYXggdmFsdWVzIGFuZFxuICogc25hcHMgdG8gc3BlY2lmaWMgcmVzb2x1dGlvbnMuIEl0IGlzIGRldGVybWluZWQgYnkgdGhlIGZvbGxvd2luZ1xuICogb3B0aW9uczogYHJlc29sdXRpb25zYCwgYG1heFJlc29sdXRpb25gLCBgbWF4Wm9vbWAgYW5kIGB6b29tRmFjdG9yYC5cbiAqIElmIGByZXNvbHV0aW9uc2AgaXMgc2V0LCB0aGUgb3RoZXIgdGhyZWUgb3B0aW9ucyBhcmUgaWdub3JlZC4gU2VlXG4gKiBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG9wdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIHZpZXdcbiAqIG9ubHkgaGFzIGEgbWluL21heCByZXN0cmljdGlvbiBhbmQgYWxsb3cgaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIHdoZW5cbiAqIHBpbmNoLXpvb21pbmcgZm9yIGV4YW1wbGUuXG4gKlxuICogVGhlICpyb3RhdGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyBhbmdsZXMuIEl0IGlzIGRldGVybWluZWRcbiAqIGJ5IHRoZSBmb2xsb3dpbmcgb3B0aW9uczogYGVuYWJsZVJvdGF0aW9uYCBhbmQgYGNvbnN0cmFpblJvdGF0aW9uYC5cbiAqIEJ5IGRlZmF1bHQgcm90YXRpb24gaXMgYWxsb3dlZCBhbmQgaXRzIHZhbHVlIGlzIHNuYXBwZWQgdG8gemVybyB3aGVuIGFwcHJvYWNoaW5nIHRoZVxuICogaG9yaXpvbnRhbC5cbiAqXG4gKiBUaGUgKmNlbnRlciBjb25zdHJhaW50KiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgZXh0ZW50YCBvcHRpb24uIEJ5XG4gKiBkZWZhdWx0IHRoZSB2aWV3IGNlbnRlciBpcyBub3QgY29uc3RyYWluZWQgYXQgYWxsLlxuICpcbiAqICMjIyBDaGFuZ2luZyB0aGUgdmlldyBzdGF0ZVxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgYHNldFpvb21gLCBgc2V0UmVzb2x1dGlvbmAsIGBzZXRDZW50ZXJgIGFuZFxuICogYHNldFJvdGF0aW9uYCBhcmUgc3ViamVjdCB0byB0aGUgYWJvdmUgbWVudGlvbmVkIGNvbnN0cmFpbnRzLiBBcyBzdWNoLCBpdFxuICogbWF5IHNvbWV0aW1lcyBub3QgYmUgcG9zc2libGUgdG8ga25vdyBpbiBhZHZhbmNlIHRoZSByZXN1bHRpbmcgc3RhdGUgb2YgdGhlXG4gKiBWaWV3LiBGb3IgZXhhbXBsZSwgY2FsbGluZyBgc2V0UmVzb2x1dGlvbigxMClgIGRvZXMgbm90IGd1YXJhbnRlZSB0aGF0XG4gKiBgZ2V0UmVzb2x1dGlvbigpYCB3aWxsIHJldHVybiBgMTBgLlxuICpcbiAqIEEgY29uc2VxdWVuY2Ugb2YgdGhpcyBpcyB0aGF0LCB3aGVuIGFwcGx5aW5nIGEgZGVsdGEgb24gdGhlIHZpZXcgc3RhdGUsIG9uZVxuICogc2hvdWxkIHVzZSBgYWRqdXN0Q2VudGVyYCwgYGFkanVzdFJvdGF0aW9uYCwgYGFkanVzdFpvb21gIGFuZCBgYWRqdXN0UmVzb2x1dGlvbmBcbiAqIHJhdGhlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIHNldHRlcnMuIFRoaXMgd2lsbCBsZXQgdmlldyBkbyBpdHMgaW50ZXJuYWxcbiAqIGNvbXB1dGF0aW9ucy4gQmVzaWRlcywgdGhlIGBhZGp1c3QqYCBtZXRob2RzIGFsc28gdGFrZSBhbiBgYW5jaG9yYFxuICogYXJndW1lbnQgd2hpY2ggYWxsb3dzIHNwZWNpZnlpbmcgYW4gb3JpZ2luIGZvciB0aGUgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogIyMjIEludGVyYWN0aW5nIHdpdGggdGhlIHZpZXdcbiAqXG4gKiBWaWV3IGNvbnN0cmFpbnRzIGFyZSB1c3VhbGx5IG9ubHkgYXBwbGllZCB3aGVuIHRoZSB2aWV3IGlzICphdCByZXN0KiwgbWVhbmluZyB0aGF0XG4gKiBubyBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgb25nb2luZy4gQXMgc3VjaCwgaWYgdGhlIHVzZXIgcHV0cyB0aGUgdmlldyBpbiBhXG4gKiBzdGF0ZSB0aGF0IGlzIG5vdCBlcXVpdmFsZW50IHRvIGEgY29uc3RyYWluZWQgb25lIChlLmcuIHJvdGF0aW5nIHRoZSB2aWV3IHdoZW5cbiAqIHRoZSBzbmFwIGFuZ2xlIGlzIDApLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgYXQgdGhlIGludGVyYWN0aW9uIGVuZCB0b1xuICogcHV0IGJhY2sgdGhlIHZpZXcgdG8gYSBzdGFibGUgc3RhdGU7XG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBWaWV3IGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBbb3B0aW9uc10gVmlldyBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Vmlld09uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuaGludHNfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8QW5pbWF0aW9uPj59XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy52aWV3cG9ydFNpemVfID0gWzEwMCwgMTAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMubmV4dENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0aW9ucy5wcm9qZWN0aW9uKSB7XG4gICAgICBkaXNhYmxlQ29vcmRpbmF0ZVdhcm5pbmcoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICBvcHRpb25zLmNlbnRlciA9IGZyb21Vc2VyQ29vcmRpbmF0ZShvcHRpb25zLmNlbnRlciwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4dGVudCkge1xuICAgICAgb3B0aW9ucy5leHRlbnQgPSBmcm9tVXNlckV4dGVudChvcHRpb25zLmV4dGVudCwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAgICovXG4gIGFwcGx5T3B0aW9uc18ob3B0aW9ucykge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBWaWV3UHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2tleV07XG4gICAgfVxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0cnVlKTtcblxuICAgIGNvbnN0IHJlc29sdXRpb25Db25zdHJhaW50SW5mbyA9IGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWF4UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblJlc29sdXRpb25fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby56b29tRmFjdG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wYWRkaW5nXyA9IG9wdGlvbnMucGFkZGluZztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblpvb21fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblpvb207XG5cbiAgICBjb25zdCBjZW50ZXJDb25zdHJhaW50ID0gY3JlYXRlQ2VudGVyQ29uc3RyYWludChvcHRpb25zKTtcbiAgICBjb25zdCByZXNvbHV0aW9uQ29uc3RyYWludCA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5jb25zdHJhaW50O1xuICAgIGNvbnN0IHJvdGF0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVJvdGF0aW9uQ29uc3RyYWludChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NvbnN0cmFpbnRzfVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHNfID0ge1xuICAgICAgY2VudGVyOiBjZW50ZXJDb25zdHJhaW50LFxuICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbkNvbnN0cmFpbnQsXG4gICAgICByb3RhdGlvbjogcm90YXRpb25Db25zdHJhaW50LFxuICAgIH07XG5cbiAgICB0aGlzLnNldFJvdGF0aW9uKG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwKTtcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFxuICAgICAgb3B0aW9ucy5jZW50ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2VudGVyIDogbnVsbFxuICAgICk7XG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFJlc29sdXRpb24ob3B0aW9ucy5yZXNvbHV0aW9uKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFpvb20ob3B0aW9ucy56b29tKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkZGluZyAoaW4gY3NzIHBpeGVscykuXG4gICAqIElmIHRoZSBtYXAgdmlld3BvcnQgaXMgcGFydGlhbGx5IGNvdmVyZWQgd2l0aCBvdGhlciBjb250ZW50IChvdmVybGF5cykgYWxvbmdcbiAgICogaXRzIGVkZ2VzLCB0aGlzIHNldHRpbmcgYWxsb3dzIHRvIHNoaWZ0IHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0IGF3YXkgZnJvbSB0aGF0XG4gICAqIGNvbnRlbnQuIFRoZSBvcmRlciBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBpcyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQuXG4gICAqIFRoZSBkZWZhdWx0IGlzIG5vIHBhZGRpbmcsIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gYFswLCAwLCAwLCAwXWAuXG4gICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFkZGluZ187XG4gIH1cbiAgc2V0IHBhZGRpbmcocGFkZGluZykge1xuICAgIGxldCBvbGRQYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICB0aGlzLnBhZGRpbmdfID0gcGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmdldENlbnRlckludGVybmFsKCk7XG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgY29uc3QgbmV3UGFkZGluZyA9IHBhZGRpbmcgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgb2xkUGFkZGluZyA9IG9sZFBhZGRpbmcgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgY29uc3Qgb2Zmc2V0WCA9XG4gICAgICAgIChyZXNvbHV0aW9uIC8gMikgKlxuICAgICAgICAobmV3UGFkZGluZ1szXSAtIG9sZFBhZGRpbmdbM10gKyBvbGRQYWRkaW5nWzFdIC0gbmV3UGFkZGluZ1sxXSk7XG4gICAgICBjb25zdCBvZmZzZXRZID1cbiAgICAgICAgKHJlc29sdXRpb24gLyAyKSAqXG4gICAgICAgIChuZXdQYWRkaW5nWzBdIC0gb2xkUGFkZGluZ1swXSArIG9sZFBhZGRpbmdbMl0gLSBuZXdQYWRkaW5nWzJdKTtcbiAgICAgIHRoaXMuc2V0Q2VudGVySW50ZXJuYWwoW2NlbnRlclswXSArIG9mZnNldFgsIGNlbnRlclsxXSAtIG9mZnNldFldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgdmlldyBvcHRpb25zIHVzZWQgdG8gY29uc3RydWN0IHRoZSB2aWV3LiAgVGhlXG4gICAqIGN1cnJlbnQgcmVzb2x1dGlvbiAob3Igem9vbSksIGNlbnRlciwgYW5kIHJvdGF0aW9uIGFyZSBhcHBsaWVkIHRvIGFueSBzdG9yZWRcbiAgICogb3B0aW9ucy4gIFRoZSBwcm92aWRlZCBvcHRpb25zIGNhbiBiZSB1c2VkIHRvIGFwcGx5IG5ldyBtaW4vbWF4IHpvb20gb3JcbiAgICogcmVzb2x1dGlvbiBsaW1pdHMuXG4gICAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG5ld09wdGlvbnMgTmV3IG9wdGlvbnMgdG8gYmUgYXBwbGllZC5cbiAgICogQHJldHVybiB7Vmlld09wdGlvbnN9IE5ldyBvcHRpb25zIHVwZGF0ZWQgd2l0aCB0aGUgY3VycmVudCB2aWV3IHN0YXRlLlxuICAgKi9cbiAgZ2V0VXBkYXRlZE9wdGlvbnNfKG5ld09wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG5cbiAgICAvLyBwcmVzZXJ2ZSByZXNvbHV0aW9uIChvciB6b29tKVxuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuem9vbSA9IHRoaXMuZ2V0Wm9vbSgpO1xuICAgIH1cblxuICAgIC8vIHByZXNlcnZlIGNlbnRlclxuICAgIG9wdGlvbnMuY2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuXG4gICAgLy8gcHJlc2VydmUgcm90YXRpb25cbiAgICBvcHRpb25zLnJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgdGhlIHZpZXcuICBUaGUgdmlldydzIGNlbnRlciwgem9vbSAob3IgcmVzb2x1dGlvbiksIGFuZCByb3RhdGlvblxuICAgKiBjYW4gYmUgYW5pbWF0ZWQgZm9yIHNtb290aCB0cmFuc2l0aW9ucyBiZXR3ZWVuIHZpZXcgc3RhdGVzLiAgRm9yIGV4YW1wbGUsXG4gICAqIHRvIGFuaW1hdGUgdGhlIHZpZXcgdG8gYSBuZXcgem9vbSBsZXZlbDpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogdmlldy5nZXRab29tKCkgKyAxfSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBhbmltYXRpb24gbGFzdHMgb25lIHNlY29uZCBhbmQgdXNlcyBpbi1hbmQtb3V0IGVhc2luZy4gIFlvdVxuICAgKiBjYW4gY3VzdG9taXplIHRoaXMgYmVoYXZpb3IgYnkgaW5jbHVkaW5nIGBkdXJhdGlvbmAgKGluIG1pbGxpc2Vjb25kcykgYW5kXG4gICAqIGBlYXNpbmdgIG9wdGlvbnMgKHNlZSB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ30pLlxuICAgKlxuICAgKiBUbyBjaGFpbiB0b2dldGhlciBtdWx0aXBsZSBhbmltYXRpb25zLCBjYWxsIHRoZSBtZXRob2Qgd2l0aCBtdWx0aXBsZVxuICAgKiBhbmltYXRpb24gb2JqZWN0cy4gIEZvciBleGFtcGxlLCB0byBmaXJzdCB6b29tIGFuZCB0aGVuIHBhbjpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogMTB9LCB7Y2VudGVyOiBbMCwgMF19KTtcbiAgICpcbiAgICogSWYgeW91IHByb3ZpZGUgYSBmdW5jdGlvbiBhcyB0aGUgbGFzdCBhcmd1bWVudCB0byB0aGUgYW5pbWF0ZSBtZXRob2QsIGl0XG4gICAqIHdpbGwgZ2V0IGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFuaW1hdGlvbiBzZXJpZXMuICBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2l0aCBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBzZXJpZXMgY29tcGxldGVkIG9uIGl0cyBvd24gb3IgYGZhbHNlYFxuICAgKiBpZiBpdCB3YXMgY2FuY2VsbGVkLlxuICAgKlxuICAgKiBBbmltYXRpb25zIGFyZSBjYW5jZWxsZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgKGUuZy4gZHJhZ2dpbmcgdGhlIG1hcCkgb3IgYnlcbiAgICogY2FsbGluZyBgdmlldy5zZXRDZW50ZXIoKWAsIGB2aWV3LnNldFJlc29sdXRpb24oKWAsIG9yIGB2aWV3LnNldFJvdGF0aW9uKClgXG4gICAqIChvciBhbm90aGVyIG1ldGhvZCB0aGF0IGNhbGxzIG9uZSBvZiB0aGVzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKEFuaW1hdGlvbk9wdGlvbnN8ZnVuY3Rpb24oYm9vbGVhbik6IHZvaWQpfSB2YXJfYXJncyBBbmltYXRpb25cbiAgICogICAgIG9wdGlvbnMuICBNdWx0aXBsZSBhbmltYXRpb25zIGNhbiBiZSBydW4gaW4gc2VyaWVzIGJ5IHBhc3NpbmcgbXVsdGlwbGVcbiAgICogICAgIG9wdGlvbnMgb2JqZWN0cy4gIFRvIHJ1biBtdWx0aXBsZSBhbmltYXRpb25zIGluIHBhcmFsbGVsLCBjYWxsIHRoZSBtZXRob2RcbiAgICogICAgIG11bHRpcGxlIHRpbWVzLiAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgY2FuIGJlIHByb3ZpZGVkIGFzIGEgZmluYWxcbiAgICogICAgIGFyZ3VtZW50LiAgVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgICAgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZWQgd2l0aG91dCBiZWluZyBjYW5jZWxsZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFuaW1hdGUodmFyX2FyZ3MpIHtcbiAgICBpZiAodGhpcy5pc0RlZigpICYmICF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5jZW50ZXIgPSBmcm9tVXNlckNvb3JkaW5hdGUoXG4gICAgICAgICAgb3B0aW9ucy5jZW50ZXIsXG4gICAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuY2hvcikge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuYW5jaG9yID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgICAgIG9wdGlvbnMuYW5jaG9yLFxuICAgICAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gb3B0aW9ucztcbiAgICB9XG4gICAgdGhpcy5hbmltYXRlSW50ZXJuYWwuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oQW5pbWF0aW9uT3B0aW9uc3xmdW5jdGlvbihib29sZWFuKTogdm9pZCl9IHZhcl9hcmdzIEFuaW1hdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYW5pbWF0ZUludGVybmFsKHZhcl9hcmdzKSB7XG4gICAgbGV0IGFuaW1hdGlvbkNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgaWYgKFxuICAgICAgYW5pbWF0aW9uQ291bnQgPiAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV0gPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV07XG4gICAgICAtLWFuaW1hdGlvbkNvdW50O1xuICAgIH1cblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGFuaW1hdGlvbkNvdW50ICYmICF0aGlzLmlzRGVmKCk7ICsraSkge1xuICAgICAgLy8gaWYgdmlldyBwcm9wZXJ0aWVzIGFyZSBub3QgeWV0IHNldCwgc2hvcnRjdXQgdG8gdGhlIGZpbmFsIHN0YXRlXG4gICAgICBjb25zdCBzdGF0ZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChzdGF0ZS5jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChzdGF0ZS5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFpvb20oc3RhdGUuem9vbSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnJlc29sdXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKHN0YXRlLnJlc29sdXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihzdGF0ZS5yb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBhbmltYXRpb25Db3VudCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLnRhcmdldENlbnRlcl8uc2xpY2UoKTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0UmVzb2x1dGlvbl87XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy50YXJnZXRSb3RhdGlvbl87XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgZm9yICg7IGkgPCBhbmltYXRpb25Db3VudDsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtBbmltYXRpb25PcHRpb25zfSAqLyAoYXJndW1lbnRzW2ldKTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgYW5jaG9yOiBvcHRpb25zLmFuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nIHx8IGluQW5kT3V0LFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZUNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldENlbnRlciA9IG9wdGlvbnMuY2VudGVyLnNsaWNlKCk7XG4gICAgICAgIGNlbnRlciA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbShvcHRpb25zLnpvb20pO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIGNvbnN0IGRlbHRhID1cbiAgICAgICAgICBtb2R1bG8ob3B0aW9ucy5yb3RhdGlvbiAtIHJvdGF0aW9uICsgTWF0aC5QSSwgMiAqIE1hdGguUEkpIC0gTWF0aC5QSTtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uID0gcm90YXRpb24gKyBkZWx0YTtcbiAgICAgICAgcm90YXRpb24gPSBhbmltYXRpb24udGFyZ2V0Um90YXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBhIG5vLW9wXG4gICAgICBpZiAoaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgYW5pbWF0aW9uLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gd2Ugc3RpbGwgcHVzaCBpdCBvbnRvIHRoZSBzZXJpZXMgZm9yIGNhbGxiYWNrIGhhbmRsaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCArPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICB9XG4gICAgICBzZXJpZXMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnNfLnB1c2goc2VyaWVzKTtcbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAxKTtcbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB2aWV3IGlzIGJlaW5nIGFuaW1hdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlldyBpcyBiZWluZyBhbmltYXRlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1tWaWV3SGludC5BTklNQVRJTkddID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlldywgc3VjaCBhcyBwYW5uaW5nIG9yIHpvb21pbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aWV3IGlzIGJlaW5nIGludGVyYWN0ZWQgd2l0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJhY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW1ZpZXdIaW50LklOVEVSQUNUSU5HXSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBvbmdvaW5nIGFuaW1hdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNhbmNlbEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LkFOSU1BVElORywgLXRoaXMuaGludHNfW1ZpZXdIaW50LkFOSU1BVElOR10pO1xuICAgIGxldCBhbmNob3I7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLmFuaW1hdGlvbnNfW2ldO1xuICAgICAgaWYgKHNlcmllc1swXS5jYWxsYmFjaykge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFjayhzZXJpZXNbMF0uY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHNlcmllcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gc2VyaWVzW2pdO1xuICAgICAgICAgIGlmICghYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBhbmltYXRpb24uYW5jaG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSBhbmNob3I7XG4gICAgdGhpcy5uZXh0Q2VudGVyXyA9IG51bGw7XG4gICAgdGhpcy5uZXh0UmVzb2x1dGlvbl8gPSBOYU47XG4gICAgdGhpcy5uZXh0Um90YXRpb25fID0gTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbGwgYW5pbWF0aW9ucy5cbiAgICovXG4gIHVwZGF0ZUFuaW1hdGlvbnNfKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVBbmltYXRpb25LZXlfKTtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IG1vcmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5hbmltYXRpb25zX1tpXTtcbiAgICAgIGxldCBzZXJpZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBzZXJpZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBzZXJpZXNbal07XG4gICAgICAgIGlmIChhbmltYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGFwc2VkID0gbm93IC0gYW5pbWF0aW9uLnN0YXJ0O1xuICAgICAgICBsZXQgZnJhY3Rpb24gPVxuICAgICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA+IDAgPyBlbGFwc2VkIC8gYW5pbWF0aW9uLmR1cmF0aW9uIDogMTtcbiAgICAgICAgaWYgKGZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICBhbmltYXRpb24uY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGZyYWN0aW9uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gYW5pbWF0aW9uLmVhc2luZyhmcmFjdGlvbik7XG4gICAgICAgIGlmIChhbmltYXRpb24uc291cmNlQ2VudGVyKSB7XG4gICAgICAgICAgY29uc3QgeDAgPSBhbmltYXRpb24uc291cmNlQ2VudGVyWzBdO1xuICAgICAgICAgIGNvbnN0IHkwID0gYW5pbWF0aW9uLnNvdXJjZUNlbnRlclsxXTtcbiAgICAgICAgICBjb25zdCB4MSA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXJbMF07XG4gICAgICAgICAgY29uc3QgeTEgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyWzFdO1xuICAgICAgICAgIHRoaXMubmV4dENlbnRlcl8gPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyO1xuICAgICAgICAgIGNvbnN0IHggPSB4MCArIHByb2dyZXNzICogKHgxIC0geDApO1xuICAgICAgICAgIGNvbnN0IHkgPSB5MCArIHByb2dyZXNzICogKHkxIC0geTApO1xuICAgICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IFt4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gJiYgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICAgICAgICBjb25zdCByZXNvbHV0aW9uID1cbiAgICAgICAgICAgIHByb2dyZXNzID09PSAxXG4gICAgICAgICAgICAgID8gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb25cbiAgICAgICAgICAgICAgOiBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiArXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgKlxuICAgICAgICAgICAgICAgICAgKGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uIC0gYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKFxuICAgICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJab29tKFxuICAgICAgICAgICAgICBjb25zdHJhaW5lZFJlc29sdXRpb24sXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmNob3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25fID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG4gICAgICAgICAgdGhpcy5hcHBseVRhcmdldFN0YXRlXyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBhbmltYXRpb24udGFyZ2V0Um90YXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCByb3RhdGlvbiA9XG4gICAgICAgICAgICBwcm9ncmVzcyA9PT0gMVxuICAgICAgICAgICAgICA/IG1vZHVsbyhhbmltYXRpb24udGFyZ2V0Um90YXRpb24gKyBNYXRoLlBJLCAyICogTWF0aC5QSSkgLVxuICAgICAgICAgICAgICAgIE1hdGguUElcbiAgICAgICAgICAgICAgOiBhbmltYXRpb24uc291cmNlUm90YXRpb24gK1xuICAgICAgICAgICAgICAgIHByb2dyZXNzICpcbiAgICAgICAgICAgICAgICAgIChhbmltYXRpb24udGFyZ2V0Um90YXRpb24gLSBhbmltYXRpb24uc291cmNlUm90YXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW5lZFJvdGF0aW9uID0gdGhpcy5jb25zdHJhaW50c18ucm90YXRpb24oXG4gICAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJSb3RhdGUoXG4gICAgICAgICAgICAgIGNvbnN0cmFpbmVkUm90YXRpb24sXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmNob3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dFJvdGF0aW9uXyA9IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbjtcbiAgICAgICAgICB0aGlzLnRhcmdldFJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8odHJ1ZSk7XG4gICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgICBpZiAoIWFuaW1hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWVzQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zX1tpXSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0SGludChWaWV3SGludC5BTklNQVRJTkcsIC0xKTtcbiAgICAgICAgdGhpcy5uZXh0Q2VudGVyXyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25fID0gTmFOO1xuICAgICAgICB0aGlzLm5leHRSb3RhdGlvbl8gPSBOYU47XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2VyaWVzWzBdLmNhbGxiYWNrO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBhbmltYXRpb25DYWxsYmFjayhjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJ1bmUgY29tcGxldGVkIHNlcmllc1xuICAgIHRoaXMuYW5pbWF0aW9uc18gPSB0aGlzLmFuaW1hdGlvbnNfLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAobW9yZSAmJiB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfLmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBUYXJnZXQgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBSb3RhdGlvbiBhbmNob3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByb3RhdGlvbiBhbmQgYW5jaG9yLlxuICAgKi9cbiAgY2FsY3VsYXRlQ2VudGVyUm90YXRlKHJvdGF0aW9uLCBhbmNob3IpIHtcbiAgICBsZXQgY2VudGVyO1xuICAgIGNvbnN0IGN1cnJlbnRDZW50ZXIgPSB0aGlzLmdldENlbnRlckludGVybmFsKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2VudGVyID0gW2N1cnJlbnRDZW50ZXJbMF0gLSBhbmNob3JbMF0sIGN1cnJlbnRDZW50ZXJbMV0gLSBhbmNob3JbMV1dO1xuICAgICAgcm90YXRlQ29vcmRpbmF0ZShjZW50ZXIsIHJvdGF0aW9uIC0gdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICAgIGFkZENvb3JkaW5hdGUoY2VudGVyLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgWm9vbSBhbmNob3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByZXNvbHV0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBjYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIGFuY2hvcikge1xuICAgIGxldCBjZW50ZXI7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICBjb25zdCBjdXJyZW50UmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGlmIChjdXJyZW50Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgeCA9XG4gICAgICAgIGFuY2hvclswXSAtXG4gICAgICAgIChyZXNvbHV0aW9uICogKGFuY2hvclswXSAtIGN1cnJlbnRDZW50ZXJbMF0pKSAvIGN1cnJlbnRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgeSA9XG4gICAgICAgIGFuY2hvclsxXSAtXG4gICAgICAgIChyZXNvbHV0aW9uICogKGFuY2hvclsxXSAtIGN1cnJlbnRDZW50ZXJbMV0pKSAvIGN1cnJlbnRSZXNvbHV0aW9uO1xuICAgICAgY2VudGVyID0gW3gsIHldO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmlld3BvcnQgc2l6ZS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3RhdGlvbl0gVGFrZSBpbnRvIGFjY291bnQgdGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3cG9ydCB3aGVuIGdpdmluZyB0aGUgc2l6ZVxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gVmlld3BvcnQgc2l6ZSBvciBgWzEwMCwgMTAwXWAgd2hlbiBubyB2aWV3cG9ydCBpcyBmb3VuZC5cbiAgICovXG4gIGdldFZpZXdwb3J0U2l6ZV8ocm90YXRpb24pIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy52aWV3cG9ydFNpemVfO1xuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgY29uc3QgdyA9IHNpemVbMF07XG4gICAgICBjb25zdCBoID0gc2l6ZVsxXTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGguYWJzKHcgKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAqIE1hdGguc2luKHJvdGF0aW9uKSksXG4gICAgICAgIE1hdGguYWJzKHcgKiBNYXRoLnNpbihyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAqIE1hdGguY29zKHJvdGF0aW9uKSksXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIHZpZXdwb3J0IHNpemUgb24gdGhlIHZpZXcuIFRoZSB2aWV3cG9ydCBzaXplIGlzIG5vdCByZWFkIGV2ZXJ5IHRpbWUgZnJvbSB0aGUgRE9NXG4gICAqIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGhpdCBhbmQgbGF5b3V0IHJlZmxvdy5cbiAgICogVGhpcyBzaG91bGQgYmUgZG9uZSBvbiBtYXAgc2l6ZSBjaGFuZ2UuXG4gICAqIE5vdGU6IHRoZSBjb25zdHJhaW50cyBhcmUgbm90IHJlc29sdmVkIGR1cmluZyBhbiBhbmltYXRpb24gdG8gYXZvaWQgc3RvcHBpbmcgaXRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIFZpZXdwb3J0IHNpemU7IGlmIHVuZGVmaW5lZCwgWzEwMCwgMTAwXSBpcyBhc3N1bWVkXG4gICAqL1xuICBzZXRWaWV3cG9ydFNpemUoc2l6ZSkge1xuICAgIHRoaXMudmlld3BvcnRTaXplXyA9IEFycmF5LmlzQXJyYXkoc2l6ZSkgPyBzaXplLnNsaWNlKCkgOiBbMTAwLCAxMDBdO1xuICAgIGlmICghdGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBjZW50ZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q2VudGVyKCkge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICBpZiAoIWNlbnRlcikge1xuICAgICAgcmV0dXJuIGNlbnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRvVXNlckNvb3JkaW5hdGUoY2VudGVyLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGNlbnRlciB3aXRob3V0IHRyYW5zZm9ybWluZyB0byB1c2VyIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICovXG4gIGdldENlbnRlckludGVybmFsKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoVmlld1Byb3BlcnR5LkNFTlRFUilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnN0cmFpbnRzfSBDb25zdHJhaW50cy5cbiAgICovXG4gIGdldENvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXNvbHV0aW9uIGNvbnN0cmFpbnQgaXMgc2V0XG4gICAqL1xuICBnZXRDb25zdHJhaW5SZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnY29uc3RyYWluUmVzb2x1dGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2hpbnRzXSBEZXN0aW5hdGlvbiBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSGludC5cbiAgICovXG4gIGdldEhpbnRzKGhpbnRzKSB7XG4gICAgaWYgKGhpbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhpbnRzWzBdID0gdGhpcy5oaW50c19bMF07XG4gICAgICBoaW50c1sxXSA9IHRoaXMuaGludHNfWzFdO1xuICAgICAgcmV0dXJuIGhpbnRzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oaW50c18uc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4dGVudCBmb3IgdGhlIGN1cnJlbnQgdmlldyBzdGF0ZSBhbmQgdGhlIHBhc3NlZCBib3ggc2l6ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIFRoZSBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3hcbiAgICogaW50byB3aGljaCB0aGUgY2FsY3VsYXRlZCBleHRlbnQgc2hvdWxkIGZpdC4gRGVmYXVsdHMgdG8gdGhlIHNpemUgb2YgdGhlXG4gICAqIG1hcCB0aGUgdmlldyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqIElmIG5vIG1hcCBvciBtdWx0aXBsZSBtYXBzIGFyZSBjb25uZWN0ZWQgdG8gdGhlIHZpZXcsIHByb3ZpZGUgdGhlIGRlc2lyZWRcbiAgICogYm94IHNpemUgKGUuZy4gYG1hcC5nZXRTaXplKClgKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGNhbGN1bGF0ZUV4dGVudChzaXplKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5jYWxjdWxhdGVFeHRlbnRJbnRlcm5hbChzaXplKTtcbiAgICByZXR1cm4gdG9Vc2VyRXh0ZW50KGV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBCb3ggcGl4ZWwgc2l6ZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiB0aGUgbWFwJ3MgbGFzdCBrbm93biB2aWV3cG9ydCBzaXplIHdpbGwgYmUgdXNlZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqL1xuICBjYWxjdWxhdGVFeHRlbnRJbnRlcm5hbChzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKCk7XG4gICAgY29uc3QgY2VudGVyID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovIChcbiAgICAgIHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKVxuICAgICk7XG4gICAgYXNzZXJ0KGNlbnRlciwgJ1RoZSB2aWV3IGNlbnRlciBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSAvKiogQHR5cGUgeyFudW1iZXJ9ICovICh0aGlzLmdldFJlc29sdXRpb24oKSk7XG4gICAgYXNzZXJ0KHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCwgJ1RoZSB2aWV3IHJlc29sdXRpb24gaXMgbm90IGRlZmluZWQnKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IC8qKiBAdHlwZSB7IW51bWJlcn0gKi8gKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgYXNzZXJ0KHJvdGF0aW9uICE9PSB1bmRlZmluZWQsICdUaGUgdmlldyByb3RhdGlvbiBpcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgcmV0dXJuIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4UmVzb2x1dGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluUmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWF4Wm9vbSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChcbiAgICAgIHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24odGhpcy5taW5SZXNvbHV0aW9uXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBUaGUgbWF4aW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXhab29tKHpvb20pIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe21heFpvb206IHpvb219KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoXG4gICAgICB0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWluWm9vbSh6b29tKSB7XG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKHRoaXMuZ2V0VXBkYXRlZE9wdGlvbnNfKHttaW5ab29tOiB6b29tfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSB2aWV3IHNob3VsZCBhbGxvdyBpbnRlcm1lZGlhcnkgem9vbSBsZXZlbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBXaGV0aGVyIHRoZSByZXNvbHV0aW9uIGlzIGNvbnN0cmFpbmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb25zdHJhaW5SZXNvbHV0aW9uKGVuYWJsZWQpIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe2NvbnN0cmFpblJlc29sdXRpb246IGVuYWJsZWR9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFRoZSBwcm9qZWN0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQcm9qZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3Rpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb25zIGZvciB0aGUgdmlldy4gVGhpcyByZXR1cm5zIHRoZSBhcnJheSBvZiByZXNvbHV0aW9uc1xuICAgKiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBWaWV3LCBvciB1bmRlZmluZWQgaWYgbm9uZSB3ZXJlIGdpdmVuLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gVGhlIHJlc29sdXRpb25zIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciBhIHByb3ZpZGVkIGV4dGVudCAoaW4gbWFwIHVuaXRzKSBhbmQgc2l6ZSAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBhdCB3aGljaCB0aGUgcHJvdmlkZWQgZXh0ZW50IHdpbGwgcmVuZGVyIGF0XG4gICAqICAgICB0aGUgZ2l2ZW4gc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbkZvckV4dGVudChleHRlbnQsIHNpemUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwoXG4gICAgICBmcm9tVXNlckV4dGVudChleHRlbnQsIHRoaXMuZ2V0UHJvamVjdGlvbigpKSxcbiAgICAgIHNpemVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgYSBwcm92aWRlZCBleHRlbnQgKGluIG1hcCB1bml0cykgYW5kIHNpemUgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gQm94IHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIHByb3ZpZGVkIGV4dGVudCB3aWxsIHJlbmRlciBhdFxuICAgKiAgICAgdGhlIGdpdmVuIHNpemUuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwoZXh0ZW50LCBzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKCk7XG4gICAgY29uc3QgeFJlc29sdXRpb24gPSBnZXRXaWR0aChleHRlbnQpIC8gc2l6ZVswXTtcbiAgICBjb25zdCB5UmVzb2x1dGlvbiA9IGdldEhlaWdodChleHRlbnQpIC8gc2l6ZVsxXTtcbiAgICByZXR1cm4gTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGFcbiAgICogcmVzb2x1dGlvbi4gRXhwb25lbnRpYWwgc2NhbGluZyBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvd2VyXSBQb3dlci5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSBSZXNvbHV0aW9uIGZvciB2YWx1ZSBmdW5jdGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uKHBvd2VyKSB7XG4gICAgcG93ZXIgPSBwb3dlciB8fCAyO1xuICAgIGNvbnN0IG1heFJlc29sdXRpb24gPSB0aGlzLmdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0aGlzLm1heFJlc29sdXRpb25fKTtcbiAgICBjb25zdCBtaW5SZXNvbHV0aW9uID0gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgICBjb25zdCBtYXggPSBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcik7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlLlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhwb3dlciwgdmFsdWUgKiBtYXgpO1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVzb2x1dGlvbiBmb3IgYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIDAgYW5kIDEuIEV4cG9uZW50aWFsIHNjYWxpbmcgaXMgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3dlcl0gUG93ZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlcik6IG51bWJlcn0gVmFsdWUgZm9yIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAqL1xuICBnZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbihwb3dlcikge1xuICAgIGNvbnN0IGxvZ1Bvd2VyID0gTWF0aC5sb2cocG93ZXIgfHwgMik7XG4gICAgY29uc3QgbWF4UmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pO1xuICAgIGNvbnN0IG1pblJlc29sdXRpb24gPSB0aGlzLm1pblJlc29sdXRpb25fO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZhbHVlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAocmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyIC8gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBtaW51cyBwYWRkaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uXSBUYWtlIGludG8gYWNjb3VudCB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0IHdoZW4gZ2l2aW5nIHRoZSBzaXplXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBWaWV3cG9ydCBzaXplIHJlZHVjZWQgYnkgdGhlIHBhZGRpbmcuXG4gICAqL1xuICBnZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKHJvdGF0aW9uKSB7XG4gICAgbGV0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8ocm90YXRpb24pO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmdfO1xuICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICBzaXplID0gW1xuICAgICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICAgIHNpemVbMV0gLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0YXRlfSBWaWV3IHN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgY2VudGVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpXG4gICAgKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICBpZiAocGFkZGluZykge1xuICAgICAgY29uc3QgcmVkdWNlZFNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICAgIGNlbnRlciA9IGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjZW50ZXIsXG4gICAgICAgIHRoaXMuZ2V0Vmlld3BvcnRTaXplXygpLFxuICAgICAgICBbcmVkdWNlZFNpemVbMF0gLyAyICsgcGFkZGluZ1szXSwgcmVkdWNlZFNpemVbMV0gLyAyICsgcGFkZGluZ1swXV0sXG4gICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiBjZW50ZXIuc2xpY2UoMCksXG4gICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogbnVsbCxcbiAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgICBuZXh0Q2VudGVyOiB0aGlzLm5leHRDZW50ZXJfLFxuICAgICAgbmV4dFJlc29sdXRpb246IHRoaXMubmV4dFJlc29sdXRpb25fLFxuICAgICAgbmV4dFJvdGF0aW9uOiB0aGlzLm5leHRSb3RhdGlvbl8sXG4gICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICB6b29tOiB0aGlzLmdldFpvb20oKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1ZpZXdTdGF0ZUxheWVyU3RhdGVFeHRlbnR9IExpa2UgYEZyYW1lU3RhdGVgLCBidXQganVzdCBgdmlld1N0YXRlYCBhbmQgYGV4dGVudGAuXG4gICAqL1xuICBnZXRWaWV3U3RhdGVBbmRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdTdGF0ZTogdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgZXh0ZW50OiB0aGlzLmNhbGN1bGF0ZUV4dGVudCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuIFRoaXMgbWV0aG9kIG1heSByZXR1cm4gbm9uLWludGVnZXIgem9vbSBsZXZlbHNcbiAgICogaWYgdGhlIHZpZXcgZG9lcyBub3QgY29uc3RyYWluIHRoZSByZXNvbHV0aW9uLCBvciBpZiBhbiBpbnRlcmFjdGlvbiBvclxuICAgKiBhbmltYXRpb24gaXMgdW5kZXJ3YXkuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFpvb20oKSB7XG4gICAgbGV0IHpvb207XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGlmIChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHpvb20gPSB0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gem9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHpvb20gbGV2ZWwgZm9yIGEgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSB6b29tIGxldmVsIGZvciB0aGUgcHJvdmlkZWQgcmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Wm9vbUZvclJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLm1pblpvb21fIHx8IDA7XG4gICAgbGV0IG1heCwgem9vbUZhY3RvcjtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uc18pIHtcbiAgICAgIGNvbnN0IG5lYXJlc3QgPSBsaW5lYXJGaW5kTmVhcmVzdCh0aGlzLnJlc29sdXRpb25zXywgcmVzb2x1dGlvbiwgMSk7XG4gICAgICBvZmZzZXQgPSBuZWFyZXN0O1xuICAgICAgbWF4ID0gdGhpcy5yZXNvbHV0aW9uc19bbmVhcmVzdF07XG4gICAgICBpZiAobmVhcmVzdCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9vbUZhY3RvciA9IG1heCAvIHRoaXMucmVzb2x1dGlvbnNfW25lYXJlc3QgKyAxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4ID0gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgICAgIHpvb21GYWN0b3IgPSB0aGlzLnpvb21GYWN0b3JfO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgTWF0aC5sb2cobWF4IC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIGEgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmlldyByZXNvbHV0aW9uIGZvciB0aGUgcHJvdmlkZWQgem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbkZvclpvb20oem9vbSkge1xuICAgIGlmICh0aGlzLnJlc29sdXRpb25zXykge1xuICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFzZUxldmVsID0gY2xhbXAoXG4gICAgICAgIE1hdGguZmxvb3Ioem9vbSksXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDJcbiAgICAgICk7XG4gICAgICBjb25zdCB6b29tRmFjdG9yID1cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvIHRoaXMucmVzb2x1dGlvbnNfW2Jhc2VMZXZlbCArIDFdO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvXG4gICAgICAgIE1hdGgucG93KHpvb21GYWN0b3IsIGNsYW1wKHpvb20gLSBiYXNlTGV2ZWwsIDAsIDEpKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gLyBNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCB6b29tIC0gdGhpcy5taW5ab29tXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpdCB0aGUgZ2l2ZW4gZ2VvbWV0cnkgb3IgZXh0ZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBtYXAgc2l6ZSBhbmQgYm9yZGVyLlxuICAgKiBUaGUgc2l6ZSBpcyBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3ggdG8gZml0IHRoZSBleHRlbnQgaW50by5cbiAgICogSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCB3YW50IHRvIHVzZSB0aGUgbWFwIHNpemUsIHRoYXQgaXMgYG1hcC5nZXRTaXplKClgLlxuICAgKiBUYWtlcyBjYXJlIG9mIHRoZSBtYXAgYW5nbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBnZW9tZXRyeU9yRXh0ZW50IFRoZSBnZW9tZXRyeSBvclxuICAgKiAgICAgZXh0ZW50IHRvIGZpdCB0aGUgdmlldyB0by5cbiAgICogQHBhcmFtIHtGaXRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZml0KGdlb21ldHJ5T3JFeHRlbnQsIG9wdGlvbnMpIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIGxldCBnZW9tZXRyeTtcbiAgICBhc3NlcnQoXG4gICAgICBBcnJheS5pc0FycmF5KGdlb21ldHJ5T3JFeHRlbnQpIHx8XG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAoZ2VvbWV0cnlPckV4dGVudCkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KSA9PT1cbiAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgJ0ludmFsaWQgZXh0ZW50IG9yIGdlb21ldHJ5IHByb3ZpZGVkIGFzIGBnZW9tZXRyeWAnXG4gICAgKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShnZW9tZXRyeU9yRXh0ZW50KSkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICAhaXNFbXB0eShnZW9tZXRyeU9yRXh0ZW50KSxcbiAgICAgICAgJ0Nhbm5vdCBmaXQgZW1wdHkgZXh0ZW50IHByb3ZpZGVkIGFzIGBnZW9tZXRyeWAnXG4gICAgICApO1xuICAgICAgY29uc3QgZXh0ZW50ID0gZnJvbVVzZXJFeHRlbnQoZ2VvbWV0cnlPckV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgICAgZ2VvbWV0cnkgPSBwb2x5Z29uRnJvbUV4dGVudChleHRlbnQpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlPckV4dGVudC5nZXRUeXBlKCkgPT09ICdDaXJjbGUnKSB7XG4gICAgICBjb25zdCBleHRlbnQgPSBmcm9tVXNlckV4dGVudChcbiAgICAgICAgZ2VvbWV0cnlPckV4dGVudC5nZXRFeHRlbnQoKSxcbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKClcbiAgICAgICk7XG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCk7XG4gICAgICBnZW9tZXRyeS5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbigpLCBnZXRDZW50ZXIoZXh0ZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeU9yRXh0ZW50XG4gICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSh1c2VyUHJvamVjdGlvbiwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5T3JFeHRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maXRJbnRlcm5hbChnZW9tZXRyeSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJvdGF0ZWQgZXh0ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnRcIikuRXh0ZW50fSBUaGUgcm90YXRlZCBleHRlbnQgZm9yIHRoZSBnZW9tZXRyeS5cbiAgICovXG4gIHJvdGF0ZWRFeHRlbnRGb3JHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IGNvc0FuZ2xlID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICBjb25zdCBjb29yZHMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgbWluUm90WCA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWluUm90WSA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCByb3RYID0gY29vcmRzW2ldICogY29zQW5nbGUgLSBjb29yZHNbaSArIDFdICogc2luQW5nbGU7XG4gICAgICBjb25zdCByb3RZID0gY29vcmRzW2ldICogc2luQW5nbGUgKyBjb29yZHNbaSArIDFdICogY29zQW5nbGU7XG4gICAgICBtaW5Sb3RYID0gTWF0aC5taW4obWluUm90WCwgcm90WCk7XG4gICAgICBtaW5Sb3RZID0gTWF0aC5taW4obWluUm90WSwgcm90WSk7XG4gICAgICBtYXhSb3RYID0gTWF0aC5tYXgobWF4Um90WCwgcm90WCk7XG4gICAgICBtYXhSb3RZID0gTWF0aC5tYXgobWF4Um90WSwgcm90WSk7XG4gICAgfVxuICAgIHJldHVybiBbbWluUm90WCwgbWluUm90WSwgbWF4Um90WCwgbWF4Um90WV07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0ZpdE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgZml0SW50ZXJuYWwoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgIHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9XG4gICAgICBvcHRpb25zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGFkZGluZyA6IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBuZWFyZXN0ID0gb3B0aW9ucy5uZWFyZXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5lYXJlc3QgOiBmYWxzZTtcbiAgICBsZXQgbWluUmVzb2x1dGlvbjtcbiAgICBpZiAob3B0aW9ucy5taW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSBvcHRpb25zLm1pblJlc29sdXRpb247XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvclpvb20ob3B0aW9ucy5tYXhab29tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IDA7XG4gICAgfVxuXG4gICAgY29uc3Qgcm90YXRlZEV4dGVudCA9IHRoaXMucm90YXRlZEV4dGVudEZvckdlb21ldHJ5KGdlb21ldHJ5KTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXNvbHV0aW9uXG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb25Gb3JFeHRlbnRJbnRlcm5hbChyb3RhdGVkRXh0ZW50LCBbXG4gICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICBzaXplWzFdIC0gcGFkZGluZ1swXSAtIHBhZGRpbmdbMl0sXG4gICAgXSk7XG4gICAgcmVzb2x1dGlvbiA9IGlzTmFOKHJlc29sdXRpb24pXG4gICAgICA/IG1pblJlc29sdXRpb25cbiAgICAgIDogTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbik7XG4gICAgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHJlc29sdXRpb24sIG5lYXJlc3QgPyAwIDogMSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgY2VudGVyXG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgY29uc3QgY2VudGVyUm90ID0gZ2V0Q2VudGVyKHJvdGF0ZWRFeHRlbnQpO1xuICAgIGNlbnRlclJvdFswXSArPSAoKHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdKSAvIDIpICogcmVzb2x1dGlvbjtcbiAgICBjZW50ZXJSb3RbMV0gKz0gKChwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSkgLyAyKSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IGNlbnRlclJvdFswXSAqIGNvc0FuZ2xlIC0gY2VudGVyUm90WzFdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyWSA9IGNlbnRlclJvdFsxXSAqIGNvc0FuZ2xlICsgY2VudGVyUm90WzBdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDb25zdHJhaW5lZENlbnRlcihbY2VudGVyWCwgY2VudGVyWV0sIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayA/IG9wdGlvbnMuY2FsbGJhY2sgOiBWT0lEO1xuXG4gICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRlSW50ZXJuYWwoXG4gICAgICAgIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IGNlbnRlcjtcbiAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oZmFsc2UsIHRydWUpO1xuICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDZW50ZXIgb24gY29vcmRpbmF0ZSBhbmQgdmlldyBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIEJveCBwaXhlbCBzaXplLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBvc2l0aW9uIFBvc2l0aW9uIG9uIHRoZSB2aWV3IHRvIGNlbnRlciBvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgY2VudGVyT24oY29vcmRpbmF0ZSwgc2l6ZSwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmNlbnRlck9uSW50ZXJuYWwoXG4gICAgICBmcm9tVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpLFxuICAgICAgc2l6ZSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgQm94IHBpeGVsIHNpemUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcG9zaXRpb24gUG9zaXRpb24gb24gdGhlIHZpZXcgdG8gY2VudGVyIG9uLlxuICAgKi9cbiAgY2VudGVyT25JbnRlcm5hbChjb29yZGluYXRlLCBzaXplLCBwb3NpdGlvbikge1xuICAgIHRoaXMuc2V0Q2VudGVySW50ZXJuYWwoXG4gICAgICBjYWxjdWxhdGVDZW50ZXJPbihcbiAgICAgICAgY29vcmRpbmF0ZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHRoaXMuZ2V0UmVzb2x1dGlvbigpLFxuICAgICAgICB0aGlzLmdldFJvdGF0aW9uKClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHNoaWZ0IGJldHdlZW4gbWFwIGFuZCB2aWV3cG9ydCBjZW50ZXIuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gQ2VudGVyIHNoaWZ0LlxuICAgKi9cbiAgY2FsY3VsYXRlQ2VudGVyU2hpZnQoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSkge1xuICAgIGxldCBjZW50ZXJTaGlmdDtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICBpZiAocGFkZGluZyAmJiBjZW50ZXIpIHtcbiAgICAgIGNvbnN0IHJlZHVjZWRTaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKC1yb3RhdGlvbik7XG4gICAgICBjb25zdCBzaGlmdGVkQ2VudGVyID0gY2FsY3VsYXRlQ2VudGVyT24oXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgW3JlZHVjZWRTaXplWzBdIC8gMiArIHBhZGRpbmdbM10sIHJlZHVjZWRTaXplWzFdIC8gMiArIHBhZGRpbmdbMF1dLFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICByb3RhdGlvblxuICAgICAgKTtcbiAgICAgIGNlbnRlclNoaWZ0ID0gW1xuICAgICAgICBjZW50ZXJbMF0gLSBzaGlmdGVkQ2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJbMV0gLSBzaGlmdGVkQ2VudGVyWzFdLFxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbnRlclNoaWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGRlZmluZWQuXG4gICAqL1xuICBpc0RlZigpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldENlbnRlckludGVybmFsKCkgJiYgdGhpcy5nZXRSZXNvbHV0aW9uKCkgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHJlbGF0aXZlIGNvb3JkaW5hdGVzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcuIEFueSBleHRlbnQgY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkZWx0YUNvb3JkaW5hdGVzIFJlbGF0aXZlIHZhbHVlIHRvIGFkZC5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRqdXN0Q2VudGVyKGRlbHRhQ29vcmRpbmF0ZXMpIHtcbiAgICBjb25zdCBjZW50ZXIgPSB0b1VzZXJDb29yZGluYXRlKHRoaXMudGFyZ2V0Q2VudGVyXywgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgIHRoaXMuc2V0Q2VudGVyKFtcbiAgICAgIGNlbnRlclswXSArIGRlbHRhQ29vcmRpbmF0ZXNbMF0sXG4gICAgICBjZW50ZXJbMV0gKyBkZWx0YUNvb3JkaW5hdGVzWzFdLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldy4gQW55IGV4dGVudCBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRlbHRhQ29vcmRpbmF0ZXMgUmVsYXRpdmUgdmFsdWUgdG8gYWRkLlxuICAgKi9cbiAgYWRqdXN0Q2VudGVySW50ZXJuYWwoZGVsdGFDb29yZGluYXRlcykge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMudGFyZ2V0Q2VudGVyXztcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFtcbiAgICAgIGNlbnRlclswXSArIGRlbHRhQ29vcmRpbmF0ZXNbMF0sXG4gICAgICBjZW50ZXJbMV0gKyBkZWx0YUNvb3JkaW5hdGVzWzFdLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoZSB2aWV3IHJlc29sdXRpb24gYnkgYSByYXRpbywgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFRoZSByYXRpbyB0byBhcHBseSBvbiB0aGUgdmlldyByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRqdXN0UmVzb2x1dGlvbihyYXRpbywgYW5jaG9yKSB7XG4gICAgYW5jaG9yID0gYW5jaG9yICYmIGZyb21Vc2VyQ29vcmRpbmF0ZShhbmNob3IsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICB0aGlzLmFkanVzdFJlc29sdXRpb25JbnRlcm5hbChyYXRpbywgYW5jaG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGUgdmlldyByZXNvbHV0aW9uIGJ5IGEgcmF0aW8sIG9wdGlvbmFsbHkgdXNpbmcgYW4gYW5jaG9yLiBBbnkgcmVzb2x1dGlvblxuICAgKiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyBUaGUgcmF0aW8gdG8gYXBwbHkgb24gdGhlIHZpZXcgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAqL1xuICBhZGp1c3RSZXNvbHV0aW9uSW50ZXJuYWwocmF0aW8sIGFuY2hvcikge1xuICAgIGNvbnN0IGlzTW92aW5nID0gdGhpcy5nZXRBbmltYXRpbmcoKSB8fCB0aGlzLmdldEludGVyYWN0aW5nKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyh0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgIGNvbnN0IG5ld1Jlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uXyAqIHJhdGlvLFxuICAgICAgMCxcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZ1xuICAgICk7XG5cbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclpvb20obmV3UmVzb2x1dGlvbiwgYW5jaG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fICo9IHJhdGlvO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIHZpZXcgem9vbSBsZXZlbCwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFJlbGF0aXZlIHZhbHVlIHRvIGFkZCB0byB0aGUgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFpvb20oZGVsdGEsIGFuY2hvcikge1xuICAgIHRoaXMuYWRqdXN0UmVzb2x1dGlvbihNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCAtZGVsdGEpLCBhbmNob3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgdmlldyByb3RhdGlvbiwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByb3RhdGlvblxuICAgKiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBSZWxhdGl2ZSB2YWx1ZSB0byBhZGQgdG8gdGhlIHpvb20gcm90YXRpb24sIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFJvdGF0aW9uKGRlbHRhLCBhbmNob3IpIHtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBmcm9tVXNlckNvb3JkaW5hdGUoYW5jaG9yLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgUmVsYXRpdmUgdmFsdWUgdG8gYWRkIHRvIHRoZSB6b29tIHJvdGF0aW9uLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKi9cbiAgYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKSB7XG4gICAgY29uc3QgaXNNb3ZpbmcgPSB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKTtcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gKyBkZWx0YSxcbiAgICAgIGlzTW92aW5nXG4gICAgKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclJvdGF0ZShuZXdSb3RhdGlvbiwgYW5jaG9yKTtcbiAgICB9XG4gICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gKz0gZGVsdGE7XG4gICAgdGhpcy5hcHBseVRhcmdldFN0YXRlXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIG9mIHRoZSBjdXJyZW50IHZpZXcuIEFueSBleHRlbnQgY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENlbnRlcihjZW50ZXIpIHtcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFxuICAgICAgY2VudGVyID8gZnJvbVVzZXJDb29yZGluYXRlKGNlbnRlciwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpIDogY2VudGVyXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciB1c2luZyB0aGUgdmlldyBwcm9qZWN0aW9uIChub3QgdGhlIHVzZXIgcHJvamVjdGlvbikuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICovXG4gIHNldENlbnRlckludGVybmFsKGNlbnRlcikge1xuICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IGNlbnRlcjtcbiAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1ZpZXdIaW50LmpzXCIpLmRlZmF1bHR9IGhpbnQgSGludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyB2YWx1ZS5cbiAgICovXG4gIHNldEhpbnQoaGludCwgZGVsdGEpIHtcbiAgICB0aGlzLmhpbnRzX1toaW50XSArPSBkZWx0YTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICByZXR1cm4gdGhpcy5oaW50c19baGludF07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXNvbHV0aW9uIGZvciB0aGlzIHZpZXcuIEFueSByZXNvbHV0aW9uIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByb3RhdGlvbiBmb3IgdGhpcyB2aWV3LiBBbnkgcm90YXRpb24gY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gVGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3IGluIHJhZGlhbnMuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogWm9vbSB0byBhIHNwZWNpZmljIHpvb20gbGV2ZWwuIEFueSByZXNvbHV0aW9uIGNvbnN0cmFpbiB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRab29tKHpvb20pIHtcbiAgICB0aGlzLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbSh6b29tKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb21wdXRlIHJvdGF0aW9uL3Jlc29sdXRpb24vY2VudGVyIGJhc2VkIG9uIHRhcmdldCB2YWx1ZXMuXG4gICAqIE5vdGU6IHdlIGhhdmUgdG8gY29tcHV0ZSByb3RhdGlvbiBmaXJzdCwgdGhlbiByZXNvbHV0aW9uIGFuZCBjZW50ZXIgY29uc2lkZXJpbmcgdGhhdFxuICAgKiBwYXJhbWV0ZXJzIGNhbiBpbmZsdWVuY2Ugb25lIGFub3RoZXIgaW4gY2FzZSBhIHZpZXcgZXh0ZW50IGNvbnN0cmFpbnQgaXMgcHJlc2VudC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RDYW5jZWxBbmltc10gRG8gbm90IGNhbmNlbCBhbmltYXRpb25zLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZU1vdmluZ10gQXBwbHkgY29uc3RyYWludHMgYXMgaWYgdGhlIHZpZXcgaXMgbW92aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXBwbHlUYXJnZXRTdGF0ZV8oZG9Ob3RDYW5jZWxBbmltcywgZm9yY2VNb3ZpbmcpIHtcbiAgICBjb25zdCBpc01vdmluZyA9XG4gICAgICB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKSB8fCBmb3JjZU1vdmluZztcblxuICAgIC8vIGNvbXB1dGUgcm90YXRpb25cbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8sXG4gICAgICBpc01vdmluZ1xuICAgICk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgMCxcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZ1xuICAgICk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGhpcy50YXJnZXRDZW50ZXJfLFxuICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZyxcbiAgICAgIHRoaXMuY2FsY3VsYXRlQ2VudGVyU2hpZnQoXG4gICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgICAgbmV3Um90YXRpb24sXG4gICAgICAgIHNpemVcbiAgICAgIClcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5ST1RBVElPTikgIT09IG5ld1JvdGF0aW9uKSB7XG4gICAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUk9UQVRJT04sIG5ld1JvdGF0aW9uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OKSAhPT0gbmV3UmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIG5ld1Jlc29sdXRpb24pO1xuICAgICAgdGhpcy5zZXQoJ3pvb20nLCB0aGlzLmdldFpvb20oKSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFuZXdDZW50ZXIgfHxcbiAgICAgICF0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSwgbmV3Q2VudGVyKVxuICAgICkge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUiwgbmV3Q2VudGVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSAmJiAhZG9Ob3RDYW5jZWxBbmltcykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIHRoaXMuY2FuY2VsQW5jaG9yXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhbnkgY29uc3RyYWludHMgbmVlZCB0byBiZSBhcHBsaWVkLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgb24gaW50ZXJhY3Rpb24gZW5kLlxuICAgKiBOb3RlOiBjYWxsaW5nIHRoaXMgd2l0aCBhIGR1cmF0aW9uIG9mIDAgd2lsbCBhcHBseSB0aGUgY29uc3RyYWluZWQgdmFsdWVzIHN0cmFpZ2h0IGF3YXksXG4gICAqIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25EaXJlY3Rpb25dIFdoaWNoIGRpcmVjdGlvbiB0byB6b29tLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICovXG4gIHJlc29sdmVDb25zdHJhaW50cyhkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiAyMDA7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gcmVzb2x1dGlvbkRpcmVjdGlvbiB8fCAwO1xuXG4gICAgY29uc3QgbmV3Um90YXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yb3RhdGlvbih0aGlzLnRhcmdldFJvdGF0aW9uXyk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgc2l6ZVxuICAgICk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGhpcy50YXJnZXRDZW50ZXJfLFxuICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgIHNpemUsXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMuY2FsY3VsYXRlQ2VudGVyU2hpZnQoXG4gICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgICAgbmV3Um90YXRpb24sXG4gICAgICAgIHNpemVcbiAgICAgIClcbiAgICApO1xuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwICYmICF0aGlzLmNhbmNlbEFuY2hvcl8pIHtcbiAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbl8gPSBuZXdSZXNvbHV0aW9uO1xuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSBuZXdSb3RhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IG5ld0NlbnRlcjtcbiAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmNob3IgPSBhbmNob3IgfHwgKGR1cmF0aW9uID09PSAwID8gdGhpcy5jYW5jZWxBbmNob3JfIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmdldFJlc29sdXRpb24oKSAhPT0gbmV3UmVzb2x1dGlvbiB8fFxuICAgICAgdGhpcy5nZXRSb3RhdGlvbigpICE9PSBuZXdSb3RhdGlvbiB8fFxuICAgICAgIXRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldENlbnRlckludGVybmFsKCksIG5ld0NlbnRlcilcbiAgICApIHtcbiAgICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICAgIHJvdGF0aW9uOiBuZXdSb3RhdGlvbixcbiAgICAgICAgY2VudGVyOiBuZXdDZW50ZXIsXG4gICAgICAgIHJlc29sdXRpb246IG5ld1Jlc29sdXRpb24sXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIFZpZXcgdGhhdCBhbiBpbnRlcmFjdGlvbiBoYXMgc3RhcnRlZC5cbiAgICogVGhlIHZpZXcgc3RhdGUgd2lsbCBiZSByZXNvbHZlZCB0byBhIHN0YWJsZSBvbmUgaWYgbmVlZGVkXG4gICAqIChkZXBlbmRpbmcgb24gaXRzIGNvbnN0cmFpbnRzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgYmVnaW5JbnRlcmFjdGlvbigpIHtcbiAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcblxuICAgIHRoaXMuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBlbmRJbnRlcmFjdGlvbihkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgYW5jaG9yID0gYW5jaG9yICYmIGZyb21Vc2VyQ29vcmRpbmF0ZShhbmNob3IsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICB0aGlzLmVuZEludGVyYWN0aW9uSW50ZXJuYWwoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKi9cbiAgZW5kSW50ZXJhY3Rpb25JbnRlcm5hbChkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgaWYgKCF0aGlzLmdldEludGVyYWN0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdmFsaWQgcG9zaXRpb24gZm9yIHRoZSB2aWV3IGNlbnRlciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29uc3RyYWludHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlciBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0YXJnZXRSZXNvbHV0aW9uXSBUYXJnZXQgcmVzb2x1dGlvbi4gSWYgbm90IHN1cHBsaWVkLCB0aGUgY3VycmVudCBvbmUgd2lsbCBiZSB1c2VkLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBndWVzcyBhIHZhbGlkIGNlbnRlciBwb3NpdGlvbiBhdCBhIGRpZmZlcmVudCB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IFZhbGlkIGNlbnRlciBwb3NpdGlvbi5cbiAgICovXG4gIGdldENvbnN0cmFpbmVkQ2VudGVyKHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbikge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8odGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGFyZ2V0Q2VudGVyLFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvbiB8fCB0aGlzLmdldFJlc29sdXRpb24oKSxcbiAgICAgIHNpemVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHZhbGlkIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHZpZXcgY29uc3RyYWludHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gdGFyZ2V0Wm9vbSBUYXJnZXQgem9vbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkaXJlY3Rpb249MF0gSW5kaWNhdGUgd2hpY2ggcmVzb2x1dGlvbiBzaG91bGQgYmUgdXNlZFxuICAgKiBieSBhIHJlbmRlcmVyIGlmIHRoZSB2aWV3IHJlc29sdXRpb24gZG9lcyBub3QgbWF0Y2ggYW55IHJlc29sdXRpb24gb2YgdGhlIHRpbGUgc291cmNlLlxuICAgKiBJZiAwLCB0aGUgbmVhcmVzdCByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC4gSWYgMSwgdGhlIG5lYXJlc3QgbG93ZXIgcmVzb2x1dGlvblxuICAgKiB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGUgbmVhcmVzdCBoaWdoZXIgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFZhbGlkIHpvb20gbGV2ZWwuXG4gICAqL1xuICBnZXRDb25zdHJhaW5lZFpvb20odGFyZ2V0Wm9vbSwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0UmVzID0gdGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbSh0YXJnZXRab29tKTtcbiAgICByZXR1cm4gdGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbihcbiAgICAgIHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRhcmdldFJlcywgZGlyZWN0aW9uKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdmFsaWQgcmVzb2x1dGlvbiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmlldyBjb25zdHJhaW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RpcmVjdGlvbj0wXSBJbmRpY2F0ZSB3aGljaCByZXNvbHV0aW9uIHNob3VsZCBiZSB1c2VkXG4gICAqIGJ5IGEgcmVuZGVyZXIgaWYgdGhlIHZpZXcgcmVzb2x1dGlvbiBkb2VzIG5vdCBtYXRjaCBhbnkgcmVzb2x1dGlvbiBvZiB0aGUgdGlsZSBzb3VyY2UuXG4gICAqIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAxLCB0aGUgbmVhcmVzdCBsb3dlciByZXNvbHV0aW9uXG4gICAqIHdpbGwgYmUgdXNlZC4gSWYgLTEsIHRoZSBuZWFyZXN0IGhpZ2hlciByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVmFsaWQgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0YXJnZXRSZXNvbHV0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgMDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG5cbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18ucmVzb2x1dGlvbih0YXJnZXRSZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0geyp9IHJldHVyblZhbHVlIFJldHVybiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHJldHVyblZhbHVlKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKHJldHVyblZhbHVlKTtcbiAgfSwgMCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2NlbnRlcmNvbnN0cmFpbnQuanNcIikuVHlwZX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDZW50ZXJDb25zdHJhaW50KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzbW9vdGggPVxuICAgICAgb3B0aW9ucy5zbW9vdGhFeHRlbnRDb25zdHJhaW50ICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnNtb290aEV4dGVudENvbnN0cmFpbnRcbiAgICAgICAgOiB0cnVlO1xuICAgIHJldHVybiBjcmVhdGVFeHRlbnQob3B0aW9ucy5leHRlbnQsIG9wdGlvbnMuY29uc3RyYWluT25seUNlbnRlciwgc21vb3RoKTtcbiAgfVxuXG4gIGNvbnN0IHByb2plY3Rpb24gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuICBpZiAob3B0aW9ucy5tdWx0aVdvcmxkICE9PSB0cnVlICYmIHByb2plY3Rpb24uaXNHbG9iYWwoKSkge1xuICAgIGNvbnN0IGV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCkuc2xpY2UoKTtcbiAgICBleHRlbnRbMF0gPSAtSW5maW5pdHk7XG4gICAgZXh0ZW50WzJdID0gSW5maW5pdHk7XG4gICAgcmV0dXJuIGNyZWF0ZUV4dGVudChleHRlbnQsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gY2VudGVyTm9uZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge3tjb25zdHJhaW50OiBpbXBvcnQoXCIuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGUsIG1heFJlc29sdXRpb246IG51bWJlcixcbiAqICAgICBtaW5SZXNvbHV0aW9uOiBudW1iZXIsIG1pblpvb206IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyfX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHV0aW9uQ29uc3RyYWludChvcHRpb25zKSB7XG4gIGxldCByZXNvbHV0aW9uQ29uc3RyYWludDtcbiAgbGV0IG1heFJlc29sdXRpb247XG4gIGxldCBtaW5SZXNvbHV0aW9uO1xuXG4gIC8vIFRPRE86IG1vdmUgdGhlc2UgdG8gYmUgb2wgY29uc3RhbnRzXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2lzc3Vlcy8yMDc2XG4gIGNvbnN0IGRlZmF1bHRNYXhab29tID0gMjg7XG4gIGNvbnN0IGRlZmF1bHRab29tRmFjdG9yID0gMjtcblxuICBsZXQgbWluWm9vbSA9XG4gICAgb3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblpvb20gOiBERUZBVUxUX01JTl9aT09NO1xuXG4gIGxldCBtYXhab29tID1cbiAgICBvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4Wm9vbSA6IGRlZmF1bHRNYXhab29tO1xuXG4gIGNvbnN0IHpvb21GYWN0b3IgPVxuICAgIG9wdGlvbnMuem9vbUZhY3RvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tRmFjdG9yIDogZGVmYXVsdFpvb21GYWN0b3I7XG5cbiAgY29uc3QgbXVsdGlXb3JsZCA9XG4gICAgb3B0aW9ucy5tdWx0aVdvcmxkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm11bHRpV29ybGQgOiBmYWxzZTtcblxuICBjb25zdCBzbW9vdGggPVxuICAgIG9wdGlvbnMuc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLnNtb290aFJlc29sdXRpb25Db25zdHJhaW50XG4gICAgICA6IHRydWU7XG5cbiAgY29uc3Qgc2hvd0Z1bGxFeHRlbnQgPVxuICAgIG9wdGlvbnMuc2hvd0Z1bGxFeHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2hvd0Z1bGxFeHRlbnQgOiBmYWxzZTtcblxuICBjb25zdCBwcm9qZWN0aW9uID0gY3JlYXRlUHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24sICdFUFNHOjM4NTcnKTtcbiAgY29uc3QgcHJvakV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGxldCBjb25zdHJhaW5Pbmx5Q2VudGVyID0gb3B0aW9ucy5jb25zdHJhaW5Pbmx5Q2VudGVyO1xuICBsZXQgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQ7XG4gIGlmICghbXVsdGlXb3JsZCAmJiAhZXh0ZW50ICYmIHByb2plY3Rpb24uaXNHbG9iYWwoKSkge1xuICAgIGNvbnN0cmFpbk9ubHlDZW50ZXIgPSBmYWxzZTtcbiAgICBleHRlbnQgPSBwcm9qRXh0ZW50O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHJlc29sdXRpb25zID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgICBtYXhSZXNvbHV0aW9uID0gcmVzb2x1dGlvbnNbbWluWm9vbV07XG4gICAgbWluUmVzb2x1dGlvbiA9XG4gICAgICByZXNvbHV0aW9uc1ttYXhab29tXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVzb2x1dGlvbnNbbWF4Wm9vbV1cbiAgICAgICAgOiByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24pIHtcbiAgICAgIHJlc29sdXRpb25Db25zdHJhaW50ID0gY3JlYXRlU25hcFRvUmVzb2x1dGlvbnMoXG4gICAgICAgIHJlc29sdXRpb25zLFxuICAgICAgICBzbW9vdGgsXG4gICAgICAgICFjb25zdHJhaW5Pbmx5Q2VudGVyICYmIGV4dGVudCxcbiAgICAgICAgc2hvd0Z1bGxFeHRlbnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdXRpb25Db25zdHJhaW50ID0gY3JlYXRlTWluTWF4UmVzb2x1dGlvbihcbiAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgbWluUmVzb2x1dGlvbixcbiAgICAgICAgc21vb3RoLFxuICAgICAgICAhY29uc3RyYWluT25seUNlbnRlciAmJiBleHRlbnQsXG4gICAgICAgIHNob3dGdWxsRXh0ZW50XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRlZmF1bHQgbWluIGFuZCBtYXggcmVzb2x1dGlvblxuICAgIGNvbnN0IHNpemUgPSAhcHJvakV4dGVudFxuICAgICAgPyAvLyB1c2UgYW4gZXh0ZW50IHRoYXQgY2FuIGZpdCB0aGUgd2hvbGUgd29ybGQgaWYgbmVlZCBiZVxuICAgICAgICAoMzYwICogTUVURVJTX1BFUl9VTklULmRlZ3JlZXMpIC8gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KClcbiAgICAgIDogTWF0aC5tYXgoZ2V0V2lkdGgocHJvakV4dGVudCksIGdldEhlaWdodChwcm9qRXh0ZW50KSk7XG5cbiAgICBjb25zdCBkZWZhdWx0TWF4UmVzb2x1dGlvbiA9XG4gICAgICBzaXplIC8gREVGQVVMVF9USUxFX1NJWkUgLyBNYXRoLnBvdyhkZWZhdWx0Wm9vbUZhY3RvciwgREVGQVVMVF9NSU5fWk9PTSk7XG5cbiAgICBjb25zdCBkZWZhdWx0TWluUmVzb2x1dGlvbiA9XG4gICAgICBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvXG4gICAgICBNYXRoLnBvdyhkZWZhdWx0Wm9vbUZhY3RvciwgZGVmYXVsdE1heFpvb20gLSBERUZBVUxUX01JTl9aT09NKTtcblxuICAgIC8vIHVzZXIgcHJvdmlkZWQgbWF4UmVzb2x1dGlvbiB0YWtlcyBwcmVjZWRlbmNlXG4gICAgbWF4UmVzb2x1dGlvbiA9IG9wdGlvbnMubWF4UmVzb2x1dGlvbjtcbiAgICBpZiAobWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5ab29tID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4UmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWluWm9vbSk7XG4gICAgfVxuXG4gICAgLy8gdXNlciBwcm92aWRlZCBtaW5SZXNvbHV0aW9uIHRha2VzIHByZWNlZGVuY2VcbiAgICBtaW5SZXNvbHV0aW9uID0gb3B0aW9ucy5taW5SZXNvbHV0aW9uO1xuICAgIGlmIChtaW5SZXNvbHV0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtaW5SZXNvbHV0aW9uID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pblJlc29sdXRpb24gPSBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1pblJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2l2ZW4gZGlzY3JldGUgem9vbSBsZXZlbHMsIG1pblJlc29sdXRpb24gbWF5IGJlIGRpZmZlcmVudCB0aGFuIHByb3ZpZGVkXG4gICAgbWF4Wm9vbSA9XG4gICAgICBtaW5ab29tICtcbiAgICAgIE1hdGguZmxvb3IoXG4gICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIE1hdGgubG9nKHpvb21GYWN0b3IpXG4gICAgICApO1xuICAgIG1pblJlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSAtIG1pblpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbikge1xuICAgICAgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVTbmFwVG9Qb3dlcihcbiAgICAgICAgem9vbUZhY3RvcixcbiAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgbWluUmVzb2x1dGlvbixcbiAgICAgICAgc21vb3RoLFxuICAgICAgICAhY29uc3RyYWluT25seUNlbnRlciAmJiBleHRlbnQsXG4gICAgICAgIHNob3dGdWxsRXh0ZW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZU1pbk1heFJlc29sdXRpb24oXG4gICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgIG1pblJlc29sdXRpb24sXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgIWNvbnN0cmFpbk9ubHlDZW50ZXIgJiYgZXh0ZW50LFxuICAgICAgICBzaG93RnVsbEV4dGVudFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25zdHJhaW50OiByZXNvbHV0aW9uQ29uc3RyYWludCxcbiAgICBtYXhSZXNvbHV0aW9uOiBtYXhSZXNvbHV0aW9uLFxuICAgIG1pblJlc29sdXRpb246IG1pblJlc29sdXRpb24sXG4gICAgbWluWm9vbTogbWluWm9vbSxcbiAgICB6b29tRmFjdG9yOiB6b29tRmFjdG9yLFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG9wdGlvbnMgVmlldyBvcHRpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9yb3RhdGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdGF0aW9uQ29uc3RyYWludChvcHRpb25zKSB7XG4gIGNvbnN0IGVuYWJsZVJvdGF0aW9uID1cbiAgICBvcHRpb25zLmVuYWJsZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmVuYWJsZVJvdGF0aW9uIDogdHJ1ZTtcbiAgaWYgKGVuYWJsZVJvdGF0aW9uKSB7XG4gICAgY29uc3QgY29uc3RyYWluUm90YXRpb24gPSBvcHRpb25zLmNvbnN0cmFpblJvdGF0aW9uO1xuICAgIGlmIChjb25zdHJhaW5Sb3RhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGNvbnN0cmFpblJvdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU25hcFRvWmVybygpO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWluUm90YXRpb24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcm90YXRpb25Ob25lO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpblJvdGF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNuYXBUb04oY29uc3RyYWluUm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcm90YXRpb25Ob25lO1xuICB9XG4gIHJldHVybiBkaXNhYmxlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBhbmltYXRpb24gaW52b2x2ZXMgbm8gdmlldyBjaGFuZ2UuXG4gKiBAcGFyYW0ge0FuaW1hdGlvbn0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgYW5pbWF0aW9uIGludm9sdmVzIG5vIHZpZXcgY2hhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICBpZiAoYW5pbWF0aW9uLnNvdXJjZUNlbnRlciAmJiBhbmltYXRpb24udGFyZ2V0Q2VudGVyKSB7XG4gICAgaWYgKCFjb29yZGluYXRlc0VxdWFsKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIsIGFuaW1hdGlvbi50YXJnZXRDZW50ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiAhPT0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiAhPT0gYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgQm94IHBpeGVsIHNpemUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBvc2l0aW9uIFBvc2l0aW9uIG9uIHRoZSB2aWV3IHRvIGNlbnRlciBvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gU2hpZnRlZCBjZW50ZXIuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNlbnRlck9uKGNvb3JkaW5hdGUsIHNpemUsIHBvc2l0aW9uLCByZXNvbHV0aW9uLCByb3RhdGlvbikge1xuICAvLyBjYWxjdWxhdGUgcm90YXRlZCBwb3NpdGlvblxuICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKC1yb3RhdGlvbik7XG4gIGxldCBzaW5BbmdsZSA9IE1hdGguc2luKC1yb3RhdGlvbik7XG4gIGxldCByb3RYID0gY29vcmRpbmF0ZVswXSAqIGNvc0FuZ2xlIC0gY29vcmRpbmF0ZVsxXSAqIHNpbkFuZ2xlO1xuICBsZXQgcm90WSA9IGNvb3JkaW5hdGVbMV0gKiBjb3NBbmdsZSArIGNvb3JkaW5hdGVbMF0gKiBzaW5BbmdsZTtcbiAgcm90WCArPSAoc2l6ZVswXSAvIDIgLSBwb3NpdGlvblswXSkgKiByZXNvbHV0aW9uO1xuICByb3RZICs9IChwb3NpdGlvblsxXSAtIHNpemVbMV0gLyAyKSAqIHJlc29sdXRpb247XG5cbiAgLy8gZ28gYmFjayB0byBvcmlnaW5hbCBhbmdsZVxuICBzaW5BbmdsZSA9IC1zaW5BbmdsZTsgLy8gZ28gYmFjayB0byBvcmlnaW5hbCByb3RhdGlvblxuICBjb25zdCBjZW50ZXJYID0gcm90WCAqIGNvc0FuZ2xlIC0gcm90WSAqIHNpbkFuZ2xlO1xuICBjb25zdCBjZW50ZXJZID0gcm90WSAqIGNvc0FuZ2xlICsgcm90WCAqIHNpbkFuZ2xlO1xuXG4gIHJldHVybiBbY2VudGVyWCwgY2VudGVyWV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXc7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0xheWVyXG4gKi9cbmltcG9ydCBCYXNlTGF5ZXIgZnJvbSAnLi9CYXNlLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTGF5ZXJQcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuLi9WaWV3LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZSk6SFRNTEVsZW1lbnR9IFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3NvdXJjZXJlYWR5J3wnY2hhbmdlOnNvdXJjZSd9IExheWVyRXZlbnRUeXBlXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9CYXNlXCIpLkJhc2VMYXllck9iamVjdEV2ZW50VHlwZXN8XG4gKiAgICAgTGF5ZXJFdmVudFR5cGUsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5MYXllclJlbmRlckV2ZW50VHlwZXMsIGltcG9ydChcIi4uL3JlbmRlci9FdmVudFwiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3xMYXllckV2ZW50VHlwZXxcbiAqICAgICBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlXCIpLkxheWVyUmVuZGVyRXZlbnRUeXBlcywgUmV0dXJuPn0gTGF5ZXJPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9IFtTb3VyY2VUeXBlPWltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdF1cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1sYXllciddIEEgQ1NTIGNsYXNzIG5hbWUgdG8gc2V0IHRvIHRoZSBsYXllciBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIFRoZSBtaW5pbXVtIHZpZXcgem9vbSBsZXZlbCAoZXhjbHVzaXZlKSBhYm92ZSB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIFRoZSBtYXhpbXVtIHZpZXcgem9vbSBsZXZlbCAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge1NvdXJjZVR5cGV9IFtzb3VyY2VdIFNvdXJjZSBmb3IgdGhpcyBsYXllci4gIElmIG5vdCBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IsXG4gKiB0aGUgc291cmNlIGNhbiBiZSBzZXQgYnkgY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyI3NldFNvdXJjZSBsYXllci5zZXRTb3VyY2Uoc291cmNlKX0gYWZ0ZXJcbiAqIGNvbnN0cnVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gW21hcF0gTWFwLlxuICogQHByb3BlcnR5IHtSZW5kZXJGdW5jdGlvbn0gW3JlbmRlcl0gUmVuZGVyIGZ1bmN0aW9uLiBUYWtlcyB0aGUgZnJhbWUgc3RhdGUgYXMgaW5wdXQgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhblxuICogSFRNTCBlbGVtZW50LiBXaWxsIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCByZW5kZXJpbmcgZm9yIHRoZSBsYXllci5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eSwgdGhlIHZhbHVlIGlzIHJvdW5kZWQgdG8gdHdvIGRpZ2l0cyB0byBhcHBlYXIgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpc2libGUgVmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFuYWdlZCBNYW5hZ2VkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlciB8IHVuZGVmaW5lZH0gekluZGV4IFpJbmRleC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIE1heGltdW0gcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIE1pbmltdW0gcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5ab29tIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhab29tIE1heGltdW0gem9vbS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZnJvbSB3aGljaCBhbGwgbGF5ZXIgdHlwZXMgYXJlIGRlcml2ZWQuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW5zdGFudGlhdGVkXG4gKiBpbiB0aGUgY2FzZSB3aGVyZSBhIGN1c3RvbSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwIHdpdGggYSBjdXN0b20gYHJlbmRlcmAgZnVuY3Rpb24uXG4gKiBTdWNoIGEgZnVuY3Rpb24gY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgcmFzdGVyIG9yIHZlY3RvciBtYXAgZGF0YS5cbiAqIExheWVycyBncm91cCB0b2dldGhlciB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgcGVydGFpbiB0byBob3cgdGhlIGRhdGEgaXMgdG8gYmVcbiAqIGRpc3BsYXllZCwgaXJyZXNwZWN0aXZlIG9mIHRoZSBzb3VyY2Ugb2YgdGhhdCBkYXRhLlxuICpcbiAqIExheWVycyBhcmUgdXN1YWxseSBhZGRlZCB0byBhIG1hcCB3aXRoIFttYXAuYWRkTGF5ZXIoKV17QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHQjYWRkTGF5ZXJ9LlxuICogQ29tcG9uZW50cyBsaWtlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3fSB1c2UgdW5tYW5hZ2VkIGxheWVyc1xuICogaW50ZXJuYWxseS4gVGhlc2UgdW5tYW5hZ2VkIGxheWVycyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAgdXNpbmdcbiAqIFtsYXllci5zZXRNYXAoKV17QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyI3NldE1hcH0gaW5zdGVhZC5cbiAqXG4gKiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSBjaGFuZ2VzLlxuICogQSBgc291cmNlcmVhZHlgIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGxheWVyJ3Mgc291cmNlIGlzIHJlYWR5LlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnQuanNcIikuUmVuZGVyRXZlbnQjcHJlcmVuZGVyXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLlJlbmRlckV2ZW50I3Bvc3RyZW5kZXJcbiAqIEBmaXJlcyBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuQmFzZUV2ZW50I3NvdXJjZXJlYWR5XG4gKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9IFtTb3VyY2VUeXBlPWltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdF1cbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vcmVuZGVyZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gW1JlbmRlcmVyVHlwZT1pbXBvcnQoXCIuLi9yZW5kZXJlci9MYXllci5qc1wiKS5kZWZhdWx0XVxuICogQGFwaVxuICovXG5jbGFzcyBMYXllciBleHRlbmRzIEJhc2VMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM8U291cmNlVHlwZT59IG9wdGlvbnMgTGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBiYXNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5zb3VyY2U7XG5cbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0xheWVyT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7TGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0xheWVyT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJlclR5cGV9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVJlYWR5XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIE92ZXJ3cml0ZSBkZWZhdWx0IHJlbmRlciBtZXRob2Qgd2l0aCBhIGN1c3RvbSBvbmVcbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWFwKSB7XG4gICAgICB0aGlzLnNldE1hcChvcHRpb25zLm1hcCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihcbiAgICAgIExheWVyUHJvcGVydHkuU09VUkNFLFxuICAgICAgdGhpcy5oYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV9cbiAgICApO1xuXG4gICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy5zb3VyY2VcbiAgICAgID8gLyoqIEB0eXBlIHtTb3VyY2VUeXBlfSAqLyAob3B0aW9ucy5zb3VyY2UpXG4gICAgICA6IG51bGw7XG4gICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IFthcnJheV0gQXJyYXkgb2YgbGF5ZXJzICh0byBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IEFycmF5IG9mIGxheWVycy5cbiAgICovXG4gIGdldExheWVyc0FycmF5KGFycmF5KSB7XG4gICAgYXJyYXkgPSBhcnJheSA/IGFycmF5IDogW107XG4gICAgYXJyYXkucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gW3N0YXRlc10gT3B0aW9uYWwgbGlzdCBvZiBsYXllciBzdGF0ZXMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IExpc3Qgb2YgbGF5ZXIgc3RhdGVzLlxuICAgKi9cbiAgZ2V0TGF5ZXJTdGF0ZXNBcnJheShzdGF0ZXMpIHtcbiAgICBzdGF0ZXMgPSBzdGF0ZXMgPyBzdGF0ZXMgOiBbXTtcbiAgICBzdGF0ZXMucHVzaCh0aGlzLmdldExheWVyU3RhdGUoKSk7XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyIHNvdXJjZS5cbiAgICogQHJldHVybiB7U291cmNlVHlwZXxudWxsfSBUaGUgbGF5ZXIgc291cmNlIChvciBgbnVsbGAgaWYgbm90IHlldCBzZXQpLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7U291cmNlVHlwZX0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuU09VUkNFKSkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTb3VyY2VUeXBlfG51bGx9IFRoZSBzb3VyY2UgYmVpbmcgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRSZW5kZXJTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5TdGF0ZX0gU291cmNlIHN0YXRlLlxuICAgKi9cbiAgZ2V0U291cmNlU3RhdGUoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICByZXR1cm4gIXNvdXJjZSA/ICd1bmRlZmluZWQnIDogc291cmNlLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVNvdXJjZUNoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgaWYgKHRoaXMuc291cmNlUmVhZHlfIHx8IHRoaXMuZ2V0U291cmNlKCkuZ2V0U3RhdGUoKSAhPT0gJ3JlYWR5Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZVJlYWR5XyA9IHRydWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdzb3VyY2VyZWFkeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMuc291cmNlQ2hhbmdlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnNvdXJjZUNoYW5nZUtleV8pO1xuICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VSZWFkeV8gPSBmYWxzZTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IGxpc3RlbihcbiAgICAgICAgc291cmNlLFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVNvdXJjZUNoYW5nZV8sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBpZiAoc291cmNlLmdldFN0YXRlKCkgPT09ICdyZWFkeScpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VSZWFkeV8gPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3NvdXJjZXJlYWR5Jyk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlXCIpLkZlYXR1cmVMaWtlPj59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoXG4gICAqIGFuIGFycmF5IG9mIGZlYXR1cmVzLlxuICAgKi9cbiAgZ2V0RmVhdHVyZXMocGl4ZWwpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXJfKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmdldEZlYXR1cmVzKHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheXxGbG9hdDMyQXJyYXl8RGF0YVZpZXd8bnVsbH0gUGl4ZWwgZGF0YS5cbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXJfIHx8ICF0aGlzLnJlbmRlcmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmdldERhdGEocGl4ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYXllciBpcyB2aXNpYmxlIG9uIHRoZSBtYXAgdmlldywgaS5lLiB3aXRoaW4gaXRzIG1pbi9tYXggcmVzb2x1dGlvbiBvciB6b29tIGFuZFxuICAgKiBleHRlbnQsIG5vdCBzZXQgdG8gYHZpc2libGU6IGZhbHNlYCwgYW5kIG5vdCBpbnNpZGUgYSBsYXllciBncm91cCB0aGF0IGlzIHNldFxuICAgKiB0byBgdmlzaWJsZTogZmFsc2VgLlxuICAgKiBAcGFyYW0ge1ZpZXd8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBbdmlld10gVmlldyBvciB7QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LlxuICAgKiBPbmx5IHJlcXVpcmVkIHdoZW4gdGhlIGxheWVyIGlzIG5vdCBhZGRlZCB0byBhIG1hcC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGxheWVyIGlzIHZpc2libGUgaW4gdGhlIG1hcCB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBpc1Zpc2libGUodmlldykge1xuICAgIGxldCBmcmFtZVN0YXRlO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwSW50ZXJuYWwoKTtcbiAgICBpZiAoIXZpZXcgJiYgbWFwKSB7XG4gICAgICB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB9XG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBWaWV3KSB7XG4gICAgICBmcmFtZVN0YXRlID0ge1xuICAgICAgICB2aWV3U3RhdGU6IHZpZXcuZ2V0U3RhdGUoKSxcbiAgICAgICAgZXh0ZW50OiB2aWV3LmNhbGN1bGF0ZUV4dGVudCgpLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWVTdGF0ZSA9IHZpZXc7XG4gICAgfVxuICAgIGlmICghZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5ICYmIG1hcCkge1xuICAgICAgZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5ID0gbWFwLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgfVxuICAgIGxldCBsYXllclN0YXRlO1xuICAgIGlmIChmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkpIHtcbiAgICAgIGxheWVyU3RhdGUgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkuZmluZChcbiAgICAgICAgKGxheWVyU3RhdGUpID0+IGxheWVyU3RhdGUubGF5ZXIgPT09IHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyU3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllckV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgaW5WaWV3KGxheWVyU3RhdGUsIGZyYW1lU3RhdGUudmlld1N0YXRlKSAmJlxuICAgICAgKCFsYXllckV4dGVudCB8fCBpbnRlcnNlY3RzKGxheWVyRXh0ZW50LCBmcmFtZVN0YXRlLmV4dGVudCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF0dHJpYnV0aW9ucyBvZiB0aGUgc291cmNlIG9mIHRoaXMgbGF5ZXIgZm9yIHRoZSBnaXZlbiB2aWV3LlxuICAgKiBAcGFyYW0ge1ZpZXd8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBbdmlld10gVmlldyBvciB7QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LlxuICAgKiBPbmx5IHJlcXVpcmVkIHdoZW4gdGhlIGxheWVyIGlzIG5vdCBhZGRlZCB0byBhIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXR0cmlidXRpb25zIGZvciB0aGlzIGxheWVyIGF0IHRoZSBnaXZlbiB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBdHRyaWJ1dGlvbnModmlldykge1xuICAgIGlmICghdGhpcy5pc1Zpc2libGUodmlldykpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGdldEF0dHJpYnV0aW9ucztcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGdldEF0dHJpYnV0aW9ucyA9IHNvdXJjZS5nZXRBdHRyaWJ1dGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKCFnZXRBdHRyaWJ1dGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9XG4gICAgICB2aWV3IGluc3RhbmNlb2YgVmlldyA/IHZpZXcuZ2V0Vmlld1N0YXRlQW5kRXh0ZW50KCkgOiB2aWV3O1xuICAgIGxldCBhdHRyaWJ1dGlvbnMgPSBnZXRBdHRyaWJ1dGlvbnMoZnJhbWVTdGF0ZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9ucykpIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IFthdHRyaWJ1dGlvbnNdO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIGNoYXJnZSB0byBtYW5hZ2UgdGhlIHJlbmRlcmluZyBvZiB0aGUgbGF5ZXIuIE9uZSBsYXllciB0eXBlIGlzXG4gICAqIGJvdW5kZWQgd2l0aCBvbmUgbGF5ZXIgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IHdoaWNoIHRoZSByZW5kZXJlciBtYXkgKGJ1dCBuZWVkIG5vdCkgdXNlXG4gICAqIGZvciByZW5kZXJpbmcgaXRzIGNvbnRlbnQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyKGZyYW1lU3RhdGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGxheWVyUmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCk7XG5cbiAgICBpZiAobGF5ZXJSZW5kZXJlci5wcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSkpIHtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxheWVyUmVuZGVyZXIucmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBsYXllciBpcyBub3QgdmlzaWJsZSBkdXJpbmcgYSBtYXAgcmVuZGVyLlxuICAgKi9cbiAgdW5yZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB1c2UgaW5zaWRlIHRoZSBsaWJyYXJ5IG9ubHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcEludGVybmFsKG1hcCkge1xuICAgIGlmICghbWFwKSB7XG4gICAgICB0aGlzLnVucmVuZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUFQLCBtYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB1c2UgaW5zaWRlIHRoZSBsaWJyYXJ5IG9ubHkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IE1hcC5cbiAgICovXG4gIGdldE1hcEludGVybmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdldChMYXllclByb3BlcnR5Lk1BUCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXIgdG8gYmUgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGxheWVycyBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsXG4gICAqIG5vdCBtYW5hZ2UgdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24uIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciB0ZW1wb3JhcnkgbGF5ZXJzLiBUbyByZW1vdmUgYW4gdW5tYW5hZ2VkIGxheWVyIGZyb20gdGhlIG1hcCxcbiAgICogdXNlIGAjc2V0TWFwKG51bGwpYC5cbiAgICpcbiAgICogVG8gYWRkIHRoZSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAsIHVzZVxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjYWRkTGF5ZXJ9IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcFByZWNvbXBvc2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubWFwUHJlY29tcG9zZUtleV8pO1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICghbWFwKSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwUmVuZGVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFJlbmRlcktleV8pO1xuICAgICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IGxpc3RlbihcbiAgICAgICAgbWFwLFxuICAgICAgICBSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSxcbiAgICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgIGNvbnN0IHJlbmRlckV2ZW50ID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHR9ICovIChldnQpO1xuICAgICAgICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPSByZW5kZXJFdmVudC5mcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZShmYWxzZSk7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgIWxheWVyU3RhdGVzQXJyYXkuc29tZShmdW5jdGlvbiAoYXJyYXlMYXllclN0YXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcnJheUxheWVyU3RhdGUubGF5ZXIgPT09IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdBIGxheWVyIGNhbiBvbmx5IGJlIGFkZGVkIHRvIHRoZSBtYXAgb25jZS4gVXNlIGVpdGhlciBgbGF5ZXIuc2V0TWFwKClgIG9yIGBtYXAuYWRkTGF5ZXIoKWAsIG5vdCBib3RoLidcbiAgICAgICAgICApO1xuICAgICAgICAgIGxheWVyU3RhdGVzQXJyYXkucHVzaChsYXllclN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IGxpc3Rlbih0aGlzLCBFdmVudFR5cGUuQ0hBTkdFLCBtYXAucmVuZGVyLCBtYXApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGF5ZXIgc291cmNlLlxuICAgKiBAcGFyYW0ge1NvdXJjZVR5cGV8bnVsbH0gc291cmNlIFRoZSBsYXllciBzb3VyY2UuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNvdXJjZShzb3VyY2UpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlNPVVJDRSwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlbmRlcmVyIGZvciB0aGlzIGxheWVyLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlclR5cGV8bnVsbH0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgdGhpcy5yZW5kZXJlcl8gPSB0aGlzLmNyZWF0ZVJlbmRlcmVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbGF5ZXIgaGFzIGEgcmVuZGVyZXIuXG4gICAqL1xuICBoYXNSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZW5kZXJlciBmb3IgdGhpcyBsYXllci5cbiAgICogQHJldHVybiB7UmVuZGVyZXJUeXBlfSBBIGxheWVyIHJlbmRlcmVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcl8pIHtcbiAgICAgIHRoaXMucmVuZGVyZXJfLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyXztcbiAgICB9XG5cbiAgICB0aGlzLnNldFNvdXJjZShudWxsKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGxheWVyIGlzIHZpc2libGUgYW5kIGlmIHRoZSBwcm92aWRlZCB2aWV3IHN0YXRlXG4gKiBoYXMgcmVzb2x1dGlvbiBhbmQgem9vbSBsZXZlbHMgdGhhdCBhcmUgaW4gcmFuZ2Ugb2YgdGhlIGxheWVyJ3MgbWluL21heC5cbiAqIEBwYXJhbSB7U3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuU3RhdGV9IHZpZXdTdGF0ZSBWaWV3IHN0YXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGxheWVyIGlzIHZpc2libGUgYXQgdGhlIGdpdmVuIHZpZXcgc3RhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpblZpZXcobGF5ZXJTdGF0ZSwgdmlld1N0YXRlKSB7XG4gIGlmICghbGF5ZXJTdGF0ZS52aXNpYmxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgaWYgKFxuICAgIHJlc29sdXRpb24gPCBsYXllclN0YXRlLm1pblJlc29sdXRpb24gfHxcbiAgICByZXNvbHV0aW9uID49IGxheWVyU3RhdGUubWF4UmVzb2x1dGlvblxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgem9vbSA9IHZpZXdTdGF0ZS56b29tO1xuICByZXR1cm4gem9vbSA+IGxheWVyU3RhdGUubWluWm9vbSAmJiB6b29tIDw9IGxheWVyU3RhdGUubWF4Wm9vbTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9FdmVudFxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuXG5jbGFzcyBSZW5kZXJFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9FdmVudFR5cGUuanNcIikuZGVmYXVsdH0gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IFtpbnZlcnNlUGl4ZWxUcmFuc2Zvcm1dIFRyYW5zZm9ybSBmb3JcbiAgICogICAgIENTUyBwaXhlbHMgdG8gcmVuZGVyZWQgcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBbZnJhbWVTdGF0ZV0gRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7PyhDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8V2ViR0xSZW5kZXJpbmdDb250ZXh0KX0gW2NvbnRleHRdIENvbnRleHQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBpbnZlcnNlUGl4ZWxUcmFuc2Zvcm0sIGZyYW1lU3RhdGUsIGNvbnRleHQpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBmcm9tIENTUyBwaXhlbHMgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIG1hcCB2aWV3cG9ydClcbiAgICAgKiB0byByZW5kZXJlZCBwaXhlbHMgb24gdGhpcyBldmVudCdzIGBjb250ZXh0YC4gT25seSBhdmFpbGFibGUgd2hlbiBhIENhbnZhcyByZW5kZXJlciBpcyB1c2VkLCBudWxsIG90aGVyd2lzZS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybXx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuaW52ZXJzZVBpeGVsVHJhbnNmb3JtID0gaW52ZXJzZVBpeGVsVHJhbnNmb3JtO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByZW5kZXIgZnJhbWUgc3RhdGUuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlID0gZnJhbWVTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENhbnZhcyBjb250ZXh0LiBOb3QgYXZhaWxhYmxlIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQgYnkgdGhlIG1hcC4gRm9yIENhbnZhcyAyRCBsYXllcnMsXG4gICAgICogdGhlIGNvbnRleHQgd2lsbCBiZSB0aGUgMkQgcmVuZGVyaW5nIGNvbnRleHQuICBGb3IgV2ViR0wgbGF5ZXJzLCB0aGUgY29udGV4dCB3aWxsIGJlIHRoZSBXZWJHTFxuICAgICAqIGNvbnRleHQuXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxXZWJHTFJlbmRlcmluZ0NvbnRleHR8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckV2ZW50O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jc3NcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZvbnRQYXJhbWV0ZXJzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3R5bGUgU3R5bGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmFyaWFudCBWYXJpYW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHdlaWdodCBXZWlnaHQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2l6ZSBTaXplLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVIZWlnaHQgTGluZUhlaWdodC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmYW1pbHkgRmFtaWx5LlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBmYW1pbGllcyBGYW1pbGllcy5cbiAqL1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgZm9yIGhpZGRlbiBmZWF0dXJlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX0hJRERFTiA9ICdvbC1oaWRkZW4nO1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdG8gaGF2ZSB0aGVtIHNlbGVjdGFibGUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfU0VMRUNUQUJMRSA9ICdvbC1zZWxlY3RhYmxlJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRoYXQgd2UnbGwgZ2l2ZSB0aGUgRE9NIGVsZW1lbnRzIHRvIGhhdmUgdGhlbSB1bnNlbGVjdGFibGUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfVU5TRUxFQ1RBQkxFID0gJ29sLXVuc2VsZWN0YWJsZSc7XG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyBmb3IgdW5zdXBwb3J0ZWQgZmVhdHVyZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19VTlNVUFBPUlRFRCA9ICdvbC11bnN1cHBvcnRlZCc7XG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyBmb3IgY29udHJvbHMuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfQ09OVFJPTCA9ICdvbC1jb250cm9sJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRoYXQgd2UnbGwgZ2l2ZSB0aGUgRE9NIGVsZW1lbnRzIHRoYXQgYXJlIGNvbGxhcHNlZCwgaS5lLlxuICogdG8gdGhvc2UgZWxlbWVudHMgd2hpY2ggdXN1YWxseSBjYW4gYmUgZXhwYW5kZWQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfQ09MTEFQU0VEID0gJ29sLWNvbGxhcHNlZCc7XG5cbi8qKlxuICogRnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDEzNTY5Ny9yZWdleC10by1wYXJzZS1hbnktY3NzLWZvbnRcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IGZvbnRSZWdFeCA9IG5ldyBSZWdFeHAoXG4gIFtcbiAgICAnXlxcXFxzKig/PSg/Oig/OlstYS16XStcXFxccyopezAsMn0oaXRhbGljfG9ibGlxdWUpKT8pJyxcbiAgICAnKD89KD86KD86Wy1hLXpdK1xcXFxzKil7MCwyfShzbWFsbC1jYXBzKSk/KScsXG4gICAgJyg/PSg/Oig/OlstYS16XStcXFxccyopezAsMn0oYm9sZCg/OmVyKT98bGlnaHRlcnxbMS05XTAwICkpPyknLFxuICAgICcoPzooPzpub3JtYWx8XFxcXDF8XFxcXDJ8XFxcXDMpXFxcXHMqKXswLDN9KCg/Onh4Py0pPycsXG4gICAgJyg/OnNtYWxsfGxhcmdlKXxtZWRpdW18c21hbGxlcnxsYXJnZXJ8W1xcXFwuXFxcXGRdKyg/OlxcXFwlfGlufFtjZW1dbXxleHxwW2N0eF0pKScsXG4gICAgJyg/OlxcXFxzKlxcXFwvXFxcXHMqKG5vcm1hbHxbXFxcXC5cXFxcZF0rKD86XFxcXCV8aW58W2NlbV1tfGV4fHBbY3R4XSk/KSknLFxuICAgICc/XFxcXHMqKFstLFxcXFxcIlxcXFxcXCdcXFxcc2Etel0rPylcXFxccyokJyxcbiAgXS5qb2luKCcnKSxcbiAgJ2knXG4pO1xuLyoqIEB0eXBlIHtBcnJheTwnc3R5bGUnfCd2YXJpYW50J3wnd2VpZ2h0J3wnc2l6ZSd8J2xpbmVIZWlnaHQnfCdmYW1pbHknPn0gKi9cbmNvbnN0IGZvbnRSZWdFeE1hdGNoSW5kZXggPSBbXG4gICdzdHlsZScsXG4gICd2YXJpYW50JyxcbiAgJ3dlaWdodCcsXG4gICdzaXplJyxcbiAgJ2xpbmVIZWlnaHQnLFxuICAnZmFtaWx5Jyxcbl07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIGZvbnQgZmFtaWxpZXMgZnJvbSBhIGZvbnQgc3BlYy4gIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3Qgd29ya1xuICogZm9yIGZvbnQgZmFtaWxpZXMgdGhhdCBoYXZlIGNvbW1hcyBpbiB0aGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTcGVjIFRoZSBDU1MgZm9udCBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0ZvbnRQYXJhbWV0ZXJzfG51bGx9IFRoZSBmb250IHBhcmFtZXRlcnMgKG9yIG51bGwgaWYgdGhlIGlucHV0IHNwZWMgaXMgaW52YWxpZCkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGb250UGFyYW1ldGVycyA9IGZ1bmN0aW9uIChmb250U3BlYykge1xuICBjb25zdCBtYXRjaCA9IGZvbnRTcGVjLm1hdGNoKGZvbnRSZWdFeCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7Rm9udFBhcmFtZXRlcnN9ICovICh7XG4gICAgbGluZUhlaWdodDogJ25vcm1hbCcsXG4gICAgc2l6ZTogJzEuMmVtJyxcbiAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB2YXJpYW50OiAnbm9ybWFsJyxcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGZvbnRSZWdFeE1hdGNoSW5kZXgubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHlsZVtmb250UmVnRXhNYXRjaEluZGV4W2ldXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBzdHlsZS5mYW1pbGllcyA9IHN0eWxlLmZhbWlseS5zcGxpdCgvLFxccz8vKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcbiIsICJpbXBvcnQge1dPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTfSBmcm9tICcuL2hhcy5qcyc7XG5cbi8qKlxuICogQG1vZHVsZSBvbC9kb21cbiAqL1xuXG4vL0ZJWE1FIE1vdmUgdGhpcyBmdW5jdGlvbiB0byB0aGUgY2FudmFzIG1vZHVsZVxuLyoqXG4gKiBDcmVhdGUgYW4gaHRtbCBjYW52YXMgZWxlbWVudCBhbmQgcmV0dXJucyBpdHMgMmQgY29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIENhbnZhcyB3aWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSBDYW52YXMgaGVpZ2h0LlxuICogQHBhcmFtIHtBcnJheTxIVE1MQ2FudmFzRWxlbWVudD59IFtjYW52YXNQb29sXSBDYW52YXMgcG9vbCB0byB0YWtlIGV4aXN0aW5nIGNhbnZhcyBmcm9tLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRTZXR0aW5nc30gW3NldHRpbmdzXSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRTZXR0aW5nc1xuICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0NvbnRleHQyRCh3aWR0aCwgaGVpZ2h0LCBjYW52YXNQb29sLCBzZXR0aW5ncykge1xuICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fE9mZnNjcmVlbkNhbnZhc30gKi9cbiAgbGV0IGNhbnZhcztcbiAgaWYgKGNhbnZhc1Bvb2wgJiYgY2FudmFzUG9vbC5sZW5ndGgpIHtcbiAgICBjYW52YXMgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoY2FudmFzUG9vbC5zaGlmdCgpKTtcbiAgfSBlbHNlIGlmIChXT1JLRVJfT0ZGU0NSRUVOX0NBTlZBUykge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGggfHwgMzAwLCBoZWlnaHQgfHwgMzAwKTtcbiAgfSBlbHNlIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgfVxuICBpZiAod2lkdGgpIHtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgfVxuICBpZiAoaGVpZ2h0KSB7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICAvL0ZJWE1FIEFsbG93IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBhcyByZXR1cm4gdHlwZVxuICByZXR1cm4gLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovIChcbiAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCBzZXR0aW5ncylcbiAgKTtcbn1cblxuLyoqXG4gKiBSZWxlYXNlcyBjYW52YXMgbWVtb3J5IHRvIGF2b2lkIGV4Y2VlZGluZyBtZW1vcnkgbGltaXRzIGluIFNhZmFyaS5cbiAqIFNlZSBodHRwczovL3BxaW5hLm5sL2Jsb2cvdG90YWwtY2FudmFzLW1lbW9yeS11c2UtZXhjZWVkcy10aGUtbWF4aW11bS1saW1pdC9cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWxlYXNlQ2FudmFzKGNvbnRleHQpIHtcbiAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gIGNhbnZhcy53aWR0aCA9IDE7XG4gIGNhbnZhcy5oZWlnaHQgPSAxO1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAxLCAxKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgY29tcHV0ZWQgd2lkdGggZm9yIHRoZSBnaXZlbiBlbGVtZW50IGluY2x1ZGluZyBtYXJnaW4sXG4gKiBwYWRkaW5nIGFuZCBib3JkZXIuXG4gKiBFcXVpdmFsZW50IHRvIGpRdWVyeSdzIGAkKGVsKS5vdXRlcldpZHRoKHRydWUpYC5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVyV2lkdGgoZWxlbWVudCkge1xuICBsZXQgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHdpZHRoICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0LCAxMCk7XG5cbiAgcmV0dXJuIHdpZHRoO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBjb21wdXRlZCBoZWlnaHQgZm9yIHRoZSBnaXZlbiBlbGVtZW50IGluY2x1ZGluZyBtYXJnaW4sXG4gKiBwYWRkaW5nIGFuZCBib3JkZXIuXG4gKiBFcXVpdmFsZW50IHRvIGpRdWVyeSdzIGAkKGVsKS5vdXRlckhlaWdodCh0cnVlKWAuXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3V0ZXJIZWlnaHQoZWxlbWVudCkge1xuICBsZXQgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCwgMTApICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tLCAxMCk7XG5cbiAgcmV0dXJuIGhlaWdodDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgTm9kZSB0byByZXBsYWNlIG9sZCBub2RlXG4gKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgVGhlIG5vZGUgdG8gYmUgcmVwbGFjZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VOb2RlKG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgY29uc3QgcGFyZW50ID0gb2xkTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmUuXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9IFRoZSBub2RlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgPyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmUgdGhlIGNoaWxkcmVuIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKSB7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBjaGlsZHJlbiBvZiBhIHBhcmVudCBub2RlIHNvIHRoZXkgbWF0Y2ggdGhlXG4gKiBwcm92aWRlZCBsaXN0IG9mIGNoaWxkcmVuLiAgVGhpcyBmdW5jdGlvbiBhaW1zIHRvIGVmZmljaWVudGx5XG4gKiByZW1vdmUsIGFkZCwgYW5kIHJlb3JkZXIgY2hpbGQgbm9kZXMgd2hpbGUgbWFpbnRhaW5pbmcgYSBzaW1wbGVcbiAqIGltcGxlbWVudGF0aW9uIChpdCBpcyBub3QgZ3VhcmFudGVlZCB0byBtaW5pbWl6ZSBET00gb3BlcmF0aW9ucykuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIHBhcmVudCBub2RlIHdob3NlIGNoaWxkcmVuIG5lZWQgcmV3b3JraW5nLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gY2hpbGRyZW4gVGhlIGRlc2lyZWQgY2hpbGRyZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlQ2hpbGRyZW4obm9kZSwgY2hpbGRyZW4pIHtcbiAgY29uc3Qgb2xkQ2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IHRydWU7ICsraSkge1xuICAgIGNvbnN0IG9sZENoaWxkID0gb2xkQ2hpbGRyZW5baV07XG4gICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIC8vIGNoZWNrIGlmIG91ciB3b3JrIGlzIGRvbmVcbiAgICBpZiAoIW9sZENoaWxkICYmICFuZXdDaGlsZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgY2hpbGRyZW4gbWF0Y2hcbiAgICBpZiAob2xkQ2hpbGQgPT09IG5ld0NoaWxkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhIG5ldyBjaGlsZCBuZWVkcyB0byBiZSBhZGRlZFxuICAgIGlmICghb2xkQ2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYW4gb2xkIGNoaWxkIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICBpZiAoIW5ld0NoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG9sZENoaWxkKTtcbiAgICAgIC0taTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHJlb3JkZXJcbiAgICBub2RlLmluc2VydEJlZm9yZShuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXNcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7V09SS0VSX09GRlNDUkVFTl9DQU5WQVN9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2dldEZvbnRQYXJhbWV0ZXJzfSBmcm9tICcuLi9jc3MuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnQ2lyY2xlJyB8ICdJbWFnZScgfCAnTGluZVN0cmluZycgfCAnUG9seWdvbicgfCAnVGV4dCcgfCAnRGVmYXVsdCd9IEJ1aWxkZXJUeXBlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gZmlsbFN0eWxlIEZpbGxTdHlsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIExhYmVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nfG51bWJlcj59IGNvbnRleHRJbnN0cnVjdGlvbnMgQ29udGV4dEluc3RydWN0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGxTdHJva2VTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY3VycmVudEZpbGxTdHlsZV0gQ3VycmVudCBGaWxsU3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjdXJyZW50U3Ryb2tlU3R5bGVdIEN1cnJlbnQgU3Ryb2tlU3R5bGUuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFtjdXJyZW50TGluZUNhcF0gQ3VycmVudCBMaW5lQ2FwLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBjdXJyZW50TGluZURhc2ggQ3VycmVudCBMaW5lRGFzaC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVEYXNoT2Zmc2V0XSBDdXJyZW50IExpbmVEYXNoT2Zmc2V0LlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gW2N1cnJlbnRMaW5lSm9pbl0gQ3VycmVudCBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVXaWR0aF0gQ3VycmVudCBMaW5lV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRNaXRlckxpbWl0XSBDdXJyZW50IE1pdGVyTGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xhc3RTdHJva2VdIExhc3Qgc3Ryb2tlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbZmlsbFN0eWxlXSBGaWxsU3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtzdHJva2VTdHlsZV0gU3Ryb2tlU3R5bGUuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFtsaW5lQ2FwXSBMaW5lQ2FwLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBsaW5lRGFzaCBMaW5lRGFzaC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZURhc2hPZmZzZXRdIExpbmVEYXNoT2Zmc2V0LlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gW2xpbmVKb2luXSBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZVdpZHRoXSBMaW5lV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pdGVyTGltaXRdIE1pdGVyTGltaXQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdHJva2VTdGF0ZVxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBsaW5lQ2FwIExpbmVDYXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxpbmVEYXNoIExpbmVEYXNoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVEYXNoT2Zmc2V0IExpbmVEYXNoT2Zmc2V0LlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gbGluZUpvaW4gTGluZUpvaW4uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZVdpZHRoIExpbmVXaWR0aC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0IE1pdGVyTGltaXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IHN0cm9rZVN0eWxlIFN0cm9rZVN0eWxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dFN0YXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZm9udCBGb250LlxuICogQHByb3BlcnR5IHtDYW52YXNUZXh0QWxpZ259IFt0ZXh0QWxpZ25dIFRleHRBbGlnbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwZWF0XSBSZXBlYXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1RleHQuanNcIikuVGV4dEp1c3RpZnl9IFtqdXN0aWZ5XSBKdXN0aWZ5LlxuICogQHByb3BlcnR5IHtDYW52YXNUZXh0QmFzZWxpbmV9IHRleHRCYXNlbGluZSBUZXh0QmFzZWxpbmUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1RleHQuanNcIikuVGV4dFBsYWNlbWVudH0gW3BsYWNlbWVudF0gUGxhY2VtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhBbmdsZV0gTWF4QW5nbGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdmVyZmxvd10gT3ZlcmZsb3cuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL0ZpbGwuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRGaWxsXSBCYWNrZ3JvdW5kRmlsbC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kU3Ryb2tlXSBCYWNrZ3JvdW5kU3Ryb2tlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZV0gU2NhbGUuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtwYWRkaW5nXSBQYWRkaW5nLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VyaWFsaXphYmxlSW5zdHJ1Y3Rpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PCo+fSBpbnN0cnVjdGlvbnMgVGhlIHJlbmRlcmluZyBpbnN0cnVjdGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5PCo+fSBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgVGhlIHJlbmRlcmluZyBoaXQgZGV0ZWN0aW9uIGluc3RydWN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgVGhlIGFycmF5IG9mIGFsbCBjb29yZGluYXRlcy5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIFRleHRTdGF0ZT59IFt0ZXh0U3RhdGVzXSBUaGUgdGV4dCBzdGF0ZXMgKGRlY2x1dHRlcmluZykuXG4gKiBAcHJvcGVydHkgeyFPYmplY3Q8c3RyaW5nLCBGaWxsU3RhdGU+fSBbZmlsbFN0YXRlc10gVGhlIGZpbGwgc3RhdGVzIChkZWNsdXR0ZXJpbmcpLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgU3Ryb2tlU3RhdGU+fSBbc3Ryb2tlU3RhdGVzXSBUaGUgc3Ryb2tlIHN0YXRlcyAoZGVjbHV0dGVyaW5nKS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3Q8bnVtYmVyLCBpbXBvcnQoXCIuL2NhbnZhcy9FeGVjdXRvci5qc1wiKS5SZXBsYXlJbWFnZU9yTGFiZWxBcmdzPn0gRGVjbHV0dGVySW1hZ2VXaXRoVGV4dFxuICovXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEZvbnQgPSAnMTBweCBzYW5zLXNlcmlmJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0RmlsbFN0eWxlID0gJyMwMDAnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0NhbnZhc0xpbmVDYXB9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZUNhcCA9ICdyb3VuZCc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMaW5lRGFzaCA9IFtdO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMaW5lRGFzaE9mZnNldCA9IDA7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Q2FudmFzTGluZUpvaW59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZUpvaW4gPSAncm91bmQnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRNaXRlckxpbWl0ID0gMTA7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTdHJva2VTdHlsZSA9ICcjMDAwJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0VGV4dEFsaWduID0gJ2NlbnRlcic7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Q2FudmFzVGV4dEJhc2VsaW5lfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFkZGluZyA9IFswLCAwLCAwLCAwXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZVdpZHRoID0gMTtcblxuLyoqXG4gKiBAdHlwZSB7QmFzZU9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrZWRGb250cyA9IG5ldyBCYXNlT2JqZWN0KCk7XG5cbi8qKlxuICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xubGV0IG1lYXN1cmVDb250ZXh0ID0gbnVsbDtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5sZXQgbWVhc3VyZUZvbnQ7XG5cbi8qKlxuICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICovXG5leHBvcnQgY29uc3QgdGV4dEhlaWdodHMgPSB7fTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxhYmVsIGNhY2hlIHdoZW4gYSBmb250IGJlY29tZXMgYXZhaWxhYmxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTcGVjIENTUyBmb250IHNwZWMuXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckZvbnQgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCByZXRyaWVzID0gMTAwO1xuICBjb25zdCBzaXplID0gJzMycHggJztcbiAgY29uc3QgcmVmZXJlbmNlRm9udHMgPSBbJ21vbm9zcGFjZScsICdzZXJpZiddO1xuICBjb25zdCBsZW4gPSByZWZlcmVuY2VGb250cy5sZW5ndGg7XG4gIGNvbnN0IHRleHQgPSAnd215dHppbFdNWVRaSUxAIy8mPyQlMTBcXHVGMDEzJztcbiAgbGV0IGludGVydmFsLCByZWZlcmVuY2VXaWR0aDtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTdHlsZSBDc3MgZm9udC1zdHlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFdlaWdodCBDc3MgZm9udC13ZWlnaHRcbiAgICogQHBhcmFtIHsqfSBmb250RmFtaWx5IENzcyBmb250LWZhbWlseVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBGb250IHdpdGggc3R5bGUgYW5kIHdlaWdodCBpcyBhdmFpbGFibGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzQXZhaWxhYmxlKGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udEZhbWlseSkge1xuICAgIGxldCBhdmFpbGFibGUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZUZvbnQgPSByZWZlcmVuY2VGb250c1tpXTtcbiAgICAgIHJlZmVyZW5jZVdpZHRoID0gbWVhc3VyZVRleHRXaWR0aChcbiAgICAgICAgZm9udFN0eWxlICsgJyAnICsgZm9udFdlaWdodCArICcgJyArIHNpemUgKyByZWZlcmVuY2VGb250LFxuICAgICAgICB0ZXh0XG4gICAgICApO1xuICAgICAgaWYgKGZvbnRGYW1pbHkgIT0gcmVmZXJlbmNlRm9udCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoXG4gICAgICAgICAgZm9udFN0eWxlICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBmb250V2VpZ2h0ICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBzaXplICtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgK1xuICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgIHJlZmVyZW5jZUZvbnQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICApO1xuICAgICAgICAvLyBJZiB3aWR0aCBhbmQgcmVmZXJlbmNlV2lkdGggYXJlIHRoZSBzYW1lLCB0aGVuIHRoZSBmYWxsYmFjayB3YXMgdXNlZFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBmb250IHdlIHdhbnRlZCwgc28gdGhlIGZvbnQgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgICAgYXZhaWxhYmxlID0gYXZhaWxhYmxlICYmIHdpZHRoICE9IHJlZmVyZW5jZVdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgIGNvbnN0IGZvbnRzID0gY2hlY2tlZEZvbnRzLmdldEtleXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmb250cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBmb250ID0gZm9udHNbaV07XG4gICAgICBpZiAoY2hlY2tlZEZvbnRzLmdldChmb250KSA8IHJldHJpZXMpIHtcbiAgICAgICAgaWYgKGlzQXZhaWxhYmxlLmFwcGx5KHRoaXMsIGZvbnQuc3BsaXQoJ1xcbicpKSkge1xuICAgICAgICAgIGNsZWFyKHRleHRIZWlnaHRzKTtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsb2FkZWQgZm9udHMgYXJlIHBpY2tlZCB1cCBieSBTYWZhcmlcbiAgICAgICAgICBtZWFzdXJlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgbWVhc3VyZUZvbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY2hlY2tlZEZvbnRzLnNldChmb250LCByZXRyaWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja2VkRm9udHMuc2V0KGZvbnQsIGNoZWNrZWRGb250cy5nZXQoZm9udCkgKyAxLCB0cnVlKTtcbiAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmb250U3BlYykge1xuICAgIGNvbnN0IGZvbnQgPSBnZXRGb250UGFyYW1ldGVycyhmb250U3BlYyk7XG4gICAgaWYgKCFmb250KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZhbWlsaWVzID0gZm9udC5mYW1pbGllcztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmYW1pbGllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBmYW1pbHkgPSBmYW1pbGllc1tpXTtcbiAgICAgIGNvbnN0IGtleSA9IGZvbnQuc3R5bGUgKyAnXFxuJyArIGZvbnQud2VpZ2h0ICsgJ1xcbicgKyBmYW1pbHk7XG4gICAgICBpZiAoY2hlY2tlZEZvbnRzLmdldChrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hlY2tlZEZvbnRzLnNldChrZXksIHJldHJpZXMsIHRydWUpO1xuICAgICAgICBpZiAoIWlzQXZhaWxhYmxlKGZvbnQuc3R5bGUsIGZvbnQud2VpZ2h0LCBmYW1pbHkpKSB7XG4gICAgICAgICAgY2hlY2tlZEZvbnRzLnNldChrZXksIDAsIHRydWUpO1xuICAgICAgICAgIGlmIChpbnRlcnZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKGNoZWNrLCAzMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBGb250IHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBNZWFzdXJlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IG1lYXN1cmVUZXh0SGVpZ2h0ID0gKGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGxldCBtZWFzdXJlRWxlbWVudDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmb250U3BlYykge1xuICAgIGxldCBoZWlnaHQgPSB0ZXh0SGVpZ2h0c1tmb250U3BlY107XG4gICAgaWYgKGhlaWdodCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChXT1JLRVJfT0ZGU0NSRUVOX0NBTlZBUykge1xuICAgICAgICBjb25zdCBmb250ID0gZ2V0Rm9udFBhcmFtZXRlcnMoZm9udFNwZWMpO1xuICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHQoZm9udFNwZWMsICdcdTAxN0RnJyk7XG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpc05hTihOdW1iZXIoZm9udC5saW5lSGVpZ2h0KSlcbiAgICAgICAgICA/IDEuMlxuICAgICAgICAgIDogTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gICAgICAgIGhlaWdodCA9XG4gICAgICAgICAgbGluZUhlaWdodCAqXG4gICAgICAgICAgKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW1lYXN1cmVFbGVtZW50KSB7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5pbm5lckhUTUwgPSAnTSc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gJzAnO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLm1heEhlaWdodCA9ICdub25lJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLmxlZnQgPSAnLTk5OTk5cHgnO1xuICAgICAgICB9XG4gICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLmZvbnQgPSBmb250U3BlYztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZWFzdXJlRWxlbWVudCk7XG4gICAgICAgIGhlaWdodCA9IG1lYXN1cmVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChtZWFzdXJlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0ZXh0SGVpZ2h0c1tmb250U3BlY10gPSBoZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICogQHJldHVybiB7VGV4dE1ldHJpY3N9IFRleHQgbWV0cmljcy5cbiAqL1xuZnVuY3Rpb24gbWVhc3VyZVRleHQoZm9udCwgdGV4dCkge1xuICBpZiAoIW1lYXN1cmVDb250ZXh0KSB7XG4gICAgbWVhc3VyZUNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG4gIH1cbiAgaWYgKGZvbnQgIT0gbWVhc3VyZUZvbnQpIHtcbiAgICBtZWFzdXJlQ29udGV4dC5mb250ID0gZm9udDtcbiAgICBtZWFzdXJlRm9udCA9IG1lYXN1cmVDb250ZXh0LmZvbnQ7XG4gIH1cbiAgcmV0dXJuIG1lYXN1cmVDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCkge1xuICByZXR1cm4gbWVhc3VyZVRleHQoZm9udCwgdGV4dCkud2lkdGg7XG59XG5cbi8qKlxuICogTWVhc3VyZSB0ZXh0IHdpZHRoIHVzaW5nIGEgY2FjaGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBUaGUgZm9udC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG1lYXN1cmUuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIG51bWJlcj59IGNhY2hlIEEgbG9va3VwIG9mIGNhY2hlZCB3aWR0aHMgYnkgdGV4dC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRleHQgd2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlQW5kQ2FjaGVUZXh0V2lkdGgoZm9udCwgdGV4dCwgY2FjaGUpIHtcbiAgaWYgKHRleHQgaW4gY2FjaGUpIHtcbiAgICByZXR1cm4gY2FjaGVbdGV4dF07XG4gIH1cbiAgY29uc3Qgd2lkdGggPSB0ZXh0XG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IE1hdGgubWF4KHByZXYsIG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgY3VycikpLCAwKTtcbiAgY2FjaGVbdGV4dF0gPSB3aWR0aDtcbiAgcmV0dXJuIHdpZHRoO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dFN0YXRlfSBiYXNlU3R5bGUgQmFzZSBzdHlsZS5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gY2h1bmtzIFRleHQgY2h1bmtzIHRvIG1lYXN1cmUuXG4gKiBAcmV0dXJuIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHdpZHRoczogQXJyYXk8bnVtYmVyPiwgaGVpZ2h0czogQXJyYXk8bnVtYmVyPiwgbGluZVdpZHRoczogQXJyYXk8bnVtYmVyPn19fSBUZXh0IG1ldHJpY3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0RGltZW5zaW9ucyhiYXNlU3R5bGUsIGNodW5rcykge1xuICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICBjb25zdCBsaW5lV2lkdGhzID0gW107XG4gIGxldCB3aWR0aCA9IDA7XG4gIGxldCBsaW5lV2lkdGggPSAwO1xuICBsZXQgaGVpZ2h0ID0gMDtcbiAgbGV0IGxpbmVIZWlnaHQgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaHVua3MubGVuZ3RoOyBpIDw9IGlpOyBpICs9IDIpIHtcbiAgICBjb25zdCB0ZXh0ID0gY2h1bmtzW2ldO1xuICAgIGlmICh0ZXh0ID09PSAnXFxuJyB8fCBpID09PSBpaSkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbGluZVdpZHRoKTtcbiAgICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSBjaHVua3NbaSArIDFdIHx8IGJhc2VTdHlsZS5mb250O1xuICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCk7XG4gICAgd2lkdGhzLnB1c2goY3VycmVudFdpZHRoKTtcbiAgICBsaW5lV2lkdGggKz0gY3VycmVudFdpZHRoO1xuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBtZWFzdXJlVGV4dEhlaWdodChmb250KTtcbiAgICBoZWlnaHRzLnB1c2goY3VycmVudEhlaWdodCk7XG4gICAgbGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGN1cnJlbnRIZWlnaHQpO1xuICB9XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodCwgd2lkdGhzLCBoZWlnaHRzLCBsaW5lV2lkdGhzfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggWCBvZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBZIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybXxudWxsfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAqIEBwYXJhbSB7TGFiZWx8SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBsYWJlbE9ySW1hZ2UgTGFiZWwuXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWCBPcmlnaW4gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaCBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzY2FsZSBTY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdJbWFnZU9yTGFiZWwoXG4gIGNvbnRleHQsXG4gIHRyYW5zZm9ybSxcbiAgb3BhY2l0eSxcbiAgbGFiZWxPckltYWdlLFxuICBvcmlnaW5YLFxuICBvcmlnaW5ZLFxuICB3LFxuICBoLFxuICB4LFxuICB5LFxuICBzY2FsZVxuKSB7XG4gIGNvbnRleHQuc2F2ZSgpO1xuXG4gIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5O1xuICB9XG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBjb250ZXh0LnRyYW5zZm9ybS5hcHBseShjb250ZXh0LCB0cmFuc2Zvcm0pO1xuICB9XG5cbiAgaWYgKC8qKiBAdHlwZSB7Kn0gKi8gKGxhYmVsT3JJbWFnZSkuY29udGV4dEluc3RydWN0aW9ucykge1xuICAgIC8vIGxhYmVsXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5zY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuICAgIGV4ZWN1dGVMYWJlbEluc3RydWN0aW9ucygvKiogQHR5cGUge0xhYmVsfSAqLyAobGFiZWxPckltYWdlKSwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAoc2NhbGVbMF0gPCAwIHx8IHNjYWxlWzFdIDwgMCkge1xuICAgIC8vIGZsaXBwZWQgaW1hZ2VcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gKi8gKFxuICAgICAgICBsYWJlbE9ySW1hZ2VcbiAgICAgICksXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB3LFxuICAgICAgaFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaW1hZ2Ugbm90IGZsaXBwZWQgdHJhbnNsYXRlIGFuZCBzY2FsZSBjYW4gYmUgYXZvaWRlZFxuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChcbiAgICAgICAgbGFiZWxPckltYWdlXG4gICAgICApLFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICB3LFxuICAgICAgaCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdyAqIHNjYWxlWzBdLFxuICAgICAgaCAqIHNjYWxlWzFdXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRleHQucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsIExhYmVsLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZUxhYmVsSW5zdHJ1Y3Rpb25zKGxhYmVsLCBjb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRleHRJbnN0cnVjdGlvbnMgPSBsYWJlbC5jb250ZXh0SW5zdHJ1Y3Rpb25zO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb250ZXh0SW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0SW5zdHJ1Y3Rpb25zW2kgKyAxXSkpIHtcbiAgICAgIGNvbnRleHRbY29udGV4dEluc3RydWN0aW9uc1tpXV0uYXBwbHkoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnNbaSArIDFdXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0W2NvbnRleHRJbnN0cnVjdGlvbnNbaV1dID0gY29udGV4dEluc3RydWN0aW9uc1tpICsgMV07XG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbWFwIGZyYW1lIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBtb3ZpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbW92ZXN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIE1PVkVTVEFSVDogJ21vdmVzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWFwIGlzIG1vdmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I21vdmVlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTU9WRUVORDogJ21vdmVlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBsb2FkaW5nIG9mIGFkZGl0aW9uYWwgbWFwIGRhdGEgKHRpbGVzLCBpbWFnZXMsIGZlYXR1cmVzKSBzdGFydHMuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbG9hZHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIExPQURTVEFSVDogJ2xvYWRzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGxvYWRpbmcgb2YgYWRkaXRpb25hbCBtYXAgZGF0YSBoYXMgY29tcGxldGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I2xvYWRlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTE9BREVORDogJ2xvYWRlbmQnLFxufTtcblxuLyoqKlxuICogQHR5cGVkZWYgeydwb3N0cmVuZGVyJ3wnbW92ZXN0YXJ0J3wnbW92ZWVuZCd8J2xvYWRzdGFydCd8J2xvYWRlbmQnfSBUeXBlc1xuICovXG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvQ29udHJvbFxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IE1hcEV2ZW50VHlwZSBmcm9tICcuLi9NYXBFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtWT0lEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge3JlbW92ZU5vZGV9IGZyb20gJy4uL2RvbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW2VsZW1lbnRdIFRoZSBlbGVtZW50IGlzIHRoZSBjb250cm9sJ3NcbiAqIGNvbnRhaW5lciBlbGVtZW50LiBUaGlzIG9ubHkgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIGlmIHlvdSdyZSBkZXZlbG9waW5nXG4gKiBhIGN1c3RvbSBjb250cm9sLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbcmVuZGVyXSBGdW5jdGlvbiBjYWxsZWQgd2hlblxuICogdGhlIGNvbnRyb2wgc2hvdWxkIGJlIHJlLXJlbmRlcmVkLiBUaGlzIGlzIGNhbGxlZCBpbiBhIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gKiBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50XG4gKiB0aGUgY29udHJvbCB0byBiZSByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29udHJvbCBpcyBhIHZpc2libGUgd2lkZ2V0IHdpdGggYSBET00gZWxlbWVudCBpbiBhIGZpeGVkIHBvc2l0aW9uIG9uIHRoZVxuICogc2NyZWVuLiBUaGV5IGNhbiBpbnZvbHZlIHVzZXIgaW5wdXQgKGJ1dHRvbnMpLCBvciBiZSBpbmZvcm1hdGlvbmFsIG9ubHk7XG4gKiB0aGUgcG9zaXRpb24gaXMgZGV0ZXJtaW5lZCB1c2luZyBDU1MuIEJ5IGRlZmF1bHQgdGhlc2UgYXJlIHBsYWNlZCBpbiB0aGVcbiAqIGNvbnRhaW5lciB3aXRoIENTUyBjbGFzcyBuYW1lIGBvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudGAsIGJ1dCBjYW4gdXNlXG4gKiBhbnkgb3V0c2lkZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBjb250cm9scy4gWW91IGNhbiB1c2UgaXQgZm9yIHNpbXBsZSBjdXN0b21cbiAqIGNvbnRyb2xzIGJ5IGNyZWF0aW5nIHRoZSBlbGVtZW50IHdpdGggbGlzdGVuZXJzLCBjcmVhdGluZyBhbiBpbnN0YW5jZTpcbiAqIGBgYGpzXG4gKiBjb25zdCBteUNvbnRyb2wgPSBuZXcgQ29udHJvbCh7ZWxlbWVudDogbXlFbGVtZW50fSk7XG4gKiBgYGBcbiAqIGFuZCB0aGVuIGFkZGluZyB0aGlzIHRvIHRoZSBtYXAuXG4gKlxuICogVGhlIG1haW4gYWR2YW50YWdlIG9mIGhhdmluZyB0aGlzIGFzIGEgY29udHJvbCByYXRoZXIgdGhhbiBhIHNpbXBsZSBzZXBhcmF0ZVxuICogRE9NIGVsZW1lbnQgaXMgdGhhdCBwcmV2ZW50aW5nIHByb3BhZ2F0aW9uIGlzIGhhbmRsZWQgZm9yIHlvdS4gQ29udHJvbHNcbiAqIHdpbGwgYWxzbyBiZSBvYmplY3RzIGluIGEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259LCBzbyB5b3UgY2FuIHVzZSB0aGVpciBtZXRob2RzLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBleHRlbmQgdGhpcyBiYXNlIGZvciB5b3VyIG93biBjb250cm9sIGNsYXNzLiBTZWVcbiAqIGV4YW1wbGVzL2N1c3RvbS1jb250cm9scyBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gZG8gdGhpcy5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENvbnRyb2wgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBDb250cm9sIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnQgJiYgIW9wdGlvbnMudGFyZ2V0ICYmICFlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQgPyBlbGVtZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyS2V5cyA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICB0aGlzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgdGhpcy5zZXRUYXJnZXQob3B0aW9ucy50YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICByZW1vdmVOb2RlKHRoaXMuZWxlbWVudCk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udHJvbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogUGFzcyBgbnVsbGAgdG8ganVzdCByZW1vdmUgdGhlIGNvbnRyb2wgZnJvbSB0aGUgY3VycmVudCBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHJlbW92ZU5vZGUodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5saXN0ZW5lcktleXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLmxpc3RlbmVyS2V5c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJLZXlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0X1xuICAgICAgICA/IHRoaXMudGFyZ2V0X1xuICAgICAgICA6IG1hcC5nZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50KCk7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgIGlmICh0aGlzLnJlbmRlciAhPT0gVk9JRCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyS2V5cy5wdXNoKFxuICAgICAgICAgIGxpc3RlbihtYXAsIE1hcEV2ZW50VHlwZS5QT1NUUkVOREVSLCB0aGlzLnJlbmRlciwgdGhpcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1hcC5yZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udHJvbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBFdmVudCBNYXAgZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbmRlcihtYXBFdmVudCkge31cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHNldCBhIHRhcmdldCBlbGVtZW50IGZvciB0aGUgY29udHJvbC4gSXQgaGFzIG5vXG4gICAqIGVmZmVjdCBpZiBpdCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbnRyb2wgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIG1hcCAoaS5lLlxuICAgKiBhZnRlciBgc2V0TWFwYCBpcyBjYWxsZWQgb24gdGhlIGNvbnRyb2wpLiBJZiBubyBgdGFyZ2V0YCBpcyBzZXQgaW4gdGhlXG4gICAqIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBjb250cm9sIGNvbnN0cnVjdG9yIGFuZCBpZiBgc2V0VGFyZ2V0YCBpcyBub3QgY2FsbGVkXG4gICAqIHRoZW4gdGhlIGNvbnRyb2wgaXMgYWRkZWQgdG8gdGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHN0cmluZ30gdGFyZ2V0IFRhcmdldC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0XyA9XG4gICAgICB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkgOiB0YXJnZXQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc2l6ZVxuICovXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYSBzaXplOiBgW3dpZHRoLCBoZWlnaHRdYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBTaXplXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyZWQgc2l6ZS5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRvIGJ1ZmZlci5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBUaGUgYnVmZmVyZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihzaXplLCBudW0sIGRlc3QpIHtcbiAgaWYgKGRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3QgPSBbMCwgMF07XG4gIH1cbiAgZGVzdFswXSA9IHNpemVbMF0gKyAyICogbnVtO1xuICBkZXN0WzFdID0gc2l6ZVsxXSArIDIgKiBudW07XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgVGhlIHNpemUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNBcmVhKHNpemUpIHtcbiAgcmV0dXJuIHNpemVbMF0gPiAwICYmIHNpemVbMV0gPiAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaXplIHNjYWxlZCBieSBhIHJhdGlvLiBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnMuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyBSYXRpby5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBUaGUgc2NhbGVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShzaXplLCByYXRpbywgZGVzdCkge1xuICBpZiAoZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdCA9IFswLCAwXTtcbiAgfVxuICBkZXN0WzBdID0gKHNpemVbMF0gKiByYXRpbyArIDAuNSkgfCAwO1xuICBkZXN0WzFdID0gKHNpemVbMV0gKiByYXRpbyArIDAuNSkgfCAwO1xuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGBTaXplYCBhcnJheSBmb3IgdGhlIHBhc3NlZCBpbiBudW1iZXIgKG1lYW5pbmc6IHNxdWFyZSkgb3JcbiAqIGBTaXplYCBhcnJheS5cbiAqIChtZWFuaW5nOiBub24tc3F1YXJlKSxcbiAqIEBwYXJhbSB7bnVtYmVyfFNpemV9IHNpemUgV2lkdGggYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBTaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TaXplKHNpemUsIGRlc3QpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBpZiAoZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdCA9IFtzaXplLCBzaXplXTtcbiAgfSBlbHNlIHtcbiAgICBkZXN0WzBdID0gc2l6ZTtcbiAgICBkZXN0WzFdID0gc2l6ZTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIEVSUk9SOiAzLFxuICBFTVBUWTogNCxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlXG4gKi9cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCB7Q1JFQVRFX0lNQUdFX0JJVE1BUCwgSU1BR0VfREVDT0RFfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQge2xpc3Rlbk9uY2UsIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7dG9Qcm9taXNlfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvSW1hZ2V+SW1hZ2VXcmFwcGVyfSBmb3IgdGhlIGltYWdlIGFuZCBhXG4gKiBge3N0cmluZ31gIGZvciB0aGUgc3JjIGFzIGFyZ3VtZW50cy4gSXQgaXMgc3VwcG9zZWQgdG8gbWFrZSBpdCBzbyB0aGVcbiAqIHVuZGVybHlpbmcgaW1hZ2Uge0BsaW5rIG1vZHVsZTpvbC9JbWFnZX5JbWFnZVdyYXBwZXIjZ2V0SW1hZ2V9IGlzIGFzc2lnbmVkIHRoZVxuICogY29udGVudCBzcGVjaWZpZWQgYnkgdGhlIHNyYy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgaXNcbiAqXG4gKiAgICAgZnVuY3Rpb24oaW1hZ2UsIHNyYykge1xuICogICAgICAgaW1hZ2UuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiAgICAgfVxuICpcbiAqIFByb3ZpZGluZyBhIGN1c3RvbSBgaW1hZ2VMb2FkRnVuY3Rpb25gIGNhbiBiZSB1c2VmdWwgdG8gbG9hZCBpbWFnZXMgd2l0aFxuICogcG9zdCByZXF1ZXN0cyBvciAtIGluIGdlbmVyYWwgLSB0aHJvdWdoIFhIUiByZXF1ZXN0cywgd2hlcmUgdGhlIHNyYyBvZiB0aGVcbiAqIGltYWdlIGVsZW1lbnQgd291bGQgYmUgc2V0IHRvIGEgZGF0YSBVUkkgd2hlbiB0aGUgY29udGVudCBpcyBsb2FkZWQuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdCwgc3RyaW5nKTogdm9pZH0gTG9hZEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbWFnZU9iamVjdFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudCwgaWYgZGlmZmVyZW50IGZyb20gdGhlIHJlcXVlc3RlZCBvbmUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcmVzb2x1dGlvbi5qc1wiKS5SZXNvbHV0aW9uTGlrZX0gW3Jlc29sdXRpb25dIFJlc29sdXRpb24sIGlmIGRpZmZlcmVudCBmcm9tIHRoZSByZXF1ZXN0ZWQgb25lLlxuICogV2hlbiB4IGFuZCB5IHJlc29sdXRpb24gYXJlIGRpZmZlcmVudCwgdXNlIHRoZSBhcnJheSB0eXBlIChgW3hSZXNvbHV0aW9uLCB5UmVzb2x1dGlvbl1gKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxSYXRpb10gUGl4ZWwgcmF0aW8sIGlmIGRpZmZlcmVudCBmcm9tIHRoZSByZXF1ZXN0ZWQgb25lLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIEltYWdlLlxuICovXG5cbi8qKlxuICogTG9hZGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGltYWdlIHNvdXJjZXMuIFJlY2VpdmVzIGV4dGVudCwgcmVzb2x1dGlvbiBhbmQgcGl4ZWwgcmF0aW8gYXMgYXJndW1lbnRzLlxuICogRm9yIGltYWdlcyB0aGF0IGNvdmVyIGFueSBleHRlbnQgYW5kIHJlc29sdXRpb24gKHN0YXRpYyBpbWFnZXMpLCB0aGUgbG9hZGVyIGZ1bmN0aW9uIHNob3VsZCBub3QgYWNjZXB0XG4gKiBhbnkgYXJndW1lbnRzLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhbiB7QGxpbmsgaW1wb3J0KFwiLi9EYXRhVGlsZS5qc1wiKS5JbWFnZUxpa2UgaW1hZ2V9LCBhblxuICoge0BsaW5rIGltcG9ydChcIi4vSW1hZ2UuanNcIikuSW1hZ2VPYmplY3QgaW1hZ2Ugb2JqZWN0fSwgb3IgYSBwcm9taXNlIGZvciB0aGUgc2FtZS5cbiAqIEZvciBsb2FkZXJzIHRoYXQgZ2VuZXJhdGUgaW1hZ2VzLCB0aGUgcHJvbWlzZSBzaG91bGQgbm90IHJlc29sdmUgdW50aWwgdGhlIGltYWdlIGlzIGxvYWRlZC5cbiAqIElmIHRoZSByZXR1cm5lZCBpbWFnZSBkb2VzIG5vdCBtYXRjaCB0aGUgZXh0ZW50LCByZXNvbHV0aW9uIG9yIHBpeGVsIHJhdGlvIHBhc3NlZCB0byB0aGUgbG9hZGVyLFxuICogaXQgaGFzIHRvIHJldHVybiBhbiB7QGxpbmsgaW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5JbWFnZU9iamVjdCBpbWFnZSBvYmplY3R9IHdpdGggdGhlIGBpbWFnZWAgYW5kIHRoZVxuICogY29ycmVjdCBgZXh0ZW50YCwgYHJlc29sdXRpb25gIGFuZCBgcGl4ZWxSYXRpb2AuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyLCBudW1iZXIsIChmdW5jdGlvbihIVE1MSW1hZ2VFbGVtZW50LCBzdHJpbmcpOiB2b2lkKT0pOiBpbXBvcnQoXCIuL0RhdGFUaWxlLmpzXCIpLkltYWdlTGlrZXxJbWFnZU9iamVjdHxQcm9taXNlPGltcG9ydChcIi4vRGF0YVRpbGUuanNcIikuSW1hZ2VMaWtlfEltYWdlT2JqZWN0Pn0gTG9hZGVyXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBMb2FkZXIgZnVuY3Rpb24gdXNlZCBmb3IgaW1hZ2Ugc291cmNlcy4gUmVjZWl2ZXMgZXh0ZW50LCByZXNvbHV0aW9uIGFuZCBwaXhlbCByYXRpbyBhcyBhcmd1bWVudHMuXG4gKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIGFuICB7QGxpbmsgaW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5JbWFnZU9iamVjdCBpbWFnZSBvYmplY3R9LlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlciwgbnVtYmVyLCAoZnVuY3Rpb24oSFRNTEltYWdlRWxlbWVudCwgc3RyaW5nKTogdm9pZCk9KTogaW1wb3J0KFwiLi9EYXRhVGlsZS5qc1wiKS5JbWFnZUxpa2V8SW1hZ2VPYmplY3R8UHJvbWlzZTxpbXBvcnQoXCIuL0RhdGFUaWxlLmpzXCIpLkltYWdlTGlrZXxJbWFnZU9iamVjdD59IEltYWdlT2JqZWN0UHJvbWlzZUxvYWRlclxuICovXG5cbmNsYXNzIEltYWdlV3JhcHBlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcnxBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLiBJZiBwcm92aWRlZCBhcyBhcnJheSwgeCBhbmQgeVxuICAgKiByZXNvbHV0aW9uIHdpbGwgYmUgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5Mb2FkZXJ9IHN0YXRlT3JMb2FkZXIgU3RhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHN0YXRlT3JMb2FkZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcnxBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID1cbiAgICAgIHR5cGVvZiBzdGF0ZU9yTG9hZGVyID09PSAnZnVuY3Rpb24nID8gSW1hZ2VTdGF0ZS5JRExFIDogc3RhdGVPckxvYWRlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5Mb2FkZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXIgPSB0eXBlb2Ygc3RhdGVPckxvYWRlciA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXRlT3JMb2FkZXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNoYW5nZWQoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50VHlwZS5DSEFOR0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IEltYWdlLlxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gUGl4ZWxSYXRpby5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpb187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfEFycmF5PG51bWJlcj59IFJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IFN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBJbWFnZVN0YXRlLkxPQURJTkc7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RSZXNvbHV0aW9uID0gQXJyYXkuaXNBcnJheShyZXNvbHV0aW9uKVxuICAgICAgICAgID8gcmVzb2x1dGlvblswXVxuICAgICAgICAgIDogcmVzb2x1dGlvbjtcbiAgICAgICAgdG9Qcm9taXNlKCgpID0+XG4gICAgICAgICAgdGhpcy5sb2FkZXIodGhpcy5nZXRFeHRlbnQoKSwgcmVxdWVzdFJlc29sdXRpb24sIHRoaXMuZ2V0UGl4ZWxSYXRpbygpKVxuICAgICAgICApXG4gICAgICAgICAgLnRoZW4oKGltYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoJ2ltYWdlJyBpbiBpbWFnZSkge1xuICAgICAgICAgICAgICB0aGlzLmltYWdlXyA9IGltYWdlLmltYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdleHRlbnQnIGluIGltYWdlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXh0ZW50ID0gaW1hZ2UuZXh0ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdyZXNvbHV0aW9uJyBpbiBpbWFnZSkge1xuICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBpbWFnZS5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdwaXhlbFJhdGlvJyBpbiBpbWFnZSkge1xuICAgICAgICAgICAgICB0aGlzLnBpeGVsUmF0aW9fID0gaW1hZ2UucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8XG4gICAgICAgICAgICAgIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgfHxcbiAgICAgICAgICAgICAgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fFxuICAgICAgICAgICAgICBpbWFnZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuTE9BREVEO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuRVJST1I7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLmNoYW5nZWQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBpbWFnZSBUaGUgaW1hZ2UuXG4gICAqL1xuICBzZXRJbWFnZShpbWFnZSkge1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXk8bnVtYmVyPn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBpbWFnZSBJbWFnZSBlbGVtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbigpOmFueX0gbG9hZEhhbmRsZXIgTG9hZCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTphbnl9IGVycm9ySGFuZGxlciBFcnJvciBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6dm9pZH0gQ2FsbGJhY2sgdG8gc3RvcCBsaXN0ZW5pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5JbWFnZShpbWFnZSwgbG9hZEhhbmRsZXIsIGVycm9ySGFuZGxlcikge1xuICBjb25zdCBpbWcgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovIChpbWFnZSk7XG4gIGxldCBsaXN0ZW5pbmcgPSB0cnVlO1xuICBsZXQgZGVjb2RpbmcgPSBmYWxzZTtcbiAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGxpc3RlbmVyS2V5cyA9IFtcbiAgICBsaXN0ZW5PbmNlKGltZywgRXZlbnRUeXBlLkxPQUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICBpZiAoIWRlY29kaW5nKSB7XG4gICAgICAgIGxvYWRIYW5kbGVyKCk7XG4gICAgICB9XG4gICAgfSksXG4gIF07XG5cbiAgaWYgKGltZy5zcmMgJiYgSU1BR0VfREVDT0RFKSB7XG4gICAgZGVjb2RpbmcgPSB0cnVlO1xuICAgIGltZ1xuICAgICAgLmRlY29kZSgpXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgICAgICBsb2FkSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgICAgbG9hZEhhbmRsZXIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lcktleXMucHVzaChsaXN0ZW5PbmNlKGltZywgRXZlbnRUeXBlLkVSUk9SLCBlcnJvckhhbmRsZXIpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiB1bmxpc3RlbigpIHtcbiAgICBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICBsaXN0ZW5lcktleXMuZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZS5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgSW1hZ2UsIG5vdCB5ZXQgbG9hZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdIGBzcmNgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UuIE9wdGlvbmFsLCBub3QgcmVxdWlyZWQgaWYgYWxyZWFkeSBwcmVzZW50LlxuICogQHJldHVybiB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYEhUTUxJbWFnZUVsZW1lbnRgLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZChpbWFnZSwgc3JjKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgICByZXNvbHZlKGltYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignSW1hZ2UgbG9hZCBlcnJvcicpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5saXN0ZW4oKSB7XG4gICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgaGFuZGxlTG9hZCk7XG4gICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICB9XG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZUxvYWQpO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgIGlmIChzcmMpIHtcbiAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgSW1hZ2UsIG5vdCB5ZXQgbG9hZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdIGBzcmNgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UuIE9wdGlvbmFsLCBub3QgcmVxdWlyZWQgaWYgYWxyZWFkeSBwcmVzZW50LlxuICogQHJldHVybiB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYEhUTUxJbWFnZUVsZW1lbnRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRmFsbGJhY2soaW1hZ2UsIHNyYykge1xuICBpZiAoc3JjKSB7XG4gICAgaW1hZ2Uuc3JjID0gc3JjO1xuICB9XG4gIHJldHVybiBpbWFnZS5zcmMgJiYgSU1BR0VfREVDT0RFXG4gICAgPyBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICBpbWFnZVxuICAgICAgICAgIC5kZWNvZGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHJlc29sdmUoaW1hZ2UpKVxuICAgICAgICAgIC5jYXRjaCgoZSkgPT5cbiAgICAgICAgICAgIGltYWdlLmNvbXBsZXRlICYmIGltYWdlLndpZHRoID8gcmVzb2x2ZShpbWFnZSkgOiByZWplY3QoZSlcbiAgICAgICAgICApXG4gICAgICApXG4gICAgOiBsb2FkKGltYWdlKTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZSBhbmQgZGVjb2RlcyBpdCB0byBhbiBgSW1hZ2VCaXRtYXBgIGlmIGBjcmVhdGVJbWFnZUJpdG1hcCgpYCBpcyBzdXBwb3J0ZWQuIFJldHVybnNcbiAqIHRoZSBsb2FkZWQgaW1hZ2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSBJbWFnZSwgbm90IHlldCBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gYHNyY2AgYXR0cmlidXRlIG9mIHRoZSBpbWFnZS4gT3B0aW9uYWwsIG5vdCByZXF1aXJlZCBpZiBhbHJlYWR5IHByZXNlbnQuXG4gKiBAcmV0dXJuIHtQcm9taXNlPEltYWdlQml0bWFwfEhUTUxJbWFnZUVsZW1lbnQ+fSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBgSW1hZ2VCaXRtYXBgIG9yIGFuXG4gKiBgSFRNTEltYWdlRWxlbWVudGAgaWYgYGNyZWF0ZUltYWdlQml0bWFwKClgIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoaW1hZ2UsIHNyYykge1xuICBpZiAoc3JjKSB7XG4gICAgaW1hZ2Uuc3JjID0gc3JjO1xuICB9XG4gIHJldHVybiBpbWFnZS5zcmMgJiYgSU1BR0VfREVDT0RFICYmIENSRUFURV9JTUFHRV9CSVRNQVBcbiAgICA/IGltYWdlXG4gICAgICAgIC5kZWNvZGUoKVxuICAgICAgICAudGhlbigoKSA9PiBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSkpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KVxuICAgIDogZGVjb2RlRmFsbGJhY2soaW1hZ2UpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVdyYXBwZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9Tb3VyY2VcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsndW5kZWZpbmVkJyB8ICdsb2FkaW5nJyB8ICdyZWFkeScgfCAnZXJyb3InfSBTdGF0ZVxuICogU3RhdGUgb2YgdGhlIHNvdXJjZSwgb25lIG9mICd1bmRlZmluZWQnLCAnbG9hZGluZycsICdyZWFkeScgb3IgJ2Vycm9yJy5cbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlZpZXdTdGF0ZUxheWVyU3RhdGVFeHRlbnR9IGFuZCByZXR1cm5zIGEgc3RyaW5nIG9yXG4gKiBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBzb3VyY2UgYXR0cmlidXRpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlZpZXdTdGF0ZUxheWVyU3RhdGVFeHRlbnQpOiAoc3RyaW5nfEFycmF5PHN0cmluZz4pfSBBdHRyaWJ1dGlvblxuICovXG5cbi8qKlxuICogQSB0eXBlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhdHRyaWJ1dGlvbiBpbmZvcm1hdGlvbiBmb3IgZGF0YSBzb3VyY2VzLlxuICpcbiAqIEl0IHJlcHJlc2VudHMgZWl0aGVyXG4gKiAqIGEgc2ltcGxlIHN0cmluZyAoZS5nLiBgJ1x1MDBBOSBBY21lIEluYy4nYClcbiAqICogYW4gYXJyYXkgb2Ygc2ltcGxlIHN0cmluZ3MgKGUuZy4gYFsnXHUwMEE5IEFjbWUgSW5jLicsICdcdTAwQTkgQmFjbWUgSW5jLiddYClcbiAqICogYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyAoe0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufSlcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfEFycmF5PHN0cmluZz58QXR0cmlidXRpb259IEF0dHJpYnV0aW9uTGlrZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtBdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLiBEZWZhdWx0IGlzIHRoZSB2aWV3IHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGU9J3JlYWR5J10gU3RhdGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD1mYWxzZV0gV3JhcFguXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3Ige0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllcn0gc291cmNlcy5cbiAqXG4gKiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UgY2hhbmdlcy5cbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG5jbGFzcyBTb3VyY2UgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBTb3VyY2Ugb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbiA9IGdldFByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BdHRyaWJ1dGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0aW9uc18gPSBhZGFwdEF0dHJpYnV0aW9ucyhvcHRpb25zLmF0dHJpYnV0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRpb25zQ29sbGFwc2libGVfID1cbiAgICAgIG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGVcbiAgICAgICAgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBzb3VyY2UgaXMgY3VycmVudGx5IGxvYWRpbmcgZGF0YS4gU291cmNlcyB0aGF0IGRlZmVyIGxvYWRpbmcgdG8gdGhlXG4gICAgICogbWFwJ3MgdGlsZSBxdWV1ZSBuZXZlciBzZXQgdGhpcyB0byBgdHJ1ZWAuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlXyA9IG9wdGlvbnMuc3RhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RhdGUgOiAncmVhZHknO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBYXyA9IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnBvbGF0ZV8gPSAhIW9wdGlvbnMuaW50ZXJwb2xhdGU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL1ZpZXcuanNcIikuVmlld09wdGlvbnMpOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy52aWV3UmVzb2x2ZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihFcnJvcik6dm9pZH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdSZWplY3RvciA9IG51bGw7XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtQcm9taXNlPGltcG9ydChcIi4uL1ZpZXcuanNcIikuVmlld09wdGlvbnM+fVxuICAgICAqL1xuICAgIHRoaXMudmlld1Byb21pc2VfID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2VsZi52aWV3UmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgc2VsZi52aWV3UmVqZWN0b3IgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhdHRyaWJ1dGlvbiBmdW5jdGlvbiBmb3IgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7P0F0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbiBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXR0cmlidXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0aW9uc187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXR0cmlidXRpb25zQ29sbGFwc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRpb25zQ29sbGFwc2libGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJvamVjdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHxudWxsfSBQcm9qZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQcm9qZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb25cIikuZGVmYXVsdH0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58bnVsbH0gUmVzb2x1dGlvbnMuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9ucyhwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UHJvbWlzZTxpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlZpZXdPcHRpb25zPn0gQSBwcm9taXNlIGZvciB2aWV3LXJlbGF0ZWQgcHJvcGVydGllcy5cbiAgICovXG4gIGdldFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld1Byb21pc2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSwgc2VlIHtAbGluayBpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX0gZm9yIHBvc3NpYmxlIHN0YXRlcy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IFN0YXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IFdyYXAgWC5cbiAgICovXG4gIGdldFdyYXBYKCkge1xuICAgIHJldHVybiB0aGlzLndyYXBYXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBVc2UgbGluZWFyIGludGVycG9sYXRpb24gd2hlbiByZXNhbXBsaW5nLlxuICAgKi9cbiAgZ2V0SW50ZXJwb2xhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyB0aGUgc291cmNlLiBUaGUgc291cmNlIHdpbGwgYmUgY2xlYXJlZCwgYW5kIGRhdGEgZnJvbSB0aGUgc2VydmVyIHdpbGwgYmUgcmVsb2FkZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhdHRyaWJ1dGlvbnMgb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtBdHRyaWJ1dGlvbkxpa2V8dW5kZWZpbmVkfSBhdHRyaWJ1dGlvbnMgQXR0cmlidXRpb25zLlxuICAgKiAgICAgQ2FuIGJlIHBhc3NlZCBhcyBgc3RyaW5nYCwgYEFycmF5PHN0cmluZz5gLCB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259LFxuICAgKiAgICAgb3IgYHVuZGVmaW5lZGAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEF0dHJpYnV0aW9ucyhhdHRyaWJ1dGlvbnMpIHtcbiAgICB0aGlzLmF0dHJpYnV0aW9uc18gPSBhZGFwdEF0dHJpYnV0aW9ucyhhdHRyaWJ1dGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUdXJucyB0aGUgYXR0cmlidXRpb25zIG9wdGlvbiBpbnRvIGFuIGF0dHJpYnV0aW9ucyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXR0cmlidXRpb25MaWtlfHVuZGVmaW5lZH0gYXR0cmlidXRpb25MaWtlIFRoZSBhdHRyaWJ1dGlvbiBvcHRpb24uXG4gKiBAcmV0dXJuIHtBdHRyaWJ1dGlvbnxudWxsfSBBbiBhdHRyaWJ1dGlvbiBmdW5jdGlvbiAob3IgbnVsbCkuXG4gKi9cbmZ1bmN0aW9uIGFkYXB0QXR0cmlidXRpb25zKGF0dHJpYnV0aW9uTGlrZSkge1xuICBpZiAoIWF0dHJpYnV0aW9uTGlrZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9uTGlrZSkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGlvbkxpa2U7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRpb25MaWtlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0aW9uTGlrZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybiBbYXR0cmlidXRpb25MaWtlXTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU291cmNlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9MYXllclxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9PYnNlcnZhYmxlLmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXJUeXBlXG4gKi9cbmNsYXNzIExheWVyUmVuZGVyZXIgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TGF5ZXJUeXBlfSBsYXllciBMYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxheWVyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXJlciBpcyBpbml0aWFsaXplZCBhbmQgcmVhZHkgdG8gcmVuZGVyLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZUltYWdlQ2hhbmdlXyA9IHRoaXMuaGFuZGxlSW1hZ2VDaGFuZ2VfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0xheWVyVHlwZX1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyXyA9IGxheWVyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvRXhlY3V0b3JHcm91cFwiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyRXhlY3V0b3JHcm91cCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGxheWVyIGxldmVsIGhpdCBkZXRlY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGltcG9ydChcIi4uL0ZlYXR1cmVcIikuRmVhdHVyZUxpa2U+Pn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGhcbiAgICogYW4gYXJyYXkgb2YgZmVhdHVyZXMuXG4gICAqL1xuICBnZXRGZWF0dXJlcyhwaXhlbCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5fEZsb2F0MzJBcnJheXxEYXRhVmlld3xudWxsfSBQaXhlbCBkYXRhLlxuICAgKi9cbiAgZ2V0RGF0YShwaXhlbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIHJlbmRlciBzaG91bGQgYmUgY2FsbGVkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gTGF5ZXIgaXMgcmVhZHkgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBwcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgbGF5ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fG51bGx9IHRhcmdldCBUYXJnZXQgdGhhdCBtYXkgYmUgdXNlZCB0byByZW5kZXIgY29udGVudCB0by5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gVGhlIHJlbmRlcmVkIGVsZW1lbnQuXG4gICAqL1xuICByZW5kZXJGcmFtZShmcmFtZVN0YXRlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdD4+fSB0aWxlcyBMb29rdXAgb2YgbG9hZGVkIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dm9pZH0gSWYgYGZhbHNlYCwgdGhlIHRpbGUgd2lsbCBub3QgYmUgY29uc2lkZXJlZCBsb2FkZWQuXG4gICAqL1xuICBsb2FkZWRUaWxlQ2FsbGJhY2sodGlsZXMsIHpvb20sIHRpbGUpIHtcbiAgICBpZiAoIXRpbGVzW3pvb21dKSB7XG4gICAgICB0aWxlc1t6b29tXSA9IHt9O1xuICAgIH1cbiAgICB0aWxlc1t6b29tXVt0aWxlLnRpbGVDb29yZC50b1N0cmluZygpXSA9IHRpbGU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IGFkZHMgbG9hZGVkIHRpbGVzIHRvIHRoZSB0aWxlIGxvb2t1cC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbiBvZiB0aGUgdGlsZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0PG51bWJlciwgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pj59IHRpbGVzIExvb2t1cCBvZiBsb2FkZWQgdGlsZXMgYnkgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gQSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggYSB6b29tIGxldmVsIGFuZCBhIHRpbGUgcmFuZ2UgdG8gYWRkIGxvYWRlZCB0aWxlcyB0byB0aGUgbG9va3VwLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVMb2FkZWRUaWxlRmluZGVyKHNvdXJjZSwgcHJvamVjdGlvbiwgdGlsZXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSByYW5nZSBpcyBmdWxseSBsb2FkZWQuXG4gICAgICAgKi9cbiAgICAgICh6b29tLCB0aWxlUmFuZ2UpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmxvYWRlZFRpbGVDYWxsYmFjay5iaW5kKHRoaXMsIHRpbGVzLCB6b29tKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5mb3JFYWNoTG9hZGVkVGlsZShwcm9qZWN0aW9uLCB6b29tLCB0aWxlUmFuZ2UsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3ZlY3Rvci5qc1wiKS5GZWF0dXJlQ2FsbGJhY2s8VD59IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9NYXAuanNcIikuSGl0TWF0Y2g8VD4+fSBtYXRjaGVzIFRoZSBoaXQgZGV0ZWN0ZWQgbWF0Y2hlcyB3aXRoIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgZnJhbWVTdGF0ZSxcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgY2FsbGJhY2ssXG4gICAgbWF0Y2hlc1xuICApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0xheWVyVHlwZX0gTGF5ZXIuXG4gICAqL1xuICBnZXRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcl87XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhY3Rpb24gbmVjZXNzYXJ5IHRvIGdldCB0aGUgbGF5ZXIgcmVuZGVyZWQgYWZ0ZXIgbmV3IGZvbnRzIGhhdmUgbG9hZGVkXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgaGFuZGxlRm9udHNDaGFuZ2VkKCkge31cblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZXMgaW4gaW1hZ2Ugc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEltYWdlIGNoYW5nZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlQ2hhbmdlXyhldmVudCkge1xuICAgIGNvbnN0IGltYWdlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAoXG4gICAgICBpbWFnZS5nZXRTdGF0ZSgpID09PSBJbWFnZVN0YXRlLkxPQURFRCB8fFxuICAgICAgaW1hZ2UuZ2V0U3RhdGUoKSA9PT0gSW1hZ2VTdGF0ZS5FUlJPUlxuICAgICkge1xuICAgICAgdGhpcy5yZW5kZXJJZlJlYWR5QW5kVmlzaWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBpZiBub3QgYWxyZWFkeSBsb2FkZWQsIGFuZCByZWdpc3RlciB0aGUgaW1hZ2UgY2hhbmdlXG4gICAqIGxpc3RlbmVyIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBpbWFnZSBJbWFnZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbWFnZSBpcyBhbHJlYWR5IGxvYWRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGxvYWRJbWFnZShpbWFnZSkge1xuICAgIGxldCBpbWFnZVN0YXRlID0gaW1hZ2UuZ2V0U3RhdGUoKTtcbiAgICBpZiAoaW1hZ2VTdGF0ZSAhPSBJbWFnZVN0YXRlLkxPQURFRCAmJiBpbWFnZVN0YXRlICE9IEltYWdlU3RhdGUuRVJST1IpIHtcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5ib3VuZEhhbmRsZUltYWdlQ2hhbmdlXyk7XG4gICAgfVxuICAgIGlmIChpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgaW1hZ2UubG9hZCgpO1xuICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlLmdldFN0YXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuTE9BREVEO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGlmIChsYXllciAmJiBsYXllci5nZXRWaXNpYmxlKCkgJiYgbGF5ZXIuZ2V0U291cmNlU3RhdGUoKSA9PT0gJ3JlYWR5Jykge1xuICAgICAgbGF5ZXIuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBkZWxldGUgdGhpcy5sYXllcl87XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXJSZW5kZXJlcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL0xheWVyXG4gKi9cbmltcG9ydCBMYXllclJlbmRlcmVyIGZyb20gJy4uL0xheWVyLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudCBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnQuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7XG4gIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLFxuICBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sXG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2FzQXJyYXl9IGZyb20gJy4uLy4uL2NvbG9yLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7XG4gIGdldEJvdHRvbUxlZnQsXG4gIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRUb3BSaWdodCxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8SFRNTENhbnZhc0VsZW1lbnQ+fVxuICovXG5leHBvcnQgY29uc3QgY2FudmFzUG9vbCA9IFtdO1xuXG4vKipcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKi9cbmxldCBwaXhlbENvbnRleHQgPSBudWxsO1xuXG5mdW5jdGlvbiBjcmVhdGVQaXhlbENvbnRleHQoKSB7XG4gIHBpeGVsQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgxLCAxLCB1bmRlZmluZWQsIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWUsXG4gIH0pO1xufVxuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBMYXllclR5cGVcbiAqIEBleHRlbmRzIHtMYXllclJlbmRlcmVyPExheWVyVHlwZT59XG4gKi9cbmNsYXNzIENhbnZhc0xheWVyUmVuZGVyZXIgZXh0ZW5kcyBMYXllclJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TGF5ZXJUeXBlfSBsYXllciBMYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxheWVyKSB7XG4gICAgc3VwZXIobGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEEgdGVtcG9yYXJ5IHRyYW5zZm9ybS4gIFRoZSB2YWx1ZXMgaW4gdGhpcyB0cmFuc2Zvcm0gc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBhXG4gICAgICogZnVuY3Rpb24gdGhhdCBzZXRzIHRoZSB2YWx1ZXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudGVtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zZm9ybSBmb3IgcmVuZGVyZWQgcGl4ZWxzIHRvIHZpZXdwb3J0IENTUyBwaXhlbHMuICBUaGlzIHRyYW5zZm9ybSBtdXN0XG4gICAgICogYmUgc2V0IHdoZW4gcmVuZGVyaW5nIGEgZnJhbWUgYW5kIG1heSBiZSB1c2VkIGJ5IG90aGVyIGZ1bmN0aW9ucyBhZnRlciByZW5kZXJpbmcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm0gZm9yIHZpZXdwb3J0IENTUyBwaXhlbHMgdG8gcmVuZGVyZWQgcGl4ZWxzLiAgVGhpcyB0cmFuc2Zvcm0gbXVzdFxuICAgICAqIGJlIHNldCB3aGVuIHJlbmRlcmluZyBhIGZyYW1lIGFuZCBtYXkgYmUgdXNlZCBieSBvdGhlciBmdW5jdGlvbnMgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXJSZXVzZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29udGV4dF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBpbWFnZSBJbWFnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXguXG4gICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fG51bGx9IFRoZSBpbWFnZSBkYXRhLlxuICAgKi9cbiAgZ2V0SW1hZ2VEYXRhKGltYWdlLCBjb2wsIHJvdykge1xuICAgIGlmICghcGl4ZWxDb250ZXh0KSB7XG4gICAgICBjcmVhdGVQaXhlbENvbnRleHQoKTtcbiAgICB9XG4gICAgcGl4ZWxDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAxLCAxKTtcblxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBwaXhlbENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBjb2wsIHJvdywgMSwgMSwgMCwgMCwgMSwgMSk7XG4gICAgICBkYXRhID0gcGl4ZWxDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcGl4ZWxDb250ZXh0ID0gbnVsbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vTWFwLmpzJykuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBCYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgZ2V0QmFja2dyb3VuZChmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgbGV0IGJhY2tncm91bmQgPSBsYXllci5nZXRCYWNrZ3JvdW5kKCk7XG4gICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gYmFja2dyb3VuZChmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlbmRlcmluZyBjb250YWluZXIgZnJvbSBhbiBleGlzdGluZyB0YXJnZXQsIGlmIGNvbXBhdGlibGUuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCBQb3RlbnRpYWwgcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybSBDU1MgVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcl0gQmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIHVzZUNvbnRhaW5lcih0YXJnZXQsIHRyYW5zZm9ybSwgYmFja2dyb3VuZENvbG9yKSB7XG4gICAgY29uc3QgbGF5ZXJDbGFzc05hbWUgPSB0aGlzLmdldExheWVyKCkuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgbGV0IGNvbnRhaW5lciwgY29udGV4dDtcbiAgICBpZiAoXG4gICAgICB0YXJnZXQgJiZcbiAgICAgIHRhcmdldC5jbGFzc05hbWUgPT09IGxheWVyQ2xhc3NOYW1lICYmXG4gICAgICAoIWJhY2tncm91bmRDb2xvciB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciAmJlxuICAgICAgICAgIGVxdWFscyhcbiAgICAgICAgICAgIGFzQXJyYXkodGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciksXG4gICAgICAgICAgICBhc0FycmF5KGJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICApKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRhcmdldC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGlmIChjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9PT0gdHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb250YWluZXIgb2YgdGhlIHByZXZpb3VzIGxheWVyIHJlbmRlcmVyIGNhbiBiZSB1c2VkLlxuICAgICAgdGhpcy5jb250YWluZXIgPSB0YXJnZXQ7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5jb250YWluZXJSZXVzZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIC8vIFByZXZpb3VzbHkgcmV1c2VkIGNvbnRhaW5lciBjYW5ub3QgYmUgdXNlZCBhbnkgbW9yZS5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRhaW5lclJldXNlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGxheWVyQ2xhc3NOYW1lO1xuICAgICAgbGV0IHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ3RvcCBsZWZ0JztcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIXRoaXMuY29udGFpbmVyUmV1c2VkICYmXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgJiZcbiAgICAgICF0aGlzLmNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICApIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgQ2xpcCBleHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNsaXBVbnJvdGF0ZWQoY29udGV4dCwgZnJhbWVTdGF0ZSwgZXh0ZW50KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG5cbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BMZWZ0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BSaWdodCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbUxlZnQpO1xuXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgdG9wTGVmdCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oaW52ZXJ0ZWQsIHRvcFJpZ2h0KTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGludmVydGVkLCBib3R0b21MZWZ0KTtcblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oTWF0aC5yb3VuZCh0b3BMZWZ0WzBdKSwgTWF0aC5yb3VuZCh0b3BMZWZ0WzFdKSk7XG4gICAgY29udGV4dC5saW5lVG8oTWF0aC5yb3VuZCh0b3BSaWdodFswXSksIE1hdGgucm91bmQodG9wUmlnaHRbMV0pKTtcbiAgICBjb250ZXh0LmxpbmVUbyhNYXRoLnJvdW5kKGJvdHRvbVJpZ2h0WzBdKSwgTWF0aC5yb3VuZChib3R0b21SaWdodFsxXSkpO1xuICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQoYm90dG9tTGVmdFswXSksIE1hdGgucm91bmQoYm90dG9tTGVmdFsxXSkpO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50Xyh0eXBlLCBjb250ZXh0LCBmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgaWYgKGxheWVyLmhhc0xpc3RlbmVyKHR5cGUpKSB7XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBSZW5kZXJFdmVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgICBsYXllci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJlUmVuZGVyKGNvbnRleHQsIGZyYW1lU3RhdGUpIHtcbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlO1xuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudF8oUmVuZGVyRXZlbnRUeXBlLlBSRVJFTkRFUiwgY29udGV4dCwgZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcG9zdFJlbmRlcihjb250ZXh0LCBmcmFtZVN0YXRlKSB7XG4gICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50XyhSZW5kZXJFdmVudFR5cGUuUE9TVFJFTkRFUiwgY29udGV4dCwgZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nIHRvIGFuIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHJvdGF0ZWQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZW5kZXJlZCBlbGVtZW50IChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVuZGVyZWQgZWxlbWVudCAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggT2Zmc2V0IG9uIHRoZSB4LWF4aXMgaW4gdmlldyBjb29yZGluYXRlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gVHJhbnNmb3JtLlxuICAgKi9cbiAgZ2V0UmVuZGVyVHJhbnNmb3JtKFxuICAgIGNlbnRlcixcbiAgICByZXNvbHV0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG9mZnNldFhcbiAgKSB7XG4gICAgY29uc3QgZHgxID0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGR5MSA9IGhlaWdodCAvIDI7XG4gICAgY29uc3Qgc3ggPSBwaXhlbFJhdGlvIC8gcmVzb2x1dGlvbjtcbiAgICBjb25zdCBzeSA9IC1zeDtcbiAgICBjb25zdCBkeDIgPSAtY2VudGVyWzBdICsgb2Zmc2V0WDtcbiAgICBjb25zdCBkeTIgPSAtY2VudGVyWzFdO1xuICAgIHJldHVybiBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgdGhpcy50ZW1wVHJhbnNmb3JtLFxuICAgICAgZHgxLFxuICAgICAgZHkxLFxuICAgICAgc3gsXG4gICAgICBzeSxcbiAgICAgIC1yb3RhdGlvbixcbiAgICAgIGR4MixcbiAgICAgIGR5MlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgZGVsZXRlIHRoaXMuZnJhbWVTdGF0ZTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNMYXllclJlbmRlcmVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9GZWF0dXJlXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4vT2JqZWN0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7dHlwZW9mIEZlYXR1cmV8dHlwZW9mIGltcG9ydChcIi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZUNsYXNzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RmVhdHVyZXxpbXBvcnQoXCIuL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmVMaWtlXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmdlb21ldHJ5JywgaW1wb3J0KFwiLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc1xuICogICAgIHwnY2hhbmdlOmdlb21ldHJ5JywgUmV0dXJuPn0gRmVhdHVyZU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gW0dlb21ldHJ5PWltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0XVxuICogQHR5cGVkZWYge09iamVjdDxzdHJpbmcsICo+ICYgeyBnZW9tZXRyeT86IEdlb21ldHJ5IH19IE9iamVjdFdpdGhHZW9tZXRyeVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSB2ZWN0b3Igb2JqZWN0IGZvciBnZW9ncmFwaGljIGZlYXR1cmVzIHdpdGggYSBnZW9tZXRyeSBhbmQgb3RoZXJcbiAqIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzLCBzaW1pbGFyIHRvIHRoZSBmZWF0dXJlcyBpbiB2ZWN0b3IgZmlsZSBmb3JtYXRzIGxpa2VcbiAqIEdlb0pTT04uXG4gKlxuICogRmVhdHVyZXMgY2FuIGJlIHN0eWxlZCBpbmRpdmlkdWFsbHkgd2l0aCBgc2V0U3R5bGVgOyBvdGhlcndpc2UgdGhleSB1c2UgdGhlXG4gKiBzdHlsZSBvZiB0aGVpciB2ZWN0b3IgbGF5ZXIuXG4gKlxuICogTm90ZSB0aGF0IGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIGFyZSBzZXQgYXMge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH0gcHJvcGVydGllcyBvblxuICogdGhlIGZlYXR1cmUgb2JqZWN0LCBzbyB0aGV5IGFyZSBvYnNlcnZhYmxlLCBhbmQgaGF2ZSBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBUeXBpY2FsbHksIGEgZmVhdHVyZSBoYXMgYSBzaW5nbGUgZ2VvbWV0cnkgcHJvcGVydHkuIFlvdSBjYW4gc2V0IHRoZVxuICogZ2VvbWV0cnkgdXNpbmcgdGhlIGBzZXRHZW9tZXRyeWAgbWV0aG9kIGFuZCBnZXQgaXQgd2l0aCBgZ2V0R2VvbWV0cnlgLlxuICogSXQgaXMgcG9zc2libGUgdG8gc3RvcmUgbW9yZSB0aGFuIG9uZSBnZW9tZXRyeSBvbiBhIGZlYXR1cmUgdXNpbmcgYXR0cmlidXRlXG4gKiBwcm9wZXJ0aWVzLiBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgdXNlZCBmb3IgcmVuZGVyaW5nIGlzIGlkZW50aWZpZWQgYnlcbiAqIHRoZSBwcm9wZXJ0eSBuYW1lIGBnZW9tZXRyeWAuIElmIHlvdSB3YW50IHRvIHVzZSBhbm90aGVyIGdlb21ldHJ5IHByb3BlcnR5XG4gKiBmb3IgcmVuZGVyaW5nLCB1c2UgdGhlIGBzZXRHZW9tZXRyeU5hbWVgIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGF0dHJpYnV0ZVxuICogcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuICBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICpcbiAqIGltcG9ydCBGZWF0dXJlIGZyb20gJ29sL0ZlYXR1cmUuanMnO1xuICogaW1wb3J0IFBvbHlnb24gZnJvbSAnb2wvZ2VvbS9Qb2x5Z29uLmpzJztcbiAqIGltcG9ydCBQb2ludCBmcm9tICdvbC9nZW9tL1BvaW50LmpzJztcbiAqXG4gKiBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmUoe1xuICogICBnZW9tZXRyeTogbmV3IFBvbHlnb24ocG9seUNvb3JkcyksXG4gKiAgIGxhYmVsUG9pbnQ6IG5ldyBQb2ludChsYWJlbENvb3JkcyksXG4gKiAgIG5hbWU6ICdNeSBQb2x5Z29uJyxcbiAqIH0pO1xuICpcbiAqIC8vIGdldCB0aGUgcG9seWdvbiBnZW9tZXRyeVxuICogY29uc3QgcG9seSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAqXG4gKiAvLyBSZW5kZXIgdGhlIGZlYXR1cmUgYXMgYSBwb2ludCB1c2luZyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBsYWJlbFBvaW50XG4gKiBmZWF0dXJlLnNldEdlb21ldHJ5TmFtZSgnbGFiZWxQb2ludCcpO1xuICpcbiAqIC8vIGdldCB0aGUgcG9pbnQgZ2VvbWV0cnlcbiAqIGNvbnN0IHBvaW50ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICogYGBgXG4gKlxuICogQGFwaVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gW0dlb21ldHJ5PWltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0XVxuICovXG5jbGFzcyBGZWF0dXJlIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5fE9iamVjdFdpdGhHZW9tZXRyeTxHZW9tZXRyeT59IFtnZW9tZXRyeU9yUHJvcGVydGllc11cbiAgICogICAgIFlvdSBtYXkgcGFzcyBhIEdlb21ldHJ5IG9iamVjdCBkaXJlY3RseSwgb3IgYW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZ1xuICAgKiAgICAgcHJvcGVydGllcy4gSWYgeW91IHBhc3MgYW4gb2JqZWN0IGxpdGVyYWwsIHlvdSBtYXkgaW5jbHVkZSBhIEdlb21ldHJ5XG4gICAqICAgICBhc3NvY2lhdGVkIHdpdGggYSBgZ2VvbWV0cnlgIGtleS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGdlb21ldHJ5T3JQcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7RmVhdHVyZU9uU2lnbmF0dXJlPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7RmVhdHVyZU9uU2lnbmF0dXJlPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtGZWF0dXJlT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaWRfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9ICdnZW9tZXRyeSc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyIHByb3ZpZGVkIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBudWxsO1xuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzLmdlb21ldHJ5TmFtZV8sIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXyk7XG5cbiAgICBpZiAoZ2VvbWV0cnlPclByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIChcbiAgICAgICAgICAvKiogQHR5cGUgez99ICovIChnZW9tZXRyeU9yUHJvcGVydGllcykuZ2V0U2ltcGxpZmllZEdlb21ldHJ5XG4gICAgICAgICkgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7R2VvbWV0cnl9ICovIChnZW9tZXRyeU9yUHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuc2V0R2VvbWV0cnkoZ2VvbWV0cnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAqPn0gKi9cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGdlb21ldHJ5T3JQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMgZmVhdHVyZS4gSWYgdGhlIG9yaWdpbmFsIGZlYXR1cmUgaGFzIGEgZ2VvbWV0cnkgaXRcbiAgICogaXMgYWxzbyBjbG9uZWQuIFRoZSBmZWF0dXJlIGlkIGlzIG5vdCBzZXQgaW4gdGhlIGNsb25lLlxuICAgKiBAcmV0dXJuIHtGZWF0dXJlPEdlb21ldHJ5Pn0gVGhlIGNsb25lLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IC8qKiBAdHlwZSB7RmVhdHVyZTxHZW9tZXRyeT59ICovIChcbiAgICAgIG5ldyBGZWF0dXJlKHRoaXMuaGFzUHJvcGVydGllcygpID8gdGhpcy5nZXRQcm9wZXJ0aWVzKCkgOiBudWxsKVxuICAgICk7XG4gICAgY2xvbmUuc2V0R2VvbWV0cnlOYW1lKHRoaXMuZ2V0R2VvbWV0cnlOYW1lKCkpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgY2xvbmUuc2V0R2VvbWV0cnkoLyoqIEB0eXBlIHtHZW9tZXRyeX0gKi8gKGdlb21ldHJ5LmNsb25lKCkpKTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjbG9uZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUncyBkZWZhdWx0IGdlb21ldHJ5LiAgQSBmZWF0dXJlIG1heSBoYXZlIGFueSBudW1iZXIgb2YgbmFtZWRcbiAgICogZ2VvbWV0cmllcy4gIFRoZSBcImRlZmF1bHRcIiBnZW9tZXRyeSAodGhlIG9uZSB0aGF0IGlzIHJlbmRlcmVkIGJ5IGRlZmF1bHQpIGlzXG4gICAqIHNldCB3aGVuIGNhbGxpbmcge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjc2V0R2VvbWV0cnl9LlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeXx1bmRlZmluZWR9IFRoZSBkZWZhdWx0IGdlb21ldHJ5IGZvciB0aGUgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7R2VvbWV0cnl8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQodGhpcy5nZW9tZXRyeU5hbWVfKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlIGlkZW50aWZpZXIuICBUaGlzIGlzIGEgc3RhYmxlIGlkZW50aWZpZXIgZm9yIHRoZSBmZWF0dXJlIGFuZFxuICAgKiBpcyBlaXRoZXIgc2V0IHdoZW4gcmVhZGluZyBkYXRhIGZyb20gYSByZW1vdGUgc291cmNlIG9yIHNldCBleHBsaWNpdGx5IGJ5XG4gICAqIGNhbGxpbmcge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjc2V0SWR9LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gSWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLmlkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUncyBkZWZhdWx0IGdlb21ldHJ5LiAgQnkgZGVmYXVsdCwgdGhlIGRlZmF1bHRcbiAgICogZ2VvbWV0cnkgaXMgbmFtZWQgYGdlb21ldHJ5YC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBHZXQgdGhlIHByb3BlcnR5IG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBkZWZhdWx0IGdlb21ldHJ5XG4gICAqICAgICBmb3IgdGhpcyBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRHZW9tZXRyeU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOYW1lXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUncyBzdHlsZS4gV2lsbCByZXR1cm4gd2hhdCB3YXMgcHJvdmlkZWQgdG8gdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI3NldFN0eWxlfSBtZXRob2QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfHVuZGVmaW5lZH0gVGhlIGZlYXR1cmUgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUncyBzdHlsZSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gUmV0dXJuIGEgZnVuY3Rpb25cbiAgICogcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0eWxlIG9mIHRoaXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3R5bGVGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUZ1bmN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlR2VvbWV0cnlDaGFuZ2VfKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVHZW9tZXRyeUNoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5Xyk7XG4gICAgICB0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBsaXN0ZW4oXG4gICAgICAgIGdlb21ldHJ5LFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlXyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGdlb21ldHJ5IGZvciB0aGUgZmVhdHVyZS4gIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHByb3BlcnR5XG4gICAqIHdpdGggdGhlIG5hbWUgcmV0dXJuZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjZ2V0R2VvbWV0cnlOYW1lfS5cbiAgICogQHBhcmFtIHtHZW9tZXRyeXx1bmRlZmluZWR9IGdlb21ldHJ5IFRoZSBuZXcgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICogQG9ic2VydmFibGVcbiAgICovXG4gIHNldEdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdGhpcy5zZXQodGhpcy5nZW9tZXRyeU5hbWVfLCBnZW9tZXRyeSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHlsZSBmb3IgdGhlIGZlYXR1cmUgdG8gb3ZlcnJpZGUgdGhlIGxheWVyIHN0eWxlLiAgVGhpcyBjYW4gYmUgYVxuICAgKiBzaW5nbGUgc3R5bGUgb2JqZWN0LCBhbiBhcnJheSBvZiBzdHlsZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhXG4gICAqIHJlc29sdXRpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygc3R5bGVzLiBUbyB1bnNldCB0aGUgZmVhdHVyZSBzdHlsZSwgY2FsbFxuICAgKiBgc2V0U3R5bGUoKWAgd2l0aG91dCBhcmd1bWVudHMgb3IgYSBmYWxzZXkgdmFsdWUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtzdHlsZV0gU3R5bGUgZm9yIHRoaXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKiBAZmlyZXMgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5CYXNlRXZlbnQjZXZlbnQ6Y2hhbmdlXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuc3R5bGVfID0gc3R5bGU7XG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9ICFzdHlsZSA/IHVuZGVmaW5lZCA6IGNyZWF0ZVN0eWxlRnVuY3Rpb24oc3R5bGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmVhdHVyZSBpZC4gIFRoZSBmZWF0dXJlIGlkIGlzIGNvbnNpZGVyZWQgc3RhYmxlIGFuZCBtYXkgYmUgdXNlZCB3aGVuXG4gICAqIHJlcXVlc3RpbmcgZmVhdHVyZXMgb3IgY29tcGFyaW5nIGlkZW50aWZpZXJzIHJldHVybmVkIGZyb20gYSByZW1vdGUgc291cmNlLlxuICAgKiBUaGUgZmVhdHVyZSBpZCBjYW4gYmUgdXNlZCB3aXRoIHRoZVxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldEZlYXR1cmVCeUlkfSBtZXRob2QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3x1bmRlZmluZWR9IGlkIFRoZSBmZWF0dXJlIGlkLlxuICAgKiBAYXBpXG4gICAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkJhc2VFdmVudCNldmVudDpjaGFuZ2VcbiAgICovXG4gIHNldElkKGlkKSB7XG4gICAgdGhpcy5pZF8gPSBpZDtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByb3BlcnR5IG5hbWUgdG8gYmUgdXNlZCB3aGVuIGdldHRpbmcgdGhlIGZlYXR1cmUncyBkZWZhdWx0IGdlb21ldHJ5LlxuICAgKiBXaGVuIGNhbGxpbmcge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjZ2V0R2VvbWV0cnl9LCB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHdpdGhcbiAgICogdGhpcyBuYW1lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBkZWZhdWx0IGdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZW9tZXRyeU5hbWUobmFtZSkge1xuICAgIHRoaXMucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5nZW9tZXRyeU5hbWVfLCB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8pO1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9IG5hbWU7XG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzLmdlb21ldHJ5TmFtZV8sIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXyk7XG4gICAgdGhpcy5oYW5kbGVHZW9tZXRyeUNoYW5nZWRfKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwcm92aWRlZCBvYmplY3QgaW50byBhIGZlYXR1cmUgc3R5bGUgZnVuY3Rpb24uICBGdW5jdGlvbnMgcGFzc2VkXG4gKiB0aHJvdWdoIHVuY2hhbmdlZC4gIEFycmF5cyBvZiBTdHlsZSBvciBzaW5nbGUgc3R5bGUgb2JqZWN0cyB3cmFwcGVkXG4gKiBpbiBhIG5ldyBmZWF0dXJlIHN0eWxlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufCFBcnJheTxpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fCFpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IG9ialxuICogICAgIEEgZmVhdHVyZSBzdHlsZSBmdW5jdGlvbiwgYSBzaW5nbGUgc3R5bGUsIG9yIGFuIGFycmF5IG9mIHN0eWxlcy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbn0gQSBzdHlsZSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRnVuY3Rpb24ob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD59XG4gICAqL1xuICBsZXQgc3R5bGVzO1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgc3R5bGVzID0gb2JqO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob2JqKS5nZXRaSW5kZXgpID09PSAnZnVuY3Rpb24nLFxuICAgICAgJ0V4cGVjdGVkIGFuIGBvbC9zdHlsZS9TdHlsZWAgb3IgYW4gYXJyYXkgb2YgYG9sL3N0eWxlL1N0eWxlLmpzYCdcbiAgICApO1xuICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9ICovIChvYmopO1xuICAgIHN0eWxlcyA9IFtzdHlsZV07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3R5bGVzO1xuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgRmVhdHVyZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvRmlsbFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfG51bGx9IFtjb2xvcj1udWxsXSBBIGNvbG9yLCBncmFkaWVudCBvciBwYXR0ZXJuLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGZvciBwb3NzaWJsZSBmb3JtYXRzLlxuICogRGVmYXVsdCBudWxsOyBpZiBudWxsLCB0aGUgQ2FudmFzL3JlbmRlcmVyIGRlZmF1bHQgYmxhY2sgd2lsbCBiZSB1c2VkLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGZpbGwgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRmlsbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29sb3JfID0gb3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xvciA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS4gVGhlIGNvbG9yIGlzIG5vdCBjbG9uZWQgaWYgaXQgaXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAgICogQHJldHVybiB7RmlsbH0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIG5ldyBGaWxsKHtcbiAgICAgIGNvbG9yOiBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yLnNsaWNlKCkgOiBjb2xvciB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfG51bGx9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2xvci5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfG51bGx9IGNvbG9yIENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb2xvcihjb2xvcikge1xuICAgIHRoaXMuY29sb3JfID0gY29sb3I7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsbDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ludGVycG9sYXRlXG4gKi9cbmltcG9ydCB7YmluYXJ5U2VhcmNofSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2xlcnB9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJhY3Rpb24gRnJhY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEZXN0aW5hdGlvbiBkaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKVxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRGVzdGluYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZVBvaW50KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGZyYWN0aW9uLFxuICBkZXN0LFxuICBkaW1lbnNpb25cbikge1xuICBsZXQgbywgdDtcbiAgY29uc3QgbiA9IChlbmQgLSBvZmZzZXQpIC8gc3RyaWRlO1xuICBpZiAobiA9PT0gMSkge1xuICAgIG8gPSBvZmZzZXQ7XG4gIH0gZWxzZSBpZiAobiA9PT0gMikge1xuICAgIG8gPSBvZmZzZXQ7XG4gICAgdCA9IGZyYWN0aW9uO1xuICB9IGVsc2UgaWYgKG4gIT09IDApIHtcbiAgICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgY29uc3QgY3VtdWxhdGl2ZUxlbmd0aHMgPSBbMF07XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldCArIHN0cmlkZTsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgbGVuZ3RoICs9IE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgICAgY3VtdWxhdGl2ZUxlbmd0aHMucHVzaChsZW5ndGgpO1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGZyYWN0aW9uICogbGVuZ3RoO1xuICAgIGNvbnN0IGluZGV4ID0gYmluYXJ5U2VhcmNoKGN1bXVsYXRpdmVMZW5ndGhzLCB0YXJnZXQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHQgPVxuICAgICAgICAodGFyZ2V0IC0gY3VtdWxhdGl2ZUxlbmd0aHNbLWluZGV4IC0gMl0pIC9cbiAgICAgICAgKGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDFdIC0gY3VtdWxhdGl2ZUxlbmd0aHNbLWluZGV4IC0gMl0pO1xuICAgICAgbyA9IG9mZnNldCArICgtaW5kZXggLSAyKSAqIHN0cmlkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbyA9IG9mZnNldCArIGluZGV4ICogc3RyaWRlO1xuICAgIH1cbiAgfVxuICBkaW1lbnNpb24gPSBkaW1lbnNpb24gPiAxID8gZGltZW5zaW9uIDogMjtcbiAgZGVzdCA9IGRlc3QgPyBkZXN0IDogbmV3IEFycmF5KGRpbWVuc2lvbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uOyArK2kpIHtcbiAgICBkZXN0W2ldID1cbiAgICAgIG8gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IE5hTlxuICAgICAgICA6IHQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZsYXRDb29yZGluYXRlc1tvICsgaV1cbiAgICAgICAgOiBsZXJwKGZsYXRDb29yZGluYXRlc1tvICsgaV0sIGZsYXRDb29yZGluYXRlc1tvICsgc3RyaWRlICsgaV0sIHQpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICogQHBhcmFtIHtib29sZWFufSBleHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZ0Nvb3JkaW5hdGVBdE0oXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgbSxcbiAgZXh0cmFwb2xhdGVcbikge1xuICBpZiAoZW5kID09IG9mZnNldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBjb29yZGluYXRlO1xuICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgLSAxXSkge1xuICAgIGlmIChleHRyYXBvbGF0ZSkge1xuICAgICAgY29vcmRpbmF0ZSA9IGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHN0cmlkZSk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZmxhdENvb3JkaW5hdGVzW2VuZCAtIDFdIDwgbSkge1xuICAgIGlmIChleHRyYXBvbGF0ZSkge1xuICAgICAgY29vcmRpbmF0ZSA9IGZsYXRDb29yZGluYXRlcy5zbGljZShlbmQgLSBzdHJpZGUsIGVuZCk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBGSVhNRSB1c2UgTygxKSBzZWFyY2hcbiAgaWYgKG0gPT0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZSAtIDFdKSB7XG4gICAgcmV0dXJuIGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHN0cmlkZSk7XG4gIH1cbiAgbGV0IGxvID0gb2Zmc2V0IC8gc3RyaWRlO1xuICBsZXQgaGkgPSBlbmQgLyBzdHJpZGU7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbKG1pZCArIDEpICogc3RyaWRlIC0gMV0pIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsbyA9IG1pZCArIDE7XG4gICAgfVxuICB9XG4gIGNvbnN0IG0wID0gZmxhdENvb3JkaW5hdGVzW2xvICogc3RyaWRlIC0gMV07XG4gIGlmIChtID09IG0wKSB7XG4gICAgcmV0dXJuIGZsYXRDb29yZGluYXRlcy5zbGljZSgobG8gLSAxKSAqIHN0cmlkZSwgKGxvIC0gMSkgKiBzdHJpZGUgKyBzdHJpZGUpO1xuICB9XG4gIGNvbnN0IG0xID0gZmxhdENvb3JkaW5hdGVzWyhsbyArIDEpICogc3RyaWRlIC0gMV07XG4gIGNvbnN0IHQgPSAobSAtIG0wKSAvIChtMSAtIG0wKTtcbiAgY29vcmRpbmF0ZSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZSAtIDE7ICsraSkge1xuICAgIGNvb3JkaW5hdGUucHVzaChcbiAgICAgIGxlcnAoXG4gICAgICAgIGZsYXRDb29yZGluYXRlc1sobG8gLSAxKSAqIHN0cmlkZSArIGldLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbbG8gKiBzdHJpZGUgKyBpXSxcbiAgICAgICAgdFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgY29vcmRpbmF0ZS5wdXNoKG0pO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludGVycG9sYXRlIEludGVycG9sYXRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfG51bGx9IENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nc0Nvb3JkaW5hdGVBdE0oXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIG0sXG4gIGV4dHJhcG9sYXRlLFxuICBpbnRlcnBvbGF0ZVxuKSB7XG4gIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZHNbZW5kcy5sZW5ndGggLSAxXSxcbiAgICAgIHN0cmlkZSxcbiAgICAgIG0sXG4gICAgICBleHRyYXBvbGF0ZVxuICAgICk7XG4gIH1cbiAgbGV0IGNvb3JkaW5hdGU7XG4gIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzW3N0cmlkZSAtIDFdKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKDAsIHN0cmlkZSk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZmxhdENvb3JkaW5hdGVzW2ZsYXRDb29yZGluYXRlcy5sZW5ndGggLSAxXSA8IG0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAtIHN0cmlkZSk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlIC0gMV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobSA8PSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gMV0pIHtcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBtLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvbGVuZ3RoXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBMZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nTGVuZ3RoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IG9mZnNldCArIHN0cmlkZTsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgbGVuZ3RoICs9IE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBlcmltZXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdMZW5ndGgoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIGxldCBwZXJpbWV0ZXIgPSBsaW5lU3RyaW5nTGVuZ3RoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gIGNvbnN0IGR4ID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV0gLSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgY29uc3QgZHkgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV0gLSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIHBlcmltZXRlciArPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICByZXR1cm4gcGVyaW1ldGVyO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9TdHJva2VcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2NvbG9yXSBBIGNvbG9yLCBncmFkaWVudCBvciBwYXR0ZXJuLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGZvciBwb3NzaWJsZSBmb3JtYXRzLlxuICogRGVmYXVsdCBudWxsOyBpZiBudWxsLCB0aGUgQ2FudmFzL3JlbmRlcmVyIGRlZmF1bHQgYmxhY2sgd2lsbCBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBbbGluZUNhcD0ncm91bmQnXSBMaW5lIGNhcCBzdHlsZTogYGJ1dHRgLCBgcm91bmRgLCBvciBgc3F1YXJlYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFtsaW5lSm9pbj0ncm91bmQnXSBMaW5lIGpvaW4gc3R5bGU6IGBiZXZlbGAsIGByb3VuZGAsIG9yIGBtaXRlcmAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtsaW5lRGFzaF0gTGluZSBkYXNoIHBhdHRlcm4uIERlZmF1bHQgaXMgYG51bGxgIChubyBkYXNoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZURhc2hPZmZzZXQ9MF0gTGluZSBkYXNoIG9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWl0ZXJMaW1pdD0xMF0gTWl0ZXIgbGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXSBXaWR0aC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBzdHJva2Ugc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIE5vdGUgdGhhdCB0aGUgZGVmYXVsdHMgZ2l2ZW4gYXJlIHRoZSBDYW52YXMgZGVmYXVsdHMsIHdoaWNoIHdpbGwgYmUgdXNlZCBpZlxuICogb3B0aW9uIGlzIG5vdCBkZWZpbmVkLiBUaGUgYGdldGAgZnVuY3Rpb25zIHJldHVybiB3aGF0ZXZlciB3YXMgZW50ZXJlZCBpblxuICogdGhlIG9wdGlvbnM7IHRoZXkgd2lsbCBub3QgcmV0dXJuIHRoZSBkZWZhdWx0LlxuICogQGFwaVxuICovXG5jbGFzcyBTdHJva2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc0xpbmVDYXB8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZUNhcF8gPSBvcHRpb25zLmxpbmVDYXA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5saW5lRGFzaF8gPSBvcHRpb25zLmxpbmVEYXNoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxpbmVEYXNoIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5saW5lRGFzaE9mZnNldF8gPSBvcHRpb25zLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzTGluZUpvaW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZUpvaW5fID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5taXRlckxpbWl0XyA9IG9wdGlvbnMubWl0ZXJMaW1pdDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy53aWR0aF8gPSBvcHRpb25zLndpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge1N0cm9rZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJva2Uoe1xuICAgICAgY29sb3I6IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3Iuc2xpY2UoKSA6IGNvbG9yIHx8IHVuZGVmaW5lZCxcbiAgICAgIGxpbmVDYXA6IHRoaXMuZ2V0TGluZUNhcCgpLFxuICAgICAgbGluZURhc2g6IHRoaXMuZ2V0TGluZURhc2goKSA/IHRoaXMuZ2V0TGluZURhc2goKS5zbGljZSgpIDogdW5kZWZpbmVkLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMuZ2V0TGluZURhc2hPZmZzZXQoKSxcbiAgICAgIGxpbmVKb2luOiB0aGlzLmdldExpbmVKb2luKCksXG4gICAgICBtaXRlckxpbWl0OiB0aGlzLmdldE1pdGVyTGltaXQoKSxcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2UgY29sb3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGNhcCB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtDYW52YXNMaW5lQ2FwfHVuZGVmaW5lZH0gTGluZSBjYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVDYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZUNhcF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGRhc2ggc3R5bGUgZm9yIHRoZSBzdHJva2UuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58bnVsbH0gTGluZSBkYXNoLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0IGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBMaW5lIGRhc2ggb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaE9mZnNldF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGpvaW4gdHlwZSBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7Q2FudmFzTGluZUpvaW58dW5kZWZpbmVkfSBMaW5lIGpvaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVKb2luKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVKb2luXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pdGVyIGxpbWl0IGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNaXRlciBsaW1pdC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5taXRlckxpbWl0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSB3aWR0aC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gV2lkdGguXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGNvbG9yIENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb2xvcihjb2xvcikge1xuICAgIHRoaXMuY29sb3JfID0gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGNhcC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNMaW5lQ2FwfHVuZGVmaW5lZH0gbGluZUNhcCBMaW5lIGNhcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZUNhcChsaW5lQ2FwKSB7XG4gICAgdGhpcy5saW5lQ2FwXyA9IGxpbmVDYXA7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGRhc2guXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxudWxsfSBsaW5lRGFzaCBMaW5lIGRhc2guXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVEYXNoKGxpbmVEYXNoKSB7XG4gICAgdGhpcy5saW5lRGFzaF8gPSBsaW5lRGFzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpbmUgZGFzaCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gbGluZURhc2hPZmZzZXQgTGluZSBkYXNoIG9mZnNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpIHtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA9IGxpbmVEYXNoT2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGluZSBqb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc0xpbmVKb2lufHVuZGVmaW5lZH0gbGluZUpvaW4gTGluZSBqb2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMaW5lSm9pbihsaW5lSm9pbikge1xuICAgIHRoaXMubGluZUpvaW5fID0gbGluZUpvaW47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaXRlciBsaW1pdC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBtaXRlckxpbWl0IE1pdGVyIGxpbWl0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaXRlckxpbWl0KG1pdGVyTGltaXQpIHtcbiAgICB0aGlzLm1pdGVyTGltaXRfID0gbWl0ZXJMaW1pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdpZHRoLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHdpZHRoIFdpZHRoLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIHRoaXMud2lkdGhfID0gd2lkdGg7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3Ryb2tlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JbWFnZVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQHByb3BlcnR5IHtib29sZWFufSByb3RhdGVXaXRoVmlldyBJZiB0aGUgaW1hZ2Ugc2hvdWxkIGdldCByb3RhdGVkIHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBkaXNwbGFjZW1lbnQgRGlzcGxhY2VtZW50LlxuICogQHByb3BlcnR5IHtcImRlY2x1dHRlclwifFwib2JzdGFjbGVcInxcIm5vbmVcInx1bmRlZmluZWR9IGRlY2x1dHRlck1vZGUgRGVjbHV0dGVyIG1vZGU6IGBkZWNsdXR0ZXJgLCBgb2JzdGFjbGVgLCAnbm9uZSAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgYmFzZSBjbGFzcyB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3QgaW5zdGFudGlhdGVkIGluXG4gKiBhcHBzLiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0sIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvQ2lyY2xlfkNpcmNsZVN0eWxlfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvUmVndWxhclNoYXBlflJlZ3VsYXJTaGFwZX0uXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgSW1hZ2VTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IG9wdGlvbnMub3BhY2l0eTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gb3B0aW9ucy5yb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUob3B0aW9ucy5zY2FsZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZGlzcGxhY2VtZW50XyA9IG9wdGlvbnMuZGlzcGxhY2VtZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8gPSBvcHRpb25zLmRlY2x1dHRlck1vZGU7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7SW1hZ2VTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XG4gICAgcmV0dXJuIG5ldyBJbWFnZVN0eWxlKHtcbiAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxuICAgICAgc2NhbGU6IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGUuc2xpY2UoKSA6IHNjYWxlLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBvcGFjaXR5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wYWNpdHkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eV87XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN5bWJvbGl6ZXIgcm90YXRlcyB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRlV2l0aFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltb2JsaXplciByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bWJvbGl6ZXIgc2NhbGUgYXJyYXkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gU2NhbGUgYXJyYXkuXG4gICAqL1xuICBnZXRTY2FsZUFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlQXJyYXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGlzcGxhY2VtZW50IG9mIHRoZSBzaGFwZVxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBTaGFwZSdzIGNlbnRlciBkaXNwbGFjZW1lbnRcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RGlzcGxhY2VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BsYWNlbWVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWNsdXR0ZXIgbW9kZSBvZiB0aGUgc2hhcGVcbiAgICogQHJldHVybiB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBTaGFwZSdzIGRlY2x1dHRlciBtb2RlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldERlY2x1dHRlck1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbHV0dGVyTW9kZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4gICAqIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbmNob3IuXG4gICAqL1xuICBnZXRBbmNob3IoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBlbGVtZW50IGZvciB0aGUgc3ltYm9saXplci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBJbWFnZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SW1hZ2UocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBJbWFnZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBwaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gUGl4ZWwgcmF0aW8uXG4gICAqL1xuICBnZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICovXG4gIGdldEltYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbiBvZiB0aGUgc3ltYm9saXplci5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWdpbi5cbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIHN5bWJvbGl6ZXIgKGluIHBpeGVscykuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNpemUuXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGlzcGxhY2VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRpc3BsYWNlbWVudCBEaXNwbGFjZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldERpc3BsYWNlbWVudChkaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudF8gPSBkaXNwbGFjZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBvcGFjaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLm9wYWNpdHlfID0gb3BhY2l0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0byByb3RhdGUgdGhlIHN0eWxlIHdpdGggdGhlIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcm90YXRlV2l0aFZpZXcgUm90YXRlIHdpdGggbWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSb3RhdGVXaXRoVmlldyhyb3RhdGVXaXRoVmlldykge1xuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gcm90YXRlV2l0aFZpZXc7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByb3RhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzY2FsZSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnNjYWxlXyA9IHNjYWxlO1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUoc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KTogdm9pZH0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICBsaXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KTogdm9pZH0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICB1bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVN0eWxlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb2xvcmxpa2VcbiAqL1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnLi9jb2xvci5qcyc7XG5cbi8qKlxuICogQSB0eXBlIGFjY2VwdGVkIGJ5IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5maWxsU3R5bGVcbiAqIG9yIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5zdHJva2VTdHlsZS5cbiAqIFJlcHJlc2VudHMgYSBjb2xvciwgcGF0dGVybiwgb3IgZ3JhZGllbnQuIFRoZSBvcmlnaW4gZm9yIHBhdHRlcm5zIGFuZFxuICogZ3JhZGllbnRzIGFzIGZpbGwgc3R5bGUgaXMgYW4gaW5jcmVtZW50IG9mIDUxMiBjc3MgcGl4ZWxzIGZyb20gbWFwIGNvb3JkaW5hdGVcbiAqIGBbMCwgMF1gLiBGb3Igc2VhbWxlc3MgcmVwZWF0IHBhdHRlcm5zLCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBwYXR0ZXJuIGltYWdlXG4gKiBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLlxuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd8Q2FudmFzUGF0dGVybnxDYW52YXNHcmFkaWVudH0gQ29sb3JMaWtlXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29sb3IuanNcIikuQ29sb3J8Q29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yTGlrZX0gVGhlIGNvbG9yIGFzIGFuIHtAbGluayBvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQ29sb3JMaWtlKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIHJldHVybiB0b1N0cmluZyhjb2xvcik7XG4gIH1cbiAgcmV0dXJuIGNvbG9yO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9SZWd1bGFyU2hhcGVcbiAqL1xuXG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0TGluZUNhcCxcbiAgZGVmYXVsdExpbmVKb2luLFxuICBkZWZhdWx0TGluZVdpZHRoLFxuICBkZWZhdWx0TWl0ZXJMaW1pdCxcbiAgZGVmYXVsdFN0cm9rZVN0eWxlLFxufSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcblxuLyoqXG4gKiBTcGVjaWZ5IHJhZGl1cyBmb3IgcmVndWxhciBwb2x5Z29ucywgb3IgcmFkaXVzMSBhbmQgcmFkaXVzMiBmb3Igc3RhcnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb2ludHMgTnVtYmVyIG9mIHBvaW50cyBmb3Igc3RhcnMgYW5kIHJlZ3VsYXIgcG9seWdvbnMuIEluIGNhc2Ugb2YgYSBwb2x5Z29uLCB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICogaXMgdGhlIG51bWJlciBvZiBzaWRlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzXSBSYWRpdXMgb2YgYSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1czFdIEZpcnN0IHJhZGl1cyBvZiBhIHN0YXIuIElnbm9yZWQgaWYgcmFkaXVzIGlzIHNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMl0gU2Vjb25kIHJhZGl1cyBvZiBhIHN0YXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2FuZ2xlPTBdIFNoYXBlJ3MgYW5nbGUgaW4gcmFkaWFucy4gQSB2YWx1ZSBvZiAwIHdpbGwgaGF2ZSBvbmUgb2YgdGhlIHNoYXBlJ3MgcG9pbnRzIGZhY2luZyB1cC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwgMF1dIERpc3BsYWNlbWVudCBvZiB0aGUgc2hhcGUgaW4gcGl4ZWxzLlxuICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgc2hpZnQgdGhlIHNoYXBlIHJpZ2h0IGFuZCB1cC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGU9MV0gU2NhbGUuIFVubGVzcyB0d28gZGltZW5zaW9uYWwgc2NhbGluZyBpcyByZXF1aXJlZCBhIGJldHRlclxuICogcmVzdWx0IG1heSBiZSBvYnRhaW5lZCB3aXRoIGFwcHJvcHJpYXRlIHNldHRpbmdzIGZvciBgcmFkaXVzYCwgYHJhZGl1czFgIGFuZCBgcmFkaXVzMmAuXG4gKiBAcHJvcGVydHkge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH0gW2RlY2x1dHRlck1vZGVdIERlY2x1dHRlciBtb2RlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfHVuZGVmaW5lZH0gc3Ryb2tlU3R5bGUgU3Ryb2tlU3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3Ryb2tlV2lkdGggU3Ryb2tlV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBTaXplLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBsaW5lQ2FwIExpbmVDYXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj58bnVsbH0gbGluZURhc2ggTGluZURhc2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXQgTGluZURhc2hPZmZzZXQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBsaW5lSm9pbiBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0IE1pdGVyTGltaXQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgcmVndWxhciBzaGFwZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLiBUaGUgcmVzdWx0aW5nIHNoYXBlIHdpbGwgYmVcbiAqIGEgcmVndWxhciBwb2x5Z29uIHdoZW4gYHJhZGl1c2AgaXMgcHJvdmlkZWQsIG9yIGEgc3RhciB3aGVuIGByYWRpdXMxYCBhbmRcbiAqIGByYWRpdXMyYCBhcmUgcHJvdmlkZWQuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFJlZ3VsYXJTaGFwZSBleHRlbmRzIEltYWdlU3R5bGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY29uc3Qgcm90YXRlV2l0aFZpZXcgPVxuICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuXG4gICAgc3VwZXIoe1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlldyxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMCxcbiAgICAgIHNjYWxlOiBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMSxcbiAgICAgIGRpc3BsYWNlbWVudDpcbiAgICAgICAgb3B0aW9ucy5kaXNwbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGlzcGxhY2VtZW50IDogWzAsIDBdLFxuICAgICAgZGVjbHV0dGVyTW9kZTogb3B0aW9ucy5kZWNsdXR0ZXJNb2RlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PG51bWJlciwgSFRNTENhbnZhc0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzZXNfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxfID0gb3B0aW9ucy5maWxsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZpbGwgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbl8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb2ludHNfID0gb3B0aW9ucy5wb2ludHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1c18gPVxuICAgICAgb3B0aW9ucy5yYWRpdXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmFkaXVzIDogb3B0aW9ucy5yYWRpdXMxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1czJfID0gb3B0aW9ucy5yYWRpdXMyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGVfID0gb3B0aW9ucy5hbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmdsZSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnNpemVfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyT3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlck9wdGlvbnNfO1xuXG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtSZWd1bGFyU2hhcGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgIGNvbnN0IHN0eWxlID0gbmV3IFJlZ3VsYXJTaGFwZSh7XG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBwb2ludHM6IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICByYWRpdXM6IHRoaXMuZ2V0UmFkaXVzKCksXG4gICAgICByYWRpdXMyOiB0aGlzLmdldFJhZGl1czIoKSxcbiAgICAgIGFuZ2xlOiB0aGlzLmdldEFuZ2xlKCksXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIHNjYWxlOiBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gICAgc3R5bGUuc2V0T3BhY2l0eSh0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IGluIHBpeGVscy4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbmNob3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFuY2hvcigpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplXztcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLmdldERpc3BsYWNlbWVudCgpO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZUFycmF5KCk7XG4gICAgLy8gYW5jaG9yIGlzIHNjYWxlZCBieSByZW5kZXJlciBidXQgZGlzcGxhY2VtZW50IHNob3VsZCBub3QgYmUgc2NhbGVkXG4gICAgLy8gc28gZGl2aWRlIGJ5IHNjYWxlIGhlcmVcbiAgICByZXR1cm4gW1xuICAgICAgc2l6ZVswXSAvIDIgLSBkaXNwbGFjZW1lbnRbMF0gLyBzY2FsZVswXSxcbiAgICAgIHNpemVbMV0gLyAyICsgZGlzcGxhY2VtZW50WzFdIC8gc2NhbGVbMV0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuZ2xlIHVzZWQgaW4gZ2VuZXJhdGluZyB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gU2hhcGUncyByb3RhdGlvbiBpbiByYWRpYW5zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIHN0eWxlIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmaWxsIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IGZpbGwgRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RmlsbChmaWxsKSB7XG4gICAgdGhpcy5maWxsXyA9IGZpbGw7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18oXG4gICAgICAgIHRoaXMucmVuZGVyT3B0aW9uc19cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhpdERldGVjdGlvbkNhbnZhc187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBpY29uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEltYWdlIG9yIENhbnZhcyBlbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgbGV0IGltYWdlID0gdGhpcy5jYW52YXNlc19bcGl4ZWxSYXRpb107XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHRoaXMucmVuZGVyT3B0aW9uc187XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgKiBwaXhlbFJhdGlvLFxuICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgKiBwaXhlbFJhdGlvXG4gICAgICApO1xuICAgICAgdGhpcy5kcmF3XyhyZW5kZXJPcHRpb25zLCBjb250ZXh0LCBwaXhlbFJhdGlvKTtcblxuICAgICAgaW1hZ2UgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIHRoaXMuY2FudmFzZXNfW3BpeGVsUmF0aW9dID0gaW1hZ2U7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIHBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBQaXhlbCByYXRpby5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICovXG4gIGdldEltYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWdpbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3JpZ2luKCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgcG9pbnRzIGZvciBnZW5lcmF0aW5nIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgcG9pbnRzIGZvciBzdGFycyBhbmQgcmVndWxhciBwb2x5Z29ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSAocHJpbWFyeSkgcmFkaXVzIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZGFyeSByYWRpdXMgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmFkaXVzMi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmFkaXVzMigpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXMyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIHN5bWJvbGl6ZXIgKGluIHBpeGVscykuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gU2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSBzdHlsZSBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKi9cbiAgbG9hZCgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIHVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhZGRpdGlvbmFsIGNhbnZhcyBzaXplIG5lZWRlZCBmb3IgdGhlIG1pdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZUpvaW4gTGluZSBqb2luXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VXaWR0aCBTdHJva2Ugd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pdGVyTGltaXQgTWl0ZXIgbGltaXRcbiAgICogQHJldHVybiB7bnVtYmVyfSBBZGRpdGlvbmFsIGNhbnZhcyBzaXplIG5lZWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlTGluZUpvaW5TaXplXyhsaW5lSm9pbiwgc3Ryb2tlV2lkdGgsIG1pdGVyTGltaXQpIHtcbiAgICBpZiAoXG4gICAgICBzdHJva2VXaWR0aCA9PT0gMCB8fFxuICAgICAgdGhpcy5wb2ludHNfID09PSBJbmZpbml0eSB8fFxuICAgICAgKGxpbmVKb2luICE9PSAnYmV2ZWwnICYmIGxpbmVKb2luICE9PSAnbWl0ZXInKVxuICAgICkge1xuICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICAvLyBtICB8IF5cbiAgICAvLyBpICB8IHxcXCAgICAgICAgICAgICAgICAgIC5cbiAgICAvLyB0ID58ICAjXFxcbiAgICAvLyBlICB8IHxcXCBcXCAgICAgICAgICAgICAgLlxuICAgIC8vIHIgICAgICBcXHNcXFxuICAgIC8vICAgICAgfCAgXFx0XFwgICAgICAgICAgLiAgICAgICAgICAgICAgICAgLlxuICAgIC8vICAgICAgICAgIFxcclxcICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICB8ICAgIFxcb1xcICAgICAgLiAgICAgICAgICAuICAuIC4gLlxuICAgIC8vICAgICAgICAgIGUgXFxrXFwgICAgICAgICAgICAuICAuICAgIC4gLlxuICAgIC8vICAgICAgfCAgICAgIFxcZVxcICAuICAgIC4gIC4gICAgICAgLiAuXG4gICAgLy8gICAgICAgZCAgICAgIFxcIFxcICAuICAuICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgfCBfIF9hXyBfXFwjICAuICAgICAgICAgICAgLiAuXG4gICAgLy8gICByMSAgICAgICAgICAvIGAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAuIC5cbiAgICAvLyAgICAgICBiICAgICAvICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICAgICAgIC8gcjIgICAgICAgICAgICAuIC5cbiAgICAvLyAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICB8XHUwM0IxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICBcdTAwQjAgY2VudGVyXG4gICAgbGV0IHIxID0gdGhpcy5yYWRpdXNfO1xuICAgIGxldCByMiA9IHRoaXMucmFkaXVzMl8gPT09IHVuZGVmaW5lZCA/IHIxIDogdGhpcy5yYWRpdXMyXztcbiAgICBpZiAocjEgPCByMikge1xuICAgICAgY29uc3QgdG1wID0gcjE7XG4gICAgICByMSA9IHIyO1xuICAgICAgcjIgPSB0bXA7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50cyA9XG4gICAgICB0aGlzLnJhZGl1czJfID09PSB1bmRlZmluZWQgPyB0aGlzLnBvaW50c18gOiB0aGlzLnBvaW50c18gKiAyO1xuICAgIGNvbnN0IGFscGhhID0gKDIgKiBNYXRoLlBJKSAvIHBvaW50cztcbiAgICBjb25zdCBhID0gcjIgKiBNYXRoLnNpbihhbHBoYSk7XG4gICAgY29uc3QgYiA9IE1hdGguc3FydChyMiAqIHIyIC0gYSAqIGEpO1xuICAgIGNvbnN0IGQgPSByMSAtIGI7XG4gICAgY29uc3QgZSA9IE1hdGguc3FydChhICogYSArIGQgKiBkKTtcbiAgICBjb25zdCBtaXRlclJhdGlvID0gZSAvIGE7XG4gICAgaWYgKGxpbmVKb2luID09PSAnbWl0ZXInICYmIG1pdGVyUmF0aW8gPD0gbWl0ZXJMaW1pdCkge1xuICAgICAgcmV0dXJuIG1pdGVyUmF0aW8gKiBzdHJva2VXaWR0aDtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIGNlbnRlciB0byB0aGUgc3Ryb2tlIGNvcm5lciB3aGVyZVxuICAgIC8vIGl0IHdhcyBjdXQgc2hvcnQgYmVjYXVzZSBvZiB0aGUgbWl0ZXIgbGltaXQuXG4gICAgLy8gICAgICAgICAgICAgIGxcbiAgICAvLyAgICAgICAgLS0tLSstLS0tIDw9IGRpc3RhbmNlIGZyb20gY2VudGVyIHRvIGhlcmUgaXMgbWF4clxuICAgIC8vICAgICAgIC8jIyMjfGsgIyNcXFxuICAgIC8vICAgICAgLyMjIyMjXiMjIyMjXFxcbiAgICAvLyAgICAgLyMjIyMgLytcXCMgcyAjXFxcbiAgICAvLyAgICAvIyMjIGgvKysrXFwjIHQgI1xcXG4gICAgLy8gICAvIyMjIHQvKysrKytcXCMgciAjXFxcbiAgICAvLyAgLyMjIyBhLysrKysrKytcXCMgbyAjXFxcbiAgICAvLyAvIyMjIHAvKysgZmlsbCArXFwjIGsgI1xcXG4gICAgLy8vIyMjIyAvKysrKyteKysrKytcXCMgZSAjXFxcbiAgICAvLyMjIyMjLysrKysrLytcXCsrKysrXFwjIyMjI1xcXG4gICAgY29uc3QgayA9IHN0cm9rZVdpZHRoIC8gMiAvIG1pdGVyUmF0aW87XG4gICAgY29uc3QgbCA9IChzdHJva2VXaWR0aCAvIDIpICogKGQgLyBlKTtcbiAgICBjb25zdCBtYXhyID0gTWF0aC5zcXJ0KChyMSArIGspICogKHIxICsgaykgKyBsICogbCk7XG4gICAgY29uc3QgYmV2ZWxBZGQgPSBtYXhyIC0gcjE7XG4gICAgaWYgKHRoaXMucmFkaXVzMl8gPT09IHVuZGVmaW5lZCB8fCBsaW5lSm9pbiA9PT0gJ2JldmVsJykge1xuICAgICAgcmV0dXJuIGJldmVsQWRkICogMjtcbiAgICB9XG4gICAgLy8gSWYgb3V0ZXIgbWl0ZXIgaXMgb3ZlciB0aGUgbWl0ZXIgbGltaXQgdGhlIGlubmVyIG1pdGVyIG1heSByZWFjaCB0aHJvdWdoIHRoZVxuICAgIC8vIGNlbnRlciBhbmQgYmUgbG9uZ2VyIHRoYW4gdGhlIGJldmVsLCBzYW1lIGNhbGN1bGF0aW9uIGFzIGFib3ZlIGJ1dCBzd2FwIHIxIC8gcjIuXG4gICAgY29uc3QgYWEgPSByMSAqIE1hdGguc2luKGFscGhhKTtcbiAgICBjb25zdCBiYiA9IE1hdGguc3FydChyMSAqIHIxIC0gYWEgKiBhYSk7XG4gICAgY29uc3QgZGQgPSByMiAtIGJiO1xuICAgIGNvbnN0IGVlID0gTWF0aC5zcXJ0KGFhICogYWEgKyBkZCAqIGRkKTtcbiAgICBjb25zdCBpbm5lck1pdGVyUmF0aW8gPSBlZSAvIGFhO1xuICAgIGlmIChpbm5lck1pdGVyUmF0aW8gPD0gbWl0ZXJMaW1pdCkge1xuICAgICAgY29uc3QgaW5uZXJMZW5ndGggPSAoaW5uZXJNaXRlclJhdGlvICogc3Ryb2tlV2lkdGgpIC8gMiAtIHIyIC0gcjE7XG4gICAgICByZXR1cm4gMiAqIE1hdGgubWF4KGJldmVsQWRkLCBpbm5lckxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBiZXZlbEFkZCAqIDI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UmVuZGVyT3B0aW9uc30gIFRoZSByZW5kZXIgb3B0aW9uc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVSZW5kZXJPcHRpb25zKCkge1xuICAgIGxldCBsaW5lQ2FwID0gZGVmYXVsdExpbmVDYXA7XG4gICAgbGV0IGxpbmVKb2luID0gZGVmYXVsdExpbmVKb2luO1xuICAgIGxldCBtaXRlckxpbWl0ID0gMDtcbiAgICBsZXQgbGluZURhc2ggPSBudWxsO1xuICAgIGxldCBsaW5lRGFzaE9mZnNldCA9IDA7XG4gICAgbGV0IHN0cm9rZVN0eWxlO1xuICAgIGxldCBzdHJva2VXaWR0aCA9IDA7XG5cbiAgICBpZiAodGhpcy5zdHJva2VfKSB7XG4gICAgICBzdHJva2VTdHlsZSA9IGFzQ29sb3JMaWtlKHRoaXMuc3Ryb2tlXy5nZXRDb2xvcigpID8/IGRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlXy5nZXRXaWR0aCgpID8/IGRlZmF1bHRMaW5lV2lkdGg7XG4gICAgICBsaW5lRGFzaCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lRGFzaCgpO1xuICAgICAgbGluZURhc2hPZmZzZXQgPSB0aGlzLnN0cm9rZV8uZ2V0TGluZURhc2hPZmZzZXQoKSA/PyAwO1xuICAgICAgbGluZUpvaW4gPSB0aGlzLnN0cm9rZV8uZ2V0TGluZUpvaW4oKSA/PyBkZWZhdWx0TGluZUpvaW47XG4gICAgICBsaW5lQ2FwID0gdGhpcy5zdHJva2VfLmdldExpbmVDYXAoKSA/PyBkZWZhdWx0TGluZUNhcDtcbiAgICAgIG1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZV8uZ2V0TWl0ZXJMaW1pdCgpID8/IGRlZmF1bHRNaXRlckxpbWl0O1xuICAgIH1cblxuICAgIGNvbnN0IGFkZCA9IHRoaXMuY2FsY3VsYXRlTGluZUpvaW5TaXplXyhsaW5lSm9pbiwgc3Ryb2tlV2lkdGgsIG1pdGVyTGltaXQpO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzXywgdGhpcy5yYWRpdXMyXyB8fCAwKTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5jZWlsKDIgKiBtYXhSYWRpdXMgKyBhZGQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdHlsZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBsaW5lQ2FwOiBsaW5lQ2FwLFxuICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgbGluZUpvaW46IGxpbmVKb2luLFxuICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlck9wdGlvbnNfID0gdGhpcy5jcmVhdGVSZW5kZXJPcHRpb25zKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVuZGVyT3B0aW9uc18uc2l6ZTtcbiAgICB0aGlzLmNhbnZhc2VzXyA9IHt9O1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IG51bGw7XG4gICAgdGhpcy5zaXplXyA9IFtzaXplLCBzaXplXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnMgUmVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IFRoZSByZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gVGhlIHBpeGVsIHJhdGlvLlxuICAgKi9cbiAgZHJhd18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgcGl4ZWxSYXRpbykge1xuICAgIGNvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgLy8gc2V0IG9yaWdpbiB0byBjYW52YXMgY2VudGVyXG4gICAgY29udGV4dC50cmFuc2xhdGUocmVuZGVyT3B0aW9ucy5zaXplIC8gMiwgcmVuZGVyT3B0aW9ucy5zaXplIC8gMik7XG5cbiAgICB0aGlzLmNyZWF0ZVBhdGhfKGNvbnRleHQpO1xuXG4gICAgaWYgKHRoaXMuZmlsbF8pIHtcbiAgICAgIGxldCBjb2xvciA9IHRoaXMuZmlsbF8uZ2V0Q29sb3IoKTtcbiAgICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBjb2xvciA9IGRlZmF1bHRGaWxsU3R5bGU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGFzQ29sb3JMaWtlKGNvbG9yKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5zdHJva2VTdHlsZSkge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUNhcCA9IHJlbmRlck9wdGlvbnMubGluZUNhcDtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSByZW5kZXJPcHRpb25zLmxpbmVKb2luO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gcmVuZGVyT3B0aW9ucy5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzIGNvbnRhaW5pbmcgdGhlIGljb25cbiAgICovXG4gIGNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucykge1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICBsZXQgY29sb3IgPSB0aGlzLmZpbGxfLmdldENvbG9yKCk7XG5cbiAgICAgIC8vIGRldGVybWluZSBpZiBmaWxsIGlzIHRyYW5zcGFyZW50IChvciBwYXR0ZXJuIG9yIGdyYWRpZW50KVxuICAgICAgbGV0IG9wYWNpdHkgPSAwO1xuICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29sb3IgPSBhc0FycmF5KGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yLmxlbmd0aCA9PT0gNCA/IGNvbG9yWzNdIDogMTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgIC8vIGlmIGEgdHJhbnNwYXJlbnQgZmlsbCBzdHlsZSBpcyBzZXQsIGNyZWF0ZSBhbiBleHRyYSBoaXQtZGV0ZWN0aW9uIGltYWdlXG4gICAgICAgIC8vIHdpdGggYSBkZWZhdWx0IGZpbGwgc3R5bGVcbiAgICAgICAgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChyZW5kZXJPcHRpb25zLnNpemUsIHJlbmRlck9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0ID8gY29udGV4dC5jYW52YXMgOiB0aGlzLmdldEltYWdlKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGRyYXcgaW4uXG4gICAqL1xuICBjcmVhdGVQYXRoXyhjb250ZXh0KSB7XG4gICAgbGV0IHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLnJhZGl1c187XG4gICAgaWYgKHBvaW50cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByYWRpdXMyID0gdGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkID8gcmFkaXVzIDogdGhpcy5yYWRpdXMyXztcbiAgICAgIGlmICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnRzICo9IDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5hbmdsZV8gLSBNYXRoLlBJIC8gMjtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoMiAqIE1hdGguUEkpIC8gcG9pbnRzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHM7IGkrKykge1xuICAgICAgICBjb25zdCBhbmdsZTAgPSBzdGFydEFuZ2xlICsgaSAqIHN0ZXA7XG4gICAgICAgIGNvbnN0IHJhZGl1c0MgPSBpICUgMiA9PT0gMCA/IHJhZGl1cyA6IHJhZGl1czI7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHJhZGl1c0MgKiBNYXRoLmNvcyhhbmdsZTApLCByYWRpdXNDICogTWF0aC5zaW4oYW5nbGUwKSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnMgUmVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IFRoZSBjb250ZXh0LlxuICAgKi9cbiAgZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCkge1xuICAgIC8vIHNldCBvcmlnaW4gdG8gY2FudmFzIGNlbnRlclxuICAgIGNvbnRleHQudHJhbnNsYXRlKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIpO1xuXG4gICAgdGhpcy5jcmVhdGVQYXRoXyhjb250ZXh0KTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5zdHJva2VTdHlsZSkge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSByZW5kZXJPcHRpb25zLmxpbmVKb2luO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gcmVuZGVyT3B0aW9ucy5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVndWxhclNoYXBlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9DaXJjbGVcbiAqL1xuXG5pbXBvcnQgUmVndWxhclNoYXBlIGZyb20gJy4vUmVndWxhclNoYXBlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYWRpdXMgQ2lyY2xlIHJhZGl1cy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbZGlzcGxhY2VtZW50PVswLDBdXSBkaXNwbGFjZW1lbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlPTFdIFNjYWxlLiBBIHR3byBkaW1lbnNpb25hbCBzY2FsZSB3aWxsIHByb2R1Y2UgYW4gZWxsaXBzZS5cbiAqIFVubGVzcyB0d28gZGltZW5zaW9uYWwgc2NhbGluZyBpcyByZXF1aXJlZCBhIGJldHRlciByZXN1bHQgbWF5IGJlIG9idGFpbmVkIHdpdGggYW4gYXBwcm9wcmlhdGUgc2V0dGluZyBmb3IgYHJhZGl1c2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UsIG1lYW5pbmdmdWwgb25seSB3aGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHR3byBkaW1lbnNpb25hbCBzY2FsZSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGVXaXRoVmlldz1mYWxzZV0gV2hldGhlciB0byByb3RhdGUgdGhlIHNoYXBlIHdpdGggdGhlIHZpZXdcbiAqIChtZWFuaW5nZnVsIG9ubHkgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSB0d28gZGltZW5zaW9uYWwgc2NhbGUpLlxuICogQHByb3BlcnR5IHtcImRlY2x1dHRlclwifFwib2JzdGFjbGVcInxcIm5vbmVcInx1bmRlZmluZWR9IFtkZWNsdXR0ZXJNb2RlXSBEZWNsdXR0ZXIgbW9kZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGNpcmNsZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBDaXJjbGVTdHlsZSBleHRlbmRzIFJlZ3VsYXJTaGFwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHtyYWRpdXM6IDV9O1xuXG4gICAgc3VwZXIoe1xuICAgICAgcG9pbnRzOiBJbmZpbml0eSxcbiAgICAgIGZpbGw6IG9wdGlvbnMuZmlsbCxcbiAgICAgIHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlLFxuICAgICAgc2NhbGU6IG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2NhbGUgOiAxLFxuICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwLFxuICAgICAgcm90YXRlV2l0aFZpZXc6XG4gICAgICAgIG9wdGlvbnMucm90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlV2l0aFZpZXcgOiBmYWxzZSxcbiAgICAgIGRpc3BsYWNlbWVudDpcbiAgICAgICAgb3B0aW9ucy5kaXNwbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGlzcGxhY2VtZW50IDogWzAsIDBdLFxuICAgICAgZGVjbHV0dGVyTW9kZTogb3B0aW9ucy5kZWNsdXR0ZXJNb2RlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge0NpcmNsZVN0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICBjb25zdCBzdHlsZSA9IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICByYWRpdXM6IHRoaXMuZ2V0UmFkaXVzKCksXG4gICAgICBzY2FsZTogQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGUsXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gICAgc3R5bGUuc2V0T3BhY2l0eSh0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2lyY2xlIHJhZGl1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBDaXJjbGUgcmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSYWRpdXMocmFkaXVzKSB7XG4gICAgdGhpcy5yYWRpdXNfID0gcmFkaXVzO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2lyY2xlU3R5bGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1N0eWxlXG4gKi9cblxuaW1wb3J0IENpcmNsZVN0eWxlIGZyb20gJy4vQ2lyY2xlLmpzJztcbmltcG9ydCBGaWxsIGZyb20gJy4vRmlsbC5qcyc7XG5pbXBvcnQgU3Ryb2tlIGZyb20gJy4vU3Ryb2tlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmV9IGFuZCBhIGB7bnVtYmVyfWBcbiAqIHJlcHJlc2VudGluZyB0aGUgdmlldydzIHJlc29sdXRpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGV9IG9yIGFuIGFycmF5IG9mIHRoZW0uIFRoaXMgd2F5IGUuZy4gYVxuICogdmVjdG9yIGxheWVyIGNhbiBiZSBzdHlsZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGVcbiAqIGZlYXR1cmUgd2lsbCBub3QgYmUgcmVuZGVyZWQuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIG51bWJlcik6KFN0eWxlfEFycmF5PFN0eWxlPnx2b2lkKX0gU3R5bGVGdW5jdGlvblxuICovXG5cbi8qKlxuICogQSB7QGxpbmsgU3R5bGV9LCBhbiBhcnJheSBvZiB7QGxpbmsgU3R5bGV9LCBvciBhIHtAbGluayBTdHlsZUZ1bmN0aW9ufS5cbiAqIEB0eXBlZGVmIHtTdHlsZXxBcnJheTxTdHlsZT58U3R5bGVGdW5jdGlvbn0gU3R5bGVMaWtlXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnl+R2VvbWV0cnl9IHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhbmQgc3R5bGVkIGZvciB0aGUgZmVhdHVyZS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSk6XG4gKiAgICAgKGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZCl9IEdlb21ldHJ5RnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi4gVGFrZXMgdHdvIGFyZ3VtZW50czpcbiAqXG4gKiAxLiBUaGUgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIGdlb21ldHJ5IGluIEdlb0pTT04gbm90YXRpb24uXG4gKiAyLiBUaGUge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXJ+U3RhdGV9IG9mIHRoZSBsYXllciByZW5kZXJlci5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fEFycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+PiksaW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLlN0YXRlKTogdm9pZH0gUmVuZGVyRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufSBbZ2VvbWV0cnldIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnlcbiAqIG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlciBmb3IgdGhpcyBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IFtpbWFnZV0gSW1hZ2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge1JlbmRlckZ1bmN0aW9ufSBbcmVuZGVyZXJdIEN1c3RvbSByZW5kZXJlci4gV2hlbiBjb25maWd1cmVkLCBgZmlsbGAsIGBzdHJva2VgIGFuZCBgaW1hZ2VgIHdpbGwgYmVcbiAqIGlnbm9yZWQsIGFuZCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBlYWNoIHJlbmRlciBmcmFtZSBmb3IgZWFjaCBnZW9tZXRyeS5cbiAqIEBwcm9wZXJ0eSB7UmVuZGVyRnVuY3Rpb259IFtoaXREZXRlY3Rpb25SZW5kZXJlcl0gQ3VzdG9tIHJlbmRlcmVyIGZvciBoaXQgZGV0ZWN0aW9uLiBJZiBwcm92aWRlZCB3aWxsIGJlIHVzZWRcbiAqIGluIGhpdCBkZXRlY3Rpb24gcmVuZGVyaW5nLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbc3Ryb2tlXSBTdHJva2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVGV4dC5qc1wiKS5kZWZhdWx0fSBbdGV4dF0gVGV4dCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBaIGluZGV4LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ29udGFpbmVyIGZvciB2ZWN0b3IgZmVhdHVyZSByZW5kZXJpbmcgc3R5bGVzLiBBbnkgY2hhbmdlcyBtYWRlIHRvIHRoZSBzdHlsZVxuICogb3IgaXRzIGNoaWxkcmVuIHRocm91Z2ggYHNldCooKWAgbWV0aG9kcyB3aWxsIG5vdCB0YWtlIGVmZmVjdCB1bnRpbCB0aGVcbiAqIGZlYXR1cmUgb3IgbGF5ZXIgdGhhdCB1c2VzIHRoZSBzdHlsZSBpcyByZS1yZW5kZXJlZC5cbiAqXG4gKiAjIyBGZWF0dXJlIHN0eWxlc1xuICpcbiAqIElmIG5vIHN0eWxlIGlzIGRlZmluZWQsIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzdHlsZSBpcyB1c2VkOlxuICogYGBganNcbiAqICBpbXBvcnQge0NpcmNsZSwgRmlsbCwgU3Ryb2tlLCBTdHlsZX0gZnJvbSAnb2wvc3R5bGUuanMnO1xuICpcbiAqICBjb25zdCBmaWxsID0gbmV3IEZpbGwoe1xuICogICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknLFxuICogIH0pO1xuICogIGNvbnN0IHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICogICAgY29sb3I6ICcjMzM5OUNDJyxcbiAqICAgIHdpZHRoOiAxLjI1LFxuICogIH0pO1xuICogIGNvbnN0IHN0eWxlcyA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICBmaWxsOiBmaWxsLFxuICogICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICogICAgICAgIHJhZGl1czogNSxcbiAqICAgICAgfSksXG4gKiAgICAgIGZpbGw6IGZpbGwsXG4gKiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICogICAgfSksXG4gKiAgXTtcbiAqIGBgYFxuICpcbiAqIEEgc2VwYXJhdGUgZWRpdGluZyBzdHlsZSBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0czpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtDaXJjbGUsIEZpbGwsIFN0cm9rZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlLmpzJztcbiAqXG4gKiAgY29uc3Qgc3R5bGVzID0ge307XG4gKiAgY29uc3Qgd2hpdGUgPSBbMjU1LCAyNTUsIDI1NSwgMV07XG4gKiAgY29uc3QgYmx1ZSA9IFswLCAxNTMsIDI1NSwgMV07XG4gKiAgY29uc3Qgd2lkdGggPSAzO1xuICogIHN0eWxlc1snUG9seWdvbiddID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICogICAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NSwgMC41XSxcbiAqICAgICAgfSksXG4gKiAgICB9KSxcbiAqICBdO1xuICogIHN0eWxlc1snTXVsdGlQb2x5Z29uJ10gPVxuICogICAgICBzdHlsZXNbJ1BvbHlnb24nXTtcbiAqICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgY29sb3I6IHdoaXRlLFxuICogICAgICAgIHdpZHRoOiB3aWR0aCArIDIsXG4gKiAgICAgIH0pLFxuICogICAgfSksXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgIGNvbG9yOiBibHVlLFxuICogICAgICAgIHdpZHRoOiB3aWR0aCxcbiAqICAgICAgfSksXG4gKiAgICB9KSxcbiAqICBdO1xuICogIHN0eWxlc1snTXVsdGlMaW5lU3RyaW5nJ10gPSBzdHlsZXNbJ0xpbmVTdHJpbmcnXTtcbiAqXG4gKiAgc3R5bGVzWydDaXJjbGUnXSA9IHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChcbiAqICAgIHN0eWxlc1snTGluZVN0cmluZyddXG4gKiAgKTtcbiAqXG4gKiAgc3R5bGVzWydQb2ludCddID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICogICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICogICAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICAgIGNvbG9yOiBibHVlLFxuICogICAgICAgIH0pLFxuICogICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgICBjb2xvcjogd2hpdGUsXG4gKiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyLFxuICogICAgICAgIH0pLFxuICogICAgICB9KSxcbiAqICAgICAgekluZGV4OiBJbmZpbml0eSxcbiAqICAgIH0pLFxuICogIF07XG4gKiAgc3R5bGVzWydNdWx0aVBvaW50J10gPVxuICogICAgICBzdHlsZXNbJ1BvaW50J107XG4gKiAgc3R5bGVzWydHZW9tZXRyeUNvbGxlY3Rpb24nXSA9XG4gKiAgICAgIHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChcbiAqICAgICAgICAgIHN0eWxlc1snTGluZVN0cmluZyddLFxuICogICAgICAgICAgc3R5bGVzWydQb2ludCddXG4gKiAgICAgICk7XG4gKiBgYGBcbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIFN0eWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb258bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshR2VvbWV0cnlGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb247XG5cbiAgICBpZiAob3B0aW9ucy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldEdlb21ldHJ5KG9wdGlvbnMuZ2VvbWV0cnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gb3B0aW9ucy5pbWFnZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbWFnZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJGdW5jdGlvbnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXJfID0gb3B0aW9ucy5yZW5kZXJlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJlciA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJGdW5jdGlvbnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uUmVuZGVyZXJfID1cbiAgICAgIG9wdGlvbnMuaGl0RGV0ZWN0aW9uUmVuZGVyZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuaGl0RGV0ZWN0aW9uUmVuZGVyZXJcbiAgICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlXyA9IG9wdGlvbnMuc3Ryb2tlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cm9rZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGV4dCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuekluZGV4XyA9IG9wdGlvbnMuekluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge1N0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBsZXQgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5ICYmIHR5cGVvZiBnZW9tZXRyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHlsZSh7XG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnkgPz8gdW5kZWZpbmVkLFxuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgaW1hZ2U6IHRoaXMuZ2V0SW1hZ2UoKSA/IHRoaXMuZ2V0SW1hZ2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyZXI6IHRoaXMuZ2V0UmVuZGVyZXIoKSA/PyB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHQoKSA/IHRoaXMuZ2V0VGV4dCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICB6SW5kZXg6IHRoaXMuZ2V0WkluZGV4KCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gdGhhdCB3YXMgY29uZmlndXJlZCB3aXRoXG4gICAqIHtAbGluayAjc2V0UmVuZGVyZXJ9IG9yIHRoZSBgcmVuZGVyZXJgIGNvbnN0cnVjdG9yIG9wdGlvbi5cbiAgICogQHJldHVybiB7UmVuZGVyRnVuY3Rpb258bnVsbH0gQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl87XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiBmb3IgdGhpcyBzdHlsZS4gV2hlbiBzZXQsIGBmaWxsYCwgYHN0cm9rZWBcbiAgICogYW5kIGBpbWFnZWAgb3B0aW9ucyBvZiB0aGUgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge1JlbmRlckZ1bmN0aW9ufG51bGx9IHJlbmRlcmVyIEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyXyA9IHJlbmRlcmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gZm9yIHRoaXMgc3R5bGUgdXNlZFxuICAgKiBpbiBoaXQgZGV0ZWN0aW9uLlxuICAgKiBAcGFyYW0ge1JlbmRlckZ1bmN0aW9ufG51bGx9IHJlbmRlcmVyIEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0SGl0RGV0ZWN0aW9uUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLmhpdERldGVjdGlvblJlbmRlcmVyXyA9IHJlbmRlcmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIHRoYXQgd2FzIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiB7QGxpbmsgI3NldEhpdERldGVjdGlvblJlbmRlcmVyfSBvciB0aGUgYGhpdERldGVjdGlvblJlbmRlcmVyYCBjb25zdHJ1Y3RvciBvcHRpb24uXG4gICAqIEByZXR1cm4ge1JlbmRlckZ1bmN0aW9ufG51bGx9IEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uUmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZ2VvbWV0cnkgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbnxudWxsfVxuICAgKiBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZ2VvbWV0cnkgdGhhdCB3aWxsXG4gICAqIGJlIHJlbmRlcmVkIHdpdGggdGhpcyBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIGdlb21ldHJ5IGZvciByZW5kZXJpbmcuXG4gICAqIEByZXR1cm4geyFHZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGEgZmVhdHVyZVxuICAgKiBhbmQgcmV0dXJucyB0aGUgZ2VvbWV0cnkgdG8gcmVuZGVyIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnlGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmaWxsIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IGZpbGwgRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RmlsbChmaWxsKSB7XG4gICAgdGhpcy5maWxsXyA9IGZpbGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fG51bGx9IEltYWdlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlIEltYWdlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRJbWFnZShpbWFnZSkge1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH0gU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0cm9rZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IHN0cm9rZSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFN0cm9rZShzdHJva2UpIHtcbiAgICB0aGlzLnN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdHxudWxsfSBUZXh0IHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dCBUZXh0IHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUZXh0KHRleHQpIHtcbiAgICB0aGlzLnRleHRfID0gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHotaW5kZXggZm9yIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gWkluZGV4LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuekluZGV4XztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBnZW9tZXRyeSB0aGF0IGlzIHJlbmRlcmVkIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb259IGdlb21ldHJ5XG4gICAqICAgICBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5IG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlclxuICAgKiAgICAgZm9yIHRoaXMgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGdlb21ldHJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdlb21ldHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGZlYXR1cmUuZ2V0KGdlb21ldHJ5KVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFnZW9tZXRyeSkge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5nZW9tZXRyeV8gPSBnZW9tZXRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHotaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gekluZGV4IFpJbmRleC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0WkluZGV4KHpJbmRleCkge1xuICAgIHRoaXMuekluZGV4XyA9IHpJbmRleDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3ZpZGVkIG9iamVjdCBpbnRvIGEgc3R5bGUgZnVuY3Rpb24uICBGdW5jdGlvbnMgcGFzc2VkIHRocm91Z2hcbiAqIHVuY2hhbmdlZC4gIEFycmF5cyBvZiBTdHlsZSBvciBzaW5nbGUgc3R5bGUgb2JqZWN0cyB3cmFwcGVkIGluIGFcbiAqIG5ldyBzdHlsZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3R5bGVGdW5jdGlvbnxBcnJheTxTdHlsZT58U3R5bGV9IG9ialxuICogICAgIEEgc3R5bGUgZnVuY3Rpb24sIGEgc2luZ2xlIHN0eWxlLCBvciBhbiBhcnJheSBvZiBzdHlsZXMuXG4gKiBAcmV0dXJuIHtTdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GdW5jdGlvbihvYmopIHtcbiAgbGV0IHN0eWxlRnVuY3Rpb247XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHlsZUZ1bmN0aW9uID0gb2JqO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdHlsZT59XG4gICAgICovXG4gICAgbGV0IHN0eWxlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBzdHlsZXMgPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvYmopLmdldFpJbmRleCkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBhbiBgU3R5bGVgIG9yIGFuIGFycmF5IG9mIGBTdHlsZWAnXG4gICAgICApO1xuICAgICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge1N0eWxlfSAqLyAob2JqKTtcbiAgICAgIHN0eWxlcyA9IFtzdHlsZV07XG4gICAgfVxuICAgIHN0eWxlRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0eWxlRnVuY3Rpb247XG59XG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN0eWxlPnxudWxsfVxuICovXG5sZXQgZGVmYXVsdFN0eWxlcyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHJldHVybiB7QXJyYXk8U3R5bGU+fSBTdHlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdHlsZShmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gIC8vIFdlIGRvbid0IHVzZSBhbiBpbW1lZGlhdGVseS1pbnZva2VkIGZ1bmN0aW9uXG4gIC8vIGFuZCBhIGNsb3N1cmUgc28gd2UgZG9uJ3QgZ2V0IGFuIGVycm9yIGF0IHNjcmlwdCBldmFsdWF0aW9uIHRpbWUgaW5cbiAgLy8gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBDYW52YXMuIChpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5DaXJjbGVTdHlsZSBkb2VzXG4gIC8vIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCB3aGljaCB3aWxsIGNhdXNlIGFuLmVycm9yXG4gIC8vIGluIHN1Y2ggYnJvd3NlcnMuKVxuICBpZiAoIWRlZmF1bHRTdHlsZXMpIHtcbiAgICBjb25zdCBmaWxsID0gbmV3IEZpbGwoe1xuICAgICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknLFxuICAgIH0pO1xuICAgIGNvbnN0IHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICAgICAgY29sb3I6ICcjMzM5OUNDJyxcbiAgICAgIHdpZHRoOiAxLjI1LFxuICAgIH0pO1xuICAgIGRlZmF1bHRTdHlsZXMgPSBbXG4gICAgICBuZXcgU3R5bGUoe1xuICAgICAgICBpbWFnZTogbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgfSksXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgfSksXG4gICAgXTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0eWxlcztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IHN0eWxlcyBmb3IgZWRpdGluZyBmZWF0dXJlcy5cbiAqIEByZXR1cm4ge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIEFycmF5PFN0eWxlPj59IFN0eWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWRpdGluZ1N0eWxlKCkge1xuICAvKiogQHR5cGUge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIEFycmF5PFN0eWxlPj59ICovXG4gIGNvbnN0IHN0eWxlcyA9IHt9O1xuICBjb25zdCB3aGl0ZSA9IFsyNTUsIDI1NSwgMjU1LCAxXTtcbiAgY29uc3QgYmx1ZSA9IFswLCAxNTMsIDI1NSwgMV07XG4gIGNvbnN0IHdpZHRoID0gMztcbiAgc3R5bGVzWydQb2x5Z29uJ10gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAwLjVdLFxuICAgICAgfSksXG4gICAgfSksXG4gIF07XG4gIHN0eWxlc1snTXVsdGlQb2x5Z29uJ10gPSBzdHlsZXNbJ1BvbHlnb24nXTtcblxuICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgY29sb3I6IHdoaXRlLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAyLFxuICAgICAgfSksXG4gICAgfSksXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgIGNvbG9yOiBibHVlLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICB9KSxcbiAgICB9KSxcbiAgXTtcbiAgc3R5bGVzWydNdWx0aUxpbmVTdHJpbmcnXSA9IHN0eWxlc1snTGluZVN0cmluZyddO1xuXG4gIHN0eWxlc1snQ2lyY2xlJ10gPSBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoc3R5bGVzWydMaW5lU3RyaW5nJ10pO1xuXG4gIHN0eWxlc1snUG9pbnQnXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgaW1hZ2U6IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgICAgY29sb3I6IGJsdWUsXG4gICAgICAgIH0pLFxuICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgICAgekluZGV4OiBJbmZpbml0eSxcbiAgICB9KSxcbiAgXTtcbiAgc3R5bGVzWydNdWx0aVBvaW50J10gPSBzdHlsZXNbJ1BvaW50J107XG5cbiAgc3R5bGVzWydHZW9tZXRyeUNvbGxlY3Rpb24nXSA9IHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChcbiAgICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSxcbiAgICBzdHlsZXNbJ1BvaW50J11cbiAgKTtcblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlIGFuZCByZXR1cm5zIGl0cyBkZWZhdWx0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUgdG8gZ2V0IHRoZSBnZW9tZXRyeSBmb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IEdlb21ldHJ5IHRvIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb24oZmVhdHVyZSkge1xuICByZXR1cm4gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdHlsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvVGV4dFxuICovXG5pbXBvcnQgRmlsbCBmcm9tICcuL0ZpbGwuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsncG9pbnQnIHwgJ2xpbmUnfSBUZXh0UGxhY2VtZW50XG4gKiBEZWZhdWx0IHRleHQgcGxhY2VtZW50IGlzIGAncG9pbnQnYC4gTm90ZSB0aGF0XG4gKiBgJ2xpbmUnYCByZXF1aXJlcyB0aGUgdW5kZXJseWluZyBnZW9tZXRyeSB0byBiZSBhIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfkxpbmVTdHJpbmd9LFxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL1BvbHlnb25+UG9seWdvbn0sIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmd+TXVsdGlMaW5lU3RyaW5nfSBvclxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL011bHRpUG9seWdvbn5NdWx0aVBvbHlnb259LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydsZWZ0JyB8ICdjZW50ZXInIHwgJ3JpZ2h0J30gVGV4dEp1c3RpZnlcbiAqL1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZpbGwgY29sb3IgdG8gdXNlIGlmIG5vIGZpbGwgd2FzIHNldCBhdCBjb25zdHJ1Y3Rpb24gdGltZTsgYVxuICogYmxhY2tpc2ggYCMzMzNgLlxuICpcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5jb25zdCBERUZBVUxUX0ZJTExfQ09MT1IgPSAnIzMzMyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtmb250XSBGb250IHN0eWxlIGFzIENTUyBgZm9udGAgdmFsdWUsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZm9udC4gRGVmYXVsdCBpcyBgJzEwcHggc2Fucy1zZXJpZidgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heEFuZ2xlPU1hdGguUEkvNF0gV2hlbiBgcGxhY2VtZW50YCBpcyBzZXQgdG8gYCdsaW5lJ2AsIGFsbG93IGEgbWF4aW11bSBhbmdsZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXG4gKiBUaGUgZXhwZWN0ZWQgdmFsdWUgaXMgaW4gcmFkaWFucywgYW5kIHRoZSBkZWZhdWx0IGlzIDQ1XHUwMEIwIChgTWF0aC5QSSAvIDRgKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0WD0wXSBIb3Jpem9udGFsIHRleHQgb2Zmc2V0IGluIHBpeGVscy4gQSBwb3NpdGl2ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRZPTBdIFZlcnRpY2FsIHRleHQgb2Zmc2V0IGluIHBpeGVscy4gQSBwb3NpdGl2ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IGRvd24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdmVyZmxvdz1mYWxzZV0gRm9yIHBvbHlnb24gbGFiZWxzIG9yIHdoZW4gYHBsYWNlbWVudGAgaXMgc2V0IHRvIGAnbGluZSdgLCBhbGxvdyB0ZXh0IHRvIGV4Y2VlZFxuICogdGhlIHdpZHRoIG9mIHRoZSBwb2x5Z29uIGF0IHRoZSBsYWJlbCBwb3NpdGlvbiBvciB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoIHRoYXQgaXQgZm9sbG93cy5cbiAqIEBwcm9wZXJ0eSB7VGV4dFBsYWNlbWVudH0gW3BsYWNlbWVudD0ncG9pbnQnXSBUZXh0IHBsYWNlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwZWF0XSBSZXBlYXQgaW50ZXJ2YWwuIFdoZW4gc2V0LCB0aGUgdGV4dCB3aWxsIGJlIHJlcGVhdGVkIGF0IHRoaXMgaW50ZXJ2YWwsIHdoaWNoIHNwZWNpZmllc1xuICogdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHRleHQgYW5jaG9ycyBpbiBwaXhlbHMuIE9ubHkgYXZhaWxhYmxlIHdoZW4gYHBsYWNlbWVudGAgaXMgc2V0IHRvIGAnbGluZSdgLiBPdmVycmlkZXMgJ3RleHRBbGlnbicuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZV0gU2NhbGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGVXaXRoVmlldz1mYWxzZV0gV2hldGhlciB0byByb3RhdGUgdGhlIHRleHQgd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb249MF0gUm90YXRpb24gaW4gcmFkaWFucyAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEFycmF5PHN0cmluZz59IFt0ZXh0XSBUZXh0IGNvbnRlbnQgb3IgcmljaCB0ZXh0IGNvbnRlbnQuIEZvciBwbGFpbiB0ZXh0IHByb3ZpZGUgYSBzdHJpbmcsIHdoaWNoIGNhblxuICogY29udGFpbiBsaW5lIGJyZWFrcyAoYFxcbmApLiBGb3IgcmljaCB0ZXh0IHByb3ZpZGUgYW4gYXJyYXkgb2YgdGV4dC9mb250IHR1cGxlcy4gQSB0dXBsZSBjb25zaXN0cyBvZiB0aGUgdGV4dCB0b1xuICogcmVuZGVyIGFuZCB0aGUgZm9udCB0byB1c2UgKG9yIGAnJ2AgdG8gdXNlIHRoZSB0ZXh0IHN0eWxlJ3MgZm9udCkuIEEgbGluZSBicmVhayBoYXMgdG8gYmUgYSBzZXBhcmF0ZSB0dXBsZSAoaS5lLiBgJ1xcbicsICcnYCkuXG4gKiAqKkV4YW1wbGU6KiogYFsnZm9vJywgJ2JvbGQgMTBweCBzYW5zLXNlcmlmJywgJyBiYXInLCAnaXRhbGljIDEwcHggc2Fucy1zZXJpZicsICcgYmF6JywgJyddYCB3aWxsIHlpZWxkIFwiKipmb28qKiAqYmFyKiBiYXpcIi5cbiAqICoqTm90ZToqKiBSaWNoIHRleHQgaXMgbm90IHN1cHBvcnRlZCBmb3IgYHBsYWNlbWVudDogJ2xpbmUnYCBvciB0aGUgaW1tZWRpYXRlIHJlbmRlcmluZyBBUEkuXG4gKiBAcHJvcGVydHkge0NhbnZhc1RleHRBbGlnbn0gW3RleHRBbGlnbl0gVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogYCdsZWZ0J2AsIGAncmlnaHQnYCwgYCdjZW50ZXInYCwgYCdlbmQnYCBvciBgJ3N0YXJ0J2AuXG4gKiBEZWZhdWx0IGlzIGAnY2VudGVyJ2AgZm9yIGBwbGFjZW1lbnQ6ICdwb2ludCdgLiBGb3IgYHBsYWNlbWVudDogJ2xpbmUnYCwgdGhlIGRlZmF1bHQgaXMgdG8gbGV0IHRoZSByZW5kZXJlciBjaG9vc2UgYVxuICogcGxhY2VtZW50IHdoZXJlIGBtYXhBbmdsZWAgaXMgbm90IGV4Y2VlZGVkLlxuICogQHByb3BlcnR5IHtUZXh0SnVzdGlmeX0gW2p1c3RpZnldIFRleHQganVzdGlmaWNhdGlvbiB3aXRoaW4gdGhlIHRleHQgYm94LlxuICogSWYgbm90IHNldCwgdGV4dCBpcyBqdXN0aWZpZWQgdG93YXJkcyB0aGUgYHRleHRBbGlnbmAgYW5jaG9yLlxuICogT3RoZXJ3aXNlLCB1c2Ugb3B0aW9ucyBgJ2xlZnQnYCwgYCdjZW50ZXInYCwgb3IgYCdyaWdodCdgIHRvIGp1c3RpZnkgdGhlIHRleHQgd2l0aGluIHRoZSB0ZXh0IGJveC5cbiAqICoqTm90ZToqKiBganVzdGlmeWAgaXMgaWdub3JlZCBmb3IgaW1tZWRpYXRlIHJlbmRlcmluZyBhbmQgYWxzbyBmb3IgYHBsYWNlbWVudDogJ2xpbmUnYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzVGV4dEJhc2VsaW5lfSBbdGV4dEJhc2VsaW5lPSdtaWRkbGUnXSBUZXh0IGJhc2UgbGluZS4gUG9zc2libGUgdmFsdWVzOiBgJ2JvdHRvbSdgLCBgJ3RvcCdgLCBgJ21pZGRsZSdgLCBgJ2FscGhhYmV0aWMnYCxcbiAqIGAnaGFuZ2luZydgLCBgJ2lkZW9ncmFwaGljJ2AuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IFtmaWxsXSBGaWxsIHN0eWxlLiBJZiBub25lIGlzIHByb3ZpZGVkLCB3ZSdsbCB1c2UgYSBkYXJrIGZpbGwtc3R5bGUgKCMzMzMpLiBTcGVjaWZ5IGBudWxsYCBmb3Igbm8gZmlsbC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRGaWxsXSBGaWxsIHN0eWxlIGZvciB0aGUgdGV4dCBiYWNrZ3JvdW5kIHdoZW4gYHBsYWNlbWVudGAgaXNcbiAqIGAncG9pbnQnYC4gRGVmYXVsdCBpcyBubyBmaWxsLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbYmFja2dyb3VuZFN0cm9rZV0gU3Ryb2tlIHN0eWxlIGZvciB0aGUgdGV4dCBiYWNrZ3JvdW5kICB3aGVuIGBwbGFjZW1lbnRgXG4gKiBpcyBgJ3BvaW50J2AuIERlZmF1bHQgaXMgbm8gc3Ryb2tlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbcGFkZGluZz1bMCwgMCwgMCwgMF1dIFBhZGRpbmcgaW4gcGl4ZWxzIGFyb3VuZCB0aGUgdGV4dCBmb3IgZGVjbHV0dGVyaW5nIGFuZCBiYWNrZ3JvdW5kLiBUaGUgb3JkZXIgb2ZcbiAqIHZhbHVlcyBpbiB0aGUgYXJyYXkgaXMgYFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdYC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCB0ZXh0IHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mb250XyA9IG9wdGlvbnMuZm9udDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zY2FsZSA6IDEpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduXyA9IG9wdGlvbnMudGV4dEFsaWduO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGV4dEp1c3RpZnl8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuanVzdGlmeV8gPSBvcHRpb25zLmp1c3RpZnk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVwZWF0XyA9IG9wdGlvbnMucmVwZWF0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRCYXNlbGluZV8gPSBvcHRpb25zLnRleHRCYXNlbGluZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9XG4gICAgICBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuZmlsbFxuICAgICAgICA6IG5ldyBGaWxsKHtjb2xvcjogREVGQVVMVF9GSUxMX0NPTE9SfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhBbmdsZV8gPVxuICAgICAgb3B0aW9ucy5tYXhBbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhBbmdsZSA6IE1hdGguUEkgLyA0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGV4dFBsYWNlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnBsYWNlbWVudF8gPVxuICAgICAgb3B0aW9ucy5wbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGxhY2VtZW50IDogJ3BvaW50JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVyZmxvd18gPSAhIW9wdGlvbnMub3ZlcmZsb3c7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFhfID0gb3B0aW9ucy5vZmZzZXRYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldFggOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0WV8gPSBvcHRpb25zLm9mZnNldFkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0WSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuYmFja2dyb3VuZEZpbGxfID0gb3B0aW9ucy5iYWNrZ3JvdW5kRmlsbFxuICAgICAgPyBvcHRpb25zLmJhY2tncm91bmRGaWxsXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5iYWNrZ3JvdW5kU3Ryb2tlXyA9IG9wdGlvbnMuYmFja2dyb3VuZFN0cm9rZVxuICAgICAgPyBvcHRpb25zLmJhY2tncm91bmRTdHJva2VcbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmdfID0gb3B0aW9ucy5wYWRkaW5nID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5wYWRkaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge1RleHR9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgIHJldHVybiBuZXcgVGV4dCh7XG4gICAgICBmb250OiB0aGlzLmdldEZvbnQoKSxcbiAgICAgIHBsYWNlbWVudDogdGhpcy5nZXRQbGFjZW1lbnQoKSxcbiAgICAgIHJlcGVhdDogdGhpcy5nZXRSZXBlYXQoKSxcbiAgICAgIG1heEFuZ2xlOiB0aGlzLmdldE1heEFuZ2xlKCksXG4gICAgICBvdmVyZmxvdzogdGhpcy5nZXRPdmVyZmxvdygpLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBzY2FsZTogQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGUsXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHQoKSxcbiAgICAgIHRleHRBbGlnbjogdGhpcy5nZXRUZXh0QWxpZ24oKSxcbiAgICAgIGp1c3RpZnk6IHRoaXMuZ2V0SnVzdGlmeSgpLFxuICAgICAgdGV4dEJhc2VsaW5lOiB0aGlzLmdldFRleHRCYXNlbGluZSgpLFxuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgb2Zmc2V0WDogdGhpcy5nZXRPZmZzZXRYKCksXG4gICAgICBvZmZzZXRZOiB0aGlzLmdldE9mZnNldFkoKSxcbiAgICAgIGJhY2tncm91bmRGaWxsOiB0aGlzLmdldEJhY2tncm91bmRGaWxsKClcbiAgICAgICAgPyB0aGlzLmdldEJhY2tncm91bmRGaWxsKCkuY2xvbmUoKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGJhY2tncm91bmRTdHJva2U6IHRoaXMuZ2V0QmFja2dyb3VuZFN0cm9rZSgpXG4gICAgICAgID8gdGhpcy5nZXRCYWNrZ3JvdW5kU3Ryb2tlKCkuY2xvbmUoKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIHBhZGRpbmc6IHRoaXMuZ2V0UGFkZGluZygpIHx8IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBvdmVyZmxvd2AgY29uZmlndXJhdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gTGV0IHRleHQgb3ZlcmZsb3cgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0aGV5IGZvbGxvdy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmZsb3dfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZm9udCBuYW1lLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBGb250LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGb250KCkge1xuICAgIHJldHVybiB0aGlzLmZvbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSBhbmdsZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWF4QW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4QW5nbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFiZWwgcGxhY2VtZW50LlxuICAgKiBAcmV0dXJuIHtUZXh0UGxhY2VtZW50fSBUZXh0IHBsYWNlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UGxhY2VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBsYWNlbWVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXBlYXQgaW50ZXJ2YWwgb2YgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlcGVhdCBpbnRlcnZhbCBpbiBwaXhlbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlcGVhdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBlYXRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeC1vZmZzZXQgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhvcml6b250YWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9mZnNldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0WF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5LW9mZnNldCBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVmVydGljYWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9mZnNldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0WV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIHN0eWxlIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdGV4dCByb3RhdGVzIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRlV2l0aFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRleHQgc2NhbGUuXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZSBhcnJheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTY2FsZSBhcnJheS5cbiAgICovXG4gIGdldFNjYWxlQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVBcnJheV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IFRleHQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGFsaWdubWVudC5cbiAgICogQHJldHVybiB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH0gVGV4dCBhbGlnbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGV4dEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLnRleHRBbGlnbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBqdXN0aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJuIHtUZXh0SnVzdGlmeXx1bmRlZmluZWR9IEp1c3RpZmljYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEp1c3RpZnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuanVzdGlmeV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGJhc2VsaW5lLlxuICAgKiBAcmV0dXJuIHtDYW52YXNUZXh0QmFzZWxpbmV8dW5kZWZpbmVkfSBUZXh0IGJhc2VsaW5lLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEJhc2VsaW5lXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgZmlsbCBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEJhY2tncm91bmRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRGaWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgc3Ryb2tlIHN0eWxlIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEJhY2tncm91bmRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZFN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYWRkaW5nIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBQYWRkaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBhZGRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVyZmxvdyBMZXQgdGV4dCBvdmVyZmxvdyB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE92ZXJmbG93KG92ZXJmbG93KSB7XG4gICAgdGhpcy5vdmVyZmxvd18gPSBvdmVyZmxvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9udCBGb250LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGb250KGZvbnQpIHtcbiAgICB0aGlzLmZvbnRfID0gZm9udDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgQW5nbGUgaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4QW5nbGUobWF4QW5nbGUpIHtcbiAgICB0aGlzLm1heEFuZ2xlXyA9IG1heEFuZ2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIEhvcml6b250YWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9mZnNldFgob2Zmc2V0WCkge1xuICAgIHRoaXMub2Zmc2V0WF8gPSBvZmZzZXRYO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeSBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIFZlcnRpY2FsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRPZmZzZXRZKG9mZnNldFkpIHtcbiAgICB0aGlzLm9mZnNldFlfID0gb2Zmc2V0WTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgcGxhY2VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRQbGFjZW1lbnR9IHBsYWNlbWVudCBQbGFjZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICB0aGlzLnBsYWNlbWVudF8gPSBwbGFjZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXBlYXQgaW50ZXJ2YWwgb2YgdGhlIHRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gW3JlcGVhdF0gUmVwZWF0IGludGVydmFsIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVwZWF0KHJlcGVhdCkge1xuICAgIHRoaXMucmVwZWF0XyA9IHJlcGVhdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0byByb3RhdGUgdGhlIHRleHQgd2l0aCB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByb3RhdGVXaXRoVmlldyBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0ZVdpdGhWaWV3KHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3Ryb2tlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuc3Ryb2tlXyA9IHN0cm9rZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfSB0ZXh0IFRleHQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHQodGV4dCkge1xuICAgIHRoaXMudGV4dF8gPSB0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBhbGlnbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH0gdGV4dEFsaWduIFRleHQgYWxpZ24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHRBbGlnbih0ZXh0QWxpZ24pIHtcbiAgICB0aGlzLnRleHRBbGlnbl8gPSB0ZXh0QWxpZ247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBqdXN0aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRKdXN0aWZ5fHVuZGVmaW5lZH0ganVzdGlmeSBKdXN0aWZpY2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRKdXN0aWZ5KGp1c3RpZnkpIHtcbiAgICB0aGlzLmp1c3RpZnlfID0ganVzdGlmeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgYmFzZWxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH0gdGV4dEJhc2VsaW5lIFRleHQgYmFzZWxpbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpIHtcbiAgICB0aGlzLnRleHRCYXNlbGluZV8gPSB0ZXh0QmFzZWxpbmU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBiYWNrZ3JvdW5kIGZpbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kRmlsbChmaWxsKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRmlsbF8gPSBmaWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFja2dyb3VuZCBzdHJva2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kU3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuYmFja2dyb3VuZFN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwYWRkaW5nIChgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF1gKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fG51bGx9IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UGFkZGluZyhwYWRkaW5nKSB7XG4gICAgdGhpcy5wYWRkaW5nXyA9IHBhZGRpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dDtcbiIsICJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgICBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0IHx8IDAsIHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSksIGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmUpO1xufVxuXG5mdW5jdGlvbiBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gYXJyW2tdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG4iLCAiaW1wb3J0IHF1aWNrc2VsZWN0IGZyb20gJ3F1aWNrc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUkJ1c2gge1xuICAgIGNvbnN0cnVjdG9yKG1heEVudHJpZXMgPSA5KSB7XG4gICAgICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG4gICAgfVxuXG4gICAgc2VhcmNoKGJib3gpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjb25zdCB0b0JCb3ggPSB0aGlzLnRvQkJveDtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1NlYXJjaCA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb2xsaWRlcyhiYm94KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5kYXRhO1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0aGlzLnRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc2NyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgY29uc3QgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5zZXJ0KGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLnRvQkJveChpdGVtKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgICAgIGxldCBpLCBwYXJlbnQsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRvQkJveChpdGVtKSB7IHJldHVybiBpdGVtOyB9XG5cbiAgICBjb21wYXJlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbiAgICBjb21wYXJlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfVxuXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYWxsKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKC4uLm5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9idWlsZChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIGNvbnN0IE4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICBsZXQgTSA9IHRoaXMuX21heEVudHJpZXM7XG4gICAgICAgIGxldCBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICBjb25zdCBOMiA9IE1hdGguY2VpbChOIC8gTSk7XG4gICAgICAgIGNvbnN0IE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKTtcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICBjb25zdCByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBfY2hvb3NlU3VidHJlZShiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBsZXQgbWluQXJlYSA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Tm9kZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIF9pbnNlcnQoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuICAgICAgICBjb25zdCBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRoaXMudG9CQm94KGl0ZW0pO1xuICAgICAgICBjb25zdCBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCkge1xuICAgICAgICBjb25zdCBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF07XG4gICAgICAgIGNvbnN0IE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfVxuXG4gICAgX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH1cblxuICAgIF9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBsZXQgbWluT3ZlcmxhcCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgY29uc3QgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXggfHwgTSAtIG07XG4gICAgfVxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSkge1xuICAgICAgICBjb25zdCBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblg7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWTtcbiAgICAgICAgY29uc3QgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpO1xuICAgICAgICBjb25zdCB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9XG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIGNvbnN0IHRvQkJveCA9IHRoaXMudG9CQm94O1xuICAgICAgICBjb25zdCBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpO1xuICAgICAgICBsZXQgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH1cblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAobGV0IGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jb25kZW5zZShwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAobGV0IGkgPSBrOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGIubWF4WCwgYS5tYXhYKSAtIE1hdGgubWluKGIubWluWCwgYS5taW5YKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgY29uc3QgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKTtcbiAgICBjb25zdCBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpO1xuICAgIGNvbnN0IG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIGNvbnN0IHN0YWNrID0gW2xlZnQsIHJpZ2h0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvbkltYWdlXG4gKi9cblxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2RlY29kZUZhbGxiYWNrfSBmcm9tICcuLi9JbWFnZS5qcyc7XG5pbXBvcnQge3NoYXJlZCBhcyBpY29uSW1hZ2VDYWNoZX0gZnJvbSAnLi9JY29uSW1hZ2VDYWNoZS5qcyc7XG5cbi8qKlxuICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xubGV0IHRhaW50ZWRUZXN0Q29udGV4dCA9IG51bGw7XG5cbmNsYXNzIEljb25JbWFnZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gaW1hZ2UgSW1hZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBpbWFnZVN0YXRlIEltYWdlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGltYWdlLCBzcmMsIGNyb3NzT3JpZ2luLCBpbWFnZVN0YXRlLCBjb2xvcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5fID0gY3Jvc3NPcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBIVE1MQ2FudmFzRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBpbWFnZVN0YXRlID09PSB1bmRlZmluZWQgPyBJbWFnZVN0YXRlLklETEUgOiBpbWFnZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9XG4gICAgICBpbWFnZSAmJiBpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQgPyBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnNyY18gPSBzcmM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGFpbnRlZF87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemVJbWFnZV8oKSB7XG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBpbWFnZSBjYW52YXMgaXMgdGFpbnRlZC5cbiAgICovXG4gIGlzVGFpbnRlZF8oKSB7XG4gICAgaWYgKHRoaXMudGFpbnRlZF8gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmltYWdlU3RhdGVfID09PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgaWYgKCF0YWludGVkVGVzdENvbnRleHQpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEsIHVuZGVmaW5lZCwge1xuICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0YWludGVkVGVzdENvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2VfLCAwLCAwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhaW50ZWRUZXN0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgIHRoaXMudGFpbnRlZF8gPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWludGVkXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhaW50ZWRfID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZUV2ZW50XygpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBJbWFnZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMuZGlzcGF0Y2hDaGFuZ2VFdmVudF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VMb2FkXygpIHtcbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gICAgdGhpcy5zaXplXyA9IFt0aGlzLmltYWdlXy53aWR0aCwgdGhpcy5pbWFnZV8uaGVpZ2h0XTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlRXZlbnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IEltYWdlIG9yIENhbnZhcyBlbGVtZW50IG9yIGltYWdlIGJpdG1hcC5cbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG4gICAgdGhpcy5yZXBsYWNlQ29sb3JfKHBpeGVsUmF0aW8pO1xuICAgIHJldHVybiB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPyB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gOiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHRoaXMucmVwbGFjZUNvbG9yXyhwaXhlbFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dID8gcGl4ZWxSYXRpbyA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VTdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUltYWdlXygpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfKSB7XG4gICAgICBpZiAodGhpcy5pc1RhaW50ZWRfKCkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemVfWzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSB0aGlzLmltYWdlXztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBJbWFnZSBzcmMuXG4gICAqL1xuICBnZXRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JjXztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VTdGF0ZV8gIT09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zcmNfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAodGhpcy5pbWFnZV8pLnNyYyA9IHRoaXMuc3JjXztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlXyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGRlY29kZUZhbGxiYWNrKHRoaXMuaW1hZ2VfLCB0aGlzLnNyY18pXG4gICAgICAgIC50aGVuKChpbWFnZSkgPT4ge1xuICAgICAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gICAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUltYWdlRXJyb3JfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGxhY2VDb2xvcl8ocGl4ZWxSYXRpbykge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmNvbG9yXyB8fFxuICAgICAgdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dIHx8XG4gICAgICB0aGlzLmltYWdlU3RhdGVfICE9PSBJbWFnZVN0YXRlLkxPQURFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZV87XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKGltYWdlLndpZHRoICogcGl4ZWxSYXRpbyk7XG4gICAgY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChpbWFnZS5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcblxuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xuICAgIGN0eC5maWxsU3R5bGUgPSBhc1N0cmluZyh0aGlzLmNvbG9yXyk7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW8sIGNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvKTtcblxuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuXG4gICAgdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dID0gY2FudmFzO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBpbWFnZSBJbWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZUtleSBTcmMuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBpbWFnZVN0YXRlIEltYWdlIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtJY29uSW1hZ2V9IEljb24gaW1hZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoaW1hZ2UsIGNhY2hlS2V5LCBjcm9zc09yaWdpbiwgaW1hZ2VTdGF0ZSwgY29sb3IpIHtcbiAgbGV0IGljb25JbWFnZSA9XG4gICAgY2FjaGVLZXkgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogaWNvbkltYWdlQ2FjaGUuZ2V0KGNhY2hlS2V5LCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICBpZiAoIWljb25JbWFnZSkge1xuICAgIGljb25JbWFnZSA9IG5ldyBJY29uSW1hZ2UoXG4gICAgICBpbWFnZSxcbiAgICAgIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCA/IGltYWdlLnNyYyB8fCB1bmRlZmluZWQgOiBjYWNoZUtleSxcbiAgICAgIGNyb3NzT3JpZ2luLFxuICAgICAgaW1hZ2VTdGF0ZSxcbiAgICAgIGNvbG9yXG4gICAgKTtcbiAgICBpY29uSW1hZ2VDYWNoZS5zZXQoY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlKTtcbiAgfVxuICByZXR1cm4gaWNvbkltYWdlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJY29uSW1hZ2U7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IEltYWdlU3R5bGUgZnJvbSAnLi9JbWFnZS5qcyc7XG5pbXBvcnQge2FzQXJyYXl9IGZyb20gJy4uL2NvbG9yLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldEljb25JbWFnZX0gZnJvbSAnLi9JY29uSW1hZ2UuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnZnJhY3Rpb24nIHwgJ3BpeGVscyd9IEljb25BbmNob3JVbml0c1xuICogQW5jaG9yIHVuaXQgY2FuIGJlIGVpdGhlciBhIGZyYWN0aW9uIG9mIHRoZSBpY29uIHNpemUgb3IgaW4gcGl4ZWxzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydib3R0b20tbGVmdCcgfCAnYm90dG9tLXJpZ2h0JyB8ICd0b3AtbGVmdCcgfCAndG9wLXJpZ2h0J30gSWNvbk9yaWdpblxuICogSWNvbiBvcmlnaW4uIE9uZSBvZiAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0JywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFthbmNob3I9WzAuNSwgMC41XV0gQW5jaG9yLiBEZWZhdWx0IHZhbHVlIGlzIHRoZSBpY29uIGNlbnRlci5cbiAqIEBwcm9wZXJ0eSB7SWNvbk9yaWdpbn0gW2FuY2hvck9yaWdpbj0ndG9wLWxlZnQnXSBPcmlnaW4gb2YgdGhlIGFuY2hvcjogYGJvdHRvbS1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsXG4gKiBgdG9wLWxlZnRgIG9yIGB0b3AtcmlnaHRgLlxuICogQHByb3BlcnR5IHtJY29uQW5jaG9yVW5pdHN9IFthbmNob3JYVW5pdHM9J2ZyYWN0aW9uJ10gVW5pdHMgaW4gd2hpY2ggdGhlIGFuY2hvciB4IHZhbHVlIGlzXG4gKiBzcGVjaWZpZWQuIEEgdmFsdWUgb2YgYCdmcmFjdGlvbidgIGluZGljYXRlcyB0aGUgeCB2YWx1ZSBpcyBhIGZyYWN0aW9uIG9mIHRoZSBpY29uLiBBIHZhbHVlIG9mIGAncGl4ZWxzJ2AgaW5kaWNhdGVzXG4gKiB0aGUgeCB2YWx1ZSBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkge0ljb25BbmNob3JVbml0c30gW2FuY2hvcllVbml0cz0nZnJhY3Rpb24nXSBVbml0cyBpbiB3aGljaCB0aGUgYW5jaG9yIHkgdmFsdWUgaXNcbiAqIHNwZWNpZmllZC4gQSB2YWx1ZSBvZiBgJ2ZyYWN0aW9uJ2AgaW5kaWNhdGVzIHRoZSB5IHZhbHVlIGlzIGEgZnJhY3Rpb24gb2YgdGhlIGljb24uIEEgdmFsdWUgb2YgYCdwaXhlbHMnYCBpbmRpY2F0ZXNcbiAqIHRoZSB5IHZhbHVlIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfSBbY29sb3JdIENvbG9yIHRvIHRpbnQgdGhlIGljb24uIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB0aGUgaWNvbiB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gTm90ZSB0aGF0IHlvdSBtdXN0IHByb3ZpZGUgYVxuICogYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBbaW1nXSBJbWFnZSBvYmplY3QgZm9yIHRoZSBpY29uLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbZGlzcGxhY2VtZW50PVswLCAwXV0gRGlzcGxhY2VtZW50IG9mIHRoZSBpY29uIGluIHBpeGVscy5cbiAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIHNoaWZ0IHRoZSBpY29uIHJpZ2h0IGFuZCB1cC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5IG9mIHRoZSBpY29uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gVGhlIHdpZHRoIG9mIHRoZSBpY29uIGluIHBpeGVscy4gVGhpcyBjYW4ndCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggYHNjYWxlYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGVpZ2h0XSBUaGUgaGVpZ2h0IG9mIHRoZSBpY29uIGluIHBpeGVscy4gVGhpcyBjYW4ndCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggYHNjYWxlYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlPTFdIFNjYWxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBpY29uIHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnMgKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSkuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtvZmZzZXQ9WzAsIDBdXSBPZmZzZXQgd2hpY2gsIHRvZ2V0aGVyIHdpdGggYHNpemVgIGFuZCBgb2Zmc2V0T3JpZ2luYCwgZGVmaW5lcyB0aGVcbiAqIHN1Yi1yZWN0YW5nbGUgdG8gdXNlIGZyb20gdGhlIG9yaWdpbmFsIChzcHJpdGUpIGltYWdlLlxuICogQHByb3BlcnR5IHtJY29uT3JpZ2lufSBbb2Zmc2V0T3JpZ2luPSd0b3AtbGVmdCddIE9yaWdpbiBvZiB0aGUgb2Zmc2V0OiBgYm90dG9tLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCxcbiAqIGB0b3AtbGVmdGAgb3IgYHRvcC1yaWdodGAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIEljb24gc2l6ZSBpbiBwaXhlbHMuIFVzZWQgdG9nZXRoZXIgd2l0aCBgb2Zmc2V0YCB0byBkZWZpbmUgdGhlXG4gKiBzdWItcmVjdGFuZ2xlIHRvIHVzZSBmcm9tIHRoZSBvcmlnaW5hbCAoc3ByaXRlKSBpbWFnZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3JjXSBJbWFnZSBzb3VyY2UgVVJJLlxuICogQHByb3BlcnR5IHtcImRlY2x1dHRlclwifFwib2JzdGFjbGVcInxcIm5vbmVcInx1bmRlZmluZWR9IFtkZWNsdXR0ZXJNb2RlXSBEZWNsdXR0ZXIgbW9kZS5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHdhbnRlZFdpZHRoIFRoZSB3YW50ZWQgd2lkdGguXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHdhbnRlZEhlaWdodCBUaGUgd2FudGVkIGhlaWdodC5cbiAqIEByZXR1cm4ge251bWJlcnxBcnJheTxudW1iZXI+fSBUaGUgc2NhbGUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNjYWxlKHdpZHRoLCBoZWlnaHQsIHdhbnRlZFdpZHRoLCB3YW50ZWRIZWlnaHQpIHtcbiAgaWYgKHdhbnRlZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgd2FudGVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW3dhbnRlZFdpZHRoIC8gd2lkdGgsIHdhbnRlZEhlaWdodCAvIGhlaWdodF07XG4gIH1cbiAgaWYgKHdhbnRlZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gd2FudGVkV2lkdGggLyB3aWR0aDtcbiAgfVxuICBpZiAod2FudGVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gd2FudGVkSGVpZ2h0IC8gaGVpZ2h0O1xuICB9XG4gIHJldHVybiAxO1xufVxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBpY29uIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEljb24gZXh0ZW5kcyBJbWFnZVN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbnN0IG9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhY2l0eSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGlvbiA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2NhbGUgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY29uc3Qgcm90YXRlV2l0aFZpZXcgPVxuICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuXG4gICAgc3VwZXIoe1xuICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIGRpc3BsYWNlbWVudDpcbiAgICAgICAgb3B0aW9ucy5kaXNwbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGlzcGxhY2VtZW50IDogWzAsIDBdLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHJvdGF0ZVdpdGhWaWV3LFxuICAgICAgZGVjbHV0dGVyTW9kZTogb3B0aW9ucy5kZWNsdXR0ZXJNb2RlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBvcHRpb25zLmFuY2hvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3IgOiBbMC41LCAwLjVdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm5vcm1hbGl6ZWRBbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0ljb25PcmlnaW59XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JPcmlnaW5fID1cbiAgICAgIG9wdGlvbnMuYW5jaG9yT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuY2hvck9yaWdpbiA6ICd0b3AtbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtJY29uQW5jaG9yVW5pdHN9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JYVW5pdHNfID1cbiAgICAgIG9wdGlvbnMuYW5jaG9yWFVuaXRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuY2hvclhVbml0cyA6ICdmcmFjdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtJY29uQW5jaG9yVW5pdHN9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JZVW5pdHNfID1cbiAgICAgIG9wdGlvbnMuYW5jaG9yWVVuaXRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuY2hvcllVbml0cyA6ICdmcmFjdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5fID1cbiAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiBudWxsO1xuXG4gICAgY29uc3QgaW1hZ2UgPSBvcHRpb25zLmltZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbWcgOiBudWxsO1xuXG4gICAgbGV0IGNhY2hlS2V5ID0gb3B0aW9ucy5zcmM7XG5cbiAgICBhc3NlcnQoXG4gICAgICAhKGNhY2hlS2V5ICE9PSB1bmRlZmluZWQgJiYgaW1hZ2UpLFxuICAgICAgJ2BpbWFnZWAgYW5kIGBzcmNgIGNhbm5vdCBiZSBwcm92aWRlZCBhdCB0aGUgc2FtZSB0aW1lJ1xuICAgICk7XG5cbiAgICBpZiAoKGNhY2hlS2V5ID09PSB1bmRlZmluZWQgfHwgY2FjaGVLZXkubGVuZ3RoID09PSAwKSAmJiBpbWFnZSkge1xuICAgICAgY2FjaGVLZXkgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovIChpbWFnZSkuc3JjIHx8IGdldFVpZChpbWFnZSk7XG4gICAgfVxuICAgIGFzc2VydChcbiAgICAgIGNhY2hlS2V5ICE9PSB1bmRlZmluZWQgJiYgY2FjaGVLZXkubGVuZ3RoID4gMCxcbiAgICAgICdBIGRlZmluZWQgYW5kIG5vbi1lbXB0eSBgc3JjYCBvciBgaW1hZ2VgIG11c3QgYmUgcHJvdmlkZWQnXG4gICAgKTtcblxuICAgIGFzc2VydChcbiAgICAgICEoXG4gICAgICAgIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkXG4gICAgICApLFxuICAgICAgJ2B3aWR0aGAgb3IgYGhlaWdodGAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyIHdpdGggYHNjYWxlYCdcbiAgICApO1xuXG4gICAgbGV0IGltYWdlU3RhdGU7XG4gICAgaWYgKG9wdGlvbnMuc3JjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGltYWdlU3RhdGUgPSBJbWFnZVN0YXRlLklETEU7XG4gICAgfSBlbHNlIGlmIChpbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgIGltYWdlU3RhdGUgPSBpbWFnZS5zcmMgPyBJbWFnZVN0YXRlLkxPQURFRCA6IEltYWdlU3RhdGUuSURMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWFnZVN0YXRlID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZVN0YXRlID0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhc0FycmF5KG9wdGlvbnMuY29sb3IpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5pY29uSW1hZ2VfID0gZ2V0SWNvbkltYWdlKFxuICAgICAgaW1hZ2UsXG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi8gKGNhY2hlS2V5KSxcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW5fLFxuICAgICAgaW1hZ2VTdGF0ZSxcbiAgICAgIHRoaXMuY29sb3JfXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRfID0gb3B0aW9ucy5vZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0IDogWzAsIDBdO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0ljb25PcmlnaW59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRPcmlnaW5fID1cbiAgICAgIG9wdGlvbnMub2Zmc2V0T3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldE9yaWdpbiA6ICd0b3AtbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaXplIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2NhbGUgaWYgd2lkdGggb3IgaGVpZ2h0IHdlcmUgZ2l2ZW4uXG4gICAgICovXG4gICAgaWYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICAgIGlmIChvcHRpb25zLnNpemUpIHtcbiAgICAgICAgW3dpZHRoLCBoZWlnaHRdID0gb3B0aW9ucy5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmdldEltYWdlKDEpO1xuICAgICAgICBpZiAoaW1hZ2Uud2lkdGggJiYgaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsT3B0aW9uc18gPSBvcHRpb25zO1xuICAgICAgICAgIGNvbnN0IG9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudW5saXN0ZW5JbWFnZUNoYW5nZShvbmxvYWQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxPcHRpb25zXykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbWFnZVNpemUgPSB0aGlzLmljb25JbWFnZV8uZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTY2FsZShcbiAgICAgICAgICAgICAgY2FsY3VsYXRlU2NhbGUoXG4gICAgICAgICAgICAgICAgaW1hZ2VTaXplWzBdLFxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZVsxXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVpZ2h0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxpc3RlbkltYWdlQ2hhbmdlKG9ubG9hZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFNjYWxlKFxuICAgICAgICAgIGNhbGN1bGF0ZVNjYWxlKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLiBUaGUgdW5kZXJseWluZyBJbWFnZS9IVE1MQ2FudmFzRWxlbWVudCBpcyBub3QgY2xvbmVkLlxuICAgKiBAcmV0dXJuIHtJY29ufSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBsZXQgc2NhbGUsIHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHRoaXMuaW5pdGlhbE9wdGlvbnNfKSB7XG4gICAgICB3aWR0aCA9IHRoaXMuaW5pdGlhbE9wdGlvbnNfLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5pbml0aWFsT3B0aW9uc18uaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICAgIHNjYWxlID0gQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSWNvbih7XG4gICAgICBhbmNob3I6IHRoaXMuYW5jaG9yXy5zbGljZSgpLFxuICAgICAgYW5jaG9yT3JpZ2luOiB0aGlzLmFuY2hvck9yaWdpbl8sXG4gICAgICBhbmNob3JYVW5pdHM6IHRoaXMuYW5jaG9yWFVuaXRzXyxcbiAgICAgIGFuY2hvcllVbml0czogdGhpcy5hbmNob3JZVW5pdHNfLFxuICAgICAgY29sb3I6XG4gICAgICAgIHRoaXMuY29sb3JfICYmIHRoaXMuY29sb3JfLnNsaWNlXG4gICAgICAgICAgPyB0aGlzLmNvbG9yXy5zbGljZSgpXG4gICAgICAgICAgOiB0aGlzLmNvbG9yXyB8fCB1bmRlZmluZWQsXG4gICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbl8sXG4gICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0Xy5zbGljZSgpLFxuICAgICAgb2Zmc2V0T3JpZ2luOiB0aGlzLm9mZnNldE9yaWdpbl8sXG4gICAgICBvcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgc2NhbGUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZV8gIT09IG51bGwgPyB0aGlzLnNpemVfLnNsaWNlKCkgOiB1bmRlZmluZWQsXG4gICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IGluIHBpeGVscy4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbmNob3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFuY2hvcigpIHtcbiAgICBsZXQgYW5jaG9yID0gdGhpcy5ub3JtYWxpemVkQW5jaG9yXztcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmFuY2hvclhVbml0c18gPT0gJ2ZyYWN0aW9uJyB8fFxuICAgICAgICB0aGlzLmFuY2hvcllVbml0c18gPT0gJ2ZyYWN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFuY2hvciA9IHRoaXMuYW5jaG9yXy5zbGljZSgpO1xuICAgICAgICBpZiAodGhpcy5hbmNob3JYVW5pdHNfID09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBhbmNob3JbMF0gKj0gc2l6ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbmNob3JZVW5pdHNfID09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBhbmNob3JbMV0gKj0gc2l6ZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hbmNob3JPcmlnaW5fICE9ICd0b3AtbGVmdCcpIHtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvciA9PT0gdGhpcy5hbmNob3JfKSB7XG4gICAgICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAndG9wLXJpZ2h0JyB8fFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgICApIHtcbiAgICAgICAgICBhbmNob3JbMF0gPSAtYW5jaG9yWzBdICsgc2l6ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5hbmNob3JPcmlnaW5fID09ICdib3R0b20tbGVmdCcgfHxcbiAgICAgICAgICB0aGlzLmFuY2hvck9yaWdpbl8gPT0gJ2JvdHRvbS1yaWdodCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgYW5jaG9yWzFdID0gLWFuY2hvclsxXSArIHNpemVbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubm9ybWFsaXplZEFuY2hvcl8gPSBhbmNob3I7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCk7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlQXJyYXkoKTtcbiAgICAvLyBhbmNob3IgaXMgc2NhbGVkIGJ5IHJlbmRlcmVyIGJ1dCBkaXNwbGFjZW1lbnQgc2hvdWxkIG5vdCBiZSBzY2FsZWRcbiAgICAvLyBzbyBkaXZpZGUgYnkgc2NhbGUgaGVyZVxuICAgIHJldHVybiBbXG4gICAgICBhbmNob3JbMF0gLSBkaXNwbGFjZW1lbnRbMF0gLyBzY2FsZVswXSxcbiAgICAgIGFuY2hvclsxXSArIGRpc3BsYWNlbWVudFsxXSAvIHNjYWxlWzFdLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAgICogc3ltYm9saXplci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgQW5jaG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBbmNob3IoYW5jaG9yKSB7XG4gICAgdGhpcy5hbmNob3JfID0gYW5jaG9yO1xuICAgIHRoaXMubm9ybWFsaXplZEFuY2hvcl8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWNvbiBjb2xvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBpY29uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2Ugb3IgQ2FudmFzIGVsZW1lbnQuIElmIHRoZSBJY29uXG4gICAqIHN0eWxlIHdhcyBjb25maWd1cmVkIHdpdGggYHNyY2Agb3Igd2l0aCBhIG5vdCBsZXQgbG9hZGVkIGBpbWdgLCBhbiBgSW1hZ2VCaXRtYXBgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldEltYWdlKHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBwaXhlbCByYXRpbyBvZiB0aGUgaW1hZ2UuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqL1xuICBnZXRJbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRJbWFnZVN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbiBvZiB0aGUgc3ltYm9saXplci5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZ2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luXykge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0XztcblxuICAgIGlmICh0aGlzLm9mZnNldE9yaWdpbl8gIT0gJ3RvcC1sZWZ0Jykge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgY29uc3QgaWNvbkltYWdlU2l6ZSA9IHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCk7XG4gICAgICBpZiAoIXNpemUgfHwgIWljb25JbWFnZVNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSBvZmZzZXQuc2xpY2UoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vZmZzZXRPcmlnaW5fID09ICd0b3AtcmlnaHQnIHx8XG4gICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgKSB7XG4gICAgICAgIG9mZnNldFswXSA9IGljb25JbWFnZVNpemVbMF0gLSBzaXplWzBdIC0gb2Zmc2V0WzBdO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ2JvdHRvbS1sZWZ0JyB8fFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ2JvdHRvbS1yaWdodCdcbiAgICAgICkge1xuICAgICAgICBvZmZzZXRbMV0gPSBpY29uSW1hZ2VTaXplWzFdIC0gc2l6ZVsxXSAtIG9mZnNldFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vcmlnaW5fID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBVUkwuXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IEltYWdlIHNyYy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3JjKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0U3JjKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBpY29uIChpbiBwaXhlbHMpLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuICF0aGlzLnNpemVfID8gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKSA6IHRoaXMuc2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS4gV2lsbCByZXR1cm4gdW5kZWZpbmVkIHdoZW4gdGhlIGljb24gaW1hZ2UgaXMgbm90IHlldCBsb2FkZWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSWNvbiB3aWR0aCAoaW4gcGl4ZWxzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlQXJyYXkoKTtcbiAgICBpZiAodGhpcy5zaXplXykge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZV9bMF0gKiBzY2FsZVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWNvbkltYWdlXy5nZXRJbWFnZVN0YXRlKCkgPT0gSW1hZ2VTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0U2l6ZSgpWzBdICogc2NhbGVbMF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGljb24gKGluIHBpeGVscykuIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCB3aGVuIHRoZSBpY29uIGltYWdlIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEljb24gaGVpZ2h0IChpbiBwaXhlbHMpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRIZWlnaHQoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlQXJyYXkoKTtcbiAgICBpZiAodGhpcy5zaXplXykge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZV9bMV0gKiBzY2FsZVsxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWNvbkltYWdlXy5nZXRJbWFnZVN0YXRlKCkgPT0gSW1hZ2VTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0U2l6ZSgpWzFdICogc2NhbGVbMV07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzY2FsZSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICBkZWxldGUgdGhpcy5pbml0aWFsT3B0aW9uc187XG4gICAgc3VwZXIuc2V0U2NhbGUoc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIGxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5pY29uSW1hZ2VfLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBXaGVuIHJlbmRlcmluZyBhIGZlYXR1cmUgd2l0aCBhbiBpY29uIHN0eWxlLCB0aGUgdmVjdG9yIHJlbmRlcmVyIHdpbGxcbiAgICogYXV0b21hdGljYWxseSBjYWxsIHRoaXMgbWV0aG9kLiBIb3dldmVyLCB5b3UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXNcbiAgICogbWV0aG9kIHlvdXJzZWxmIGZvciBwcmVsb2FkaW5nIG9yIG90aGVyIHB1cnBvc2VzLlxuICAgKiBAYXBpXG4gICAqL1xuICBsb2FkKCkge1xuICAgIHRoaXMuaWNvbkltYWdlXy5sb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgdW5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcikge1xuICAgIHRoaXMuaWNvbkltYWdlXy5yZW1vdmVFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DSEFOR0UsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJY29uO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9leHByL2V4cHJlc3Npb25cbiAqL1xuaW1wb3J0IHthc2NlbmRpbmd9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7aXNTdHJpbmdDb2xvcn0gZnJvbSAnLi4vY29sb3IuanMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaW5jbHVkZXMgdHlwZXMgYW5kIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBhcnJheSBlbmNvZGVkIGV4cHJlc3Npb25zLlxuICogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIGFuIGVuY29kZWQgZXhwcmVzc2lvbiBpcyBvbmUgb2YgdGhlIHNwZWNpZmljIGV4cHJlc3Npb24gY2xhc3Nlcy5cbiAqIER1cmluZyBwYXJzaW5nLCBpbmZvcm1hdGlvbiBpcyBhZGRlZCB0byB0aGUgcGFyc2luZyBjb250ZXh0IGFib3V0IHRoZSBkYXRhIGFjY2Vzc2VkIGJ5IHRoZVxuICogZXhwcmVzc2lvbi5cbiAqL1xuXG4vKipcbiAqIEJhc2UgdHlwZSB1c2VkIGZvciBsaXRlcmFsIHN0eWxlIHBhcmFtZXRlcnM7IGNhbiBiZSBhIG51bWJlciBsaXRlcmFsIG9yIHRoZSBvdXRwdXQgb2YgYW4gb3BlcmF0b3IsXG4gKiB3aGljaCBpbiB0dXJucyB0YWtlcyB7QGxpbmsgaW1wb3J0KFwiLi9leHByZXNzaW9uLmpzXCIpLkV4cHJlc3Npb25WYWx1ZX0gYXJndW1lbnRzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3BlcmF0b3JzIGNhbiBiZSB1c2VkOlxuICpcbiAqICogUmVhZGluZyBvcGVyYXRvcnM6XG4gKiAgICogYFsnYmFuZCcsIGJhbmRJbmRleCwgeE9mZnNldCwgeU9mZnNldF1gIEZvciB0aWxlIGxheWVycyBvbmx5LiBGZXRjaGVzIHBpeGVsIHZhbHVlcyBmcm9tIGJhbmRcbiAqICAgICBgYmFuZEluZGV4YCBvZiB0aGUgc291cmNlJ3MgZGF0YS4gVGhlIGZpcnN0IGBiYW5kSW5kZXhgIG9mIHRoZSBzb3VyY2UgZGF0YSBpcyBgMWAuIEZldGNoZWQgdmFsdWVzXG4gKiAgICAgYXJlIGluIHRoZSAwLi4xIHJhbmdlLiB7QGxpbmsgaW1wb3J0KFwiLi4vc291cmNlL1RpbGVJbWFnZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2VzIGhhdmUgNCBiYW5kczogcmVkLFxuICogICAgIGdyZWVuLCBibHVlIGFuZCBhbHBoYS4ge0BsaW5rIGltcG9ydChcIi4uL3NvdXJjZS9EYXRhVGlsZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2VzIGNhbiBoYXZlIGFueSBudW1iZXJcbiAqICAgICBvZiBiYW5kcywgZGVwZW5kaW5nIG9uIHRoZSB1bmRlcmx5aW5nIGRhdGEgc291cmNlIGFuZFxuICogICAgIHtAbGluayBpbXBvcnQoXCIuLi9zb3VyY2UvR2VvVElGRi5qc1wiKS5PcHRpb25zIGNvbmZpZ3VyYXRpb259LiBgeE9mZnNldGAgYW5kIGB5T2Zmc2V0YCBhcmUgb3B0aW9uYWxcbiAqICAgICBhbmQgYWxsb3cgc3BlY2lmeWluZyBwaXhlbCBvZmZzZXRzIGZvciB4IGFuZCB5LiBUaGlzIGlzIHVzZWQgZm9yIHNhbXBsaW5nIGRhdGEgZnJvbSBuZWlnaGJvcmluZyBwaXhlbHMuXG4gKiAgICogYFsnZ2V0JywgJ2F0dHJpYnV0ZU5hbWUnLCB0eXBlSGludF1gIGZldGNoZXMgYSBmZWF0dXJlIHByb3BlcnR5IHZhbHVlLCBzaW1pbGFyIHRvIGBmZWF0dXJlLmdldCgnYXR0cmlidXRlTmFtZScpYFxuICogICAgIEEgdHlwZSBoaW50IGNhbiBvcHRpb25hbGx5IGJlIHNwZWNpZmllZCwgaW4gY2FzZSB0aGUgcmVzdWx0aW5nIGV4cHJlc3Npb24gY29udGFpbnMgYSB0eXBlIGFtYmlndWl0eSB3aGljaFxuICogICAgIHdpbGwgbWFrZSBpdCBpbnZhbGlkLiBUeXBlIGhpbnRzIGNhbiBiZSBvbmUgb2Y6ICdzdHJpbmcnLCAnY29sb3InLCAnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnbnVtYmVyW10nXG4gKiAgICogYFsnZ2VvbWV0cnktdHlwZSddYCByZXR1cm5zIGEgZmVhdHVyZSdzIGdlb21ldHJ5IHR5cGUgYXMgc3RyaW5nLCBlaXRoZXI6ICdMaW5lU3RyaW5nJywgJ1BvaW50JyBvciAnUG9seWdvbidcbiAqICAgICBgTXVsdGkqYCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIHRoZWlyIHNpbmd1bGFyIGVxdWl2YWxlbnRcbiAqICAgICBgQ2lyY2xlYCBnZW9tZXRyaWVzIGFyZSByZXR1cm5lZCBhcyAnUG9seWdvbidcbiAqICAgICBgR2VvbWV0cnlDb2xsZWN0aW9uYCBnZW9tZXRyaWVzIGFyZSByZXR1cm5lZCBhcyB0aGUgdHlwZSBvZiB0aGUgZmlyc3QgZ2VvbWV0cnkgZm91bmQgaW4gdGhlIGNvbGxlY3Rpb25cbiAqICAgKiBgWydyZXNvbHV0aW9uJ11gIHJldHVybnMgdGhlIGN1cnJlbnQgcmVzb2x1dGlvblxuICogICAqIGBbJ3RpbWUnXWAgcmV0dXJucyB0aGUgdGltZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBjcmVhdGlvbiBvZiB0aGUgbGF5ZXJcbiAqICAgKiBgWyd2YXInLCAndmFyTmFtZSddYCBmZXRjaGVzIGEgdmFsdWUgZnJvbSB0aGUgc3R5bGUgdmFyaWFibGVzOyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoYXQgdmFyaWFibGUgaXMgdW5kZWZpbmVkXG4gKiAgICogYFsnem9vbSddYCByZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAqXG4gKiAqIE1hdGggb3BlcmF0b3JzOlxuICogICAqIGBbJyonLCB2YWx1ZTEsIHZhbHVlMiwgLi4uXWAgbXVsdGlwbGllcyB0aGUgdmFsdWVzIChlaXRoZXIgbnVtYmVycyBvciBjb2xvcnMpXG4gKiAgICogYFsnLycsIHZhbHVlMSwgdmFsdWUyXWAgZGl2aWRlcyBgdmFsdWUxYCBieSBgdmFsdWUyYFxuICogICAqIGBbJysnLCB2YWx1ZTEsIHZhbHVlMiwgLi4uXWAgYWRkcyB0aGUgdmFsdWVzXG4gKiAgICogYFsnLScsIHZhbHVlMSwgdmFsdWUyXWAgc3VidHJhY3RzIGB2YWx1ZTJgIGZyb20gYHZhbHVlMWBcbiAqICAgKiBgWydjbGFtcCcsIHZhbHVlLCBsb3csIGhpZ2hdYCBjbGFtcHMgYHZhbHVlYCBiZXR3ZWVuIGBsb3dgIGFuZCBgaGlnaGBcbiAqICAgKiBgWyclJywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYHZhbHVlMSAlIHZhbHVlMmAgKG1vZHVsbylcbiAqICAgKiBgWydeJywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIHRoZSB2YWx1ZSBvZiBgdmFsdWUxYCByYWlzZWQgdG8gdGhlIGB2YWx1ZTJgIHBvd2VyXG4gKiAgICogYFsnYWJzJywgdmFsdWUxXWAgcmV0dXJucyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYHZhbHVlMWBcbiAqICAgKiBgWydmbG9vcicsIHZhbHVlMV1gIHJldHVybnMgdGhlIG5lYXJlc3QgaW50ZWdlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlMWBcbiAqICAgKiBgWydyb3VuZCcsIHZhbHVlMV1gIHJldHVybnMgdGhlIG5lYXJlc3QgaW50ZWdlciB0byBgdmFsdWUxYFxuICogICAqIGBbJ2NlaWwnLCB2YWx1ZTFdYCByZXR1cm5zIHRoZSBuZWFyZXN0IGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZTFgXG4gKiAgICogYFsnc2luJywgdmFsdWUxXWAgcmV0dXJucyB0aGUgc2luZSBvZiBgdmFsdWUxYFxuICogICAqIGBbJ2NvcycsIHZhbHVlMV1gIHJldHVybnMgdGhlIGNvc2luZSBvZiBgdmFsdWUxYFxuICogICAqIGBbJ2F0YW4nLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgYGF0YW4yKHZhbHVlMSwgdmFsdWUyKWAuIElmIGB2YWx1ZTJgIGlzIG5vdCBwcm92aWRlZCwgcmV0dXJucyBgYXRhbih2YWx1ZTEpYFxuICogICAqIGBbJ3NxcnQnLCB2YWx1ZTFdYCByZXR1cm5zIHRoZSBzcXVhcmUgcm9vdCBvZiBgdmFsdWUxYFxuICpcbiAqICogVHJhbnNmb3JtIG9wZXJhdG9yczpcbiAqICAgKiBgWydjYXNlJywgY29uZGl0aW9uMSwgb3V0cHV0MSwgLi4uY29uZGl0aW9uTiwgb3V0cHV0TiwgZmFsbGJhY2tdYCBzZWxlY3RzIHRoZSBmaXJzdCBvdXRwdXQgd2hvc2UgY29ycmVzcG9uZGluZ1xuICogICAgIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gYHRydWVgLiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgcmV0dXJucyB0aGUgYGZhbGxiYWNrYCB2YWx1ZS5cbiAqICAgICBBbGwgY29uZGl0aW9ucyBzaG91bGQgYmUgYGJvb2xlYW5gLCBvdXRwdXQgYW5kIGZhbGxiYWNrIGNhbiBiZSBhbnkga2luZC5cbiAqICAgKiBgWydtYXRjaCcsIGlucHV0LCBtYXRjaDEsIG91dHB1dDEsIC4uLm1hdGNoTiwgb3V0cHV0TiwgZmFsbGJhY2tdYCBjb21wYXJlcyB0aGUgYGlucHV0YCB2YWx1ZSBhZ2FpbnN0IGFsbFxuICogICAgIHByb3ZpZGVkIGBtYXRjaFhgIHZhbHVlcywgcmV0dXJuaW5nIHRoZSBvdXRwdXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBmaXJzdCB2YWxpZCBtYXRjaC4gSWYgbm8gbWF0Y2ggaXMgZm91bmQsXG4gKiAgICAgcmV0dXJucyB0aGUgYGZhbGxiYWNrYCB2YWx1ZS5cbiAqICAgICBgaW5wdXRgIGFuZCBgbWF0Y2hYYCB2YWx1ZXMgbXVzdCBhbGwgYmUgb2YgdGhlIHNhbWUgdHlwZSwgYW5kIGNhbiBiZSBgbnVtYmVyYCBvciBgc3RyaW5nYC4gYG91dHB1dFhgIGFuZFxuICogICAgIGBmYWxsYmFja2AgdmFsdWVzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZSwgYW5kIGNhbiBiZSBvZiBhbnkga2luZC5cbiAqICAgKiBgWydpbnRlcnBvbGF0ZScsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wMSwgb3V0cHV0MSwgLi4uc3RvcE4sIG91dHB1dE5dYCByZXR1cm5zIGEgdmFsdWUgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuXG4gKiAgICAgcGFpcnMgb2YgaW5wdXRzIGFuZCBvdXRwdXRzOyBgaW50ZXJwb2xhdGlvbmAgY2FuIGVpdGhlciBiZSBgWydsaW5lYXInXWAgb3IgYFsnZXhwb25lbnRpYWwnLCBiYXNlXWAgd2hlcmUgYGJhc2VgIGlzXG4gKiAgICAgdGhlIHJhdGUgb2YgaW5jcmVhc2UgZnJvbSBzdG9wIEEgdG8gc3RvcCBCIChpLmUuIHBvd2VyIHRvIHdoaWNoIHRoZSBpbnRlcnBvbGF0aW9uIHJhdGlvIGlzIHJhaXNlZCk7IGEgdmFsdWVcbiAqICAgICBvZiAxIGlzIGVxdWl2YWxlbnQgdG8gYFsnbGluZWFyJ11gLlxuICogICAgIGBpbnB1dGAgYW5kIGBzdG9wWGAgdmFsdWVzIG11c3QgYWxsIGJlIG9mIHR5cGUgYG51bWJlcmAuIGBvdXRwdXRYYCB2YWx1ZXMgY2FuIGJlIGBudW1iZXJgIG9yIGBjb2xvcmAgdmFsdWVzLlxuICogICAgIE5vdGU6IGBpbnB1dGAgd2lsbCBiZSBjbGFtcGVkIGJldHdlZW4gYHN0b3AxYCBhbmQgYHN0b3BOYCwgbWVhbmluZyB0aGF0IGFsbCBvdXRwdXQgdmFsdWVzIHdpbGwgYmUgY29tcHJpc2VkXG4gKiAgICAgYmV0d2VlbiBgb3V0cHV0MWAgYW5kIGBvdXRwdXROYC5cbiAqXG4gKiAqIExvZ2ljYWwgb3BlcmF0b3JzOlxuICogICAqIGBbJzwnLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgYHRydWVgIGlmIGB2YWx1ZTFgIGlzIHN0cmljdGx5IGxvd2VyIHRoYW4gYHZhbHVlMmAsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJzw9JywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBpcyBsb3dlciB0aGFuIG9yIGVxdWFscyBgdmFsdWUyYCwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnPicsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlMWAgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIGB2YWx1ZTJgLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWyc+PScsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlMWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFscyBgdmFsdWUyYCwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnPT0nLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgYHRydWVgIGlmIGB2YWx1ZTFgIGVxdWFscyBgdmFsdWUyYCwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnIT0nLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgYHRydWVgIGlmIGB2YWx1ZTFgIGRvZXMgbm90IGVxdWFsIGB2YWx1ZTJgLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWychJywgdmFsdWUxXWAgcmV0dXJucyBgZmFsc2VgIGlmIGB2YWx1ZTFgIGlzIGB0cnVlYCBvciBncmVhdGVyIHRoYW4gYDBgLCBvciBgdHJ1ZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJ2FsbCcsIHZhbHVlMSwgdmFsdWUyLCAuLi5dYCByZXR1cm5zIGB0cnVlYCBpZiBhbGwgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWydhbnknLCB2YWx1ZTEsIHZhbHVlMiwgLi4uXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYW55IG9mIHRoZSBpbnB1dHMgYXJlIGB0cnVlYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnYmV0d2VlbicsIHZhbHVlMSwgdmFsdWUyLCB2YWx1ZTNdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBpcyBjb250YWluZWQgYmV0d2VlbiBgdmFsdWUyYCBhbmQgYHZhbHVlM2BcbiAqICAgICAoaW5jbHVzaXZlbHkpLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWydpbicsIG5lZWRsZSwgaGF5c3RhY2tdYCByZXR1cm5zIGB0cnVlYCBpZiBgbmVlZGxlYCBpcyBmb3VuZCBpbiBgaGF5c3RhY2tgLCBhbmRcbiAqICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgICBUaGlzIG9wZXJhdG9yIGhhcyB0aGUgZm9sbG93aW5nIGxpbWl0YXRpb25zOlxuICogICAgICogYGhheXN0YWNrYCBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChzZWFyY2hpbmcgZm9yIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nIGlzIG5vdCBzdXBwb3J0ZWQgeWV0KVxuICogICAgICogT25seSBsaXRlcmFsIGFycmF5cyBhcmUgc3VwcG9ydGVkIGFzIGBoYXlzdGFja2AgZm9yIG5vdzsgdGhpcyBtZWFucyB0aGF0IGBoYXlzdGFja2AgY2Fubm90IGJlIHRoZSByZXN1bHQgb2YgYW5cbiAqICAgICBleHByZXNzaW9uLiBJZiBgaGF5c3RhY2tgIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHVzZSB0aGUgYGxpdGVyYWxgIG9wZXJhdG9yIHRvIGRpc2FtYmlndWF0ZSBmcm9tIGFuIGV4cHJlc3Npb246XG4gKiAgICAgYFsnbGl0ZXJhbCcsIFsnYWJjJywgJ2RlZicsICdnaGknXV1gXG4gKlxuICogKiBDb252ZXJzaW9uIG9wZXJhdG9yczpcbiAqICAgKiBgWydhcnJheScsIHZhbHVlMSwgLi4udmFsdWVOXWAgY3JlYXRlcyBhIG51bWVyaWNhbCBhcnJheSBmcm9tIGBudW1iZXJgIHZhbHVlczsgcGxlYXNlIG5vdGUgdGhhdCB0aGUgYW1vdW50IG9mXG4gKiAgICAgdmFsdWVzIGNhbiBjdXJyZW50bHkgb25seSBiZSAyLCAzIG9yIDQuXG4gKiAgICogYFsnY29sb3InLCByZWQsIGdyZWVuLCBibHVlLCBhbHBoYV1gIGNyZWF0ZXMgYSBgY29sb3JgIHZhbHVlIGZyb20gYG51bWJlcmAgdmFsdWVzOyB0aGUgYGFscGhhYCBwYXJhbWV0ZXIgaXNcbiAqICAgICBvcHRpb25hbDsgaWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgdG8gMS5cbiAqICAgICBOb3RlOiBgcmVkYCwgYGdyZWVuYCBhbmQgYGJsdWVgIGNvbXBvbmVudHMgbXVzdCBiZSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTU7IGBhbHBoYWAgYmV0d2VlbiAwIGFuZCAxLlxuICogICAqIGBbJ3BhbGV0dGUnLCBpbmRleCwgY29sb3JzXWAgcGlja3MgYSBgY29sb3JgIHZhbHVlIGZyb20gYW4gYXJyYXkgb2YgY29sb3JzIHVzaW5nIHRoZSBnaXZlbiBpbmRleDsgdGhlIGBpbmRleGBcbiAqICAgICBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gYSBudW1iZXI7IHRoZSBpdGVtcyBpbiB0aGUgYGNvbG9yc2AgYXJyYXkgbXVzdCBiZSBzdHJpbmdzIHdpdGggaGV4IGNvbG9yc1xuICogICAgIChlLmcuIGAnIzg2QTEzNidgKSwgY29sb3JzIHVzaW5nIHRoZSByZ2JhW2FdIGZ1bmN0aW9uYWwgbm90YXRpb24gKGUuZy4gYCdyZ2IoMTM0LCAxNjEsIDU0KSdgIG9yIGAncmdiYSgxMzQsIDE2MSwgNTQsIDEpJ2ApLFxuICogICAgIG5hbWVkIGNvbG9ycyAoZS5nLiBgJ3JlZCdgKSwgb3IgYXJyYXkgbGl0ZXJhbHMgd2l0aCAzIChbciwgZywgYl0pIG9yIDQgKFtyLCBnLCBiLCBhXSkgdmFsdWVzICh3aXRoIHIsIGcsIGFuZCBiXG4gKiAgICAgaW4gdGhlIDAtMjU1IHJhbmdlIGFuZCBhIGluIHRoZSAwLTEgcmFuZ2UpLlxuICpcbiAqIFZhbHVlcyBjYW4gZWl0aGVyIGJlIGxpdGVyYWxzIG9yIGFub3RoZXIgb3BlcmF0b3IsIGFzIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcmVjdXJzaXZlbHkuXG4gKiBMaXRlcmFsIHZhbHVlcyBjYW4gYmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczpcbiAqICogYGJvb2xlYW5gXG4gKiAqIGBudW1iZXJgXG4gKiAqIGBudW1iZXJbXWAgKG51bWJlciBhcnJheXMgY2FuIG9ubHkgaGF2ZSBhIGxlbmd0aCBvZiAyLCAzIG9yIDQpXG4gKiAqIGBzdHJpbmdgXG4gKiAqIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9XG4gKlxuICogQHR5cGVkZWYge0FycmF5PCo+fGltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gRXhwcmVzc2lvblZhbHVlXG4gKiBAYXBpXG4gKi9cblxubGV0IG51bVR5cGVzID0gMDtcbmV4cG9ydCBjb25zdCBOb25lVHlwZSA9IDA7XG5leHBvcnQgY29uc3QgQm9vbGVhblR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgTnVtYmVyVHlwZSA9IDEgPDwgbnVtVHlwZXMrKztcbmV4cG9ydCBjb25zdCBTdHJpbmdUeXBlID0gMSA8PCBudW1UeXBlcysrO1xuZXhwb3J0IGNvbnN0IENvbG9yVHlwZSA9IDEgPDwgbnVtVHlwZXMrKztcbmV4cG9ydCBjb25zdCBOdW1iZXJBcnJheVR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgQW55VHlwZSA9IE1hdGgucG93KDIsIG51bVR5cGVzKSAtIDE7XG5cbmNvbnN0IHR5cGVOYW1lcyA9IHtcbiAgW0Jvb2xlYW5UeXBlXTogJ2Jvb2xlYW4nLFxuICBbTnVtYmVyVHlwZV06ICdudW1iZXInLFxuICBbU3RyaW5nVHlwZV06ICdzdHJpbmcnLFxuICBbQ29sb3JUeXBlXTogJ2NvbG9yJyxcbiAgW051bWJlckFycmF5VHlwZV06ICdudW1iZXJbXScsXG59O1xuXG5jb25zdCBuYW1lZFR5cGVzID0gT2JqZWN0LmtleXModHlwZU5hbWVzKS5tYXAoTnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG5cbi8qKlxuICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBhIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdHlwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHR5cGUgbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVOYW1lKHR5cGUpIHtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lZFR5cGUgb2YgbmFtZWRUeXBlcykge1xuICAgIGlmIChpbmNsdWRlc1R5cGUodHlwZSwgbmFtZWRUeXBlKSkge1xuICAgICAgbmFtZXMucHVzaCh0eXBlTmFtZXNbbmFtZWRUeXBlXSk7XG4gICAgfVxuICB9XG4gIGlmIChuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ3VudHlwZWQnO1xuICB9XG4gIGlmIChuYW1lcy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmpvaW4oJyBvciAnKTtcbiAgfVxuICByZXR1cm4gbmFtZXMuc2xpY2UoMCwgLTEpLmpvaW4oJywgJykgKyAnLCBvciAnICsgbmFtZXNbbmFtZXMubGVuZ3RoIC0gMV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJyb2FkIFRoZSBicm9hZCB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNwZWNpZmljIFRoZSBzcGVjaWZpYyB0eXBlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGJyb2FkIHR5cGUgaW5jbHVkZXMgdGhlIHNwZWNpZmljIHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlc1R5cGUoYnJvYWQsIHNwZWNpZmljKSB7XG4gIHJldHVybiAoYnJvYWQgJiBzcGVjaWZpYykgPT09IHNwZWNpZmljO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvbmVUeXBlIE9uZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IG90aGVyVHlwZSBBbm90aGVyIHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2V0IG9mIHR5cGVzIG92ZXJsYXAgKHNoYXJlIGEgY29tbW9uIHNwZWNpZmljIHR5cGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdmVybGFwc1R5cGUob25lVHlwZSwgb3RoZXJUeXBlKSB7XG4gIHJldHVybiAhIShvbmVUeXBlICYgb3RoZXJUeXBlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCBUaGUgZXhwZWN0ZWQgdHlwZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBnaXZlbiB0eXBlIGlzIGV4YWN0bHkgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGUodHlwZSwgZXhwZWN0ZWQpIHtcbiAgcmV0dXJuIHR5cGUgPT09IGV4cGVjdGVkO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtib29sZWFufG51bWJlcnxzdHJpbmd8QXJyYXk8bnVtYmVyPn0gTGl0ZXJhbFZhbHVlXG4gKi9cblxuZXhwb3J0IGNsYXNzIExpdGVyYWxFeHByZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSB2YWx1ZSB0eXBlLlxuICAgKiBAcGFyYW0ge0xpdGVyYWxWYWx1ZX0gdmFsdWUgVGhlIGxpdGVyYWwgdmFsdWUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDYWxsRXhwcmVzc2lvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgcmV0dXJuIHR5cGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgb3BlcmF0b3IuXG4gICAqIEBwYXJhbSB7Li4uRXhwcmVzc2lvbn0gYXJncyBUaGUgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3BlcmF0b3IsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge0xpdGVyYWxFeHByZXNzaW9ufENhbGxFeHByZXNzaW9ufSBFeHByZXNzaW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzaW5nQ29udGV4dFxuICogQHByb3BlcnR5IHtTZXQ8c3RyaW5nPn0gdmFyaWFibGVzIFZhcmlhYmxlcyByZWZlcmVuY2VkIHdpdGggdGhlICd2YXInIG9wZXJhdG9yLlxuICogQHByb3BlcnR5IHtTZXQ8c3RyaW5nPn0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIHJlZmVyZW5jZWQgd2l0aCB0aGUgJ2dldCcgb3BlcmF0b3IuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZlYXR1cmVJZCBUaGUgc3R5bGUgdXNlcyB0aGUgZmVhdHVyZSBpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGV8aW1wb3J0KFwiLi4vc3R5bGUvd2ViZ2wuanNcIikuV2ViR0xTdHlsZX0gc3R5bGUgVGhlIHN0eWxlIGJlaW5nIHBhcnNlZFxuICovXG5cbi8qKlxuICogQHJldHVybiB7UGFyc2luZ0NvbnRleHR9IEEgbmV3IHBhcnNpbmcgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5ld1BhcnNpbmdDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIHZhcmlhYmxlczogbmV3IFNldCgpLFxuICAgIHByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgICBmZWF0dXJlSWQ6IGZhbHNlLFxuICAgIHN0eWxlOiB7fSxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZUhpbnQgVHlwZSBoaW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJlc3VsdGluZyB2YWx1ZSB0eXBlICh3aWxsIGJlIGEgc2luZ2xlIHR5cGUpXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGVGcm9tSGludCh0eXBlSGludCkge1xuICBzd2l0Y2ggKHR5cGVIaW50KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBTdHJpbmdUeXBlO1xuICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgIHJldHVybiBDb2xvclR5cGU7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBOdW1iZXJUeXBlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xlYW5UeXBlO1xuICAgIGNhc2UgJ251bWJlcltdJzpcbiAgICAgIHJldHVybiBOdW1iZXJBcnJheVR5cGU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIHR5cGUgaGludDogJHt0eXBlSGludH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtMaXRlcmFsVmFsdWV8QXJyYXl9IEVuY29kZWRFeHByZXNzaW9uXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZWRFeHByZXNzaW9ufSBlbmNvZGVkIFRoZSBlbmNvZGVkIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3R5cGVIaW50XSBPcHRpb25hbCB0eXBlIGhpbnRcbiAqIEByZXR1cm4ge0V4cHJlc3Npb259IFRoZSBwYXJzZWQgZXhwcmVzc2lvbiByZXN1bHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShlbmNvZGVkLCBjb250ZXh0LCB0eXBlSGludCkge1xuICBzd2l0Y2ggKHR5cGVvZiBlbmNvZGVkKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6IHtcbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oQm9vbGVhblR5cGUsIGVuY29kZWQpO1xuICAgIH1cbiAgICBjYXNlICdudW1iZXInOiB7XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKE51bWJlclR5cGUsIGVuY29kZWQpO1xuICAgIH1cbiAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICBsZXQgdHlwZSA9IFN0cmluZ1R5cGU7XG4gICAgICBpZiAoaXNTdHJpbmdDb2xvcihlbmNvZGVkKSkge1xuICAgICAgICB0eXBlIHw9IENvbG9yVHlwZTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHRoZSBnaXZlbiB0eXBlIGhpbnQgb25seSBpZiBpdCB3b24ndCByZXN1bHQgaW4gYW4gZW1wdHkgdHlwZVxuICAgICAgaWYgKCFpc1R5cGUodHlwZSAmIHR5cGVIaW50LCBOb25lVHlwZSkpIHtcbiAgICAgICAgdHlwZSAmPSB0eXBlSGludDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24odHlwZSwgZW5jb2RlZCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIC8vIHBhc3NcbiAgICB9XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZW5jb2RlZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cHJlc3Npb24gbXVzdCBiZSBhbiBhcnJheSBvciBhIHByaW1pdGl2ZSB2YWx1ZScpO1xuICB9XG5cbiAgaWYgKGVuY29kZWQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBleHByZXNzaW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kZWRbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlQ2FsbEV4cHJlc3Npb24oZW5jb2RlZCwgY29udGV4dCwgdHlwZUhpbnQpO1xuICB9XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGVuY29kZWQpIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICB9XG4gIH1cblxuICBsZXQgdHlwZSA9IE51bWJlckFycmF5VHlwZTtcbiAgaWYgKGVuY29kZWQubGVuZ3RoID09PSAzIHx8IGVuY29kZWQubGVuZ3RoID09PSA0KSB7XG4gICAgdHlwZSB8PSBDb2xvclR5cGU7XG4gIH1cbiAgaWYgKHR5cGVIaW50KSB7XG4gICAgdHlwZSAmPSB0eXBlSGludDtcbiAgfVxuICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKHR5cGUsIGVuY29kZWQpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgT3BzID0ge1xuICBHZXQ6ICdnZXQnLFxuICBWYXI6ICd2YXInLFxuICBDb25jYXQ6ICdjb25jYXQnLFxuICBHZW9tZXRyeVR5cGU6ICdnZW9tZXRyeS10eXBlJyxcbiAgQW55OiAnYW55JyxcbiAgQWxsOiAnYWxsJyxcbiAgTm90OiAnIScsXG4gIFJlc29sdXRpb246ICdyZXNvbHV0aW9uJyxcbiAgWm9vbTogJ3pvb20nLFxuICBUaW1lOiAndGltZScsXG4gIEVxdWFsOiAnPT0nLFxuICBOb3RFcXVhbDogJyE9JyxcbiAgR3JlYXRlclRoYW46ICc+JyxcbiAgR3JlYXRlclRoYW5PckVxdWFsVG86ICc+PScsXG4gIExlc3NUaGFuOiAnPCcsXG4gIExlc3NUaGFuT3JFcXVhbFRvOiAnPD0nLFxuICBNdWx0aXBseTogJyonLFxuICBEaXZpZGU6ICcvJyxcbiAgQWRkOiAnKycsXG4gIFN1YnRyYWN0OiAnLScsXG4gIENsYW1wOiAnY2xhbXAnLFxuICBNb2Q6ICclJyxcbiAgUG93OiAnXicsXG4gIEFiczogJ2FicycsXG4gIEZsb29yOiAnZmxvb3InLFxuICBDZWlsOiAnY2VpbCcsXG4gIFJvdW5kOiAncm91bmQnLFxuICBTaW46ICdzaW4nLFxuICBDb3M6ICdjb3MnLFxuICBBdGFuOiAnYXRhbicsXG4gIFNxcnQ6ICdzcXJ0JyxcbiAgTWF0Y2g6ICdtYXRjaCcsXG4gIEJldHdlZW46ICdiZXR3ZWVuJyxcbiAgSW50ZXJwb2xhdGU6ICdpbnRlcnBvbGF0ZScsXG4gIENhc2U6ICdjYXNlJyxcbiAgSW46ICdpbicsXG4gIE51bWJlcjogJ251bWJlcicsXG4gIFN0cmluZzogJ3N0cmluZycsXG4gIEFycmF5OiAnYXJyYXknLFxuICBDb2xvcjogJ2NvbG9yJyxcbiAgSWQ6ICdpZCcsXG4gIEJhbmQ6ICdiYW5kJyxcbiAgUGFsZXR0ZTogJ3BhbGV0dGUnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXksIFBhcnNpbmdDb250ZXh0LCBudW1iZXIpOkV4cHJlc3Npb259IFBhcnNlclxuICogVGhpcmQgYXJndW1lbnQgaXMgYSB0eXBlIGhpbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBQYXJzZXI+fVxuICovXG5jb25zdCBwYXJzZXJzID0ge1xuICBbT3BzLkdldF06IGNyZWF0ZVBhcnNlcihcbiAgICAoW18sIHR5cGVIaW50XSkgPT4ge1xuICAgICAgaWYgKHR5cGVIaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldFR5cGVGcm9tSGludChcbiAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi8gKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtMaXRlcmFsRXhwcmVzc2lvbn0gKi8gKHR5cGVIaW50KS52YWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbnlUeXBlO1xuICAgIH0sXG4gICAgd2l0aEFyZ3NDb3VudCgxLCAyKSxcbiAgICB3aXRoR2V0QXJnc1xuICApLFxuICBbT3BzLlZhcl06IGNyZWF0ZVBhcnNlcihcbiAgICAoW2ZpcnN0QXJnXSkgPT4gZmlyc3RBcmcudHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDEsIDEpLFxuICAgIHdpdGhWYXJBcmdzXG4gICksXG4gIFtPcHMuSWRdOiBjcmVhdGVQYXJzZXIoTnVtYmVyVHlwZSB8IFN0cmluZ1R5cGUsIHdpdGhOb0FyZ3MsIHVzZXNGZWF0dXJlSWQpLFxuICBbT3BzLkNvbmNhdF06IGNyZWF0ZVBhcnNlcihcbiAgICBTdHJpbmdUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMiwgSW5maW5pdHkpLFxuICAgIHBhcnNlQXJnc09mVHlwZShBbnlUeXBlKVxuICApLFxuICBbT3BzLkdlb21ldHJ5VHlwZV06IGNyZWF0ZVBhcnNlcihTdHJpbmdUeXBlLCB3aXRoTm9BcmdzKSxcbiAgW09wcy5SZXNvbHV0aW9uXTogY3JlYXRlUGFyc2VyKE51bWJlclR5cGUsIHdpdGhOb0FyZ3MpLFxuICBbT3BzLlpvb21dOiBjcmVhdGVQYXJzZXIoTnVtYmVyVHlwZSwgd2l0aE5vQXJncyksXG4gIFtPcHMuVGltZV06IGNyZWF0ZVBhcnNlcihOdW1iZXJUeXBlLCB3aXRoTm9BcmdzKSxcbiAgW09wcy5BbnldOiBjcmVhdGVQYXJzZXIoXG4gICAgQm9vbGVhblR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgyLCBJbmZpbml0eSksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKEJvb2xlYW5UeXBlKVxuICApLFxuICBbT3BzLkFsbF06IGNyZWF0ZVBhcnNlcihcbiAgICBCb29sZWFuVHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDIsIEluZmluaXR5KSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoQm9vbGVhblR5cGUpXG4gICksXG4gIFtPcHMuTm90XTogY3JlYXRlUGFyc2VyKFxuICAgIEJvb2xlYW5UeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMSwgMSksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKEJvb2xlYW5UeXBlKVxuICApLFxuICBbT3BzLkVxdWFsXTogY3JlYXRlUGFyc2VyKFxuICAgIEJvb2xlYW5UeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMiwgMiksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKEFueVR5cGUpLFxuICAgIG5hcnJvd0FyZ3NUeXBlXG4gICksXG4gIFtPcHMuTm90RXF1YWxdOiBjcmVhdGVQYXJzZXIoXG4gICAgQm9vbGVhblR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgyLCAyKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoQW55VHlwZSksXG4gICAgbmFycm93QXJnc1R5cGVcbiAgKSxcbiAgW09wcy5HcmVhdGVyVGhhbl06IGNyZWF0ZVBhcnNlcihcbiAgICBCb29sZWFuVHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDIsIDIpLFxuICAgIHBhcnNlQXJnc09mVHlwZShBbnlUeXBlKSxcbiAgICBuYXJyb3dBcmdzVHlwZVxuICApLFxuICBbT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvXTogY3JlYXRlUGFyc2VyKFxuICAgIEJvb2xlYW5UeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMiwgMiksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKEFueVR5cGUpLFxuICAgIG5hcnJvd0FyZ3NUeXBlXG4gICksXG4gIFtPcHMuTGVzc1RoYW5dOiBjcmVhdGVQYXJzZXIoXG4gICAgQm9vbGVhblR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgyLCAyKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoQW55VHlwZSksXG4gICAgbmFycm93QXJnc1R5cGVcbiAgKSxcbiAgW09wcy5MZXNzVGhhbk9yRXF1YWxUb106IGNyZWF0ZVBhcnNlcihcbiAgICBCb29sZWFuVHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDIsIDIpLFxuICAgIHBhcnNlQXJnc09mVHlwZShBbnlUeXBlKSxcbiAgICBuYXJyb3dBcmdzVHlwZVxuICApLFxuICBbT3BzLk11bHRpcGx5XTogY3JlYXRlUGFyc2VyKFxuICAgIChwYXJzZWRBcmdzKSA9PiB7XG4gICAgICBsZXQgb3V0cHV0VHlwZSA9IE51bWJlclR5cGUgfCBDb2xvclR5cGU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZEFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0VHlwZSAmPSBwYXJzZWRBcmdzW2ldLnR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0VHlwZTtcbiAgICB9LFxuICAgIHdpdGhBcmdzQ291bnQoMiwgSW5maW5pdHkpLFxuICAgIHBhcnNlQXJnc09mVHlwZShOdW1iZXJUeXBlIHwgQ29sb3JUeXBlKSxcbiAgICBuYXJyb3dBcmdzVHlwZVxuICApLFxuICBbT3BzLkRpdmlkZV06IGNyZWF0ZVBhcnNlcihcbiAgICBOdW1iZXJUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMiwgMiksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKE51bWJlclR5cGUpXG4gICksXG4gIFtPcHMuQWRkXTogY3JlYXRlUGFyc2VyKFxuICAgIE51bWJlclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgyLCBJbmZpbml0eSksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKE51bWJlclR5cGUpXG4gICksXG4gIFtPcHMuU3VidHJhY3RdOiBjcmVhdGVQYXJzZXIoXG4gICAgTnVtYmVyVHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDIsIDIpLFxuICAgIHBhcnNlQXJnc09mVHlwZShOdW1iZXJUeXBlKVxuICApLFxuICBbT3BzLkNsYW1wXTogY3JlYXRlUGFyc2VyKFxuICAgIE51bWJlclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgzLCAzKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5Nb2RdOiBjcmVhdGVQYXJzZXIoXG4gICAgTnVtYmVyVHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDIsIDIpLFxuICAgIHBhcnNlQXJnc09mVHlwZShOdW1iZXJUeXBlKVxuICApLFxuICBbT3BzLlBvd106IGNyZWF0ZVBhcnNlcihcbiAgICBOdW1iZXJUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMiwgMiksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKE51bWJlclR5cGUpXG4gICksXG4gIFtPcHMuQWJzXTogY3JlYXRlUGFyc2VyKFxuICAgIE51bWJlclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgxLCAxKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5GbG9vcl06IGNyZWF0ZVBhcnNlcihcbiAgICBOdW1iZXJUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMSwgMSksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKE51bWJlclR5cGUpXG4gICksXG4gIFtPcHMuQ2VpbF06IGNyZWF0ZVBhcnNlcihcbiAgICBOdW1iZXJUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMSwgMSksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKE51bWJlclR5cGUpXG4gICksXG4gIFtPcHMuUm91bmRdOiBjcmVhdGVQYXJzZXIoXG4gICAgTnVtYmVyVHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDEsIDEpLFxuICAgIHBhcnNlQXJnc09mVHlwZShOdW1iZXJUeXBlKVxuICApLFxuICBbT3BzLlNpbl06IGNyZWF0ZVBhcnNlcihcbiAgICBOdW1iZXJUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMSwgMSksXG4gICAgcGFyc2VBcmdzT2ZUeXBlKE51bWJlclR5cGUpXG4gICksXG4gIFtPcHMuQ29zXTogY3JlYXRlUGFyc2VyKFxuICAgIE51bWJlclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgxLCAxKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5BdGFuXTogY3JlYXRlUGFyc2VyKFxuICAgIE51bWJlclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgxLCAyKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5TcXJ0XTogY3JlYXRlUGFyc2VyKFxuICAgIE51bWJlclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgxLCAxKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5NYXRjaF06IGNyZWF0ZVBhcnNlcihcbiAgICAocGFyc2VkQXJncykgPT4ge1xuICAgICAgbGV0IHR5cGUgPSBBbnlUeXBlO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwYXJzZWRBcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHR5cGUgJj0gcGFyc2VkQXJnc1tpXS50eXBlO1xuICAgICAgfVxuICAgICAgdHlwZSAmPSBwYXJzZWRBcmdzW3BhcnNlZEFyZ3MubGVuZ3RoIC0gMV0udHlwZTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG4gICAgd2l0aEFyZ3NDb3VudCg0LCBJbmZpbml0eSksXG4gICAgd2l0aEV2ZW5BcmdzLFxuICAgIHBhcnNlTWF0Y2hBcmdzXG4gICksXG4gIFtPcHMuQmV0d2Vlbl06IGNyZWF0ZVBhcnNlcihcbiAgICBCb29sZWFuVHlwZSxcbiAgICB3aXRoQXJnc0NvdW50KDMsIDMpLFxuICAgIHBhcnNlQXJnc09mVHlwZShOdW1iZXJUeXBlKVxuICApLFxuICBbT3BzLkludGVycG9sYXRlXTogY3JlYXRlUGFyc2VyKFxuICAgIChwYXJzZWRBcmdzKSA9PiB7XG4gICAgICBsZXQgdHlwZSA9IENvbG9yVHlwZSB8IE51bWJlclR5cGU7XG4gICAgICBmb3IgKGxldCBpID0gMzsgaSA8IHBhcnNlZEFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdHlwZSAmPSBwYXJzZWRBcmdzW2ldLnR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuICAgIHdpdGhBcmdzQ291bnQoNiwgSW5maW5pdHkpLFxuICAgIHdpdGhFdmVuQXJncyxcbiAgICBwYXJzZUludGVycG9sYXRlQXJnc1xuICApLFxuICBbT3BzLkNhc2VdOiBjcmVhdGVQYXJzZXIoXG4gICAgKHBhcnNlZEFyZ3MpID0+IHtcbiAgICAgIGxldCB0eXBlID0gQW55VHlwZTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFyc2VkQXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB0eXBlICY9IHBhcnNlZEFyZ3NbaV0udHlwZTtcbiAgICAgIH1cbiAgICAgIHR5cGUgJj0gcGFyc2VkQXJnc1twYXJzZWRBcmdzLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuICAgIHdpdGhBcmdzQ291bnQoMywgSW5maW5pdHkpLFxuICAgIHdpdGhPZGRBcmdzLFxuICAgIHBhcnNlQ2FzZUFyZ3NcbiAgKSxcbiAgW09wcy5Jbl06IGNyZWF0ZVBhcnNlcihCb29sZWFuVHlwZSwgd2l0aEFyZ3NDb3VudCgyLCAyKSwgcGFyc2VJbkFyZ3MpLFxuICBbT3BzLk51bWJlcl06IGNyZWF0ZVBhcnNlcihcbiAgICBOdW1iZXJUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMSwgSW5maW5pdHkpLFxuICAgIHBhcnNlQXJnc09mVHlwZShBbnlUeXBlKVxuICApLFxuICBbT3BzLlN0cmluZ106IGNyZWF0ZVBhcnNlcihcbiAgICBTdHJpbmdUeXBlLFxuICAgIHdpdGhBcmdzQ291bnQoMSwgSW5maW5pdHkpLFxuICAgIHBhcnNlQXJnc09mVHlwZShBbnlUeXBlKVxuICApLFxuICBbT3BzLkFycmF5XTogY3JlYXRlUGFyc2VyKFxuICAgIChwYXJzZWRBcmdzKSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VkQXJncy5sZW5ndGggPT09IDMgfHwgcGFyc2VkQXJncy5sZW5ndGggPT09IDRcbiAgICAgICAgPyBOdW1iZXJBcnJheVR5cGUgfCBDb2xvclR5cGVcbiAgICAgICAgOiBOdW1iZXJBcnJheVR5cGU7XG4gICAgfSxcbiAgICB3aXRoQXJnc0NvdW50KDEsIEluZmluaXR5KSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5Db2xvcl06IGNyZWF0ZVBhcnNlcihcbiAgICBDb2xvclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgzLCA0KSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5CYW5kXTogY3JlYXRlUGFyc2VyKFxuICAgIE51bWJlclR5cGUsXG4gICAgd2l0aEFyZ3NDb3VudCgxLCAzKSxcbiAgICBwYXJzZUFyZ3NPZlR5cGUoTnVtYmVyVHlwZSlcbiAgKSxcbiAgW09wcy5QYWxldHRlXTogY3JlYXRlUGFyc2VyKENvbG9yVHlwZSwgd2l0aEFyZ3NDb3VudCgyLCAyKSwgcGFyc2VQYWxldHRlQXJncyksXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihBcnJheTxFbmNvZGVkRXhwcmVzc2lvbj4sIFBhcnNpbmdDb250ZXh0LCBBcnJheTxFeHByZXNzaW9uPiwgbnVtYmVyPyk6QXJyYXk8RXhwcmVzc2lvbj58dm9pZH0gQXJnVmFsaWRhdG9yXG4gKiBBbiBhcmd1bWVudCB2YWxpZGF0b3IgYXBwbGllcyB2YXJpb3VzIGNoZWNrcyB0byBhbiBlbmNvZGVkIGV4cHJlc3Npb24gYXJndW1lbnRzXG4gKiBSZXR1cm5zIHRoZSBwYXJzZWQgYXJndW1lbnRzIGlmIGFueS5cbiAqIFRoaXJkIGFyZ3VtZW50IGlzIHRoZSBhcnJheSBvZiBwYXJzZWQgYXJndW1lbnRzIGZyb20gcHJldmlvdXMgdmFsaWRhdG9yc1xuICogRm91cnRoIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIHR5cGUgaGludFxuICovXG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhHZXRBcmdzKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgY29uc3QgYXJnID0gcGFyc2UoZW5jb2RlZFsxXSwgY29udGV4dCk7XG4gIGlmICghKGFyZyBpbnN0YW5jZW9mIExpdGVyYWxFeHByZXNzaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBsaXRlcmFsIGFyZ3VtZW50IGZvciBnZXQgb3BlcmF0aW9uJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN0cmluZyBhcmd1bWVudCBmb3IgZ2V0IG9wZXJhdGlvbicpO1xuICB9XG4gIGNvbnRleHQucHJvcGVydGllcy5hZGQoYXJnLnZhbHVlKTtcbiAgaWYgKGVuY29kZWQubGVuZ3RoID09PSAzKSB7XG4gICAgY29uc3QgaGludCA9IHBhcnNlKGVuY29kZWRbMl0sIGNvbnRleHQpO1xuICAgIHJldHVybiBbYXJnLCBoaW50XTtcbiAgfVxuICByZXR1cm4gW2FyZ107XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhWYXJBcmdzKGVuY29kZWQsIGNvbnRleHQsIHBhcnNlZEFyZ3MsIHR5cGVIaW50KSB7XG4gIGNvbnN0IHZhck5hbWUgPSBlbmNvZGVkWzFdO1xuICBpZiAodHlwZW9mIHZhck5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN0cmluZyBhcmd1bWVudCBmb3IgdmFyIG9wZXJhdGlvbicpO1xuICB9XG4gIGNvbnRleHQudmFyaWFibGVzLmFkZCh2YXJOYW1lKTtcbiAgaWYgKFxuICAgICEoJ3ZhcmlhYmxlcycgaW4gY29udGV4dC5zdHlsZSkgfHxcbiAgICBjb250ZXh0LnN0eWxlLnZhcmlhYmxlc1t2YXJOYW1lXSA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiBbbmV3IExpdGVyYWxFeHByZXNzaW9uKEFueVR5cGUsIHZhck5hbWUpXTtcbiAgfVxuICBjb25zdCBpbml0aWFsVmFsdWUgPSBjb250ZXh0LnN0eWxlLnZhcmlhYmxlc1t2YXJOYW1lXTtcbiAgY29uc3QgYXJnID0gLyoqIEB0eXBlIHtMaXRlcmFsRXhwcmVzc2lvbn0gKi8gKHBhcnNlKGluaXRpYWxWYWx1ZSwgY29udGV4dCkpO1xuICBhcmcudmFsdWUgPSB2YXJOYW1lO1xuICBpZiAodHlwZUhpbnQgJiYgIW92ZXJsYXBzVHlwZSh0eXBlSGludCwgYXJnLnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSB2YXJpYWJsZSAke3Zhck5hbWV9IGhhcyB0eXBlICR7dHlwZU5hbWUoXG4gICAgICAgIGFyZy50eXBlXG4gICAgICApfSBidXQgdGhlIGZvbGxvd2luZyB0eXBlIHdhcyBleHBlY3RlZDogJHt0eXBlTmFtZSh0eXBlSGludCl9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIFthcmddO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB1c2VzRmVhdHVyZUlkKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgY29udGV4dC5mZWF0dXJlSWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB3aXRoTm9BcmdzKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3BlcmF0aW9uID0gZW5jb2RlZFswXTtcbiAgaWYgKGVuY29kZWQubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBubyBhcmd1bWVudHMgZm9yICR7b3BlcmF0aW9ufSBvcGVyYXRpb25gKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbkFyZ3MgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBcmdzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHtBcmdWYWxpZGF0b3J9IFRoZSBhcmd1bWVudCB2YWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aEFyZ3NDb3VudChtaW5BcmdzLCBtYXhBcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZW5jb2RlZCwgY29udGV4dCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVuY29kZWRbMF07XG4gICAgY29uc3QgYXJnQ291bnQgPSBlbmNvZGVkLmxlbmd0aCAtIDE7XG4gICAgaWYgKG1pbkFyZ3MgPT09IG1heEFyZ3MpIHtcbiAgICAgIGlmIChhcmdDb3VudCAhPT0gbWluQXJncykge1xuICAgICAgICBjb25zdCBwbHVyYWwgPSBtaW5BcmdzID09PSAxID8gJycgOiAncyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgJHttaW5BcmdzfSBhcmd1bWVudCR7cGx1cmFsfSBmb3IgJHtvcGVyYXRpb259LCBnb3QgJHthcmdDb3VudH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmdDb3VudCA8IG1pbkFyZ3MgfHwgYXJnQ291bnQgPiBtYXhBcmdzKSB7XG4gICAgICBjb25zdCByYW5nZSA9XG4gICAgICAgIG1heEFyZ3MgPT09IEluZmluaXR5XG4gICAgICAgICAgPyBgJHttaW5BcmdzfSBvciBtb3JlYFxuICAgICAgICAgIDogYCR7bWluQXJnc30gdG8gJHttYXhBcmdzfWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCAke3JhbmdlfSBhcmd1bWVudHMgZm9yICR7b3BlcmF0aW9ufSwgZ290ICR7YXJnQ291bnR9YFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ1R5cGUgVGhlIGFyZ3VtZW50IHR5cGUuXG4gKiBAcmV0dXJuIHtBcmdWYWxpZGF0b3J9IFRoZSBhcmd1bWVudCB2YWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcmdzT2ZUeXBlKGFyZ1R5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbmNvZGVkLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZW5jb2RlZFswXTtcbiAgICBjb25zdCBhcmdDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59XG4gICAgICovXG4gICAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmdDb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UoZW5jb2RlZFtpICsgMV0sIGNvbnRleHQpO1xuICAgICAgaWYgKCFvdmVybGFwc1R5cGUoYXJnVHlwZSwgZXhwcmVzc2lvbi50eXBlKSkge1xuICAgICAgICBjb25zdCBnb3RUeXBlID0gdHlwZU5hbWUoYXJnVHlwZSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IHR5cGVOYW1lKGV4cHJlc3Npb24udHlwZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5leHBlY3RlZCB0eXBlIGZvciBhcmd1bWVudCAke2l9IG9mICR7b3BlcmF0aW9ufSBvcGVyYXRpb25gICtcbiAgICAgICAgICAgIGAsIGdvdCAke2dvdFR5cGV9IGJ1dCBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBleHByZXNzaW9uLnR5cGUgJj0gYXJnVHlwZTtcbiAgICAgIGFyZ3NbaV0gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJnVmFsaWRhdG9yfVxuICovXG5mdW5jdGlvbiBuYXJyb3dBcmdzVHlwZShlbmNvZGVkLCBjb250ZXh0LCBwYXJzZWRBcmdzKSB7XG4gIGNvbnN0IG9wZXJhdGlvbiA9IGVuY29kZWRbMF07XG4gIGNvbnN0IGFyZ0NvdW50ID0gZW5jb2RlZC5sZW5ndGggLSAxO1xuXG4gIC8vIGZpcnN0IHBhc3MgdG8gZGV0ZXJtaW5lIGEgbmFycm93ZWQgZG93biB0eXBlXG4gIGxldCBzYW1lVHlwZSA9IEFueVR5cGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkQXJncy5sZW5ndGg7ICsraSkge1xuICAgIHNhbWVUeXBlICY9IHBhcnNlZEFyZ3NbaV0udHlwZTtcbiAgfVxuXG4gIGlmIChzYW1lVHlwZSA9PT0gTm9uZVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm8gY29tbW9uIHR5cGUgY291bGQgYmUgZm91bmQgZm9yIGFyZ3VtZW50cyBvZiAke29wZXJhdGlvbn0gb3BlcmF0aW9uYFxuICAgICk7XG4gIH1cblxuICAvLyByZS1wYXJzZSBhcmdzXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJnQ291bnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ0NvdW50OyArK2kpIHtcbiAgICBhcmdzW2ldID0gcGFyc2UoZW5jb2RlZFtpICsgMV0sIGNvbnRleHQsIHNhbWVUeXBlKTtcbiAgfVxuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJnVmFsaWRhdG9yfVxuICovXG5mdW5jdGlvbiB3aXRoT2RkQXJncyhlbmNvZGVkLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wZXJhdGlvbiA9IGVuY29kZWRbMF07XG4gIGNvbnN0IGFyZ0NvdW50ID0gZW5jb2RlZC5sZW5ndGggLSAxO1xuICBpZiAoYXJnQ291bnQgJSAyID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEFuIG9kZCBhbW91bnQgb2YgYXJndW1lbnRzIHdhcyBleHBlY3RlZCBmb3Igb3BlcmF0aW9uICR7b3BlcmF0aW9ufSwgZ290ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGFyZ0NvdW50XG4gICAgICApfSBpbnN0ZWFkYFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJnVmFsaWRhdG9yfVxuICovXG5mdW5jdGlvbiB3aXRoRXZlbkFyZ3MoZW5jb2RlZCwgY29udGV4dCkge1xuICBjb25zdCBvcGVyYXRpb24gPSBlbmNvZGVkWzBdO1xuICBjb25zdCBhcmdDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcbiAgaWYgKGFyZ0NvdW50ICUgMiA9PT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBbiBldmVuIGFtb3VudCBvZiBhcmd1bWVudHMgd2FzIGV4cGVjdGVkIGZvciBvcGVyYXRpb24gJHtvcGVyYXRpb259LCBnb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgYXJnQ291bnRcbiAgICAgICl9IGluc3RlYWRgXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiBwYXJzZU1hdGNoQXJncyhlbmNvZGVkLCBjb250ZXh0LCBwYXJzZWRBcmdzLCB0eXBlSGludCkge1xuICBjb25zdCBhcmdzQ291bnQgPSBlbmNvZGVkLmxlbmd0aCAtIDE7XG5cbiAgY29uc3QgaW5wdXQgPSBwYXJzZShlbmNvZGVkWzFdLCBjb250ZXh0KTtcbiAgbGV0IGlucHV0VHlwZSA9IGlucHV0LnR5cGU7XG4gIGNvbnN0IGZhbGxiYWNrID0gcGFyc2UoZW5jb2RlZFtlbmNvZGVkLmxlbmd0aCAtIDFdLCBjb250ZXh0KTtcbiAgbGV0IG91dHB1dFR5cGUgPVxuICAgIHR5cGVIaW50ICE9PSB1bmRlZmluZWQgPyB0eXBlSGludCAmIGZhbGxiYWNrLnR5cGUgOiBmYWxsYmFjay50eXBlO1xuXG4gIC8vIGZpcnN0IHBhcnNlIGFyZ3MgdG8gZmlndXJlIG91dCBwb3NzaWJsZSB0eXBlc1xuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3NDb3VudCAtIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3NDb3VudCAtIDI7IGkgKz0gMikge1xuICAgIGNvbnN0IG1hdGNoID0gcGFyc2UoZW5jb2RlZFtpICsgMl0sIGNvbnRleHQpO1xuICAgIGNvbnN0IG91dHB1dCA9IHBhcnNlKGVuY29kZWRbaSArIDNdLCBjb250ZXh0KTtcbiAgICBpbnB1dFR5cGUgJj0gbWF0Y2gudHlwZTtcbiAgICBvdXRwdXRUeXBlICY9IG91dHB1dC50eXBlO1xuICAgIGFyZ3NbaV0gPSBtYXRjaDtcbiAgICBhcmdzW2kgKyAxXSA9IG91dHB1dDtcbiAgfVxuXG4gIC8vIGNoZWNrIGlucHV0IGFuZCBvdXRwdXQgdHlwZXMgdmFsaWRpdHlcbiAgY29uc3QgZXhwZWN0ZWRJbnB1dFR5cGUgPSBTdHJpbmdUeXBlIHwgTnVtYmVyVHlwZSB8IEJvb2xlYW5UeXBlO1xuICBpZiAoIW92ZXJsYXBzVHlwZShleHBlY3RlZElucHV0VHlwZSwgaW5wdXRUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhbiBpbnB1dCBvZiB0eXBlICR7dHlwZU5hbWUoXG4gICAgICAgIGV4cGVjdGVkSW5wdXRUeXBlXG4gICAgICApfSBmb3IgdGhlIGludGVycG9sYXRlIG9wZXJhdGlvbmAgKyBgLCBnb3QgJHt0eXBlTmFtZShpbnB1dFR5cGUpfSBpbnN0ZWFkYFxuICAgICk7XG4gIH1cbiAgaWYgKGlzVHlwZShvdXRwdXRUeXBlLCBOb25lVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ291bGQgbm90IGZpbmQgYSBjb21tb24gb3V0cHV0IHR5cGUgZm9yIHRoZSBmb2xsb3dpbmcgbWF0Y2ggb3BlcmF0aW9uOiBgICtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZW5jb2RlZClcbiAgICApO1xuICB9XG5cbiAgLy8gcGFyc2UgYWdhaW4gaW5wdXRzIGFuZCBvdXRwdXRzIHdpdGggY29tbW9uIHR5cGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzQ291bnQgLSAyOyBpICs9IDIpIHtcbiAgICBjb25zdCBtYXRjaCA9IHBhcnNlKGVuY29kZWRbaSArIDJdLCBjb250ZXh0LCBpbnB1dFR5cGUpO1xuICAgIGNvbnN0IG91dHB1dCA9IHBhcnNlKGVuY29kZWRbaSArIDNdLCBjb250ZXh0LCBvdXRwdXRUeXBlKTtcbiAgICBhcmdzW2ldID0gbWF0Y2g7XG4gICAgYXJnc1tpICsgMV0gPSBvdXRwdXQ7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHBhcnNlKGVuY29kZWRbMV0sIGNvbnRleHQsIGlucHV0VHlwZSksXG4gICAgLi4uYXJncyxcbiAgICBwYXJzZShlbmNvZGVkW2VuY29kZWQubGVuZ3RoIC0gMV0sIGNvbnRleHQsIG91dHB1dFR5cGUpLFxuICBdO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiBwYXJzZUludGVycG9sYXRlQXJncyhlbmNvZGVkLCBjb250ZXh0LCBwYXJzZWRBcmdzLCB0eXBlSGludCkge1xuICBjb25zdCBpbnRlcnBvbGF0aW9uVHlwZSA9IGVuY29kZWRbMV07XG4gIGxldCBpbnRlcnBvbGF0aW9uO1xuICBzd2l0Y2ggKGludGVycG9sYXRpb25UeXBlWzBdKSB7XG4gICAgY2FzZSAnbGluZWFyJzpcbiAgICAgIGludGVycG9sYXRpb24gPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZXhwb25lbnRpYWwnOlxuICAgICAgaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb25UeXBlWzFdO1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcnBvbGF0aW9uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyIGJhc2UgZm9yIGV4cG9uZW50aWFsIGludGVycG9sYXRpb25gICtcbiAgICAgICAgICAgIGAsIGdvdCAke0pTT04uc3RyaW5naWZ5KGludGVycG9sYXRpb24pfSBpbnN0ZWFkYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGludGVycG9sYXRpb24gPSBudWxsO1xuICB9XG4gIGlmICghaW50ZXJwb2xhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGludGVycG9sYXRpb24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShpbnRlcnBvbGF0aW9uVHlwZSl9YFxuICAgICk7XG4gIH1cbiAgaW50ZXJwb2xhdGlvbiA9IHBhcnNlKGludGVycG9sYXRpb24sIGNvbnRleHQpO1xuXG4gIC8vIGNoZWNrIGlucHV0IHR5cGVzXG4gIGxldCBpbnB1dCA9IHBhcnNlKGVuY29kZWRbMl0sIGNvbnRleHQpO1xuICBpZiAoIW92ZXJsYXBzVHlwZShOdW1iZXJUeXBlLCBpbnB1dC50eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhbiBpbnB1dCBvZiB0eXBlIG51bWJlciBmb3IgdGhlIGludGVycG9sYXRlIG9wZXJhdGlvbmAgK1xuICAgICAgICBgLCBnb3QgJHt0eXBlTmFtZShpbnB1dC50eXBlKX0gaW5zdGVhZGBcbiAgICApO1xuICB9XG4gIGlucHV0ID0gcGFyc2UoZW5jb2RlZFsyXSwgY29udGV4dCwgTnVtYmVyVHlwZSk7IC8vIHBhcnNlIGFnYWluIHdpdGggbmFycm93ZXIgb3V0cHV0XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShlbmNvZGVkLmxlbmd0aCAtIDMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBsZXQgc3RvcCA9IHBhcnNlKGVuY29kZWRbaSArIDNdLCBjb250ZXh0KTtcbiAgICBpZiAoIW92ZXJsYXBzVHlwZShOdW1iZXJUeXBlLCBzdG9wLnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBhbGwgc3RvcCBpbnB1dCB2YWx1ZXMgaW4gdGhlIGludGVycG9sYXRlIG9wZXJhdGlvbiB0byBiZSBvZiB0eXBlIG51bWJlcmAgK1xuICAgICAgICAgIGAsIGdvdCAke3R5cGVOYW1lKHN0b3AudHlwZSl9IGF0IHBvc2l0aW9uICR7aSArIDJ9IGluc3RlYWRgXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgb3V0cHV0ID0gcGFyc2UoZW5jb2RlZFtpICsgNF0sIGNvbnRleHQpO1xuICAgIGlmICghb3ZlcmxhcHNUeXBlKE51bWJlclR5cGUgfCBDb2xvclR5cGUsIG91dHB1dC50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgYWxsIHN0b3Agb3V0cHV0IHZhbHVlcyBpbiB0aGUgaW50ZXJwb2xhdGUgb3BlcmF0aW9uIHRvIGJlIGEgbnVtYmVyIG9yIGNvbG9yYCArXG4gICAgICAgICAgYCwgZ290ICR7dHlwZU5hbWUob3V0cHV0LnR5cGUpfSBhdCBwb3NpdGlvbiAke2kgKyAzfSBpbnN0ZWFkYFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gcGFyc2UgYWdhaW4gd2l0aCBuYXJyb3dlciB0eXBlc1xuICAgIHN0b3AgPSBwYXJzZShlbmNvZGVkW2kgKyAzXSwgY29udGV4dCwgTnVtYmVyVHlwZSk7XG4gICAgb3V0cHV0ID0gcGFyc2UoZW5jb2RlZFtpICsgNF0sIGNvbnRleHQsIE51bWJlclR5cGUgfCBDb2xvclR5cGUpO1xuICAgIGFyZ3NbaV0gPSBzdG9wO1xuICAgIGFyZ3NbaSArIDFdID0gb3V0cHV0O1xuICB9XG5cbiAgcmV0dXJuIFtpbnRlcnBvbGF0aW9uLCBpbnB1dCwgLi4uYXJnc107XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FzZUFyZ3MoZW5jb2RlZCwgY29udGV4dCwgcGFyc2VkQXJncywgdHlwZUhpbnQpIHtcbiAgY29uc3QgZmFsbGJhY2sgPSBwYXJzZShlbmNvZGVkW2VuY29kZWQubGVuZ3RoIC0gMV0sIGNvbnRleHQpO1xuICBsZXQgb3V0cHV0VHlwZSA9XG4gICAgdHlwZUhpbnQgIT09IHVuZGVmaW5lZCA/IHR5cGVIaW50ICYgZmFsbGJhY2sudHlwZSA6IGZhbGxiYWNrLnR5cGU7XG5cbiAgLy8gZmlyc3QgcGFyc2UgYXJncyB0byBmaWd1cmUgb3V0IHBvc3NpYmxlIHR5cGVzXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoZW5jb2RlZC5sZW5ndGggLSAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIGNvbnN0IGNvbmRpdGlvbiA9IHBhcnNlKGVuY29kZWRbaSArIDFdLCBjb250ZXh0KTtcbiAgICBjb25zdCBvdXRwdXQgPSBwYXJzZShlbmNvZGVkW2kgKyAyXSwgY29udGV4dCk7XG4gICAgaWYgKCFvdmVybGFwc1R5cGUoQm9vbGVhblR5cGUsIGNvbmRpdGlvbi50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgYWxsIGNvbmRpdGlvbnMgaW4gdGhlIGNhc2Ugb3BlcmF0aW9uIHRvIGJlIG9mIHR5cGUgYm9vbGVhbmAgK1xuICAgICAgICAgIGAsIGdvdCAke3R5cGVOYW1lKGNvbmRpdGlvbi50eXBlKX0gYXQgcG9zaXRpb24gJHtpfSBpbnN0ZWFkYFxuICAgICAgKTtcbiAgICB9XG4gICAgb3V0cHV0VHlwZSAmPSBvdXRwdXQudHlwZTtcbiAgICBhcmdzW2ldID0gY29uZGl0aW9uO1xuICAgIGFyZ3NbaSArIDFdID0gb3V0cHV0O1xuICB9XG5cbiAgaWYgKGlzVHlwZShvdXRwdXRUeXBlLCBOb25lVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ291bGQgbm90IGZpbmQgYSBjb21tb24gb3V0cHV0IHR5cGUgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZSBvcGVyYXRpb246IGAgK1xuICAgICAgICBKU09OLnN0cmluZ2lmeShlbmNvZGVkKVxuICAgICk7XG4gIH1cblxuICAvLyBwYXJzZSBhZ2FpbiBhcmdzIHdpdGggY29tbW9uIG91dHB1dCB0eXBlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICBhcmdzW2kgKyAxXSA9IHBhcnNlKGVuY29kZWRbaSArIDJdLCBjb250ZXh0LCBvdXRwdXRUeXBlKTtcbiAgfVxuICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBwYXJzZShcbiAgICBlbmNvZGVkW2VuY29kZWQubGVuZ3RoIC0gMV0sXG4gICAgY29udGV4dCxcbiAgICBvdXRwdXRUeXBlXG4gICk7XG5cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW5BcmdzKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXJ8c3RyaW5nPn0gKi9cbiAgbGV0IGhheXN0YWNrID0gLyoqIEB0eXBlIHthbnl9ICovIChlbmNvZGVkWzJdKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGhheXN0YWNrKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgXCJpblwiIG9wZXJhdG9yIHdhcyBwcm92aWRlZCBhIGxpdGVyYWwgdmFsdWUgd2hpY2ggd2FzIG5vdCBhbiBhcnJheSBhcyBzZWNvbmQgYXJndW1lbnQuYFxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYXlzdGFja1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoaGF5c3RhY2tbMF0gIT09ICdsaXRlcmFsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRm9yIHRoZSBcImluXCIgb3BlcmF0b3IsIGEgc3RyaW5nIGFycmF5IHNob3VsZCBiZSB3cmFwcGVkIGluIGEgXCJsaXRlcmFsXCIgb3BlcmF0b3IgdG8gZGlzYW1iaWd1YXRlIGZyb20gZXhwcmVzc2lvbnMuYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGhheXN0YWNrWzFdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIFwiaW5cIiBvcGVyYXRvciB3YXMgcHJvdmlkZWQgYSBsaXRlcmFsIHZhbHVlIHdoaWNoIHdhcyBub3QgYW4gYXJyYXkgYXMgc2Vjb25kIGFyZ3VtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGhheXN0YWNrID0gaGF5c3RhY2tbMV07XG4gIH1cblxuICBsZXQgbmVlZGxlVHlwZSA9IFN0cmluZ1R5cGUgfCBOdW1iZXJUeXBlO1xuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGhheXN0YWNrLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IHBhcnNlKGhheXN0YWNrW2ldLCBjb250ZXh0KTtcbiAgICBuZWVkbGVUeXBlICY9IGFyZy50eXBlO1xuICAgIGFyZ3NbaV0gPSBhcmc7XG4gIH1cbiAgaWYgKGlzVHlwZShuZWVkbGVUeXBlLCBOb25lVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ291bGQgbm90IGZpbmQgYSBjb21tb24gdHlwZSBmb3IgdGhlIGZvbGxvd2luZyBpbiBvcGVyYXRpb246IGAgK1xuICAgICAgICBKU09OLnN0cmluZ2lmeShlbmNvZGVkKVxuICAgICk7XG4gIH1cblxuICBjb25zdCBuZWVkbGUgPSBwYXJzZShlbmNvZGVkWzFdLCBjb250ZXh0LCBuZWVkbGVUeXBlKTtcbiAgcmV0dXJuIFtuZWVkbGUsIC4uLmFyZ3NdO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiBwYXJzZVBhbGV0dGVBcmdzKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgY29uc3QgaW5kZXggPSBwYXJzZShlbmNvZGVkWzFdLCBjb250ZXh0LCBOdW1iZXJUeXBlKTtcbiAgaWYgKGluZGV4LnR5cGUgIT09IE51bWJlclR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIGZpcnN0IGFyZ3VtZW50IG9mIHBhbGV0dGUgbXVzdCBiZSBhbiBudW1iZXIsIGdvdCAke3R5cGVOYW1lKFxuICAgICAgICBpbmRleC50eXBlXG4gICAgICApfSBpbnN0ZWFkYFxuICAgICk7XG4gIH1cbiAgY29uc3QgY29sb3JzID0gZW5jb2RlZFsyXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9ycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgYXJndW1lbnQgb2YgcGFsZXR0ZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cbiAgY29uc3QgcGFyc2VkQ29sb3JzID0gbmV3IEFycmF5KGNvbG9ycy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZENvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvbG9yID0gcGFyc2UoY29sb3JzW2ldLCBjb250ZXh0LCBDb2xvclR5cGUpO1xuICAgIGlmICghKGNvbG9yIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgcGFsZXR0ZSBjb2xvciBhdCBpbmRleCAke2l9IG11c3QgYmUgYSBsaXRlcmFsIHZhbHVlYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFvdmVybGFwc1R5cGUoY29sb3IudHlwZSwgQ29sb3JUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIHBhbGV0dGUgY29sb3IgYXQgaW5kZXggJHtpfSBzaG91bGQgYmUgb2YgdHlwZSBjb2xvciwgZ290ICR7dHlwZU5hbWUoXG4gICAgICAgICAgY29sb3IudHlwZVxuICAgICAgICApfSBpbnN0ZWFkYFxuICAgICAgKTtcbiAgICB9XG4gICAgcGFyc2VkQ29sb3JzW2ldID0gY29sb3I7XG4gIH1cbiAgcmV0dXJuIFtpbmRleCwgLi4ucGFyc2VkQ29sb3JzXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcnxmdW5jdGlvbihBcnJheTxFeHByZXNzaW9uPik6bnVtYmVyfSByZXR1cm5UeXBlIFRoZSByZXR1cm4gdHlwZSBvZiB0aGUgb3BlcmF0b3I7IGNhbiBiZSBhIGZpeGVkIHZhbHVlIG9yIGEgY2FsbGJhY2sgdGFraW5nIHRoZSBwYXJzZWRcbiAqIGFyZ3VtZW50c1xuICogQHBhcmFtIHtBcnJheTxBcmdWYWxpZGF0b3I+fSBhcmdWYWxpZGF0b3JzIEEgY2hhaW4gb2YgYXJndW1lbnQgdmFsaWRhdG9yczsgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbGFzdCB2YWxpZGF0b3JcbiAqIHdpbGwgYmUgdXNlZCBhcyBwYXJzZWQgYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtQYXJzZXJ9IFRoZSBwYXJzZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihyZXR1cm5UeXBlLCAuLi5hcmdWYWxpZGF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZW5jb2RlZCwgY29udGV4dCwgdHlwZUhpbnQpIHtcbiAgICBjb25zdCBvcGVyYXRvciA9IGVuY29kZWRbMF07XG4gICAgbGV0IHBhcnNlZEFyZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ1ZhbGlkYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZEFyZ3MgPVxuICAgICAgICBhcmdWYWxpZGF0b3JzW2ldKGVuY29kZWQsIGNvbnRleHQsIHBhcnNlZEFyZ3MsIHR5cGVIaW50KSB8fCBwYXJzZWRBcmdzO1xuICAgIH1cbiAgICBsZXQgYWN0dWFsVHlwZSA9XG4gICAgICB0eXBlb2YgcmV0dXJuVHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHJldHVyblR5cGUocGFyc2VkQXJncykgOiByZXR1cm5UeXBlO1xuICAgIGlmICh0eXBlSGludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIW92ZXJsYXBzVHlwZShhY3R1YWxUeXBlLCB0eXBlSGludCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUaGUgZm9sbG93aW5nIGV4cHJlc3Npb24gd2FzIGV4cGVjdGVkIHRvIHJldHVybiAke3R5cGVOYW1lKFxuICAgICAgICAgICAgdHlwZUhpbnRcbiAgICAgICAgICApfSwgYnV0IHJldHVybnMgJHt0eXBlTmFtZShhY3R1YWxUeXBlKX0gaW5zdGVhZDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGVuY29kZWRcbiAgICAgICAgICApfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGFjdHVhbFR5cGUgJj0gdHlwZUhpbnQ7XG4gICAgfVxuICAgIGlmIChhY3R1YWxUeXBlID09PSBOb25lVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm8gbWF0Y2hpbmcgdHlwZSB3YXMgZm91bmQgZm9yIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbjogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBlbmNvZGVkXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDYWxsRXhwcmVzc2lvbihhY3R1YWxUeXBlLCBvcGVyYXRvciwgLi4ucGFyc2VkQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gZW5jb2RlZCBUaGUgZW5jb2RlZCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt0eXBlSGludF0gT3B0aW9uYWwgdHlwZSBoaW50XG4gKiBAcmV0dXJuIHtFeHByZXNzaW9ufSBUaGUgcGFyc2VkIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FsbEV4cHJlc3Npb24oZW5jb2RlZCwgY29udGV4dCwgdHlwZUhpbnQpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBlbmNvZGVkWzBdO1xuXG4gIGNvbnN0IHBhcnNlciA9IHBhcnNlcnNbb3BlcmF0b3JdO1xuICBpZiAoIXBhcnNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtvcGVyYXRvcn1gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VyKGVuY29kZWQsIGNvbnRleHQsIHR5cGVIaW50KTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZXhwci9jcHVcbiAqL1xuXG5pbXBvcnQge1xuICBDb2xvclR5cGUsXG4gIExpdGVyYWxFeHByZXNzaW9uLFxuICBPcHMsXG4gIG92ZXJsYXBzVHlwZSxcbiAgcGFyc2UsXG4gIHR5cGVOYW1lLFxufSBmcm9tICcuL2V4cHJlc3Npb24uanMnO1xuaW1wb3J0IHtcbiAgZnJvbVN0cmluZyxcbiAgbGNoYVRvUmdiYSxcbiAgbm9ybWFsaXplLFxuICByZ2JhVG9MY2hhLFxuICB3aXRoQWxwaGEsXG59IGZyb20gJy4uL2NvbG9yLmpzJztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIGluY2x1ZGVzIGZ1bmN0aW9ucyB0byBidWlsZCBleHByZXNzaW9ucyBmb3IgZXZhbHVhdGlvbiBvbiB0aGUgQ1BVLlxuICogQnVpbGRpbmcgaXMgY29tcG9zZWQgb2YgdHdvIHN0ZXBzOiBwYXJzaW5nIGFuZCBjb21waWxpbmcuICBUaGUgcGFyc2luZyBzdGVwIHRha2VzIGFuIGVuY29kZWRcbiAqIGV4cHJlc3Npb24gYW5kIHJldHVybnMgYW4gaW5zdGFuY2Ugb2Ygb25lIG9mIHRoZSBleHByZXNzaW9uIGNsYXNzZXMuICBUaGUgY29tcGlsaW5nIHN0ZXAgdGFrZXNcbiAqIHRoZSBleHByZXNzaW9uIGluc3RhbmNlIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgZXZhbHVhdGVkIGluIHRvIHJldHVybiBhIGxpdGVyYWxcbiAqIHZhbHVlLiAgVGhlIGV2YWx1YXRvciBmdW5jdGlvbiBzaG91bGQgZG8gYXMgbGl0dGxlIGFsbG9jYXRpb24gYW5kIHdvcmsgYXMgcG9zc2libGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmFsdWF0aW9uQ29udGV4dFxuICogQHByb3BlcnR5IHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHZhbHVlcyBmb3IgcHJvcGVydGllcyB1c2VkIGluICdnZXQnIGV4cHJlc3Npb25zLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHZhcmlhYmxlcyBUaGUgdmFsdWVzIGZvciB2YXJpYWJsZXMgdXNlZCBpbiAndmFyJyBleHByZXNzaW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSBtYXAgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bWJlcnxudWxsfSBmZWF0dXJlSWQgVGhlIGZlYXR1cmUgaWQuXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtFdmFsdWF0aW9uQ29udGV4dH0gQSBuZXcgZXZhbHVhdGlvbiBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmV3RXZhbHVhdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgdmFyaWFibGVzOiB7fSxcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICByZXNvbHV0aW9uOiBOYU4sXG4gICAgZmVhdHVyZUlkOiBudWxsLFxuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6aW1wb3J0KFwiLi9leHByZXNzaW9uLmpzXCIpLkxpdGVyYWxWYWx1ZX0gRXhwcmVzc2lvbkV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpib29sZWFufSBCb29sZWFuRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOm51bWJlcn0gTnVtYmVyRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOnN0cmluZ30gU3RyaW5nRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOihBcnJheTxudW1iZXI+fHN0cmluZyl9IENvbG9yTGlrZUV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpBcnJheTxudW1iZXI+fSBOdW1iZXJBcnJheUV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpBcnJheTxudW1iZXI+fSBDb29yZGluYXRlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOihBcnJheTxudW1iZXI+fG51bWJlcil9IFNpemVMaWtlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuRW5jb2RlZEV4cHJlc3Npb259IGVuY29kZWQgVGhlIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZW5jb2RlZCwgdHlwZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UoZW5jb2RlZCwgY29udGV4dCk7XG4gIGlmICghb3ZlcmxhcHNUeXBlKHR5cGUsIGV4cHJlc3Npb24udHlwZSkpIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IHR5cGVOYW1lKHR5cGUpO1xuICAgIGNvbnN0IGFjdHVhbCA9IHR5cGVOYW1lKGV4cHJlc3Npb24udHlwZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGV4cHJlc3Npb24gdG8gYmUgb2YgdHlwZSAke2V4cGVjdGVkfSwgZ290ICR7YWN0dWFsfWBcbiAgICApO1xuICB9XG4gIHJldHVybiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXhwcmVzc2lvbi5qc1wiKS5FeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pIHtcbiAgICAvLyBjb252ZXJ0IGNvbG9ycyB0byBhcnJheSBpZiBwb3NzaWJsZVxuICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IENvbG9yVHlwZSAmJiB0eXBlb2YgZXhwcmVzc2lvbi52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBmcm9tU3RyaW5nKGV4cHJlc3Npb24udmFsdWUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yVmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcGVyYXRvciA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlIE9wcy5OdW1iZXI6XG4gICAgY2FzZSBPcHMuU3RyaW5nOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUFzc2VydGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdldDpcbiAgICBjYXNlIE9wcy5WYXI6IHtcbiAgICAgIHJldHVybiBjb21waWxlQWNjZXNzb3JFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5JZDoge1xuICAgICAgcmV0dXJuIChleHByZXNzaW9uKSA9PiBleHByZXNzaW9uLmZlYXR1cmVJZDtcbiAgICB9XG4gICAgY2FzZSBPcHMuQ29uY2F0OiB7XG4gICAgICBjb25zdCBhcmdzID0gZXhwcmVzc2lvbi5hcmdzLm1hcCgoZSkgPT4gY29tcGlsZUV4cHJlc3Npb24oZSwgY29udGV4dCkpO1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PlxuICAgICAgICAnJy5jb25jYXQoLi4uYXJncy5tYXAoKGFyZykgPT4gYXJnKGNvbnRleHQpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuUmVzb2x1dGlvbjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBjb250ZXh0LnJlc29sdXRpb247XG4gICAgfVxuICAgIGNhc2UgT3BzLkFueTpcbiAgICBjYXNlIE9wcy5BbGw6XG4gICAgY2FzZSBPcHMuTm90OiB7XG4gICAgICByZXR1cm4gY29tcGlsZUxvZ2ljYWxFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5FcXVhbDpcbiAgICBjYXNlIE9wcy5Ob3RFcXVhbDpcbiAgICBjYXNlIE9wcy5MZXNzVGhhbjpcbiAgICBjYXNlIE9wcy5MZXNzVGhhbk9yRXF1YWxUbzpcbiAgICBjYXNlIE9wcy5HcmVhdGVyVGhhbjpcbiAgICBjYXNlIE9wcy5HcmVhdGVyVGhhbk9yRXF1YWxUbzoge1xuICAgICAgcmV0dXJuIGNvbXBpbGVDb21wYXJpc29uRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTXVsdGlwbHk6XG4gICAgY2FzZSBPcHMuRGl2aWRlOlxuICAgIGNhc2UgT3BzLkFkZDpcbiAgICBjYXNlIE9wcy5TdWJ0cmFjdDpcbiAgICBjYXNlIE9wcy5DbGFtcDpcbiAgICBjYXNlIE9wcy5Nb2Q6XG4gICAgY2FzZSBPcHMuUG93OlxuICAgIGNhc2UgT3BzLkFiczpcbiAgICBjYXNlIE9wcy5GbG9vcjpcbiAgICBjYXNlIE9wcy5DZWlsOlxuICAgIGNhc2UgT3BzLlJvdW5kOlxuICAgIGNhc2UgT3BzLlNpbjpcbiAgICBjYXNlIE9wcy5Db3M6XG4gICAgY2FzZSBPcHMuQXRhbjpcbiAgICBjYXNlIE9wcy5TcXJ0OiB7XG4gICAgICByZXR1cm4gY29tcGlsZU51bWVyaWNFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5NYXRjaDoge1xuICAgICAgcmV0dXJuIGNvbXBpbGVNYXRjaEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkludGVycG9sYXRlOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUludGVycG9sYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRvciAke29wZXJhdG9yfWApO1xuICAgIH1cbiAgICAvLyBUT0RPOiB1bmltcGxlbWVudGVkXG4gICAgLy8gT3BzLkdlb21ldHJ5VHlwZVxuICAgIC8vIE9wcy5ab29tXG4gICAgLy8gT3BzLlRpbWVcbiAgICAvLyBPcHMuQmV0d2VlblxuICAgIC8vIE9wcy5DYXNlXG4gICAgLy8gT3BzLkluXG4gICAgLy8gT3BzLkFycmF5XG4gICAgLy8gT3BzLkNvbG9yXG4gICAgLy8gT3BzLkJhbmRcbiAgICAvLyBPcHMuUGFsZXR0ZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVBc3NlcnRpb25FeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBPcHMuTnVtYmVyOlxuICAgIGNhc2UgT3BzLlN0cmluZzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbaV0oY29udGV4dCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG9uZSBvZiB0aGUgdmFsdWVzIHRvIGJlIGEgJHt0eXBlfWApO1xuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhc3NlcnRpb24gb3BlcmF0b3IgJHt0eXBlfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQWNjZXNzb3JFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgY29uc3QgbmFtZUV4cHJlc3Npb24gPSAvKiogQHR5cGUge0xpdGVyYWxFeHByZXNzaW9ufSAqLyAoZXhwcmVzc2lvbi5hcmdzWzBdKTtcbiAgY29uc3QgbmFtZSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAobmFtZUV4cHJlc3Npb24udmFsdWUpO1xuICBzd2l0Y2ggKGV4cHJlc3Npb24ub3BlcmF0b3IpIHtcbiAgICBjYXNlIE9wcy5HZXQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gY29udGV4dC5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIH1cbiAgICBjYXNlIE9wcy5WYXI6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gY29udGV4dC52YXJpYWJsZXNbbmFtZV07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWNjZXNzb3Igb3BlcmF0b3IgJHtleHByZXNzaW9uLm9wZXJhdG9yfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtCb29sZWFuRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQ29tcGFyaXNvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBvcCA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlZnQgPSBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3NbMF0sIGNvbnRleHQpO1xuICBjb25zdCByaWdodCA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1sxXSwgY29udGV4dCk7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlIE9wcy5FcXVhbDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpID09PSByaWdodChjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTm90RXF1YWw6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gbGVmdChjb250ZXh0KSAhPT0gcmlnaHQoY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkxlc3NUaGFuOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGxlZnQoY29udGV4dCkgPCByaWdodChjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTGVzc1RoYW5PckVxdWFsVG86IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gbGVmdChjb250ZXh0KSA8PSByaWdodChjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuR3JlYXRlclRoYW46IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gbGVmdChjb250ZXh0KSA+IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5HcmVhdGVyVGhhbk9yRXF1YWxUbzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpID49IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBhcmlzb24gb3BlcmF0b3IgJHtvcH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7Qm9vbGVhbkV2YWx1YXRvcn0gVGhlIGV2YWx1YXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUxvZ2ljYWxFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgY29uc3Qgb3AgPSBleHByZXNzaW9uLm9wZXJhdG9yO1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3NbaV0sIGNvbnRleHQpO1xuICB9XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlIE9wcy5Bbnk6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbaV0oY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5BbGw6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKCFhcmdzW2ldKGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTm90OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+ICFhcmdzWzBdKGNvbnRleHQpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2ljYWwgb3BlcmF0b3IgJHtvcH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7TnVtYmVyRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlTnVtZXJpY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBvcCA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLk11bHRpcGx5OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhbHVlICo9IGFyZ3NbaV0oY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuRGl2aWRlOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGFyZ3NbMF0oY29udGV4dCkgLyBhcmdzWzFdKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5BZGQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFsdWUgKz0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5TdWJ0cmFjdDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBhcmdzWzBdKGNvbnRleHQpIC0gYXJnc1sxXShjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQ2xhbXA6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF0oY29udGV4dCk7XG4gICAgICAgIGNvbnN0IG1pbiA9IGFyZ3NbMV0oY29udGV4dCk7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4ID0gYXJnc1syXShjb250ZXh0KTtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5Nb2Q6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gYXJnc1swXShjb250ZXh0KSAlIGFyZ3NbMV0oY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLlBvdzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLnBvdyhhcmdzWzBdKGNvbnRleHQpLCBhcmdzWzFdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQWJzOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguYWJzKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5GbG9vcjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmZsb29yKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5DZWlsOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguY2VpbChhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuUm91bmQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5yb3VuZChhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuU2luOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguc2luKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Db3M6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5jb3MoYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkF0YW46IHtcbiAgICAgIGlmIChsZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmF0YW4yKGFyZ3NbMF0oY29udGV4dCksIGFyZ3NbMV0oY29udGV4dCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmF0YW4oYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLlNxcnQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5zcXJ0KGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG51bWVyaWMgb3BlcmF0b3IgJHtvcH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbkV2YWx1YXRvcn0gVGhlIGV2YWx1YXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZU1hdGNoRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3NbaV0sIGNvbnRleHQpO1xuICB9XG4gIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYXJnc1swXShjb250ZXh0KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAodmFsdWUgPT09IGFyZ3NbaV0oY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbaSArIDFdKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJnc1tsZW5ndGggLSAxXShjb250ZXh0KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbkV2YWx1YXRvcn0gVGhlIGV2YWx1YXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUludGVycG9sYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3NbaV0sIGNvbnRleHQpO1xuICB9XG4gIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBhcmdzWzBdKGNvbnRleHQpO1xuICAgIGNvbnN0IHZhbHVlID0gYXJnc1sxXShjb250ZXh0KTtcblxuICAgIGxldCBwcmV2aW91c0lucHV0O1xuICAgIGxldCBwcmV2aW91c091dHB1dDtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGFyZ3NbaV0oY29udGV4dCk7XG4gICAgICBsZXQgb3V0cHV0ID0gYXJnc1tpICsgMV0oY29udGV4dCk7XG4gICAgICBjb25zdCBpc0NvbG9yID0gQXJyYXkuaXNBcnJheShvdXRwdXQpO1xuICAgICAgaWYgKGlzQ29sb3IpIHtcbiAgICAgICAgb3V0cHV0ID0gd2l0aEFscGhhKG91dHB1dCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQgPj0gdmFsdWUpIHtcbiAgICAgICAgaWYgKGkgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlQ29sb3IoXG4gICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBwcmV2aW91c0lucHV0LFxuICAgICAgICAgICAgcHJldmlvdXNPdXRwdXQsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIG91dHB1dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlTnVtYmVyKFxuICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgcHJldmlvdXNJbnB1dCxcbiAgICAgICAgICBwcmV2aW91c091dHB1dCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBvdXRwdXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzSW5wdXQgPSBpbnB1dDtcbiAgICAgIHByZXZpb3VzT3V0cHV0ID0gb3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNPdXRwdXQ7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2UgVGhlIGJhc2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0MSBUaGUgZmlyc3QgaW5wdXQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0cHV0MSBUaGUgZmlyc3Qgb3V0cHV0IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0MiBUaGUgc2Vjb25kIGlucHV0IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IG91dHB1dDIgVGhlIHNlY29uZCBvdXRwdXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKGJhc2UsIHZhbHVlLCBpbnB1dDEsIG91dHB1dDEsIGlucHV0Miwgb3V0cHV0Mikge1xuICBjb25zdCBkZWx0YSA9IGlucHV0MiAtIGlucHV0MTtcbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgcmV0dXJuIG91dHB1dDE7XG4gIH1cbiAgY29uc3QgYWxvbmcgPSB2YWx1ZSAtIGlucHV0MTtcbiAgY29uc3QgZmFjdG9yID1cbiAgICBiYXNlID09PSAxXG4gICAgICA/IGFsb25nIC8gZGVsdGFcbiAgICAgIDogKE1hdGgucG93KGJhc2UsIGFsb25nKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRlbHRhKSAtIDEpO1xuICByZXR1cm4gb3V0cHV0MSArIGZhY3RvciAqIChvdXRwdXQyIC0gb3V0cHV0MSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2UgVGhlIGJhc2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0MSBUaGUgZmlyc3QgaW5wdXQgdmFsdWUuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29sb3IuanMnKS5Db2xvcn0gcmdiYTEgVGhlIGZpcnN0IG91dHB1dCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dDIgVGhlIHNlY29uZCBpbnB1dCB2YWx1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb2xvci5qcycpLkNvbG9yfSByZ2JhMiBUaGUgc2Vjb25kIG91dHB1dCB2YWx1ZS5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vY29sb3IuanMnKS5Db2xvcn0gVGhlIGludGVycG9sYXRlZCBjb2xvci5cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCByZ2JhMSwgaW5wdXQyLCByZ2JhMikge1xuICBjb25zdCBkZWx0YSA9IGlucHV0MiAtIGlucHV0MTtcbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgcmV0dXJuIHJnYmExO1xuICB9XG4gIGNvbnN0IGxjaGExID0gcmdiYVRvTGNoYShyZ2JhMSk7XG4gIGNvbnN0IGxjaGEyID0gcmdiYVRvTGNoYShyZ2JhMik7XG4gIGxldCBkZWx0YUh1ZSA9IGxjaGEyWzJdIC0gbGNoYTFbMl07XG4gIGlmIChkZWx0YUh1ZSA+IDE4MCkge1xuICAgIGRlbHRhSHVlIC09IDM2MDtcbiAgfSBlbHNlIGlmIChkZWx0YUh1ZSA8IC0xODApIHtcbiAgICBkZWx0YUh1ZSArPSAzNjA7XG4gIH1cblxuICBjb25zdCBsY2hhID0gW1xuICAgIGludGVycG9sYXRlTnVtYmVyKGJhc2UsIHZhbHVlLCBpbnB1dDEsIGxjaGExWzBdLCBpbnB1dDIsIGxjaGEyWzBdKSxcbiAgICBpbnRlcnBvbGF0ZU51bWJlcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCBsY2hhMVsxXSwgaW5wdXQyLCBsY2hhMlsxXSksXG4gICAgbGNoYTFbMl0gKyBpbnRlcnBvbGF0ZU51bWJlcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCAwLCBpbnB1dDIsIGRlbHRhSHVlKSxcbiAgICBpbnRlcnBvbGF0ZU51bWJlcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCByZ2JhMVszXSwgaW5wdXQyLCByZ2JhMlszXSksXG4gIF07XG4gIHJldHVybiBub3JtYWxpemUobGNoYVRvUmdiYShsY2hhKSk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvc3R5bGVcbiAqL1xuXG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uLy4uL3N0eWxlL0NpcmNsZS5qcyc7XG5pbXBvcnQgRmlsbCBmcm9tICcuLi8uLi9zdHlsZS9GaWxsLmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL3N0eWxlL0ljb24uanMnO1xuaW1wb3J0IFJlZ3VsYXJTaGFwZSBmcm9tICcuLi8uLi9zdHlsZS9SZWd1bGFyU2hhcGUuanMnO1xuaW1wb3J0IFN0cm9rZSBmcm9tICcuLi8uLi9zdHlsZS9TdHJva2UuanMnO1xuaW1wb3J0IFN0eWxlIGZyb20gJy4uLy4uL3N0eWxlL1N0eWxlLmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4uLy4uL3N0eWxlL1RleHQuanMnO1xuaW1wb3J0IHtcbiAgQm9vbGVhblR5cGUsXG4gIENvbG9yVHlwZSxcbiAgTnVtYmVyQXJyYXlUeXBlLFxuICBOdW1iZXJUeXBlLFxuICBTdHJpbmdUeXBlLFxuICBuZXdQYXJzaW5nQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vZXhwci9leHByZXNzaW9uLmpzJztcbmltcG9ydCB7YnVpbGRFeHByZXNzaW9uLCBuZXdFdmFsdWF0aW9uQ29udGV4dH0gZnJvbSAnLi4vLi4vZXhwci9jcHUuanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi8uLi9vYmouanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uLy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaW5jbHVkZXMgZnVuY3Rpb25zIHRvIGJ1aWxkIHN0eWxlcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlci4gIEJ1aWxkaW5nXG4gKiBpcyBjb21wb3NlZCBvZiB0d28gc3RlcHM6IHBhcnNpbmcgYW5kIGNvbXBpbGluZy4gIFRoZSBwYXJzaW5nIHN0ZXAgdGFrZXMgYW4gZW5jb2RlZCBleHByZXNzaW9uXG4gKiBhbmQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBvbmUgb2YgdGhlIGV4cHJlc3Npb24gY2xhc3Nlcy4gIFRoZSBjb21waWxpbmcgc3RlcCB0YWtlcyB0aGVcbiAqIGV4cHJlc3Npb24gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgdG8gcmV0dXJuIGEgbGl0ZXJhbCB2YWx1ZS4gIFRoZVxuICogZXZhbHVhdG9yIGZ1bmN0aW9uIHNob3VsZCBkbyBhcyBsaXR0bGUgYWxsb2NhdGlvbiBhbmQgd29yayBhcyBwb3NzaWJsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZX0gRmxhdFN0eWxlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9leHByZXNzaW9uLmpzXCIpLkVuY29kZWRFeHByZXNzaW9ufSBFbmNvZGVkRXhwcmVzc2lvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2V4cHIvZXhwcmVzc2lvbi5qc1wiKS5QYXJzaW5nQ29udGV4dH0gUGFyc2luZ0NvbnRleHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9leHByL2V4cHJlc3Npb24uanNcIikuQ2FsbEV4cHJlc3Npb259IENhbGxFeHByZXNzaW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9jcHUuanNcIikuRXZhbHVhdGlvbkNvbnRleHR9IEV2YWx1YXRpb25Db250ZXh0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9jcHUuanNcIikuRXhwcmVzc2lvbkV2YWx1YXRvcn0gRXhwcmVzc2lvbkV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtFdmFsdWF0aW9uQ29udGV4dH0gY29udGV4dCBUaGUgZXZhbHVhdGlvbiBjb250ZXh0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQWx3YXlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGFsd2F5cyhjb250ZXh0KSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRhcHRzIGEgcnVsZSBldmFsdWF0b3IgdG8gdGhlIGV4aXN0aW5nIHN0eWxlIGZ1bmN0aW9uIGludGVyZmFjZS5cbiAqIEFmdGVyIHdlIGhhdmUgZGVwcmVjYXRlZCB0aGUgc3R5bGUgZnVuY3Rpb24sIHdlIGNhbiB1c2UgdGhlIGNvbXBpbGVkIHJ1bGVzIGRpcmVjdGx5XG4gKiBhbmQgcGFzcyBhIG1vcmUgY29tcGxldGUgZXZhbHVhdGlvbiBjb250ZXh0ICh2YXJpYWJsZXMsIHpvb20sIHRpbWUsIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi8uLi9zdHlsZS9mbGF0LmpzJykuUnVsZT59IHJ1bGVzIFRoZSBydWxlcy5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vc3R5bGUvU3R5bGUuanMnKS5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNUb1N0eWxlRnVuY3Rpb24ocnVsZXMpIHtcbiAgY29uc3QgcGFyc2luZ0NvbnRleHQgPSBuZXdQYXJzaW5nQ29udGV4dCgpO1xuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZFJ1bGVTZXQocnVsZXMsIHBhcnNpbmdDb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGlvbkNvbnRleHQgPSBuZXdFdmFsdWF0aW9uQ29udGV4dCgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICBldmFsdWF0aW9uQ29udGV4dC5wcm9wZXJ0aWVzID0gZmVhdHVyZS5nZXRQcm9wZXJ0aWVzSW50ZXJuYWwoKTtcbiAgICBldmFsdWF0aW9uQ29udGV4dC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBpZiAocGFyc2luZ0NvbnRleHQuZmVhdHVyZUlkKSB7XG4gICAgICBjb25zdCBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV2YWx1YXRpb25Db250ZXh0LmZlYXR1cmVJZCA9IGlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZhbHVhdGlvbkNvbnRleHQuZmVhdHVyZUlkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2YWx1YXRvcihldmFsdWF0aW9uQ29udGV4dCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGFwdHMgYSBzdHlsZSBldmFsdWF0b3IgdG8gdGhlIGV4aXN0aW5nIHN0eWxlIGZ1bmN0aW9uIGludGVyZmFjZS5cbiAqIEFmdGVyIHdlIGhhdmUgZGVwcmVjYXRlZCB0aGUgc3R5bGUgZnVuY3Rpb24sIHdlIGNhbiB1c2UgdGhlIGNvbXBpbGVkIHJ1bGVzIGRpcmVjdGx5XG4gKiBhbmQgcGFzcyBhIG1vcmUgY29tcGxldGUgZXZhbHVhdGlvbiBjb250ZXh0ICh2YXJpYWJsZXMsIHpvb20sIHRpbWUsIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi8uLi9zdHlsZS9mbGF0LmpzJykuRmxhdFN0eWxlPn0gZmxhdFN0eWxlcyBUaGUgZmxhdCBzdHlsZXMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3N0eWxlL1N0eWxlLmpzJykuU3R5bGVGdW5jdGlvbn0gQSBzdHlsZSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXRTdHlsZXNUb1N0eWxlRnVuY3Rpb24oZmxhdFN0eWxlcykge1xuICBjb25zdCBwYXJzaW5nQ29udGV4dCA9IG5ld1BhcnNpbmdDb250ZXh0KCk7XG4gIGNvbnN0IGxlbmd0aCA9IGZsYXRTdHlsZXMubGVuZ3RoO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8U3R5bGVFdmFsdWF0b3I+fVxuICAgKi9cbiAgY29uc3QgZXZhbHVhdG9ycyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgZXZhbHVhdG9yc1tpXSA9IGJ1aWxkU3R5bGUoZmxhdFN0eWxlc1tpXSwgcGFyc2luZ0NvbnRleHQpO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25Db250ZXh0ID0gbmV3RXZhbHVhdGlvbkNvbnRleHQoKTtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAgICovXG4gIGNvbnN0IHN0eWxlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIGV2YWx1YXRpb25Db250ZXh0LnByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXNJbnRlcm5hbCgpO1xuICAgIGV2YWx1YXRpb25Db250ZXh0LnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIGlmIChwYXJzaW5nQ29udGV4dC5mZWF0dXJlSWQpIHtcbiAgICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXZhbHVhdGlvbkNvbnRleHQuZmVhdHVyZUlkID0gaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmFsdWF0aW9uQ29udGV4dC5mZWF0dXJlSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbm9uTnVsbENvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IGV2YWx1YXRvcnNbaV0oZXZhbHVhdGlvbkNvbnRleHQpO1xuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHN0eWxlc1tub25OdWxsQ291bnRdID0gc3R5bGU7XG4gICAgICAgIG5vbk51bGxDb3VudCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHlsZXMubGVuZ3RoID0gbm9uTnVsbENvdW50O1xuICAgIHJldHVybiBzdHlsZXM7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpBcnJheTxTdHlsZT59IFJ1bGVTZXRFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbXBpbGVkUnVsZVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9uRXZhbHVhdG9yfSBmaWx0ZXIgVGhlIGNvbXBpbGVkIGZpbHRlciBldmFsdWF0b3IuXG4gKiBAcHJvcGVydHkge0FycmF5PFN0eWxlRXZhbHVhdG9yPn0gc3R5bGVzIFRoZSBsaXN0IG9mIGNvbXBpbGVkIHN0eWxlIGV2YWx1YXRvcnMuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vLi4vc3R5bGUvZmxhdC5qcycpLlJ1bGU+fSBydWxlcyBUaGUgcnVsZXMuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtSdWxlU2V0RXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRSdWxlU2V0KHJ1bGVzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PENvbXBpbGVkUnVsZT59XG4gICAqL1xuICBjb25zdCBjb21waWxlZFJ1bGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tpXTtcbiAgICBjb25zdCBmaWx0ZXIgPVxuICAgICAgJ2ZpbHRlcicgaW4gcnVsZVxuICAgICAgICA/IGJ1aWxkRXhwcmVzc2lvbihydWxlLmZpbHRlciwgQm9vbGVhblR5cGUsIGNvbnRleHQpXG4gICAgICAgIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0eWxlRXZhbHVhdG9yPn1cbiAgICAgKi9cbiAgICBsZXQgc3R5bGVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUuc3R5bGUpKSB7XG4gICAgICBjb25zdCBzdHlsZUxlbmd0aCA9IHJ1bGUuc3R5bGUubGVuZ3RoO1xuICAgICAgc3R5bGVzID0gbmV3IEFycmF5KHN0eWxlTGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3R5bGVMZW5ndGg7ICsraikge1xuICAgICAgICBzdHlsZXNbal0gPSBidWlsZFN0eWxlKHJ1bGUuc3R5bGVbal0sIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbYnVpbGRTdHlsZShydWxlLnN0eWxlLCBjb250ZXh0KV07XG4gICAgfVxuXG4gICAgY29tcGlsZWRSdWxlc1tpXSA9IHtmaWx0ZXIsIHN0eWxlc307XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgICAqL1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuXG4gICAgbGV0IHNvbWVNYXRjaGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZmlsdGVyRXZhbHVhdG9yID0gY29tcGlsZWRSdWxlc1tpXS5maWx0ZXI7XG4gICAgICBpZiAoIWZpbHRlckV2YWx1YXRvcihjb250ZXh0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChydWxlc1tpXS5lbHNlICYmIHNvbWVNYXRjaGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc29tZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBzdHlsZUV2YWx1YXRvciBvZiBjb21waWxlZFJ1bGVzW2ldLnN0eWxlcykge1xuICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlRXZhbHVhdG9yKGNvbnRleHQpO1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpTdHlsZXxudWxsfSBTdHlsZUV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBBIGZsYXQgc3R5bGUgbGl0ZXJhbC5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge1N0eWxlRXZhbHVhdG9yfSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgc3R5bGUuICBUaGUgc3R5bGUgcmV0dXJuZWQgYnlcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZXVzZWQgYmV0d2VlbiBpbnZvY2F0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU3R5bGUoZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGV2YWx1YXRlRmlsbCA9IGJ1aWxkRmlsbChmbGF0U3R5bGUsICcnLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVTdHJva2UgPSBidWlsZFN0cm9rZShmbGF0U3R5bGUsICcnLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVUZXh0ID0gYnVpbGRUZXh0KGZsYXRTdHlsZSwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlSW1hZ2UgPSBidWlsZEltYWdlKGZsYXRTdHlsZSwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlWkluZGV4ID0gbnVtYmVyRXZhbHVhdG9yKGZsYXRTdHlsZSwgJ3otaW5kZXgnLCBjb250ZXh0KTtcblxuICBpZiAoXG4gICAgIWV2YWx1YXRlRmlsbCAmJlxuICAgICFldmFsdWF0ZVN0cm9rZSAmJlxuICAgICFldmFsdWF0ZVRleHQgJiZcbiAgICAhZXZhbHVhdGVJbWFnZSAmJlxuICAgICFpc0VtcHR5KGZsYXRTdHlsZSlcbiAgKSB7XG4gICAgLy8gYXNzdW1lIHRoaXMgaXMgYSB1c2VyIGVycm9yXG4gICAgLy8gd291bGQgYmUgbmljZSB0byBjaGVjayB0aGUgcHJvcGVydGllcyBhbmQgc3VnZ2VzdCBcImRpZCB5b3UgbWVhbi4uLlwiXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ05vIGZpbGwsIHN0cm9rZSwgcG9pbnQsIG9yIHRleHQgc3ltYm9saXplciBwcm9wZXJ0aWVzIGluIHN0eWxlOiAnICtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZmxhdFN0eWxlKVxuICAgICk7XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IG5ldyBTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGlmIChldmFsdWF0ZUZpbGwpIHtcbiAgICAgIGNvbnN0IGZpbGwgPSBldmFsdWF0ZUZpbGwoY29udGV4dCk7XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3R5bGUuc2V0RmlsbChmaWxsKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICBjb25zdCBzdHJva2UgPSBldmFsdWF0ZVN0cm9rZShjb250ZXh0KTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldFN0cm9rZShzdHJva2UpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVUZXh0KSB7XG4gICAgICBjb25zdCB0ZXh0ID0gZXZhbHVhdGVUZXh0KGNvbnRleHQpO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldFRleHQodGV4dCk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZUltYWdlKSB7XG4gICAgICBjb25zdCBpbWFnZSA9IGV2YWx1YXRlSW1hZ2UoY29udGV4dCk7XG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldEltYWdlKGltYWdlKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlWkluZGV4KSB7XG4gICAgICBzdHlsZS5zZXRaSW5kZXgoZXZhbHVhdGVaSW5kZXgoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpGaWxsfG51bGx9IEZpbGxFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtGaWxsRXZhbHVhdG9yP30gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhIGZpbGwuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRmlsbChmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCkge1xuICBjb25zdCBldmFsdWF0ZUNvbG9yID0gY29sb3JMaWtlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZmlsbC1jb2xvcicsXG4gICAgY29udGV4dFxuICApO1xuICBpZiAoIWV2YWx1YXRlQ29sb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZpbGwgPSBuZXcgRmlsbCgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCBjb2xvciA9IGV2YWx1YXRlQ29sb3IoY29udGV4dCk7XG4gICAgaWYgKGNvbG9yID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmaWxsLnNldENvbG9yKGNvbG9yKTtcbiAgICByZXR1cm4gZmlsbDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOlN0cm9rZXxudWxsfSBTdHJva2VFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtTdHJva2VFdmFsdWF0b3I/fSBBIGZ1bmN0aW9uIHRoZSBldmFsdWF0ZXMgdG8gYSBzdHJva2UuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KSB7XG4gIGNvbnN0IGV2YWx1YXRlV2lkdGggPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2Utd2lkdGgnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUNvbG9yID0gY29sb3JMaWtlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWNvbG9yJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgaWYgKCFldmFsdWF0ZVdpZHRoICYmICFldmFsdWF0ZUNvbG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBldmFsdWF0ZUxpbmVDYXAgPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbGluZS1jYXAnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUxpbmVKb2luID0gc3RyaW5nRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWxpbmUtam9pbicsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlTGluZURhc2ggPSBudW1iZXJBcnJheUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS1saW5lLWRhc2gnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUxpbmVEYXNoT2Zmc2V0ID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWxpbmUtZGFzaC1vZmZzZXQnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU1pdGVyTGltaXQgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbWl0ZXItbGltaXQnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBzdHJva2UgPSBuZXcgU3Ryb2tlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmIChldmFsdWF0ZUNvbG9yKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2YWx1YXRlQ29sb3IoY29udGV4dCk7XG4gICAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0cm9rZS5zZXRDb2xvcihjb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlV2lkdGgpIHtcbiAgICAgIHN0cm9rZS5zZXRXaWR0aChldmFsdWF0ZVdpZHRoKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVMaW5lQ2FwKSB7XG4gICAgICBjb25zdCBsaW5lQ2FwID0gZXZhbHVhdGVMaW5lQ2FwKGNvbnRleHQpO1xuICAgICAgaWYgKGxpbmVDYXAgIT09ICdidXR0JyAmJiBsaW5lQ2FwICE9PSAncm91bmQnICYmIGxpbmVDYXAgIT09ICdzcXVhcmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYnV0dCwgcm91bmQsIG9yIHNxdWFyZSBsaW5lIGNhcCcpO1xuICAgICAgfVxuICAgICAgc3Ryb2tlLnNldExpbmVDYXAobGluZUNhcCk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTGluZUpvaW4pIHtcbiAgICAgIGNvbnN0IGxpbmVKb2luID0gZXZhbHVhdGVMaW5lSm9pbihjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgbGluZUpvaW4gIT09ICdiZXZlbCcgJiZcbiAgICAgICAgbGluZUpvaW4gIT09ICdyb3VuZCcgJiZcbiAgICAgICAgbGluZUpvaW4gIT09ICdtaXRlcidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIgbGluZSBqb2luJyk7XG4gICAgICB9XG4gICAgICBzdHJva2Uuc2V0TGluZUpvaW4obGluZUpvaW4pO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUxpbmVEYXNoKSB7XG4gICAgICBzdHJva2Uuc2V0TGluZURhc2goZXZhbHVhdGVMaW5lRGFzaChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTGluZURhc2hPZmZzZXQpIHtcbiAgICAgIHN0cm9rZS5zZXRMaW5lRGFzaE9mZnNldChldmFsdWF0ZUxpbmVEYXNoT2Zmc2V0KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVNaXRlckxpbWl0KSB7XG4gICAgICBzdHJva2Uuc2V0TWl0ZXJMaW1pdChldmFsdWF0ZU1pdGVyTGltaXQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJva2U7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpUZXh0fSBUZXh0RXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7VGV4dEV2YWx1YXRvcj99IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYSB0ZXh0IHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVGV4dChmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZml4ID0gJ3RleHQtJztcblxuICAvLyBDdXJyZW50bHksIGFuIEFycmF5PHN0cmluZz4gbWF5IGJlIHVzZWQgZm9yIHJpY2ggdGV4dCBzdXBwb3J0LiAgVGhpcyBkb2Vzbid0XG4gIC8vIHdvcmsgd2l0aCBvdXIgZXhwcmVzc2lvbiBzeW50YXggd2hlcmUgYXJyYXlzIG9mIHN0cmluZ3MgYXJlIGludGVycHJldGVkIGFzXG4gIC8vIGNhbGwgZXhwcmVzc2lvbnMuICBUbyBzdXBwb3J0IHJpY2ggdGV4dCwgd2UgY291bGQgYWRkIGEgJ3N0cmluZ3MnIG9wZXJhdG9yXG4gIC8vIHdoZXJlIGFsbCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50cyB3b3VsZCBiZSBzdHJpbmcgdmFsdWVzLlxuICBjb25zdCBldmFsdWF0ZVZhbHVlID0gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3ZhbHVlJywgY29udGV4dCk7XG4gIGlmICghZXZhbHVhdGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUJhY2tncm91bmRGaWxsID0gYnVpbGRGaWxsKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnYmFja2dyb3VuZC0nLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVN0cm9rZSA9IGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUJhY2tncm91bmRTdHJva2UgPSBidWlsZFN0cm9rZShcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2JhY2tncm91bmQtJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVGb250ID0gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2ZvbnQnLCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZU1heEFuZ2xlID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnbWF4LWFuZ2xlJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVPZmZzZXRYID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnb2Zmc2V0LXgnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU9mZnNldFkgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdvZmZzZXQteScsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlT3ZlcmZsb3cgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnb3ZlcmZsb3cnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVBsYWNlbWVudCA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3BsYWNlbWVudCcsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUmVwZWF0ID0gbnVtYmVyRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JlcGVhdCcsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUm90YXRpb24gPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGlvbicsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlQWxpZ24gPSBzdHJpbmdFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAnYWxpZ24nLCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUp1c3RpZnkgPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdqdXN0aWZ5JyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVCYXNlbGluZSA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2Jhc2VsaW5lJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVQYWRkaW5nID0gbnVtYmVyQXJyYXlFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdwYWRkaW5nJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KHt9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGV4dC5zZXRUZXh0KGV2YWx1YXRlVmFsdWUoY29udGV4dCkpO1xuXG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgdGV4dC5zZXRGaWxsKGV2YWx1YXRlRmlsbChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQmFja2dyb3VuZEZpbGwpIHtcbiAgICAgIHRleHQuc2V0QmFja2dyb3VuZEZpbGwoZXZhbHVhdGVCYWNrZ3JvdW5kRmlsbChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICB0ZXh0LnNldFN0cm9rZShldmFsdWF0ZVN0cm9rZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQmFja2dyb3VuZFN0cm9rZSkge1xuICAgICAgdGV4dC5zZXRCYWNrZ3JvdW5kU3Ryb2tlKGV2YWx1YXRlQmFja2dyb3VuZFN0cm9rZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlRm9udCkge1xuICAgICAgdGV4dC5zZXRGb250KGV2YWx1YXRlRm9udChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTWF4QW5nbGUpIHtcbiAgICAgIHRleHQuc2V0TWF4QW5nbGUoZXZhbHVhdGVNYXhBbmdsZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT2Zmc2V0WCkge1xuICAgICAgdGV4dC5zZXRPZmZzZXRYKGV2YWx1YXRlT2Zmc2V0WChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT2Zmc2V0WSkge1xuICAgICAgdGV4dC5zZXRPZmZzZXRZKGV2YWx1YXRlT2Zmc2V0WShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT3ZlcmZsb3cpIHtcbiAgICAgIHRleHQuc2V0T3ZlcmZsb3coZXZhbHVhdGVPdmVyZmxvdyhjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUGxhY2VtZW50KSB7XG4gICAgICBjb25zdCBwbGFjZW1lbnQgPSBldmFsdWF0ZVBsYWNlbWVudChjb250ZXh0KTtcbiAgICAgIGlmIChwbGFjZW1lbnQgIT09ICdwb2ludCcgJiYgcGxhY2VtZW50ICE9PSAnbGluZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb2ludCBvciBsaW5lIGZvciB0ZXh0LXBsYWNlbWVudCcpO1xuICAgICAgfVxuICAgICAgdGV4dC5zZXRQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSZXBlYXQpIHtcbiAgICAgIHRleHQuc2V0UmVwZWF0KGV2YWx1YXRlUmVwZWF0KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVTY2FsZSkge1xuICAgICAgdGV4dC5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGVXaXRoVmlldykge1xuICAgICAgdGV4dC5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGlvbikge1xuICAgICAgdGV4dC5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVBbGlnbikge1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gZXZhbHVhdGVBbGlnbihjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgdGV4dEFsaWduICE9PSAnbGVmdCcgJiZcbiAgICAgICAgdGV4dEFsaWduICE9PSAnY2VudGVyJyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdyaWdodCcgJiZcbiAgICAgICAgdGV4dEFsaWduICE9PSAnZW5kJyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdzdGFydCdcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGxlZnQsIHJpZ2h0LCBjZW50ZXIsIHN0YXJ0LCBvciBlbmQgZm9yIHRleHQtYWxpZ24nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0ZXh0LnNldFRleHRBbGlnbih0ZXh0QWxpZ24pO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUp1c3RpZnkpIHtcbiAgICAgIGNvbnN0IGp1c3RpZnkgPSBldmFsdWF0ZUp1c3RpZnkoY29udGV4dCk7XG4gICAgICBpZiAoanVzdGlmeSAhPT0gJ2xlZnQnICYmIGp1c3RpZnkgIT09ICdyaWdodCcgJiYganVzdGlmeSAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsZWZ0LCByaWdodCwgb3IgY2VudGVyIGZvciB0ZXh0LWp1c3RpZnknKTtcbiAgICAgIH1cbiAgICAgIHRleHQuc2V0SnVzdGlmeShqdXN0aWZ5KTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVCYXNlbGluZSkge1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gZXZhbHVhdGVCYXNlbGluZShjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnYm90dG9tJyAmJlxuICAgICAgICB0ZXh0QmFzZWxpbmUgIT09ICd0b3AnICYmXG4gICAgICAgIHRleHRCYXNlbGluZSAhPT0gJ21pZGRsZScgJiZcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnYWxwaGFiZXRpYycgJiZcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnaGFuZ2luZydcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGJvdHRvbSwgdG9wLCBtaWRkbGUsIGFscGhhYmV0aWMsIG9yIGhhbmdpbmcgZm9yIHRleHQtYmFzZWxpbmUnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0ZXh0LnNldFRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZVBhZGRpbmcpIHtcbiAgICAgIHRleHQuc2V0UGFkZGluZyhldmFsdWF0ZVBhZGRpbmcoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6aW1wb3J0KFwiLi4vLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gSW1hZ2VFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtJbWFnZUV2YWx1YXRvcj99IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYW4gaW1hZ2Ugc3ltYm9saXplci5cbiAqL1xuZnVuY3Rpb24gYnVpbGRJbWFnZShmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgaWYgKCdpY29uLXNyYycgaW4gZmxhdFN0eWxlKSB7XG4gICAgcmV0dXJuIGJ1aWxkSWNvbihmbGF0U3R5bGUsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKCdzaGFwZS1wb2ludHMnIGluIGZsYXRTdHlsZSkge1xuICAgIHJldHVybiBidWlsZFNoYXBlKGZsYXRTdHlsZSwgY29udGV4dCk7XG4gIH1cblxuICBpZiAoJ2NpcmNsZS1yYWRpdXMnIGluIGZsYXRTdHlsZSkge1xuICAgIHJldHVybiBidWlsZENpcmNsZShmbGF0U3R5bGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0ltYWdlRXZhbHVhdG9yfSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGFuIGltYWdlIHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSWNvbihmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZml4ID0gJ2ljb24tJztcblxuICAvLyByZXF1aXJlZCBwcm9wZXJ0eVxuICBjb25zdCBzcmNOYW1lID0gcHJlZml4ICsgJ3NyYyc7XG4gIGNvbnN0IHNyYyA9IHJlcXVpcmVTdHJpbmcoZmxhdFN0eWxlW3NyY05hbWVdLCBzcmNOYW1lKTtcblxuICAvLyBzZXR0YWJsZSBwcm9wZXJ0aWVzXG4gIGNvbnN0IGV2YWx1YXRlQW5jaG9yID0gY29vcmRpbmF0ZUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2FuY2hvcicsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlT3BhY2l0eSA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ29wYWNpdHknLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZURpc3BsYWNlbWVudCA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkaXNwbGFjZW1lbnQnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVJvdGF0aW9uID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRpb24nLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3ID0gYm9vbGVhbkV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0ZS13aXRoLXZpZXcnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICAvLyB0aGUgcmVtYWluaW5nIHN5bWJvbGl6ZXIgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzZXR0YWJsZVxuICBjb25zdCBhbmNob3JPcmlnaW4gPSBvcHRpb25hbEljb25PcmlnaW4oZmxhdFN0eWxlLCBwcmVmaXggKyAnYW5jaG9yLW9yaWdpbicpO1xuICBjb25zdCBhbmNob3JYVW5pdHMgPSBvcHRpb25hbEljb25BbmNob3JVbml0cyhcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2FuY2hvci14LXVuaXRzJ1xuICApO1xuICBjb25zdCBhbmNob3JZVW5pdHMgPSBvcHRpb25hbEljb25BbmNob3JVbml0cyhcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2FuY2hvci15LXVuaXRzJ1xuICApO1xuICBjb25zdCBjb2xvciA9IG9wdGlvbmFsQ29sb3JMaWtlKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2NvbG9yJyk7XG4gIGNvbnN0IGNyb3NzT3JpZ2luID0gb3B0aW9uYWxTdHJpbmcoZmxhdFN0eWxlLCBwcmVmaXggKyAnY3Jvc3Mtb3JpZ2luJyk7XG4gIGNvbnN0IG9mZnNldCA9IG9wdGlvbmFsTnVtYmVyQXJyYXkoZmxhdFN0eWxlLCBwcmVmaXggKyAnb2Zmc2V0Jyk7XG4gIGNvbnN0IG9mZnNldE9yaWdpbiA9IG9wdGlvbmFsSWNvbk9yaWdpbihmbGF0U3R5bGUsIHByZWZpeCArICdvZmZzZXQtb3JpZ2luJyk7XG4gIGNvbnN0IHdpZHRoID0gb3B0aW9uYWxOdW1iZXIoZmxhdFN0eWxlLCBwcmVmaXggKyAnd2lkdGgnKTtcbiAgY29uc3QgaGVpZ2h0ID0gb3B0aW9uYWxOdW1iZXIoZmxhdFN0eWxlLCBwcmVmaXggKyAnaGVpZ2h0Jyk7XG4gIGNvbnN0IHNpemUgPSBvcHRpb25hbFNpemUoZmxhdFN0eWxlLCBwcmVmaXggKyAnc2l6ZScpO1xuICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gb3B0aW9uYWxEZWNsdXR0ZXJNb2RlKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2RlY2x1dHRlcicpO1xuXG4gIGNvbnN0IGljb24gPSBuZXcgSWNvbih7XG4gICAgc3JjLFxuICAgIGFuY2hvck9yaWdpbixcbiAgICBhbmNob3JYVW5pdHMsXG4gICAgYW5jaG9yWVVuaXRzLFxuICAgIGNvbG9yLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIG9mZnNldCxcbiAgICBvZmZzZXRPcmlnaW4sXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIHNpemUsXG4gICAgZGVjbHV0dGVyTW9kZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGV2YWx1YXRlT3BhY2l0eSkge1xuICAgICAgaWNvbi5zZXRPcGFjaXR5KGV2YWx1YXRlT3BhY2l0eShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBpY29uLnNldERpc3BsYWNlbWVudChldmFsdWF0ZURpc3BsYWNlbWVudChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUm90YXRpb24pIHtcbiAgICAgIGljb24uc2V0Um90YXRpb24oZXZhbHVhdGVSb3RhdGlvbihjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUm90YXRlV2l0aFZpZXcpIHtcbiAgICAgIGljb24uc2V0Um90YXRlV2l0aFZpZXcoZXZhbHVhdGVSb3RhdGVXaXRoVmlldyhjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIGljb24uc2V0U2NhbGUoZXZhbHVhdGVTY2FsZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQW5jaG9yKSB7XG4gICAgICBpY29uLnNldEFuY2hvcihldmFsdWF0ZUFuY2hvcihjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBpY29uO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtJbWFnZUV2YWx1YXRvcn0gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBpY29uIHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU2hhcGUoZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHByZWZpeCA9ICdzaGFwZS0nO1xuXG4gIC8vIHJlcXVpcmVkIHByb3BlcnR5XG4gIGNvbnN0IHBvaW50c05hbWUgPSBwcmVmaXggKyAncG9pbnRzJztcbiAgY29uc3QgcG9pbnRzID0gcmVxdWlyZU51bWJlcihmbGF0U3R5bGVbcG9pbnRzTmFtZV0sIHBvaW50c05hbWUpO1xuXG4gIC8vIHNldHRhYmxlIHByb3BlcnRpZXNcbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVTdHJva2UgPSBidWlsZFN0cm9rZShmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZURpc3BsYWNlbWVudCA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkaXNwbGFjZW1lbnQnLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3QgZXZhbHVhdGVSb3RhdGlvbiA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0aW9uJyxcbiAgICBjb250ZXh0XG4gICk7XG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dFxuICApO1xuXG4gIC8vIHRoZSByZW1haW5pbmcgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzZXR0YWJsZVxuICBjb25zdCByYWRpdXMgPSBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByZWZpeCArICdyYWRpdXMnKTtcbiAgY29uc3QgcmFkaXVzMSA9IG9wdGlvbmFsTnVtYmVyKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JhZGl1czEnKTtcbiAgY29uc3QgcmFkaXVzMiA9IG9wdGlvbmFsTnVtYmVyKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JhZGl1czInKTtcbiAgY29uc3QgYW5nbGUgPSBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByZWZpeCArICdhbmdsZScpO1xuICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gb3B0aW9uYWxEZWNsdXR0ZXJNb2RlKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGVjbHV0dGVyLW1vZGUnXG4gICk7XG5cbiAgY29uc3Qgc2hhcGUgPSBuZXcgUmVndWxhclNoYXBlKHtcbiAgICBwb2ludHMsXG4gICAgcmFkaXVzLFxuICAgIHJhZGl1czEsXG4gICAgcmFkaXVzMixcbiAgICBhbmdsZSxcbiAgICBkZWNsdXR0ZXJNb2RlLFxuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoZXZhbHVhdGVGaWxsKSB7XG4gICAgICBzaGFwZS5zZXRGaWxsKGV2YWx1YXRlRmlsbChjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVN0cm9rZSkge1xuICAgICAgc2hhcGUuc2V0U3Ryb2tlKGV2YWx1YXRlU3Ryb2tlKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBzaGFwZS5zZXREaXNwbGFjZW1lbnQoZXZhbHVhdGVEaXNwbGFjZW1lbnQoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGlvbikge1xuICAgICAgc2hhcGUuc2V0Um90YXRpb24oZXZhbHVhdGVSb3RhdGlvbihjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgICBzaGFwZS5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIHNoYXBlLnNldFNjYWxlKGV2YWx1YXRlU2NhbGUoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7SW1hZ2VFdmFsdWF0b3J9IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYSBjaXJjbGUgc3ltYm9saXplci5cbiAqL1xuZnVuY3Rpb24gYnVpbGRDaXJjbGUoZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHByZWZpeCA9ICdjaXJjbGUtJztcblxuICAvLyBzZXR0YWJsZSBwcm9wZXJ0aWVzXG4gIGNvbnN0IGV2YWx1YXRlRmlsbCA9IGJ1aWxkRmlsbChmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU3Ryb2tlID0gYnVpbGRTdHJva2UoZmxhdFN0eWxlLCBwcmVmaXgsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVJhZGl1cyA9IG51bWJlckV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdyYWRpdXMnLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVTY2FsZSA9IHNpemVMaWtlRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3NjYWxlJywgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlRGlzcGxhY2VtZW50ID0gY29vcmRpbmF0ZUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2Rpc3BsYWNlbWVudCcsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCBldmFsdWF0ZVJvdGF0aW9uID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRpb24nLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3QgZXZhbHVhdGVSb3RhdGVXaXRoVmlldyA9IGJvb2xlYW5FdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGUtd2l0aC12aWV3JyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgLy8gdGhlIHJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBub3QgY3VycmVudGx5IHNldHRhYmxlXG4gIGNvbnN0IGRlY2x1dHRlck1vZGUgPSBvcHRpb25hbERlY2x1dHRlck1vZGUoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkZWNsdXR0ZXItbW9kZSdcbiAgKTtcblxuICBjb25zdCBjaXJjbGUgPSBuZXcgQ2lyY2xlKHtcbiAgICByYWRpdXM6IDUsIC8vIHRoaXMgaXMgYXJiaXRyYXJ5LCBidXQgcmVxdWlyZWQgLSB0aGUgZXZhbHVhdGVkIHJhZGl1cyBpcyB1c2VkIGJlbG93XG4gICAgZGVjbHV0dGVyTW9kZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGV2YWx1YXRlUmFkaXVzKSB7XG4gICAgICBjaXJjbGUuc2V0UmFkaXVzKGV2YWx1YXRlUmFkaXVzKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgY2lyY2xlLnNldEZpbGwoZXZhbHVhdGVGaWxsKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICBjaXJjbGUuc2V0U3Ryb2tlKGV2YWx1YXRlU3Ryb2tlKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBjaXJjbGUuc2V0RGlzcGxhY2VtZW50KGV2YWx1YXRlRGlzcGxhY2VtZW50KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRpb24pIHtcbiAgICAgIGNpcmNsZS5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRlV2l0aFZpZXcpIHtcbiAgICAgIGNpcmNsZS5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIGNpcmNsZS5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY2xlO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5OdW1iZXJFdmFsdWF0b3J8dW5kZWZpbmVkfSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3Igb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBudW1iZXJFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyVHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlTnVtYmVyKGV2YWx1YXRvcihjb250ZXh0KSwgbmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLlN0cmluZ0V2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBTdHJpbmdUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVTdHJpbmcoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuQm9vbGVhbkV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgQm9vbGVhblR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRvcihjb250ZXh0KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBib29sZWFuIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuQ29sb3JMaWtlRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBjb2xvckxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihcbiAgICBmbGF0U3R5bGVbbmFtZV0sXG4gICAgQ29sb3JUeXBlIHwgU3RyaW5nVHlwZSxcbiAgICBjb250ZXh0XG4gICk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlQ29sb3JMaWtlKGV2YWx1YXRvcihjb250ZXh0KSwgbmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLk51bWJlckFycmF5RXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBudW1iZXJBcnJheUV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyQXJyYXlUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVOdW1iZXJBcnJheShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5Db29yZGluYXRlRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBjb29yZGluYXRlRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBOdW1iZXJBcnJheVR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCBhcnJheSA9IHJlcXVpcmVOdW1iZXJBcnJheShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdHdvIG51bWJlcnMgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5TaXplTGlrZUV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gc2l6ZUxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihcbiAgICBmbGF0U3R5bGVbbmFtZV0sXG4gICAgTnVtYmVyQXJyYXlUeXBlIHwgTnVtYmVyVHlwZSxcbiAgICBjb250ZXh0XG4gICk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlU2l6ZUxpa2UoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gQSBudW1iZXIgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHZhbHVlID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IEEgc2l6ZSBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsU2l6ZShmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvU2l6ZShlbmNvZGVkKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoZW5jb2RlZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyIG9yIHNpemUgYXJyYXkgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgaWYgKFxuICAgIGVuY29kZWQubGVuZ3RoICE9PSAyIHx8XG4gICAgdHlwZW9mIGVuY29kZWRbMF0gIT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIGVuY29kZWRbMV0gIT09ICdudW1iZXInXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXIgb3Igc2l6ZSBhcnJheSBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gQSBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbFN0cmluZyhmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kZWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0cmluZyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uT3JpZ2lufHVuZGVmaW5lZH0gQW4gaWNvbiBvcmlnaW4gb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbEljb25PcmlnaW4oZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKFxuICAgIGVuY29kZWQgIT09ICdib3R0b20tbGVmdCcgJiZcbiAgICBlbmNvZGVkICE9PSAnYm90dG9tLXJpZ2h0JyAmJlxuICAgIGVuY29kZWQgIT09ICd0b3AtbGVmdCcgJiZcbiAgICBlbmNvZGVkICE9PSAndG9wLXJpZ2h0J1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodCwgdG9wLWxlZnQsIG9yIHRvcC1yaWdodCBmb3IgJHtwcm9wZXJ0eX1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uQW5jaG9yVW5pdHN8dW5kZWZpbmVkfSBJY29uIGFuY2hvciB1bml0cyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsSWNvbkFuY2hvclVuaXRzKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChlbmNvZGVkICE9PSAncGl4ZWxzJyAmJiBlbmNvZGVkICE9PSAnZnJhY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBwaXhlbHMgb3IgZnJhY3Rpb24gZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBBbiBhcnJheSBvZiBudW1iZXJzIG9yIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWxOdW1iZXJBcnJheShmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gcmVxdWlyZU51bWJlckFycmF5KGVuY29kZWQsIHByb3BlcnR5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBJY29uIGRlY2x1dHRlciBtb2RlLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbERlY2x1dHRlck1vZGUoZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGVkICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgaWYgKGVuY29kZWQgIT09ICdkZWNsdXR0ZXInICYmIGVuY29kZWQgIT09ICdvYnN0YWNsZScgJiYgZW5jb2RlZCAhPT0gJ25vbmUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBkZWNsdXR0ZXIsIG9ic3RhY2xlLCBvciBub25lIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHN5bWJvbGl6ZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIGNvbG9yIHZhbHVlcyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsQ29sb3JMaWtlKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiByZXF1aXJlQ29sb3JMaWtlKGVuY29kZWQsIHByb3BlcnR5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXJBcnJheSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgb2YgbnVtYmVycyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVN0cmluZyh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXIodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHN0cmluZ30gQSBjb2xvci5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUNvbG9yTGlrZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3QgYXJyYXkgPSByZXF1aXJlTnVtYmVyQXJyYXkodmFsdWUsIHByb3BlcnR5KTtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDwgMyB8fCBsZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGNvbG9yIHdpdGggMyBvciA0IHZhbHVlcyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtudW1iZXJ8QXJyYXk8bnVtYmVyPn0gQSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVTaXplTGlrZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3Qgc2l6ZSA9IHJlcXVpcmVOdW1iZXJBcnJheSh2YWx1ZSwgcHJvcGVydHkpO1xuICBpZiAoc2l6ZS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIGFycmF5IG9mIHR3byBudW1iZXJzIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlVmVjdG9yXG4gKi9cbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBSQnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQgU3R5bGUsIHtcbiAgY3JlYXRlRGVmYXVsdFN0eWxlLFxuICB0b0Z1bmN0aW9uIGFzIHRvU3R5bGVGdW5jdGlvbixcbn0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuaW1wb3J0IHtcbiAgZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbixcbiAgcnVsZXNUb1N0eWxlRnVuY3Rpb24sXG59IGZyb20gJy4uL3JlbmRlci9jYW52YXMvc3R5bGUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9IFZlY3RvclNvdXJjZVR5cGVcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1sYXllciddIEEgQ1NTIGNsYXNzIG5hbWUgdG8gc2V0IHRvIHRoZSBsYXllciBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIFRoZSBtaW5pbXVtIHZpZXcgem9vbSBsZXZlbCAoZXhjbHVzaXZlKSBhYm92ZSB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIFRoZSBtYXhpbXVtIHZpZXcgem9vbSBsZXZlbCAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufSBbcmVuZGVyT3JkZXJdIFJlbmRlciBvcmRlci4gRnVuY3Rpb24gdG8gYmUgdXNlZCB3aGVuIHNvcnRpbmdcbiAqIGZlYXR1cmVzIGJlZm9yZSByZW5kZXJpbmcuIEJ5IGRlZmF1bHQgZmVhdHVyZXMgYXJlIGRyYXduIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXJlIGNyZWF0ZWQuIFVzZVxuICogYG51bGxgIHRvIGF2b2lkIHRoZSBzb3J0LCBidXQgZ2V0IGFuIHVuZGVmaW5lZCBkcmF3IG9yZGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZW5kZXJCdWZmZXI9MTAwXSBUaGUgYnVmZmVyIGluIHBpeGVscyBhcm91bmQgdGhlIHZpZXdwb3J0IGV4dGVudCB1c2VkIGJ5IHRoZVxuICogcmVuZGVyZXIgd2hlbiBnZXR0aW5nIGZlYXR1cmVzIGZyb20gdGhlIHZlY3RvciBzb3VyY2UgZm9yIHRoZSByZW5kZXJpbmcgb3IgaGl0LWRldGVjdGlvbi5cbiAqIFJlY29tbWVuZGVkIHZhbHVlOiB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBzeW1ib2wsIGxpbmUgd2lkdGggb3IgbGFiZWwuXG4gKiBAcHJvcGVydHkge1ZlY3RvclNvdXJjZVR5cGV9IFtzb3VyY2VdIFNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IFttYXBdIFNldHMgdGhlIGxheWVyIGFzIG92ZXJsYXkgb24gYSBtYXAuIFRoZSBtYXAgd2lsbCBub3QgbWFuYWdlXG4gKiB0aGlzIGxheWVyIGluIGl0cyBsYXllcnMgY29sbGVjdGlvbiwgYW5kIHRoZSBsYXllciB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiB0ZW1wb3JhcnkgbGF5ZXJzLiBUaGUgc3RhbmRhcmQgd2F5IHRvIGFkZCBhIGxheWVyIHRvIGEgbWFwIGFuZCBoYXZlIGl0IG1hbmFnZWQgYnkgdGhlIG1hcCBpcyB0b1xuICogdXNlIFttYXAuYWRkTGF5ZXIoKV17QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHQjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVjbHV0dGVyPWZhbHNlXSBEZWNsdXR0ZXIgaW1hZ2VzIGFuZCB0ZXh0LiBEZWNsdXR0ZXJpbmcgaXMgYXBwbGllZCB0byBhbGxcbiAqIGltYWdlIGFuZCB0ZXh0IHN0eWxlcyBvZiBhbGwgVmVjdG9yIGFuZCBWZWN0b3JUaWxlIGxheWVycyB0aGF0IGhhdmUgc2V0IHRoaXMgdG8gYHRydWVgLiBUaGUgcHJpb3JpdHlcbiAqIGlzIGRlZmluZWQgYnkgdGhlIHotaW5kZXggb2YgdGhlIGxheWVyLCB0aGUgYHpJbmRleGAgb2YgdGhlIHN0eWxlIGFuZCB0aGUgcmVuZGVyIG9yZGVyIG9mIGZlYXR1cmVzLlxuICogSGlnaGVyIHotaW5kZXggbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBXaXRoaW4gdGhlIHNhbWUgei1pbmRleCwgYSBmZWF0dXJlIHJlbmRlcmVkIGJlZm9yZSBhbm90aGVyIGhhc1xuICogaGlnaGVyIHByaW9yaXR5LlxuICpcbiAqIEFzIGFuIG9wdGltaXphdGlvbiBkZWNsdXR0ZXJlZCBmZWF0dXJlcyBmcm9tIGxheWVycyB3aXRoIHRoZSBzYW1lIGBjbGFzc05hbWVgIGFyZSByZW5kZXJlZCBhYm92ZVxuICogdGhlIGZpbGwgYW5kIHN0cm9rZSBzdHlsZXMgb2YgYWxsIG9mIHRob3NlIGxheWVycyByZWdhcmRsZXNzIG9mIHotaW5kZXguICBUbyBvcHQgb3V0IG9mIHRoaXNcbiAqIGJlaGF2aW9yIGFuZCBwbGFjZSBkZWNsdXR0ZXJkIGZlYXR1cmVzIHdpdGggdGhlaXIgb3duIGxheWVyIGNvbmZpZ3VyZSB0aGUgbGF5ZXIgd2l0aCBhIGBjbGFzc05hbWVgXG4gKiBvdGhlciB0aGFuIGBvbC1sYXllcmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZXxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZUxpa2V8bnVsbH0gW3N0eWxlXSBMYXllciBzdHlsZS4gV2hlbiBzZXQgdG8gYG51bGxgLCBvbmx5XG4gKiBmZWF0dXJlcyB0aGF0IGhhdmUgdGhlaXIgb3duIHN0eWxlIHdpbGwgYmUgcmVuZGVyZWQuIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlfSBmb3IgdGhlIGRlZmF1bHQgc3R5bGVcbiAqIHdoaWNoIHdpbGwgYmUgdXNlZCBpZiB0aGlzIGlzIG5vdCBzZXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5CYWNrZ3JvdW5kQ29sb3J9IFtiYWNrZ3JvdW5kXSBCYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgbGF5ZXIuIElmIG5vdCBzcGVjaWZpZWQsIG5vIGJhY2tncm91bmRcbiAqIHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUFuaW1hdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLCBmZWF0dXJlIGJhdGNoZXMgd2lsbFxuICogYmUgcmVjcmVhdGVkIGR1cmluZyBhbmltYXRpb25zLiBUaGlzIG1lYW5zIHRoYXQgbm8gdmVjdG9ycyB3aWxsIGJlIHNob3duIGNsaXBwZWQsIGJ1dCB0aGVcbiAqIHNldHRpbmcgd2lsbCBoYXZlIGEgcGVyZm9ybWFuY2UgaW1wYWN0IGZvciBsYXJnZSBhbW91bnRzIG9mIHZlY3RvciBkYXRhLiBXaGVuIHNldCB0byBgZmFsc2VgLFxuICogYmF0Y2hlcyB3aWxsIGJlIHJlY3JlYXRlZCB3aGVuIG5vIGFuaW1hdGlvbiBpcyBhY3RpdmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUludGVyYWN0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAsIGZlYXR1cmUgYmF0Y2hlcyB3aWxsXG4gKiBiZSByZWNyZWF0ZWQgZHVyaW5nIGludGVyYWN0aW9ucy4gU2VlIGFsc28gYHVwZGF0ZVdoaWxlQW5pbWF0aW5nYC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgUHJvcGVydHkgPSB7XG4gIFJFTkRFUl9PUkRFUjogJ3JlbmRlck9yZGVyJyxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVmVjdG9yIGRhdGEgdGhhdCBpcyByZW5kZXJlZCBjbGllbnQtc2lkZS5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSBWZWN0b3JTb3VyY2VUeXBlXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllci5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JUaWxlTGF5ZXIuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXJlci9jYW52YXMvVmVjdG9ySW1hZ2VMYXllci5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlcmVyL3dlYmdsL1BvaW50c0xheWVyLmpzXCIpLmRlZmF1bHR9IFJlbmRlcmVyVHlwZVxuICogQGV4dGVuZHMge0xheWVyPFZlY3RvclNvdXJjZVR5cGUsIFJlbmRlcmVyVHlwZT59XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEJhc2VWZWN0b3JMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uczxWZWN0b3JTb3VyY2VUeXBlPn0gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBiYXNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnN0eWxlO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5yZW5kZXJCdWZmZXI7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJfID1cbiAgICAgIG9wdGlvbnMuZGVjbHV0dGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlY2x1dHRlciA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyQnVmZmVyXyA9XG4gICAgICBvcHRpb25zLnJlbmRlckJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJCdWZmZXIgOiAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyIHByb3ZpZGVkIHN0eWxlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTdHlsZSBmdW5jdGlvbiBmb3IgdXNlIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zZXRTdHlsZShvcHRpb25zLnN0eWxlKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVXaGlsZUFuaW1hdGluZ18gPVxuICAgICAgb3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZ1xuICAgICAgICA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdfID1cbiAgICAgIG9wdGlvbnMudXBkYXRlV2hpbGVJbnRlcmFjdGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nXG4gICAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRGVjbHV0dGVyLlxuICAgKi9cbiAgZ2V0RGVjbHV0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2x1dHRlcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0b3Btb3N0IGZlYXR1cmUgdGhhdCBpbnRlcnNlY3RzIHRoZSBnaXZlbiBwaXhlbCBvbiB0aGUgdmlld3BvcnQuIFJldHVybnMgYSBwcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBmZWF0dXJlcy4gVGhlIGFycmF5IHdpbGwgZWl0aGVyIGNvbnRhaW4gdGhlIHRvcG1vc3QgZmVhdHVyZVxuICAgKiB3aGVuIGEgaGl0IHdhcyBkZXRlY3RlZCwgb3IgaXQgd2lsbCBiZSBlbXB0eS5cbiAgICpcbiAgICogVGhlIGhpdCBkZXRlY3Rpb24gYWxnb3JpdGhtIHVzZWQgZm9yIHRoaXMgbWV0aG9kIGlzIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2UsIGJ1dCBpcyBsZXNzXG4gICAqIGFjY3VyYXRlIHRoYW4gdGhlIG9uZSB1c2VkIGluIFttYXAuZ2V0RmVhdHVyZXNBdFBpeGVsKClde0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0I2dldEZlYXR1cmVzQXRQaXhlbH0uXG4gICAqIFRleHQgaXMgbm90IGNvbnNpZGVyZWQsIGFuZCBpY29ucyBhcmUgb25seSByZXByZXNlbnRlZCBieSB0aGVpciBib3VuZGluZyBib3ggaW5zdGVhZCBvZiB0aGUgZXhhY3RcbiAgICogaW1hZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGltcG9ydChcIi4uL0ZlYXR1cmVcIikuRmVhdHVyZUxpa2U+Pn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgZmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzKHBpeGVsKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldEZlYXR1cmVzKHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZW5kZXIgYnVmZmVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlckJ1ZmZlcl87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpOiBudW1iZXJ8bnVsbHx1bmRlZmluZWR9IFJlbmRlclxuICAgKiAgICAgb3JkZXIuXG4gICAqL1xuICBnZXRSZW5kZXJPcmRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoUHJvcGVydHkuUkVOREVSX09SREVSKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBmb3IgZmVhdHVyZXMuICBUaGlzIHJldHVybnMgd2hhdGV2ZXIgd2FzIHBhc3NlZCB0byB0aGUgYHN0eWxlYFxuICAgKiBvcHRpb24gYXQgY29uc3RydWN0aW9uIG9yIHRvIHRoZSBgc2V0U3R5bGVgIG1ldGhvZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfG51bGx8dW5kZWZpbmVkfSBMYXllciBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258dW5kZWZpbmVkfSBMYXllciBzdHlsZSBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3R5bGVGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUZ1bmN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBsYXllciBzaG91bGQgYmUgdXBkYXRlZCB3aGlsZVxuICAgKiAgICAgYW5pbWF0aW5nLlxuICAgKi9cbiAgZ2V0VXBkYXRlV2hpbGVBbmltYXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlV2hpbGVBbmltYXRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlbmRlcmVkIGxheWVyIHNob3VsZCBiZSB1cGRhdGVkIHdoaWxlXG4gICAqICAgICBpbnRlcmFjdGluZy5cbiAgICovXG4gIGdldFVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlV2hpbGVJbnRlcmFjdGluZ187XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGRlY2x1dHRlciBpdGVtcyBmb3IgdGhpcyBsYXllclxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRGVjbHV0dGVyKGZyYW1lU3RhdGUpIHtcbiAgICBpZiAoIWZyYW1lU3RhdGUuZGVjbHV0dGVyVHJlZSkge1xuICAgICAgZnJhbWVTdGF0ZS5kZWNsdXR0ZXJUcmVlID0gbmV3IFJCdXNoKDkpO1xuICAgIH1cbiAgICAvKiogQHR5cGUgeyp9ICovICh0aGlzLmdldFJlbmRlcmVyKCkpLnJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufG51bGx8dW5kZWZpbmVkfSByZW5kZXJPcmRlclxuICAgKiAgICAgUmVuZGVyIG9yZGVyLlxuICAgKi9cbiAgc2V0UmVuZGVyT3JkZXIocmVuZGVyT3JkZXIpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5SRU5ERVJfT1JERVIsIHJlbmRlck9yZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0eWxlIGZvciBmZWF0dXJlcy4gIFRoaXMgY2FuIGJlIGEgc2luZ2xlIHN0eWxlIG9iamVjdCwgYW4gYXJyYXlcbiAgICogb2Ygc3R5bGVzLCBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBmZWF0dXJlIGFuZCByZXNvbHV0aW9uIGFuZCByZXR1cm5zXG4gICAqIGFuIGFycmF5IG9mIHN0eWxlcy4gSWYgc2V0IHRvIGBudWxsYCwgdGhlIGxheWVyIGhhcyBubyBzdHlsZSAoYSBgbnVsbGAgc3R5bGUpLFxuICAgKiBzbyBvbmx5IGZlYXR1cmVzIHRoYXQgaGF2ZSB0aGVpciBvd24gc3R5bGVzIHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIGxheWVyLiBDYWxsXG4gICAqIGBzZXRTdHlsZSgpYCB3aXRob3V0IGFyZ3VtZW50cyB0byByZXNldCB0byB0aGUgZGVmYXVsdCBzdHlsZS4gU2VlXG4gICAqIFt0aGUgb2wvc3R5bGUvU3R5bGUgbW9kdWxlXXtAbGluayBtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGV9IGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgZGVmYXVsdCBzdHlsZS5cbiAgICpcbiAgICogSWYgeW91ciBsYXllciBoYXMgYSBzdGF0aWMgc3R5bGUsIHlvdSBjYW4gdXNlIFtmbGF0IHN0eWxlXXtAbGluayBtb2R1bGU6b2wvc3R5bGUvZmxhdH5GbGF0U3R5bGV9IG9iamVjdFxuICAgKiBsaXRlcmFscyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgU3R5bGVgIGFuZCBzeW1ib2xpemVyIGNvbnN0cnVjdG9ycyAoYEZpbGxgLCBgU3Ryb2tlYCwgZXRjLik6XG4gICAqIGBgYGpzXG4gICAqIHZlY3RvckxheWVyLnNldFN0eWxlKHtcbiAgICogICBcImZpbGwtY29sb3JcIjogXCJ5ZWxsb3dcIixcbiAgICogICBcInN0cm9rZS1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAqICAgXCJzdHJva2Utd2lkdGhcIjogNFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGVMaWtlfG51bGx9IFtzdHlsZV0gTGF5ZXIgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZV8gPSB0b1N0eWxlTGlrZShzdHlsZSk7XG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9XG4gICAgICBzdHlsZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvU3R5bGVGdW5jdGlvbih0aGlzLnN0eWxlXyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2VyY2UgdGhlIGFsbG93ZWQgc3R5bGUgdHlwZXMgaW50byBhIHNob3J0ZXIgbGlzdCBvZiB0eXBlcy4gIEZsYXQgc3R5bGVzLCBhcnJheXMgb2YgZmxhdFxuICogc3R5bGVzLCBhbmQgYXJyYXlzIG9mIHJ1bGVzIGFyZSBjb252ZXJ0ZWQgaW50byBzdHlsZSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGVMaWtlfG51bGx9IFtzdHlsZV0gTGF5ZXIgc3R5bGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8bnVsbH0gVGhlIHN0eWxlLlxuICovXG5mdW5jdGlvbiB0b1N0eWxlTGlrZShzdHlsZSkge1xuICBpZiAoc3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVEZWZhdWx0U3R5bGU7XG4gIH1cbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgaWYgKHN0eWxlIGluc3RhbmNlb2YgU3R5bGUpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgIHJldHVybiBmbGF0U3R5bGVzVG9TdHlsZUZ1bmN0aW9uKFtzdHlsZV0pO1xuICB9XG4gIGlmIChzdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBzdHlsZS5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gc3R5bGVbMF07XG5cbiAgaWYgKGZpcnN0IGluc3RhbmNlb2YgU3R5bGUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgICAqL1xuICAgIGNvbnN0IHN0eWxlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHN0eWxlW2ldO1xuICAgICAgaWYgKCEoY2FuZGlkYXRlIGluc3RhbmNlb2YgU3R5bGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBsaXN0IG9mIHN0eWxlIGluc3RhbmNlcycpO1xuICAgICAgfVxuICAgICAgc3R5bGVzW2ldID0gY2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG5cbiAgaWYgKCdzdHlsZScgaW4gZmlyc3QpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSBBcnJheTxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLlJ1bGU+XG4gICAgICovXG4gICAgY29uc3QgcnVsZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBzdHlsZVtpXTtcbiAgICAgIGlmICghKCdzdHlsZScgaW4gY2FuZGlkYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgbGlzdCBvZiBydWxlcyB3aXRoIGEgc3R5bGUgcHJvcGVydHknKTtcbiAgICAgIH1cbiAgICAgIHJ1bGVzW2ldID0gY2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZXNUb1N0eWxlRnVuY3Rpb24ocnVsZXMpO1xuICB9XG5cbiAgY29uc3QgZmxhdFN0eWxlcyA9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZT59ICovIChzdHlsZSk7XG4gIHJldHVybiBmbGF0U3R5bGVzVG9TdHlsZUZ1bmN0aW9uKGZsYXRTdHlsZXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlVmVjdG9yTGF5ZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvSW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IEluc3RydWN0aW9uID0ge1xuICBCRUdJTl9HRU9NRVRSWTogMCxcbiAgQkVHSU5fUEFUSDogMSxcbiAgQ0lSQ0xFOiAyLFxuICBDTE9TRV9QQVRIOiAzLFxuICBDVVNUT006IDQsXG4gIERSQVdfQ0hBUlM6IDUsXG4gIERSQVdfSU1BR0U6IDYsXG4gIEVORF9HRU9NRVRSWTogNyxcbiAgRklMTDogOCxcbiAgTU9WRV9UT19MSU5FX1RPOiA5LFxuICBTRVRfRklMTF9TVFlMRTogMTAsXG4gIFNFVF9TVFJPS0VfU1RZTEU6IDExLFxuICBTVFJPS0U6IDEyLFxufTtcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8SW5zdHJ1Y3Rpb24+fVxuICovXG5leHBvcnQgY29uc3QgZmlsbEluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLkZJTExdO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJva2VJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5TVFJPS0VdO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCBjb25zdCBiZWdpblBhdGhJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5CRUdJTl9QQVRIXTtcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8SW5zdHJ1Y3Rpb24+fVxuICovXG5leHBvcnQgY29uc3QgY2xvc2VQYXRoSW5zdHJ1Y3Rpb24gPSBbSW5zdHJ1Y3Rpb24uQ0xPU0VfUEFUSF07XG5cbmV4cG9ydCBkZWZhdWx0IEluc3RydWN0aW9uO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvVmVjdG9yQ29udGV4dFxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ29udGV4dCBmb3IgZHJhd2luZyBnZW9tZXRyaWVzLiAgQSB2ZWN0b3IgY29udGV4dCBpcyBhdmFpbGFibGUgb24gcmVuZGVyXG4gKiBldmVudHMgYW5kIGRvZXMgbm90IG5lZWQgdG8gYmUgY29uc3RydWN0ZWQgZGlyZWN0bHkuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFZlY3RvckNvbnRleHQge1xuICAvKipcbiAgICogUmVuZGVyIGEgZ2VvbWV0cnkgd2l0aCBhIGN1c3RvbSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVuZGVyZXIgUmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhpdERldGVjdGlvblJlbmRlcmVyIFJlbmRlcmVyLlxuICAgKi9cbiAgZHJhd0N1c3RvbShnZW9tZXRyeSwgZmVhdHVyZSwgcmVuZGVyZXIsIGhpdERldGVjdGlvblJlbmRlcmVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBnZW9tZXRyeS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFRoZSBnZW9tZXRyeSB0byByZW5kZXIuXG4gICAqL1xuICBkcmF3R2VvbWV0cnkoZ2VvbWV0cnkpIHt9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVuZGVyaW5nIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBjaXJjbGVHZW9tZXRyeSBDaXJjbGUgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3Q2lyY2xlKGNpcmNsZUdlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICAgKi9cbiAgZHJhd0ZlYXR1cmUoZmVhdHVyZSwgc3R5bGUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkgR2VvbWV0cnkgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGxpbmVTdHJpbmdHZW9tZXRyeSBMaW5lIHN0cmluZyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3TGluZVN0cmluZyhsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gbXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkgTXVsdGlMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdNdWx0aUxpbmVTdHJpbmcobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IG11bHRpUG9pbnRHZW9tZXRyeSBNdWx0aVBvaW50IGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdNdWx0aVBvaW50KG11bHRpUG9pbnRHZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBtdWx0aVBvbHlnb25HZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd011bHRpUG9seWdvbihtdWx0aVBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IHBvaW50R2VvbWV0cnkgUG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvaW50KHBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IHBvbHlnb25HZW9tZXRyeSBQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdQb2x5Z29uKHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbFN0eWxlIEZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IHN0cm9rZVN0eWxlIFN0cm9rZSBzdHlsZS5cbiAgICovXG4gIHNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlU3R5bGUgSW1hZ2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJJbWFnZVdpdGhUZXh0fSBbZGVjbHV0dGVySW1hZ2VXaXRoVGV4dF0gU2hhcmVkIGRhdGEgZm9yIGNvbWJpbmVkIGRlY2x1dHRlcmluZyB3aXRoIGEgdGV4dCBzdHlsZS5cbiAgICovXG4gIHNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9UZXh0LmpzXCIpLmRlZmF1bHR9IHRleHRTdHlsZSBUZXh0IHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMuanNcIikuRGVjbHV0dGVySW1hZ2VXaXRoVGV4dH0gW2RlY2x1dHRlckltYWdlV2l0aFRleHRdIFNoYXJlZCBkYXRhIGZvciBjb21iaW5lZCBkZWNsdXR0ZXJpbmcgd2l0aCBhbiBpbWFnZSBzdHlsZS5cbiAgICovXG4gIHNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIGRlY2x1dHRlckltYWdlV2l0aFRleHQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvckNvbnRleHQ7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvQnVpbGRlclxuICovXG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24gZnJvbSAnLi9JbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQgUmVsYXRpb25zaGlwIGZyb20gJy4uLy4uL2V4dGVudC9SZWxhdGlvbnNoaXAuanMnO1xuaW1wb3J0IFZlY3RvckNvbnRleHQgZnJvbSAnLi4vVmVjdG9yQ29udGV4dC5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi8uLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtcbiAgYnVmZmVyLFxuICBjbG9uZSxcbiAgY29udGFpbnNDb29yZGluYXRlLFxuICBjb29yZGluYXRlUmVsYXRpb25zaGlwLFxufSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtcbiAgZGVmYXVsdEZpbGxTdHlsZSxcbiAgZGVmYXVsdExpbmVDYXAsXG4gIGRlZmF1bHRMaW5lRGFzaCxcbiAgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxuICBkZWZhdWx0TGluZUpvaW4sXG4gIGRlZmF1bHRMaW5lV2lkdGgsXG4gIGRlZmF1bHRNaXRlckxpbWl0LFxuICBkZWZhdWx0U3Ryb2tlU3R5bGUsXG59IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQge2VxdWFscywgcmV2ZXJzZVN1YkFycmF5fSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge1xuICBpbmZsYXRlQ29vcmRpbmF0ZXMsXG4gIGluZmxhdGVDb29yZGluYXRlc0FycmF5LFxuICBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5LFxufSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyc7XG5cbmNsYXNzIENhbnZhc0J1aWxkZXIgZXh0ZW5kcyBWZWN0b3JDb250ZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IG1heEV4dGVudCBNYXhpbXVtIGV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZSA9IHRvbGVyYW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLm1heEV4dGVudCA9IG1heEV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heExpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24xXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5idWZmZXJlZE1heEV4dGVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcENvb3JkaW5hdGVfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gKi8gKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGFzaEFycmF5IERhc2ggYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IERhc2ggYXJyYXkgd2l0aCBwaXhlbCByYXRpbyBhcHBsaWVkXG4gICAqL1xuICBhcHBseVBpeGVsUmF0aW8oZGFzaEFycmF5KSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICByZXR1cm4gcGl4ZWxSYXRpbyA9PSAxXG4gICAgICA/IGRhc2hBcnJheVxuICAgICAgOiBkYXNoQXJyYXkubWFwKGZ1bmN0aW9uIChkYXNoKSB7XG4gICAgICAgICAgcmV0dXJuIGRhc2ggKiBwaXhlbFJhdGlvO1xuICAgICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE15IGVuZFxuICAgKi9cbiAgYXBwZW5kRmxhdFBvaW50Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBzdHJpZGUpIHtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkTWF4RXh0ZW50KCk7XG4gICAgY29uc3QgdG1wQ29vcmQgPSB0aGlzLnRtcENvb3JkaW5hdGVfO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5jb29yZGluYXRlcztcbiAgICBsZXQgbXlFbmQgPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IHN0cmlkZSkge1xuICAgICAgdG1wQ29vcmRbMF0gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICB0bXBDb29yZFsxXSA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBpZiAoY29udGFpbnNDb29yZGluYXRlKGV4dGVudCwgdG1wQ29vcmQpKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzW215RW5kKytdID0gdG1wQ29vcmRbMF07XG4gICAgICAgIGNvb3JkaW5hdGVzW215RW5kKytdID0gdG1wQ29vcmRbMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBteUVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlZCBMYXN0IGlucHV0IGNvb3JkaW5hdGUgZXF1YWxzIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBGaXJzdCBTa2lwIGZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7bnVtYmVyfSBNeSBlbmQuXG4gICAqL1xuICBhcHBlbmRGbGF0TGluZUNvb3JkaW5hdGVzKFxuICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICBvZmZzZXQsXG4gICAgZW5kLFxuICAgIHN0cmlkZSxcbiAgICBjbG9zZWQsXG4gICAgc2tpcEZpcnN0XG4gICkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5jb29yZGluYXRlcztcbiAgICBsZXQgbXlFbmQgPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5nZXRCdWZmZXJlZE1heEV4dGVudCgpO1xuICAgIGlmIChza2lwRmlyc3QpIHtcbiAgICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgfVxuICAgIGxldCBsYXN0WENvb3JkID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgbGV0IGxhc3RZQ29vcmQgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgY29uc3QgbmV4dENvb3JkID0gdGhpcy50bXBDb29yZGluYXRlXztcbiAgICBsZXQgc2tpcHBlZCA9IHRydWU7XG5cbiAgICBsZXQgaSwgbGFzdFJlbCwgbmV4dFJlbDtcbiAgICBmb3IgKGkgPSBvZmZzZXQgKyBzdHJpZGU7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBuZXh0Q29vcmRbMF0gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICBuZXh0Q29vcmRbMV0gPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgbmV4dFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBuZXh0Q29vcmQpO1xuICAgICAgaWYgKG5leHRSZWwgIT09IGxhc3RSZWwpIHtcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICBjb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RYQ29vcmQ7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBsYXN0WUNvb3JkO1xuICAgICAgICAgIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFswXTtcbiAgICAgICAgY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMV07XG4gICAgICB9IGVsc2UgaWYgKG5leHRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcpIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMF07XG4gICAgICAgIGNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzFdO1xuICAgICAgICBza2lwcGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RYQ29vcmQgPSBuZXh0Q29vcmRbMF07XG4gICAgICBsYXN0WUNvb3JkID0gbmV4dENvb3JkWzFdO1xuICAgICAgbGFzdFJlbCA9IG5leHRSZWw7XG4gICAgfVxuXG4gICAgLy8gTGFzdCBjb29yZGluYXRlIGVxdWFscyBmaXJzdCBvciBvbmx5IG9uZSBwb2ludCB0byBhcHBlbmQ6XG4gICAgaWYgKChjbG9zZWQgJiYgc2tpcHBlZCkgfHwgaSA9PT0gb2Zmc2V0ICsgc3RyaWRlKSB7XG4gICAgICBjb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RYQ29vcmQ7XG4gICAgICBjb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RZQ29vcmQ7XG4gICAgfVxuICAgIHJldHVybiBteUVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJ1aWxkZXJFbmRzIEJ1aWxkZXIgZW5kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBPZmZzZXQuXG4gICAqL1xuICBkcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIGJ1aWxkZXJFbmRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgICAgY29uc3QgYnVpbGRlckVuZCA9IHRoaXMuYXBwZW5kRmxhdExpbmVDb29yZGluYXRlcyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBidWlsZGVyRW5kcy5wdXNoKGJ1aWxkZXJFbmQpO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbmRlcmVyIFJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoaXREZXRlY3Rpb25SZW5kZXJlciBSZW5kZXJlci5cbiAgICovXG4gIGRyYXdDdXN0b20oZ2VvbWV0cnksIGZlYXR1cmUsIHJlbmRlcmVyLCBoaXREZXRlY3Rpb25SZW5kZXJlcikge1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG5cbiAgICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAgIGNvbnN0IHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIGNvbnN0IGJ1aWxkZXJCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuXG4gICAgbGV0IGZsYXRDb29yZGluYXRlcywgYnVpbGRlckVuZCwgYnVpbGRlckVuZHMsIGJ1aWxkZXJFbmRzcztcbiAgICBsZXQgb2Zmc2V0O1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPVxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICApLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICAgIGJ1aWxkZXJFbmRzcyA9IFtdO1xuICAgICAgICBjb25zdCBlbmRzcyA9XG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICkuZ2V0RW5kc3MoKTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgIGNvbnN0IG15RW5kcyA9IFtdO1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZHJhd0N1c3RvbUNvb3JkaW5hdGVzXyhcbiAgICAgICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIGVuZHNzW2ldLFxuICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgbXlFbmRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBidWlsZGVyRW5kc3MucHVzaChteUVuZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICBidWlsZGVyQmVnaW4sXG4gICAgICAgICAgYnVpbGRlckVuZHNzLFxuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXksXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgICAgYnVpbGRlckJlZ2luLFxuICAgICAgICAgIGJ1aWxkZXJFbmRzcyxcbiAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICBoaXREZXRlY3Rpb25SZW5kZXJlciB8fCByZW5kZXJlcixcbiAgICAgICAgICBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5LFxuICAgICAgICBdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgIGJ1aWxkZXJFbmRzID0gW107XG4gICAgICAgIGZsYXRDb29yZGluYXRlcyA9XG4gICAgICAgICAgdHlwZSA9PSAnUG9seWdvbidcbiAgICAgICAgICAgID8gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgICAgICkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKVxuICAgICAgICAgICAgOiBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfKFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICApLmdldEVuZHMoKSxcbiAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgYnVpbGRlckVuZHNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICBidWlsZGVyRW5kcyxcbiAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICBidWlsZGVyQmVnaW4sXG4gICAgICAgICAgYnVpbGRlckVuZHMsXG4gICAgICAgICAgZ2VvbWV0cnksXG4gICAgICAgICAgaGl0RGV0ZWN0aW9uUmVuZGVyZXIgfHwgcmVuZGVyZXIsXG4gICAgICAgICAgaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXksXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgY2FzZSAnQ2lyY2xlJzpcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICAgIGJ1aWxkZXJFbmQgPSB0aGlzLmFwcGVuZEZsYXRMaW5lQ29vcmRpbmF0ZXMoXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICBidWlsZGVyRW5kLFxuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgIGluZmxhdGVDb29yZGluYXRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICBidWlsZGVyQmVnaW4sXG4gICAgICAgICAgYnVpbGRlckVuZCxcbiAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICBoaXREZXRlY3Rpb25SZW5kZXJlciB8fCByZW5kZXJlcixcbiAgICAgICAgICBpbmZsYXRlQ29vcmRpbmF0ZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgYnVpbGRlckVuZCA9IHRoaXMuYXBwZW5kRmxhdFBvaW50Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBzdHJpZGUpO1xuXG4gICAgICAgIGlmIChidWlsZGVyRW5kID4gYnVpbGRlckJlZ2luKSB7XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgICAgICBidWlsZGVyQmVnaW4sXG4gICAgICAgICAgICBidWlsZGVyRW5kLFxuICAgICAgICAgICAgZ2VvbWV0cnksXG4gICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgIGluZmxhdGVDb29yZGluYXRlcyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICAgIGJ1aWxkZXJFbmQsXG4gICAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICAgIGhpdERldGVjdGlvblJlbmRlcmVyIHx8IHJlbmRlcmVyLFxuICAgICAgICAgICAgaW5mbGF0ZUNvb3JkaW5hdGVzLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcy5wdXNoKGZsYXRDb29yZGluYXRlc1swXSwgZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgYnVpbGRlckVuZCA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICBidWlsZGVyQmVnaW4sXG4gICAgICAgICAgYnVpbGRlckVuZCxcbiAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICBidWlsZGVyQmVnaW4sXG4gICAgICAgICAgYnVpbGRlckVuZCxcbiAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICBoaXREZXRlY3Rpb25SZW5kZXJlciB8fCByZW5kZXJlcixcbiAgICAgICAgXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgdGhpcy5lbmRHZW9tZXRyeShmZWF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeVwiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGJlZ2luR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfID0gW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlksXG4gICAgICBmZWF0dXJlLFxuICAgICAgMCxcbiAgICAgIGdlb21ldHJ5LFxuICAgIF07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfKTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfID0gW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlksXG4gICAgICBmZWF0dXJlLFxuICAgICAgMCxcbiAgICAgIGdlb21ldHJ5LFxuICAgIF07XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaCh0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU2VyaWFsaXphYmxlSW5zdHJ1Y3Rpb25zfSB0aGUgc2VyaWFsaXphYmxlIGluc3RydWN0aW9ucy5cbiAgICovXG4gIGZpbmlzaCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgIGhpdERldGVjdGlvbkluc3RydWN0aW9uczogdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMsXG4gICAgICBjb29yZGluYXRlczogdGhpcy5jb29yZGluYXRlcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldmVyc2UgdGhlIGhpdCBkZXRlY3Rpb24gaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgcmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucygpIHtcbiAgICBjb25zdCBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgPSB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucztcbiAgICAvLyBzdGVwIDEgLSByZXZlcnNlIGFycmF5XG4gICAgaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnJldmVyc2UoKTtcbiAgICAvLyBzdGVwIDIgLSByZXZlcnNlIGluc3RydWN0aW9ucyB3aXRoaW4gZ2VvbWV0cnkgYmxvY2tzXG4gICAgbGV0IGk7XG4gICAgY29uc3QgbiA9IGhpdERldGVjdGlvbkluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgbGV0IGluc3RydWN0aW9uO1xuICAgIGxldCB0eXBlO1xuICAgIGxldCBiZWdpbiA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGluc3RydWN0aW9uID0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdHlwZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnN0cnVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoaW5zdHJ1Y3Rpb25bMF0pO1xuICAgICAgaWYgKHR5cGUgPT0gQ2FudmFzSW5zdHJ1Y3Rpb24uRU5EX0dFT01FVFJZKSB7XG4gICAgICAgIGJlZ2luID0gaTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBDYW52YXNJbnN0cnVjdGlvbi5CRUdJTl9HRU9NRVRSWSkge1xuICAgICAgICBpbnN0cnVjdGlvblsyXSA9IGk7XG4gICAgICAgIHJldmVyc2VTdWJBcnJheSh0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucywgYmVnaW4sIGkpO1xuICAgICAgICBiZWdpbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbFN0eWxlIEZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IHN0cm9rZVN0eWxlIFN0cm9rZSBzdHlsZS5cbiAgICovXG4gIHNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChmaWxsU3R5bGUpIHtcbiAgICAgIGNvbnN0IGZpbGxTdHlsZUNvbG9yID0gZmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICBzdGF0ZS5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShcbiAgICAgICAgZmlsbFN0eWxlQ29sb3IgPyBmaWxsU3R5bGVDb2xvciA6IGRlZmF1bHRGaWxsU3R5bGVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmZpbGxTdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUNvbG9yID0gc3Ryb2tlU3R5bGUuZ2V0Q29sb3IoKTtcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgIHN0cm9rZVN0eWxlQ29sb3IgPyBzdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlXG4gICAgICApO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lQ2FwID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpO1xuICAgICAgc3RhdGUubGluZUNhcCA9XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZUNhcCAhPT0gdW5kZWZpbmVkID8gc3Ryb2tlU3R5bGVMaW5lQ2FwIDogZGVmYXVsdExpbmVDYXA7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUxpbmVEYXNoID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgIHN0YXRlLmxpbmVEYXNoID0gc3Ryb2tlU3R5bGVMaW5lRGFzaFxuICAgICAgICA/IHN0cm9rZVN0eWxlTGluZURhc2guc2xpY2UoKVxuICAgICAgICA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgPSBzdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgc3RhdGUubGluZURhc2hPZmZzZXQgPSBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0XG4gICAgICAgID8gc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldFxuICAgICAgICA6IGRlZmF1bHRMaW5lRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZUpvaW4gPSBzdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpO1xuICAgICAgc3RhdGUubGluZUpvaW4gPVxuICAgICAgICBzdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHN0cm9rZVN0eWxlTGluZUpvaW5cbiAgICAgICAgICA6IGRlZmF1bHRMaW5lSm9pbjtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlV2lkdGggPSBzdHJva2VTdHlsZS5nZXRXaWR0aCgpO1xuICAgICAgc3RhdGUubGluZVdpZHRoID1cbiAgICAgICAgc3Ryb2tlU3R5bGVXaWR0aCAhPT0gdW5kZWZpbmVkID8gc3Ryb2tlU3R5bGVXaWR0aCA6IGRlZmF1bHRMaW5lV2lkdGg7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZU1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICBzdGF0ZS5taXRlckxpbWl0ID1cbiAgICAgICAgc3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHN0cm9rZVN0eWxlTWl0ZXJMaW1pdFxuICAgICAgICAgIDogZGVmYXVsdE1pdGVyTGltaXQ7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lV2lkdGggPiB0aGlzLm1heExpbmVXaWR0aCkge1xuICAgICAgICB0aGlzLm1heExpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aDtcbiAgICAgICAgLy8gaW52YWxpZGF0ZSB0aGUgYnVmZmVyZWQgbWF4IGV4dGVudCBjYWNoZVxuICAgICAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZUNhcCA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLmxpbmVEYXNoID0gbnVsbDtcbiAgICAgIHN0YXRlLmxpbmVEYXNoT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZUpvaW4gPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lV2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5taXRlckxpbWl0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcmV0dXJuIHtBcnJheTwqPn0gRmlsbCBpbnN0cnVjdGlvbi5cbiAgICovXG4gIGNyZWF0ZUZpbGwoc3RhdGUpIHtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi9cbiAgICBjb25zdCBmaWxsSW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsIGZpbGxTdHlsZV07XG4gICAgaWYgKHR5cGVvZiBmaWxsU3R5bGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBGaWxsIGlzIGEgcGF0dGVybiBvciBncmFkaWVudCAtIGFsaWduIGl0IVxuICAgICAgZmlsbEluc3RydWN0aW9uLnB1c2godHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxsSW5zdHJ1Y3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICovXG4gIGFwcGx5U3Ryb2tlKHN0YXRlKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNyZWF0ZVN0cm9rZShzdGF0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEByZXR1cm4ge0FycmF5PCo+fSBTdHJva2UgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBjcmVhdGVTdHJva2Uoc3RhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRSxcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgc3RhdGUubGluZVdpZHRoICogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgc3RhdGUubGluZUNhcCxcbiAgICAgIHN0YXRlLmxpbmVKb2luLFxuICAgICAgc3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgIHRoaXMuYXBwbHlQaXhlbFJhdGlvKHN0YXRlLmxpbmVEYXNoKSxcbiAgICAgIHN0YXRlLmxpbmVEYXNoT2Zmc2V0ICogdGhpcy5waXhlbFJhdGlvLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOkNhbnZhc0J1aWxkZXIsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGUpOkFycmF5PCo+fSBjcmVhdGVGaWxsIENyZWF0ZSBmaWxsLlxuICAgKi9cbiAgdXBkYXRlRmlsbFN0eWxlKHN0YXRlLCBjcmVhdGVGaWxsKSB7XG4gICAgY29uc3QgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGlmICh0eXBlb2YgZmlsbFN0eWxlICE9PSAnc3RyaW5nJyB8fCBzdGF0ZS5jdXJyZW50RmlsbFN0eWxlICE9IGZpbGxTdHlsZSkge1xuICAgICAgaWYgKGZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goY3JlYXRlRmlsbC5jYWxsKHRoaXMsIHN0YXRlKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jdXJyZW50RmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6Q2FudmFzQnVpbGRlciwgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZSk6IHZvaWR9IGFwcGx5U3Ryb2tlIEFwcGx5IHN0cm9rZS5cbiAgICovXG4gIHVwZGF0ZVN0cm9rZVN0eWxlKHN0YXRlLCBhcHBseVN0cm9rZSkge1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgY29uc3QgbGluZUNhcCA9IHN0YXRlLmxpbmVDYXA7XG4gICAgY29uc3QgbGluZURhc2ggPSBzdGF0ZS5saW5lRGFzaDtcbiAgICBjb25zdCBsaW5lRGFzaE9mZnNldCA9IHN0YXRlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIGNvbnN0IGxpbmVKb2luID0gc3RhdGUubGluZUpvaW47XG4gICAgY29uc3QgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgIGNvbnN0IG1pdGVyTGltaXQgPSBzdGF0ZS5taXRlckxpbWl0O1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSAhPSBzdHJva2VTdHlsZSB8fFxuICAgICAgc3RhdGUuY3VycmVudExpbmVDYXAgIT0gbGluZUNhcCB8fFxuICAgICAgKGxpbmVEYXNoICE9IHN0YXRlLmN1cnJlbnRMaW5lRGFzaCAmJlxuICAgICAgICAhZXF1YWxzKHN0YXRlLmN1cnJlbnRMaW5lRGFzaCwgbGluZURhc2gpKSB8fFxuICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoT2Zmc2V0ICE9IGxpbmVEYXNoT2Zmc2V0IHx8XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZUpvaW4gIT0gbGluZUpvaW4gfHxcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lV2lkdGggIT0gbGluZVdpZHRoIHx8XG4gICAgICBzdGF0ZS5jdXJyZW50TWl0ZXJMaW1pdCAhPSBtaXRlckxpbWl0XG4gICAgKSB7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcHBseVN0cm9rZS5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIHN0YXRlLmN1cnJlbnRNaXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBlbmRHZW9tZXRyeShmZWF0dXJlKSB7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24xX1syXSA9IHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aDtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfID0gbnVsbDtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfWzJdID0gdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMubGVuZ3RoO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8gPSBudWxsO1xuICAgIGNvbnN0IGVuZEdlb21ldHJ5SW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uRU5EX0dFT01FVFJZLCBmZWF0dXJlXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGVuZEdlb21ldHJ5SW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goZW5kR2VvbWV0cnlJbnN0cnVjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXJlZCByZW5kZXJpbmcgZXh0ZW50LiAgUmVuZGVyaW5nIHdpbGwgYmUgY2xpcHBlZCB0byB0aGUgZXh0ZW50XG4gICAqIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gIFRvIGFjY291bnQgZm9yIHN5bWJvbGl6ZXJzIHRoYXQgbWF5IGludGVyc2VjdFxuICAgKiB0aGlzIGV4dGVudCwgd2UgY2FsY3VsYXRlIGEgYnVmZmVyZWQgZXh0ZW50IChlLmcuIGJhc2VkIG9uIHN0cm9rZSB3aWR0aCkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBidWZmZXJlZCByZW5kZXJpbmcgZXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRCdWZmZXJlZE1heEV4dGVudCgpIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IGNsb25lKHRoaXMubWF4RXh0ZW50KTtcbiAgICAgIGlmICh0aGlzLm1heExpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSAodGhpcy5yZXNvbHV0aW9uICogKHRoaXMubWF4TGluZVdpZHRoICsgMSkpIC8gMjtcbiAgICAgICAgYnVmZmVyKHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfLCB3aWR0aCwgdGhpcy5idWZmZXJlZE1heEV4dGVudF8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5idWZmZXJlZE1heEV4dGVudF87XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzQnVpbGRlcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9JbWFnZUJ1aWxkZXJcbiAqL1xuaW1wb3J0IENhbnZhc0J1aWxkZXIgZnJvbSAnLi9CdWlsZGVyLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcblxuY2xhc3MgQ2FudmFzSW1hZ2VCdWlsZGVyIGV4dGVuZHMgQ2FudmFzQnVpbGRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4aW11bSBleHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKi9cbiAgY29uc3RydWN0b3IodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pIHtcbiAgICBzdXBlcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlUGl4ZWxSYXRpb18gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5YXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5ZXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGhfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIHNoYXJlZCB3aXRoIGEgdGV4dCBidWlsZGVyIGZvciBjb21iaW5lZCBkZWNsdXR0ZXJpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckltYWdlV2l0aFRleHR9XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IHBvaW50R2VvbWV0cnkgUG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvaW50KHBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShwb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBwb2ludEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IHBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IG15RW5kID0gdGhpcy5hcHBlbmRGbGF0UG9pbnRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLFxuICAgICAgbXlCZWdpbixcbiAgICAgIG15RW5kLFxuICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMuYW5jaG9yWV8gKiB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBNYXRoLmNlaWwodGhpcy5oZWlnaHRfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMub3BhY2l0eV8sXG4gICAgICB0aGlzLm9yaWdpblhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fLFxuICAgICAgdGhpcy5vcmlnaW5ZXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMucm90YXRlV2l0aFZpZXdfLFxuICAgICAgdGhpcy5yb3RhdGlvbl8sXG4gICAgICBbXG4gICAgICAgICh0aGlzLnNjYWxlX1swXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICAgICh0aGlzLnNjYWxlX1sxXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBdLFxuICAgICAgTWF0aC5jZWlsKHRoaXMud2lkdGhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8sXG4gICAgICB0aGlzLmRlY2x1dHRlckltYWdlV2l0aFRleHRfLFxuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSxcbiAgICAgIG15QmVnaW4sXG4gICAgICBteUVuZCxcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfLFxuICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyB0byBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgIHRoaXMuYW5jaG9yWF8sXG4gICAgICB0aGlzLmFuY2hvcllfLFxuICAgICAgdGhpcy5oZWlnaHRfLFxuICAgICAgMSxcbiAgICAgIHRoaXMub3JpZ2luWF8sXG4gICAgICB0aGlzLm9yaWdpbllfLFxuICAgICAgdGhpcy5yb3RhdGVXaXRoVmlld18sXG4gICAgICB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfLFxuICAgICAgdGhpcy53aWR0aF8sXG4gICAgICB0aGlzLmRlY2x1dHRlck1vZGVfLFxuICAgICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyxcbiAgICBdKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBtdWx0aVBvaW50R2VvbWV0cnkgTXVsdGlQb2ludCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3TXVsdGlQb2ludChtdWx0aVBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShtdWx0aVBvaW50R2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IG11bHRpUG9pbnRHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBtdWx0aVBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IG15RW5kID0gdGhpcy5hcHBlbmRGbGF0UG9pbnRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLFxuICAgICAgbXlCZWdpbixcbiAgICAgIG15RW5kLFxuICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMuYW5jaG9yWV8gKiB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBNYXRoLmNlaWwodGhpcy5oZWlnaHRfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMub3BhY2l0eV8sXG4gICAgICB0aGlzLm9yaWdpblhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fLFxuICAgICAgdGhpcy5vcmlnaW5ZXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMucm90YXRlV2l0aFZpZXdfLFxuICAgICAgdGhpcy5yb3RhdGlvbl8sXG4gICAgICBbXG4gICAgICAgICh0aGlzLnNjYWxlX1swXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICAgICh0aGlzLnNjYWxlX1sxXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBdLFxuICAgICAgTWF0aC5jZWlsKHRoaXMud2lkdGhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8sXG4gICAgICB0aGlzLmRlY2x1dHRlckltYWdlV2l0aFRleHRfLFxuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSxcbiAgICAgIG15QmVnaW4sXG4gICAgICBteUVuZCxcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfLFxuICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyB0byBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgIHRoaXMuYW5jaG9yWF8sXG4gICAgICB0aGlzLmFuY2hvcllfLFxuICAgICAgdGhpcy5oZWlnaHRfLFxuICAgICAgMSxcbiAgICAgIHRoaXMub3JpZ2luWF8sXG4gICAgICB0aGlzLm9yaWdpbllfLFxuICAgICAgdGhpcy5yb3RhdGVXaXRoVmlld18sXG4gICAgICB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfLFxuICAgICAgdGhpcy53aWR0aF8sXG4gICAgICB0aGlzLmRlY2x1dHRlck1vZGVfLFxuICAgICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyxcbiAgICBdKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TZXJpYWxpemFibGVJbnN0cnVjdGlvbnN9IHRoZSBzZXJpYWxpemFibGUgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIHRoaXMucmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucygpO1xuICAgIC8vIEZJWE1FIHRoaXMgZG9lc24ndCByZWFsbHkgcHJvdGVjdCB1cyBhZ2FpbnN0IGZ1cnRoZXIgY2FsbHMgdG8gZHJhdypHZW9tZXRyeVxuICAgIHRoaXMuYW5jaG9yWF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hbmNob3JZXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IG51bGw7XG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcGFjaXR5XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9yaWdpblhfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3JpZ2luWV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aF8gPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN1cGVyLmZpbmlzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2VTdHlsZSBJbWFnZSBzdHlsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzaGFyZWREYXRhXSBTaGFyZWQgZGF0YS5cbiAgICovXG4gIHNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgc2hhcmVkRGF0YSkge1xuICAgIGNvbnN0IGFuY2hvciA9IGltYWdlU3R5bGUuZ2V0QW5jaG9yKCk7XG4gICAgY29uc3Qgc2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgIGNvbnN0IG9yaWdpbiA9IGltYWdlU3R5bGUuZ2V0T3JpZ2luKCk7XG4gICAgdGhpcy5pbWFnZVBpeGVsUmF0aW9fID0gaW1hZ2VTdHlsZS5nZXRQaXhlbFJhdGlvKHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5hbmNob3JYXyA9IGFuY2hvclswXTtcbiAgICB0aGlzLmFuY2hvcllfID0gYW5jaG9yWzFdO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gaW1hZ2VTdHlsZS5nZXRIaXREZXRlY3Rpb25JbWFnZSgpO1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2VTdHlsZS5nZXRJbWFnZSh0aGlzLnBpeGVsUmF0aW8pO1xuICAgIHRoaXMuaGVpZ2h0XyA9IHNpemVbMV07XG4gICAgdGhpcy5vcGFjaXR5XyA9IGltYWdlU3R5bGUuZ2V0T3BhY2l0eSgpO1xuICAgIHRoaXMub3JpZ2luWF8gPSBvcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZXyA9IG9yaWdpblsxXTtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IGltYWdlU3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IGltYWdlU3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICB0aGlzLnNjYWxlXyA9IGltYWdlU3R5bGUuZ2V0U2NhbGVBcnJheSgpO1xuICAgIHRoaXMud2lkdGhfID0gc2l6ZVswXTtcbiAgICB0aGlzLmRlY2x1dHRlck1vZGVfID0gaW1hZ2VTdHlsZS5nZXREZWNsdXR0ZXJNb2RlKCk7XG4gICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyA9IHNoYXJlZERhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzSW1hZ2VCdWlsZGVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0xpbmVTdHJpbmdCdWlsZGVyXG4gKi9cbmltcG9ydCBDYW52YXNCdWlsZGVyIGZyb20gJy4vQnVpbGRlci5qcyc7XG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24sIHtcbiAgYmVnaW5QYXRoSW5zdHJ1Y3Rpb24sXG4gIHN0cm9rZUluc3RydWN0aW9uLFxufSBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7ZGVmYXVsdExpbmVEYXNoLCBkZWZhdWx0TGluZURhc2hPZmZzZXR9IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5cbmNsYXNzIENhbnZhc0xpbmVTdHJpbmdCdWlsZGVyIGV4dGVuZHMgQ2FudmFzQnVpbGRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4aW11bSBleHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKi9cbiAgY29uc3RydWN0b3IodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pIHtcbiAgICBzdXBlcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBlbmQuXG4gICAqL1xuICBkcmF3RmxhdENvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgICBjb25zdCBteUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgY29uc3QgbXlFbmQgPSB0aGlzLmFwcGVuZEZsYXRMaW5lQ29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBjb25zdCBtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbiA9IFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLk1PVkVfVE9fTElORV9UTyxcbiAgICAgIG15QmVnaW4sXG4gICAgICBteUVuZCxcbiAgICBdO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgIHJldHVybiBlbmQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGxpbmVTdHJpbmdHZW9tZXRyeSBMaW5lIHN0cmluZyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3TGluZVN0cmluZyhsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBjb25zdCBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgaWYgKHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQgfHwgbGluZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KGxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChcbiAgICAgIFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRSxcbiAgICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsXG4gICAgICAgIHN0YXRlLmxpbmVXaWR0aCxcbiAgICAgICAgc3RhdGUubGluZUNhcCxcbiAgICAgICAgc3RhdGUubGluZUpvaW4sXG4gICAgICAgIHN0YXRlLm1pdGVyTGltaXQsXG4gICAgICAgIGRlZmF1bHRMaW5lRGFzaCxcbiAgICAgICAgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxuICAgICAgXSxcbiAgICAgIGJlZ2luUGF0aEluc3RydWN0aW9uXG4gICAgKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBsaW5lU3RyaW5nR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gbGluZVN0cmluZ0dlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc18oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHN0cmlkZVxuICAgICk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5lbmRHZW9tZXRyeShmZWF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd011bHRpTGluZVN0cmluZyhtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aDtcbiAgICBpZiAoc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCB8fCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0cm9rZVN0eWxlKHN0YXRlLCB0aGlzLmFwcGx5U3Ryb2tlKTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goXG4gICAgICBbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICBzdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIHN0YXRlLmxpbmVDYXAsXG4gICAgICAgIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBkZWZhdWx0TGluZURhc2gsXG4gICAgICAgIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgIF0sXG4gICAgICBiZWdpblBhdGhJbnN0cnVjdGlvblxuICAgICk7XG4gICAgY29uc3QgZW5kcyA9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LmdldEVuZHMoKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc18oXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuZHNbaV0pLFxuICAgICAgICBzdHJpZGVcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9uc30gdGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmxhc3RTdHJva2UgIT0gdW5kZWZpbmVkICYmXG4gICAgICBzdGF0ZS5sYXN0U3Ryb2tlICE9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIHN1cGVyLmZpbmlzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqL1xuICBhcHBseVN0cm9rZShzdGF0ZSkge1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmxhc3RTdHJva2UgIT0gdW5kZWZpbmVkICYmXG4gICAgICBzdGF0ZS5sYXN0U3Ryb2tlICE9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHN0YXRlLmxhc3RTdHJva2UgPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGUubGFzdFN0cm9rZSA9IDA7XG4gICAgc3VwZXIuYXBwbHlTdHJva2Uoc3RhdGUpO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0xpbmVTdHJpbmdCdWlsZGVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL1BvbHlnb25CdWlsZGVyXG4gKi9cbmltcG9ydCBDYW52YXNCdWlsZGVyIGZyb20gJy4vQnVpbGRlci5qcyc7XG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24sIHtcbiAgYmVnaW5QYXRoSW5zdHJ1Y3Rpb24sXG4gIGNsb3NlUGF0aEluc3RydWN0aW9uLFxuICBmaWxsSW5zdHJ1Y3Rpb24sXG4gIHN0cm9rZUluc3RydWN0aW9uLFxufSBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7XG4gIGRlZmF1bHRGaWxsU3R5bGUsXG4gIGRlZmF1bHRMaW5lRGFzaCxcbiAgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxufSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IHtzbmFwfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG5jbGFzcyBDYW52YXNQb2x5Z29uQnVpbGRlciBleHRlbmRzIENhbnZhc0J1aWxkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gZXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gICAgc3VwZXIodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICAgKi9cbiAgZHJhd0ZsYXRDb29yZGluYXRlc3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZmlsbCA9IHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN0cm9rZSA9IHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbnVtRW5kcyA9IGVuZHMubGVuZ3RoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRW5kczsgKytpKSB7XG4gICAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgY29uc3QgbXlFbmQgPSB0aGlzLmFwcGVuZEZsYXRMaW5lQ29vcmRpbmF0ZXMoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgIXN0cm9rZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1vdmVUb0xpbmVUb0luc3RydWN0aW9uID0gW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5NT1ZFX1RPX0xJTkVfVE8sXG4gICAgICAgIG15QmVnaW4sXG4gICAgICAgIG15RW5kLFxuICAgICAgXTtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogb25seSBjYWxsIGNsb3NlUGF0aCgpIHdoZW4gd2UgaGF2ZSBhIHN0cm9rZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSByaW5nIGlzIGNsb3NlZCBhbHJlYWR5IChzZWUgYXBwZW5kRmxhdExpbmVDb29yZGluYXRlcyBhYm92ZSkuXG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goY2xvc2VQYXRoSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGNsb3NlUGF0aEluc3RydWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goZmlsbEluc3RydWN0aW9uKTtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goZmlsbEluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZUdlb21ldHJ5IENpcmNsZSBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdDaXJjbGUoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSA9PT0gdW5kZWZpbmVkICYmIHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGVzXygpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShjaXJjbGVHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsXG4gICAgICAgIGRlZmF1bHRGaWxsU3R5bGUsXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSxcbiAgICAgICAgc3RhdGUubGluZVdpZHRoLFxuICAgICAgICBzdGF0ZS5saW5lQ2FwLFxuICAgICAgICBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgICAgZGVmYXVsdExpbmVEYXNoLFxuICAgICAgICBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICBdKTtcbiAgICB9XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gY2lyY2xlR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gY2lyY2xlR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHRoaXMuYXBwZW5kRmxhdExpbmVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgc3RyaWRlLFxuICAgICAgZmFsc2UsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgY2lyY2xlSW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uQ0lSQ0xFLCBteUJlZ2luXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uLCBjaXJjbGVJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChiZWdpblBhdGhJbnN0cnVjdGlvbiwgY2lyY2xlSW5zdHJ1Y3Rpb24pO1xuICAgIGlmIChzdGF0ZS5maWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5lbmRHZW9tZXRyeShmZWF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gcG9seWdvbkdlb21ldHJ5IFBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvbHlnb24ocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICBjb25zdCBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIGlmIChmaWxsU3R5bGUgPT09IHVuZGVmaW5lZCAmJiBzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlc18oKTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgZGVmYXVsdEZpbGxTdHlsZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICBzdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIHN0YXRlLmxpbmVDYXAsXG4gICAgICAgIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBkZWZhdWx0TGluZURhc2gsXG4gICAgICAgIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gcG9seWdvbkdlb21ldHJ5LmdldEVuZHMoKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdGhpcy5kcmF3RmxhdENvb3JkaW5hdGVzc18oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoZW5kcyksXG4gICAgICBzdHJpZGVcbiAgICApO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBtdWx0aVBvbHlnb25HZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd011bHRpUG9seWdvbihtdWx0aVBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlID09PSB1bmRlZmluZWQgJiYgc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZXNfKCk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KG11bHRpUG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgZGVmYXVsdEZpbGxTdHlsZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICBzdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIHN0YXRlLmxpbmVDYXAsXG4gICAgICAgIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBkZWZhdWx0TGluZURhc2gsXG4gICAgICAgIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBlbmRzcyA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlQb2x5Z29uR2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBtdWx0aVBvbHlnb25HZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmRyYXdGbGF0Q29vcmRpbmF0ZXNzXyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGVuZHNzW2ldLFxuICAgICAgICBzdHJpZGVcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9uc30gdGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgdGhpcy5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgLy8gV2Ugd2FudCB0byBwcmVzZXJ2ZSB0b3BvbG9neSB3aGVuIGRyYXdpbmcgcG9seWdvbnMuICBQb2x5Z29ucyBhcmVcbiAgICAvLyBzaW1wbGlmaWVkIHVzaW5nIHF1YW50aXphdGlvbiBhbmQgcG9pbnQgZWxpbWluYXRpb24uIEhvd2V2ZXIsIHdlIG1pZ2h0XG4gICAgLy8gaGF2ZSByZWNlaXZlZCBhIG1peCBvZiBxdWFudGl6ZWQgYW5kIG5vbi1xdWFudGl6ZWQgZ2VvbWV0cmllcywgc28gZW5zdXJlXG4gICAgLy8gdGhhdCBhbGwgYXJlIHF1YW50aXplZCBieSBxdWFudGl6aW5nIGFsbCBjb29yZGluYXRlcyBpbiB0aGUgYmF0Y2guXG4gICAgY29uc3QgdG9sZXJhbmNlID0gdGhpcy50b2xlcmFuY2U7XG4gICAgaWYgKHRvbGVyYW5jZSAhPT0gMCkge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZGluYXRlc1tpXSA9IHNuYXAoY29vcmRpbmF0ZXNbaV0sIHRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5maW5pc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0RmlsbFN0cm9rZVN0eWxlc18oKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlRmlsbFN0eWxlKHN0YXRlLCB0aGlzLmNyZWF0ZUZpbGwpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1BvbHlnb25CdWlsZGVyO1xuIiwgImltcG9ydCB7bGVycH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBjaHVua3Mgb2YgZXF1YWwgbGVuZ3RoIGZyb20gYSBsaW5lc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gY2h1bmtMZW5ndGggTGVuZ3RoIG9mIGVhY2ggY2h1bmsuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBTdGFydCBvZmZzZXQgb2YgdGhlIGBmbGF0Q29vcmRpbmF0ZXNgLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0IG9mIHRoZSBgZmxhdENvb3JkaW5hdGVzYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IENodW5rcyBvZiBsaW5lc3RyaW5ncyB3aXRoIHN0cmlkZSAyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZUNodW5rKGNodW5rTGVuZ3RoLCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCBjdXJzb3IgPSBvZmZzZXQ7XG4gIGxldCBjaHVua00gPSAwO1xuICBsZXQgY3VycmVudENodW5rID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgMik7XG4gIHdoaWxlIChjaHVua00gPCBjaHVua0xlbmd0aCAmJiBjdXJzb3IgKyBzdHJpZGUgPCBlbmQpIHtcbiAgICBjb25zdCBbeDEsIHkxXSA9IGN1cnJlbnRDaHVuay5zbGljZSgtMik7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbY3Vyc29yICsgc3RyaWRlXTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tjdXJzb3IgKyBzdHJpZGUgKyAxXTtcbiAgICBjb25zdCBzZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KFxuICAgICAgKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpXG4gICAgKTtcbiAgICBjaHVua00gKz0gc2VnbWVudExlbmd0aDtcbiAgICBpZiAoY2h1bmtNID49IGNodW5rTGVuZ3RoKSB7XG4gICAgICBjb25zdCBtID0gKGNodW5rTGVuZ3RoIC0gY2h1bmtNICsgc2VnbWVudExlbmd0aCkgLyBzZWdtZW50TGVuZ3RoO1xuICAgICAgY29uc3QgeCA9IGxlcnAoeDEsIHgyLCBtKTtcbiAgICAgIGNvbnN0IHkgPSBsZXJwKHkxLCB5MiwgbSk7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaCh4LCB5KTtcbiAgICAgIGNodW5rcy5wdXNoKGN1cnJlbnRDaHVuayk7XG4gICAgICBjdXJyZW50Q2h1bmsgPSBbeCwgeV07XG4gICAgICBpZiAoY2h1bmtNID09IGNodW5rTGVuZ3RoKSB7XG4gICAgICAgIGN1cnNvciArPSBzdHJpZGU7XG4gICAgICB9XG4gICAgICBjaHVua00gPSAwO1xuICAgIH0gZWxzZSBpZiAoY2h1bmtNIDwgY2h1bmtMZW5ndGgpIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbY3Vyc29yICsgc3RyaWRlXSxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW2N1cnNvciArIHN0cmlkZSArIDFdXG4gICAgICApO1xuICAgICAgY3Vyc29yICs9IHN0cmlkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWlzc2luZyA9IHNlZ21lbnRMZW5ndGggLSBjaHVua007XG4gICAgICBjb25zdCB4ID0gbGVycCh4MSwgeDIsIG1pc3NpbmcgLyBzZWdtZW50TGVuZ3RoKTtcbiAgICAgIGNvbnN0IHkgPSBsZXJwKHkxLCB5MiwgbWlzc2luZyAvIHNlZ21lbnRMZW5ndGgpO1xuICAgICAgY3VycmVudENodW5rLnB1c2goeCwgeSk7XG4gICAgICBjaHVua3MucHVzaChjdXJyZW50Q2h1bmspO1xuICAgICAgY3VycmVudENodW5rID0gW3gsIHldO1xuICAgICAgY2h1bmtNID0gMDtcbiAgICAgIGN1cnNvciArPSBzdHJpZGU7XG4gICAgfVxuICB9XG4gIGlmIChjaHVua00gPiAwKSB7XG4gICAgY2h1bmtzLnB1c2goY3VycmVudENodW5rKTtcbiAgfVxuICByZXR1cm4gY2h1bmtzO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc3RyYWlnaHRjaHVua1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFuZ2xlIE1heGltdW0gYWNjZXB0YWJsZSBhbmdsZSBkZWx0YSBiZXR3ZWVuIHNlZ21lbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFN0YXJ0IGFuZCBlbmQgb2YgdGhlIGZpcnN0IHN1aXRhYmxlIGNodW5rIG9mIHRoZVxuICogZ2l2ZW4gYGZsYXRDb29yZGluYXRlc2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGluZ0NodW5rKG1heEFuZ2xlLCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgbGV0IGNodW5rU3RhcnQgPSBvZmZzZXQ7XG4gIGxldCBjaHVua0VuZCA9IG9mZnNldDtcbiAgbGV0IGNodW5rTSA9IDA7XG4gIGxldCBtID0gMDtcbiAgbGV0IHN0YXJ0ID0gb2Zmc2V0O1xuICBsZXQgYWNvcywgaSwgbTEyLCBtMjMsIHgxLCB5MSwgeDEyLCB5MTIsIHgyMywgeTIzO1xuICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgIGlmICh4MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4MjMgPSB4MiAtIHgxO1xuICAgICAgeTIzID0geTIgLSB5MTtcbiAgICAgIG0yMyA9IE1hdGguc3FydCh4MjMgKiB4MjMgKyB5MjMgKiB5MjMpO1xuICAgICAgaWYgKHgxMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gKz0gbTEyO1xuICAgICAgICBhY29zID0gTWF0aC5hY29zKCh4MTIgKiB4MjMgKyB5MTIgKiB5MjMpIC8gKG0xMiAqIG0yMykpO1xuICAgICAgICBpZiAoYWNvcyA+IG1heEFuZ2xlKSB7XG4gICAgICAgICAgaWYgKG0gPiBjaHVua00pIHtcbiAgICAgICAgICAgIGNodW5rTSA9IG07XG4gICAgICAgICAgICBjaHVua1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaHVua0VuZCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIHN0YXJ0ID0gaSAtIHN0cmlkZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbTEyID0gbTIzO1xuICAgICAgeDEyID0geDIzO1xuICAgICAgeTEyID0geTIzO1xuICAgIH1cbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgbSArPSBtMjM7XG4gIHJldHVybiBtID4gY2h1bmtNID8gW3N0YXJ0LCBpXSA6IFtjaHVua1N0YXJ0LCBjaHVua0VuZF07XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvVGV4dEJ1aWxkZXJcbiAqL1xuaW1wb3J0IENhbnZhc0J1aWxkZXIgZnJvbSAnLi9CdWlsZGVyLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0Rm9udCxcbiAgZGVmYXVsdExpbmVDYXAsXG4gIGRlZmF1bHRMaW5lRGFzaCxcbiAgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxuICBkZWZhdWx0TGluZUpvaW4sXG4gIGRlZmF1bHRMaW5lV2lkdGgsXG4gIGRlZmF1bHRNaXRlckxpbWl0LFxuICBkZWZhdWx0UGFkZGluZyxcbiAgZGVmYXVsdFN0cm9rZVN0eWxlLFxuICBkZWZhdWx0VGV4dEFsaWduLFxuICBkZWZhdWx0VGV4dEJhc2VsaW5lLFxuICByZWdpc3RlckZvbnQsXG59IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVDaHVua30gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L2xpbmVjaHVuay5qcyc7XG5pbXBvcnQge21hdGNoaW5nQ2h1bmt9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9zdHJhaWdodGNodW5rLmpzJztcbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7e2xlZnQ6IDAsIGNlbnRlcjogMC41LCByaWdodDogMSwgdG9wOiAwLCBtaWRkbGU6IDAuNSwgaGFuZ2luZzogMC4yLCBhbHBoYWJldGljOiAwLjgsIGlkZW9ncmFwaGljOiAwLjgsIGJvdHRvbTogMX19XG4gKi9cbmV4cG9ydCBjb25zdCBURVhUX0FMSUdOID0ge1xuICAnbGVmdCc6IDAsXG4gICdjZW50ZXInOiAwLjUsXG4gICdyaWdodCc6IDEsXG4gICd0b3AnOiAwLFxuICAnbWlkZGxlJzogMC41LFxuICAnaGFuZ2luZyc6IDAuMixcbiAgJ2FscGhhYmV0aWMnOiAwLjgsXG4gICdpZGVvZ3JhcGhpYyc6IDAuOCxcbiAgJ2JvdHRvbSc6IDEsXG59O1xuXG5jbGFzcyBDYW52YXNUZXh0QnVpbGRlciBleHRlbmRzIENhbnZhc0J1aWxkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gZXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gICAgc3VwZXIodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8SFRNTENhbnZhc0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRSb3RhdGlvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuZmlsbFN0YXRlcyA9IHt9O1xuICAgIHRoaXMuZmlsbFN0YXRlc1tkZWZhdWx0RmlsbFN0eWxlXSA9IHtmaWxsU3R5bGU6IGRlZmF1bHRGaWxsU3R5bGV9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlU3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0YXRlXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX0gKi8gKHt9KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50ZXh0S2V5XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbEtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZUtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIERhdGEgc2hhcmVkIHdpdGggYW4gaW1hZ2UgYnVpbGRlciBmb3IgY29tYmluZWQgZGVjbHV0dGVyaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJJbWFnZVdpdGhUZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVySW1hZ2VXaXRoVGV4dF8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9uc30gdGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gc3VwZXIuZmluaXNoKCk7XG4gICAgaW5zdHJ1Y3Rpb25zLnRleHRTdGF0ZXMgPSB0aGlzLnRleHRTdGF0ZXM7XG4gICAgaW5zdHJ1Y3Rpb25zLmZpbGxTdGF0ZXMgPSB0aGlzLmZpbGxTdGF0ZXM7XG4gICAgaW5zdHJ1Y3Rpb25zLnN0cm9rZVN0YXRlcyA9IHRoaXMuc3Ryb2tlU3RhdGVzO1xuICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGNvbnN0IGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG4gICAgY29uc3Qgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV87XG4gICAgY29uc3QgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgIGlmICh0aGlzLnRleHRfID09PSAnJyB8fCAhdGV4dFN0YXRlIHx8ICghZmlsbFN0YXRlICYmICFzdHJva2VTdGF0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXM7XG4gICAgbGV0IGJlZ2luID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuXG4gICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXMgPSBudWxsO1xuICAgIGxldCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcblxuICAgIGlmIChcbiAgICAgIHRleHRTdGF0ZS5wbGFjZW1lbnQgPT09ICdsaW5lJyAmJlxuICAgICAgKGdlb21ldHJ5VHlwZSA9PSAnTGluZVN0cmluZycgfHxcbiAgICAgICAgZ2VvbWV0cnlUeXBlID09ICdNdWx0aUxpbmVTdHJpbmcnIHx8XG4gICAgICAgIGdlb21ldHJ5VHlwZSA9PSAnUG9seWdvbicgfHxcbiAgICAgICAgZ2VvbWV0cnlUeXBlID09ICdNdWx0aVBvbHlnb24nKVxuICAgICkge1xuICAgICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZ2V0QnVmZmVyZWRNYXhFeHRlbnQoKSwgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBlbmRzO1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBpZiAoZ2VvbWV0cnlUeXBlID09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBlbmRzID0gW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgZW5kcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICkuZ2V0RW5kcygpO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIGVuZHMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICAgLmdldEVuZHMoKVxuICAgICAgICAgIC5zbGljZSgwLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGNvbnN0IGVuZHNzID1cbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgKS5nZXRFbmRzcygpO1xuICAgICAgICBlbmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICBlbmRzLnB1c2goZW5kc3NbaV1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJlZ2luR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICAgICAgY29uc3QgcmVwZWF0ID0gdGV4dFN0YXRlLnJlcGVhdDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJlcGVhdCA/IHVuZGVmaW5lZCA6IHRleHRTdGF0ZS50ZXh0QWxpZ247XG4gICAgICAvLyBObyBganVzdGlmeWAgc3VwcG9ydCBmb3IgbGluZSBwbGFjZW1lbnQuXG4gICAgICBsZXQgZmxhdE9mZnNldCA9IDA7XG4gICAgICBmb3IgKGxldCBvID0gMCwgb28gPSBlbmRzLmxlbmd0aDsgbyA8IG9vOyArK28pIHtcbiAgICAgICAgbGV0IGNodW5rcztcbiAgICAgICAgaWYgKHJlcGVhdCkge1xuICAgICAgICAgIGNodW5rcyA9IGxpbmVDaHVuayhcbiAgICAgICAgICAgIHJlcGVhdCAqIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgIGZsYXRPZmZzZXQsXG4gICAgICAgICAgICBlbmRzW29dLFxuICAgICAgICAgICAgc3RyaWRlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVua3MgPSBbZmxhdENvb3JkaW5hdGVzLnNsaWNlKGZsYXRPZmZzZXQsIGVuZHNbb10pXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjID0gMCwgY2MgPSBjaHVua3MubGVuZ3RoOyBjIDwgY2M7ICsrYykge1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2NdO1xuICAgICAgICAgIGxldCBjaHVua0JlZ2luID0gMDtcbiAgICAgICAgICBsZXQgY2h1bmtFbmQgPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKHRleHRBbGlnbiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbWF0Y2hpbmdDaHVuayhcbiAgICAgICAgICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlLFxuICAgICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgY2h1bmsubGVuZ3RoLFxuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2h1bmtCZWdpbiA9IHJhbmdlWzBdO1xuICAgICAgICAgICAgY2h1bmtFbmQgPSByYW5nZVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGNodW5rQmVnaW47IGkgPCBjaHVua0VuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goY2h1bmtbaV0sIGNodW5rW2kgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVuZCA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICBmbGF0T2Zmc2V0ID0gZW5kc1tvXTtcbiAgICAgICAgICB0aGlzLmRyYXdDaGFyc18oYmVnaW4sIGVuZCk7XG4gICAgICAgICAgYmVnaW4gPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZW9tZXRyeVdpZHRocyA9IHRleHRTdGF0ZS5vdmVyZmxvdyA/IG51bGwgOiBbXTtcbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnlUeXBlKSB7XG4gICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgICApLmdldEZsYXRNaWRwb2ludCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDaXJjbGUnOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICkuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICAgKS5nZXRGbGF0TWlkcG9pbnRzKCk7XG4gICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICkuZ2V0RmxhdEludGVyaW9yUG9pbnQoKTtcbiAgICAgICAgICBpZiAoIXRleHRTdGF0ZS5vdmVyZmxvdykge1xuICAgICAgICAgICAgZ2VvbWV0cnlXaWR0aHMucHVzaChmbGF0Q29vcmRpbmF0ZXNbMl0gLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgIGNvbnN0IGludGVyaW9yUG9pbnRzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICAgKS5nZXRGbGF0SW50ZXJpb3JQb2ludHMoKTtcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnRlcmlvclBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAoIXRleHRTdGF0ZS5vdmVyZmxvdykge1xuICAgICAgICAgICAgICBnZW9tZXRyeVdpZHRocy5wdXNoKGludGVyaW9yUG9pbnRzW2kgKyAyXSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaChpbnRlcmlvclBvaW50c1tpXSwgaW50ZXJpb3JQb2ludHNbaSArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZsYXRDb29yZGluYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMuYXBwZW5kRmxhdFBvaW50Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBzdHJpZGUpO1xuICAgICAgaWYgKGVuZCA9PT0gYmVnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBnZW9tZXRyeVdpZHRocyAmJlxuICAgICAgICAoZW5kIC0gYmVnaW4pIC8gMiAhPT0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHN0cmlkZVxuICAgICAgKSB7XG4gICAgICAgIGxldCBiZWcgPSBiZWdpbiAvIDI7XG4gICAgICAgIGdlb21ldHJ5V2lkdGhzID0gZ2VvbWV0cnlXaWR0aHMuZmlsdGVyKCh3LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3Qga2VlcCA9XG4gICAgICAgICAgICBjb29yZGluYXRlc1soYmVnICsgaSkgKiAyXSA9PT0gZmxhdENvb3JkaW5hdGVzW2kgKiBzdHJpZGVdICYmXG4gICAgICAgICAgICBjb29yZGluYXRlc1soYmVnICsgaSkgKiAyICsgMV0gPT09IGZsYXRDb29yZGluYXRlc1tpICogc3RyaWRlICsgMV07XG4gICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAtLWJlZztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtlZXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNhdmVUZXh0U3RhdGVzXygpO1xuXG4gICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsIHx8IHRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlKFxuICAgICAgICAgIHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCxcbiAgICAgICAgICB0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZVxuICAgICAgICApO1xuICAgICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVGaWxsU3R5bGUodGhpcy5zdGF0ZSwgdGhpcy5jcmVhdGVGaWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0cm9rZVN0eWxlKHRoaXMuc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jcmVhdGVTdHJva2UodGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG5cbiAgICAgIC8vIGFkanVzdCBwYWRkaW5nIGZvciBuZWdhdGl2ZSBzY2FsZVxuICAgICAgbGV0IHBhZGRpbmcgPSB0ZXh0U3RhdGUucGFkZGluZztcbiAgICAgIGlmIChcbiAgICAgICAgcGFkZGluZyAhPSBkZWZhdWx0UGFkZGluZyAmJlxuICAgICAgICAodGV4dFN0YXRlLnNjYWxlWzBdIDwgMCB8fCB0ZXh0U3RhdGUuc2NhbGVbMV0gPCAwKVxuICAgICAgKSB7XG4gICAgICAgIGxldCBwMCA9IHRleHRTdGF0ZS5wYWRkaW5nWzBdO1xuICAgICAgICBsZXQgcDEgPSB0ZXh0U3RhdGUucGFkZGluZ1sxXTtcbiAgICAgICAgbGV0IHAyID0gdGV4dFN0YXRlLnBhZGRpbmdbMl07XG4gICAgICAgIGxldCBwMyA9IHRleHRTdGF0ZS5wYWRkaW5nWzNdO1xuICAgICAgICBpZiAodGV4dFN0YXRlLnNjYWxlWzBdIDwgMCkge1xuICAgICAgICAgIHAxID0gLXAxO1xuICAgICAgICAgIHAzID0gLXAzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0U3RhdGUuc2NhbGVbMV0gPCAwKSB7XG4gICAgICAgICAgcDAgPSAtcDA7XG4gICAgICAgICAgcDIgPSAtcDI7XG4gICAgICAgIH1cbiAgICAgICAgcGFkZGluZyA9IFtwMCwgcDEsIHAyLCBwM107XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBpbWFnZSBpcyB1bmtub3duIGF0IHRoaXMgc3RhZ2Ugc28gd2UgcGFzcyBudWxsOyBpdCB3aWxsIGJlIGNvbXB1dGVkIGF0IHJlbmRlciB0aW1lLlxuICAgICAgLy8gRm9yIGNsYXJpdHksIHdlIHBhc3MgTmFOIGZvciBvZmZzZXRYLCBvZmZzZXRZLCB3aWR0aCBhbmQgaGVpZ2h0LCB3aGljaCB3aWxsIGJlIGNvbXB1dGVkIGF0XG4gICAgICAvLyByZW5kZXIgdGltZS5cbiAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSxcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGVuZCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgTmFOLFxuICAgICAgICBOYU4sXG4gICAgICAgIE5hTixcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfLFxuICAgICAgICB0aGlzLnRleHRSb3RhdGlvbl8sXG4gICAgICAgIFsxLCAxXSxcbiAgICAgICAgTmFOLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMuZGVjbHV0dGVySW1hZ2VXaXRoVGV4dF8sXG4gICAgICAgIHBhZGRpbmcgPT0gZGVmYXVsdFBhZGRpbmdcbiAgICAgICAgICA/IGRlZmF1bHRQYWRkaW5nXG4gICAgICAgICAgOiBwYWRkaW5nLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICByZXR1cm4gcCAqIHBpeGVsUmF0aW87XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgISF0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwsXG4gICAgICAgICEhdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UsXG4gICAgICAgIHRoaXMudGV4dF8sXG4gICAgICAgIHRoaXMudGV4dEtleV8sXG4gICAgICAgIHRoaXMuc3Ryb2tlS2V5XyxcbiAgICAgICAgdGhpcy5maWxsS2V5XyxcbiAgICAgICAgdGhpcy50ZXh0T2Zmc2V0WF8sXG4gICAgICAgIHRoaXMudGV4dE9mZnNldFlfLFxuICAgICAgICBnZW9tZXRyeVdpZHRocyxcbiAgICAgIF0pO1xuICAgICAgY29uc3Qgc2NhbGUgPSAxIC8gcGl4ZWxSYXRpbztcbiAgICAgIC8vIFNldCBkZWZhdWx0IGZpbGwgZm9yIGhpdCBkZXRlY3Rpb24gYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3VycmVudEZpbGxTdHlsZSA9IHRoaXMuc3RhdGUuZmlsbFN0eWxlO1xuICAgICAgaWYgKHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCkge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGxTdHlsZSA9IGRlZmF1bHRGaWxsU3R5bGU7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jcmVhdGVGaWxsKHRoaXMuc3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLFxuICAgICAgICBiZWdpbixcbiAgICAgICAgZW5kLFxuICAgICAgICBudWxsLFxuICAgICAgICBOYU4sXG4gICAgICAgIE5hTixcbiAgICAgICAgTmFOLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18sXG4gICAgICAgIHRoaXMudGV4dFJvdGF0aW9uXyxcbiAgICAgICAgW3NjYWxlLCBzY2FsZV0sXG4gICAgICAgIE5hTixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLmRlY2x1dHRlckltYWdlV2l0aFRleHRfLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCxcbiAgICAgICAgISF0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSxcbiAgICAgICAgdGhpcy50ZXh0XyxcbiAgICAgICAgdGhpcy50ZXh0S2V5XyxcbiAgICAgICAgdGhpcy5zdHJva2VLZXlfLFxuICAgICAgICB0aGlzLmZpbGxLZXlfID8gZGVmYXVsdEZpbGxTdHlsZSA6IHRoaXMuZmlsbEtleV8sXG4gICAgICAgIHRoaXMudGV4dE9mZnNldFhfLFxuICAgICAgICB0aGlzLnRleHRPZmZzZXRZXyxcbiAgICAgICAgZ2VvbWV0cnlXaWR0aHMsXG4gICAgICBdKTtcbiAgICAgIC8vIFJlc2V0IHByZXZpb3VzIGZpbGxcbiAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsU3R5bGUgPSBjdXJyZW50RmlsbFN0eWxlO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRmlsbCh0aGlzLnN0YXRlKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzYXZlVGV4dFN0YXRlc18oKSB7XG4gICAgY29uc3Qgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV87XG4gICAgY29uc3QgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgIGNvbnN0IGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG5cbiAgICBjb25zdCBzdHJva2VLZXkgPSB0aGlzLnN0cm9rZUtleV87XG4gICAgaWYgKHN0cm9rZVN0YXRlKSB7XG4gICAgICBpZiAoIShzdHJva2VLZXkgaW4gdGhpcy5zdHJva2VTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3RhdGVzW3N0cm9rZUtleV0gPSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICAgIGxpbmVDYXA6IHN0cm9rZVN0YXRlLmxpbmVDYXAsXG4gICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICAgIGxpbmVXaWR0aDogc3Ryb2tlU3RhdGUubGluZVdpZHRoLFxuICAgICAgICAgIGxpbmVKb2luOiBzdHJva2VTdGF0ZS5saW5lSm9pbixcbiAgICAgICAgICBtaXRlckxpbWl0OiBzdHJva2VTdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICAgIGxpbmVEYXNoOiBzdHJva2VTdGF0ZS5saW5lRGFzaCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dEtleSA9IHRoaXMudGV4dEtleV87XG4gICAgaWYgKCEodGV4dEtleSBpbiB0aGlzLnRleHRTdGF0ZXMpKSB7XG4gICAgICB0aGlzLnRleHRTdGF0ZXNbdGV4dEtleV0gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRTdGF0ZS5mb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRTdGF0ZS50ZXh0QWxpZ24gfHwgZGVmYXVsdFRleHRBbGlnbixcbiAgICAgICAganVzdGlmeTogdGV4dFN0YXRlLmp1c3RpZnksXG4gICAgICAgIHRleHRCYXNlbGluZTogdGV4dFN0YXRlLnRleHRCYXNlbGluZSB8fCBkZWZhdWx0VGV4dEJhc2VsaW5lLFxuICAgICAgICBzY2FsZTogdGV4dFN0YXRlLnNjYWxlLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZmlsbEtleSA9IHRoaXMuZmlsbEtleV87XG4gICAgaWYgKGZpbGxTdGF0ZSkge1xuICAgICAgaWYgKCEoZmlsbEtleSBpbiB0aGlzLmZpbGxTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMuZmlsbFN0YXRlc1tmaWxsS2V5XSA9IHtcbiAgICAgICAgICBmaWxsU3R5bGU6IGZpbGxTdGF0ZS5maWxsU3R5bGUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbiBCZWdpbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqL1xuICBkcmF3Q2hhcnNfKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXztcbiAgICBjb25zdCB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG5cbiAgICBjb25zdCBzdHJva2VLZXkgPSB0aGlzLnN0cm9rZUtleV87XG4gICAgY29uc3QgdGV4dEtleSA9IHRoaXMudGV4dEtleV87XG4gICAgY29uc3QgZmlsbEtleSA9IHRoaXMuZmlsbEtleV87XG4gICAgdGhpcy5zYXZlVGV4dFN0YXRlc18oKTtcblxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgY29uc3QgYmFzZWxpbmUgPSBURVhUX0FMSUdOW3RleHRTdGF0ZS50ZXh0QmFzZWxpbmVdO1xuXG4gICAgY29uc3Qgb2Zmc2V0WSA9IHRoaXMudGV4dE9mZnNldFlfICogcGl4ZWxSYXRpbztcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy50ZXh0XztcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IHN0cm9rZVN0YXRlXG4gICAgICA/IChzdHJva2VTdGF0ZS5saW5lV2lkdGggKiBNYXRoLmFicyh0ZXh0U3RhdGUuc2NhbGVbMF0pKSAvIDJcbiAgICAgIDogMDtcblxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUyxcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kLFxuICAgICAgYmFzZWxpbmUsXG4gICAgICB0ZXh0U3RhdGUub3ZlcmZsb3csXG4gICAgICBmaWxsS2V5LFxuICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlLFxuICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgIG9mZnNldFksXG4gICAgICBzdHJva2VLZXksXG4gICAgICBzdHJva2VXaWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgICB0ZXh0LFxuICAgICAgdGV4dEtleSxcbiAgICAgIDEsXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0NIQVJTLFxuICAgICAgYmVnaW4sXG4gICAgICBlbmQsXG4gICAgICBiYXNlbGluZSxcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdyxcbiAgICAgIGZpbGxLZXkgPyBkZWZhdWx0RmlsbFN0eWxlIDogZmlsbEtleSxcbiAgICAgIHRleHRTdGF0ZS5tYXhBbmdsZSxcbiAgICAgIHBpeGVsUmF0aW8sXG4gICAgICBvZmZzZXRZLFxuICAgICAgc3Ryb2tlS2V5LFxuICAgICAgc3Ryb2tlV2lkdGggKiBwaXhlbFJhdGlvLFxuICAgICAgdGV4dCxcbiAgICAgIHRleHRLZXksXG4gICAgICAxIC8gcGl4ZWxSYXRpbyxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dFN0eWxlIFRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2hhcmVkRGF0YV0gU2hhcmVkIGRhdGEuXG4gICAqL1xuICBzZXRUZXh0U3R5bGUodGV4dFN0eWxlLCBzaGFyZWREYXRhKSB7XG4gICAgbGV0IHRleHRTdGF0ZSwgZmlsbFN0YXRlLCBzdHJva2VTdGF0ZTtcbiAgICBpZiAoIXRleHRTdHlsZSkge1xuICAgICAgdGhpcy50ZXh0XyA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ZXh0RmlsbFN0eWxlID0gdGV4dFN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmICghdGV4dEZpbGxTdHlsZSkge1xuICAgICAgICBmaWxsU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gZmlsbFN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXztcbiAgICAgICAgaWYgKCFmaWxsU3RhdGUpIHtcbiAgICAgICAgICBmaWxsU3RhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9ICovICh7fSk7XG4gICAgICAgICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IGZpbGxTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsU3RhdGUuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgICAgdGV4dEZpbGxTdHlsZS5nZXRDb2xvcigpIHx8IGRlZmF1bHRGaWxsU3R5bGVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlID0gdGV4dFN0eWxlLmdldFN0cm9rZSgpO1xuICAgICAgaWYgKCF0ZXh0U3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgc3Ryb2tlU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBzdHJva2VTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgICAgICBpZiAoIXN0cm9rZVN0YXRlKSB7XG4gICAgICAgICAgc3Ryb2tlU3RhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX0gKi8gKHt9KTtcbiAgICAgICAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBzdHJva2VTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lRGFzaCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgICBjb25zdCBsaW5lRGFzaE9mZnNldCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgICBjb25zdCBsaW5lV2lkdGggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgICAgY29uc3QgbWl0ZXJMaW1pdCA9IHRleHRTdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpIHx8IGRlZmF1bHRMaW5lQ2FwO1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lRGFzaCA9IGxpbmVEYXNoID8gbGluZURhc2guc2xpY2UoKSA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgPVxuICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TGluZURhc2hPZmZzZXQgOiBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKSB8fCBkZWZhdWx0TGluZUpvaW47XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA9XG4gICAgICAgICAgbGluZVdpZHRoID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TGluZVdpZHRoIDogbGluZVdpZHRoO1xuICAgICAgICBzdHJva2VTdGF0ZS5taXRlckxpbWl0ID1cbiAgICAgICAgICBtaXRlckxpbWl0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWl0ZXJMaW1pdCA6IG1pdGVyTGltaXQ7XG4gICAgICAgIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgICAgdGV4dFN0cm9rZVN0eWxlLmdldENvbG9yKCkgfHwgZGVmYXVsdFN0cm9rZVN0eWxlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICAgIGNvbnN0IGZvbnQgPSB0ZXh0U3R5bGUuZ2V0Rm9udCgpIHx8IGRlZmF1bHRGb250O1xuICAgICAgcmVnaXN0ZXJGb250KGZvbnQpO1xuICAgICAgY29uc3QgdGV4dFNjYWxlID0gdGV4dFN0eWxlLmdldFNjYWxlQXJyYXkoKTtcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdyA9IHRleHRTdHlsZS5nZXRPdmVyZmxvdygpO1xuICAgICAgdGV4dFN0YXRlLmZvbnQgPSBmb250O1xuICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlID0gdGV4dFN0eWxlLmdldE1heEFuZ2xlKCk7XG4gICAgICB0ZXh0U3RhdGUucGxhY2VtZW50ID0gdGV4dFN0eWxlLmdldFBsYWNlbWVudCgpO1xuICAgICAgdGV4dFN0YXRlLnRleHRBbGlnbiA9IHRleHRTdHlsZS5nZXRUZXh0QWxpZ24oKTtcbiAgICAgIHRleHRTdGF0ZS5yZXBlYXQgPSB0ZXh0U3R5bGUuZ2V0UmVwZWF0KCk7XG4gICAgICB0ZXh0U3RhdGUuanVzdGlmeSA9IHRleHRTdHlsZS5nZXRKdXN0aWZ5KCk7XG4gICAgICB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lID1cbiAgICAgICAgdGV4dFN0eWxlLmdldFRleHRCYXNlbGluZSgpIHx8IGRlZmF1bHRUZXh0QmFzZWxpbmU7XG4gICAgICB0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwgPSB0ZXh0U3R5bGUuZ2V0QmFja2dyb3VuZEZpbGwoKTtcbiAgICAgIHRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlID0gdGV4dFN0eWxlLmdldEJhY2tncm91bmRTdHJva2UoKTtcbiAgICAgIHRleHRTdGF0ZS5wYWRkaW5nID0gdGV4dFN0eWxlLmdldFBhZGRpbmcoKSB8fCBkZWZhdWx0UGFkZGluZztcbiAgICAgIHRleHRTdGF0ZS5zY2FsZSA9IHRleHRTY2FsZSA9PT0gdW5kZWZpbmVkID8gWzEsIDFdIDogdGV4dFNjYWxlO1xuXG4gICAgICBjb25zdCB0ZXh0T2Zmc2V0WCA9IHRleHRTdHlsZS5nZXRPZmZzZXRYKCk7XG4gICAgICBjb25zdCB0ZXh0T2Zmc2V0WSA9IHRleHRTdHlsZS5nZXRPZmZzZXRZKCk7XG4gICAgICBjb25zdCB0ZXh0Um90YXRlV2l0aFZpZXcgPSB0ZXh0U3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIGNvbnN0IHRleHRSb3RhdGlvbiA9IHRleHRTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgICAgdGhpcy50ZXh0XyA9IHRleHRTdHlsZS5nZXRUZXh0KCkgfHwgJyc7XG4gICAgICB0aGlzLnRleHRPZmZzZXRYXyA9IHRleHRPZmZzZXRYID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFg7XG4gICAgICB0aGlzLnRleHRPZmZzZXRZXyA9IHRleHRPZmZzZXRZID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFk7XG4gICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPVxuICAgICAgICB0ZXh0Um90YXRlV2l0aFZpZXcgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdGV4dFJvdGF0ZVdpdGhWaWV3O1xuICAgICAgdGhpcy50ZXh0Um90YXRpb25fID0gdGV4dFJvdGF0aW9uID09PSB1bmRlZmluZWQgPyAwIDogdGV4dFJvdGF0aW9uO1xuXG4gICAgICB0aGlzLnN0cm9rZUtleV8gPSBzdHJva2VTdGF0ZVxuICAgICAgICA/ICh0eXBlb2Ygc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgPT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGVcbiAgICAgICAgICAgIDogZ2V0VWlkKHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlKSkgK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ICtcbiAgICAgICAgICAnfCcgK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCArXG4gICAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLm1pdGVyTGltaXQgK1xuICAgICAgICAgICdbJyArXG4gICAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2guam9pbigpICtcbiAgICAgICAgICAnXSdcbiAgICAgICAgOiAnJztcbiAgICAgIHRoaXMudGV4dEtleV8gPVxuICAgICAgICB0ZXh0U3RhdGUuZm9udCArXG4gICAgICAgIHRleHRTdGF0ZS5zY2FsZSArXG4gICAgICAgICh0ZXh0U3RhdGUudGV4dEFsaWduIHx8ICc/JykgK1xuICAgICAgICAodGV4dFN0YXRlLnJlcGVhdCB8fCAnPycpICtcbiAgICAgICAgKHRleHRTdGF0ZS5qdXN0aWZ5IHx8ICc/JykgK1xuICAgICAgICAodGV4dFN0YXRlLnRleHRCYXNlbGluZSB8fCAnPycpO1xuICAgICAgdGhpcy5maWxsS2V5XyA9IGZpbGxTdGF0ZVxuICAgICAgICA/IHR5cGVvZiBmaWxsU3RhdGUuZmlsbFN0eWxlID09ICdzdHJpbmcnXG4gICAgICAgICAgPyBmaWxsU3RhdGUuZmlsbFN0eWxlXG4gICAgICAgICAgOiAnfCcgKyBnZXRVaWQoZmlsbFN0YXRlLmZpbGxTdHlsZSlcbiAgICAgICAgOiAnJztcbiAgICB9XG4gICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyA9IHNoYXJlZERhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGV4dEJ1aWxkZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwXG4gKi9cblxuaW1wb3J0IEJ1aWxkZXIgZnJvbSAnLi9CdWlsZGVyLmpzJztcbmltcG9ydCBJbWFnZUJ1aWxkZXIgZnJvbSAnLi9JbWFnZUJ1aWxkZXIuanMnO1xuaW1wb3J0IExpbmVTdHJpbmdCdWlsZGVyIGZyb20gJy4vTGluZVN0cmluZ0J1aWxkZXIuanMnO1xuaW1wb3J0IFBvbHlnb25CdWlsZGVyIGZyb20gJy4vUG9seWdvbkJ1aWxkZXIuanMnO1xuaW1wb3J0IFRleHRCdWlsZGVyIGZyb20gJy4vVGV4dEJ1aWxkZXIuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkJ1aWxkZXJUeXBlLCB0eXBlb2YgQnVpbGRlcj59XG4gKi9cbmNvbnN0IEJBVENIX0NPTlNUUlVDVE9SUyA9IHtcbiAgJ0NpcmNsZSc6IFBvbHlnb25CdWlsZGVyLFxuICAnRGVmYXVsdCc6IEJ1aWxkZXIsXG4gICdJbWFnZSc6IEltYWdlQnVpbGRlcixcbiAgJ0xpbmVTdHJpbmcnOiBMaW5lU3RyaW5nQnVpbGRlcixcbiAgJ1BvbHlnb24nOiBQb2x5Z29uQnVpbGRlcixcbiAgJ1RleHQnOiBUZXh0QnVpbGRlcixcbn07XG5cbmNsYXNzIEJ1aWxkZXJHcm91cCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4IGV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZV8gPSB0b2xlcmFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50XyA9IG1heEV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5CdWlsZGVyVHlwZSwgQnVpbGRlcj4+fVxuICAgICAqL1xuICAgIHRoaXMuYnVpbGRlcnNCeVpJbmRleF8gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgIU9iamVjdDxpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuQnVpbGRlclR5cGUsIGltcG9ydChcIi4vQnVpbGRlci5qc1wiKS5TZXJpYWxpemFibGVJbnN0cnVjdGlvbnM+Pn0gVGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnNcbiAgICovXG4gIGZpbmlzaCgpIHtcbiAgICBjb25zdCBidWlsZGVySW5zdHJ1Y3Rpb25zID0ge307XG4gICAgZm9yIChjb25zdCB6S2V5IGluIHRoaXMuYnVpbGRlcnNCeVpJbmRleF8pIHtcbiAgICAgIGJ1aWxkZXJJbnN0cnVjdGlvbnNbektleV0gPSBidWlsZGVySW5zdHJ1Y3Rpb25zW3pLZXldIHx8IHt9O1xuICAgICAgY29uc3QgYnVpbGRlcnMgPSB0aGlzLmJ1aWxkZXJzQnlaSW5kZXhfW3pLZXldO1xuICAgICAgZm9yIChjb25zdCBidWlsZGVyS2V5IGluIGJ1aWxkZXJzKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXJJbnN0cnVjdGlvbiA9IGJ1aWxkZXJzW2J1aWxkZXJLZXldLmZpbmlzaCgpO1xuICAgICAgICBidWlsZGVySW5zdHJ1Y3Rpb25zW3pLZXldW2J1aWxkZXJLZXldID0gYnVpbGRlckluc3RydWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlckluc3RydWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHpJbmRleCBaIGluZGV4LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5CdWlsZGVyVHlwZX0gYnVpbGRlclR5cGUgUmVwbGF5IHR5cGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1ZlY3RvckNvbnRleHQuanNcIikuZGVmYXVsdH0gUmVwbGF5LlxuICAgKi9cbiAgZ2V0QnVpbGRlcih6SW5kZXgsIGJ1aWxkZXJUeXBlKSB7XG4gICAgY29uc3QgekluZGV4S2V5ID0gekluZGV4ICE9PSB1bmRlZmluZWQgPyB6SW5kZXgudG9TdHJpbmcoKSA6ICcwJztcbiAgICBsZXQgcmVwbGF5cyA9IHRoaXMuYnVpbGRlcnNCeVpJbmRleF9bekluZGV4S2V5XTtcbiAgICBpZiAocmVwbGF5cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXBsYXlzID0ge307XG4gICAgICB0aGlzLmJ1aWxkZXJzQnlaSW5kZXhfW3pJbmRleEtleV0gPSByZXBsYXlzO1xuICAgIH1cbiAgICBsZXQgcmVwbGF5ID0gcmVwbGF5c1tidWlsZGVyVHlwZV07XG4gICAgaWYgKHJlcGxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IEJBVENIX0NPTlNUUlVDVE9SU1tidWlsZGVyVHlwZV07XG4gICAgICByZXBsYXkgPSBuZXcgQ29uc3RydWN0b3IoXG4gICAgICAgIHRoaXMudG9sZXJhbmNlXyxcbiAgICAgICAgdGhpcy5tYXhFeHRlbnRfLFxuICAgICAgICB0aGlzLnJlc29sdXRpb25fLFxuICAgICAgICB0aGlzLnBpeGVsUmF0aW9fXG4gICAgICApO1xuICAgICAgcmVwbGF5c1tidWlsZGVyVHlwZV0gPSByZXBsYXk7XG4gICAgfVxuICAgIHJldHVybiByZXBsYXk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVpbGRlckdyb3VwO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvdGV4dHBhdGhcbiAqL1xuaW1wb3J0IHtsZXJwfSBmcm9tICcuLi8uLi9tYXRoLmpzJztcbmltcG9ydCB7cm90YXRlfSBmcm9tICcuL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgUGF0aCB0byBwdXQgdGV4dCBvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgU3RhcnQgb2Zmc2V0IG9mIHRoZSBgZmxhdENvb3JkaW5hdGVzYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldCBvZiB0aGUgYGZsYXRDb29yZGluYXRlc2AuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGxhY2Ugb24gdGhlIHBhdGguXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRNIG0gYWxvbmcgdGhlIHBhdGggd2hlcmUgdGhlIHRleHQgc3RhcnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFuZ2xlIE1heCBhbmdsZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJzIGluIHJhZGlhbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgVGhlIHByb2R1Y3Qgb2YgdGhlIHRleHQgc2NhbGUgYW5kIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBudW1iZXI+KTpudW1iZXJ9IG1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aCBNZWFzdXJlIGFuZCBjYWNoZSB0ZXh0IHdpZHRoLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgVGhlIGZvbnQuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIG51bWJlcj59IGNhY2hlIEEgY2FjaGUgb2YgbWVhc3VyZWQgd2lkdGhzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBmbGF0Q29vcmRpbmF0ZXMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGV4dCBuZWVkcyB0byBiZSByZXZlcnNlZC5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+PnxudWxsfSBUaGUgcmVzdWx0IGFycmF5IChvciBudWxsIGlmIGBtYXhBbmdsZWAgd2FzXG4gKiBleGNlZWRlZCkuIEVudHJpZXMgb2YgdGhlIGFycmF5IGFyZSB4LCB5LCBhbmNob3JYLCBhbmdsZSwgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3VGV4dE9uUGF0aChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICB0ZXh0LFxuICBzdGFydE0sXG4gIG1heEFuZ2xlLFxuICBzY2FsZSxcbiAgbWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoLFxuICBmb250LFxuICBjYWNoZSxcbiAgcm90YXRpb25cbikge1xuICBsZXQgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgbGV0IHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBsZXQgeDEgPSAwO1xuICBsZXQgeTEgPSAwO1xuICBsZXQgc2VnbWVudExlbmd0aCA9IDA7XG4gIGxldCBzZWdtZW50TSA9IDA7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIHNlZ21lbnRNICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgc2VnbWVudExlbmd0aCA9IE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9XG4gIGRvIHtcbiAgICBhZHZhbmNlKCk7XG4gIH0gd2hpbGUgKG9mZnNldCA8IGVuZCAtIHN0cmlkZSAmJiBzZWdtZW50TSArIHNlZ21lbnRMZW5ndGggPCBzdGFydE0pO1xuXG4gIGxldCBpbnRlcnBvbGF0ZSA9XG4gICAgc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAoc3RhcnRNIC0gc2VnbWVudE0pIC8gc2VnbWVudExlbmd0aDtcbiAgY29uc3QgYmVnaW5YID0gbGVycCh4MSwgeDIsIGludGVycG9sYXRlKTtcbiAgY29uc3QgYmVnaW5ZID0gbGVycCh5MSwgeTIsIGludGVycG9sYXRlKTtcblxuICBjb25zdCBzdGFydE9mZnNldCA9IG9mZnNldCAtIHN0cmlkZTtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBzZWdtZW50TTtcbiAgY29uc3QgZW5kTSA9IHN0YXJ0TSArIHNjYWxlICogbWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoKGZvbnQsIHRleHQsIGNhY2hlKTtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCAtIHN0cmlkZSAmJiBzZWdtZW50TSArIHNlZ21lbnRMZW5ndGggPCBlbmRNKSB7XG4gICAgYWR2YW5jZSgpO1xuICB9XG4gIGludGVycG9sYXRlID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAoZW5kTSAtIHNlZ21lbnRNKSAvIHNlZ21lbnRMZW5ndGg7XG4gIGNvbnN0IGVuZFggPSBsZXJwKHgxLCB4MiwgaW50ZXJwb2xhdGUpO1xuICBjb25zdCBlbmRZID0gbGVycCh5MSwgeTIsIGludGVycG9sYXRlKTtcblxuICAvLyBLZWVwIHRleHQgdXByaWdodFxuICBsZXQgcmV2ZXJzZTtcbiAgaWYgKHJvdGF0aW9uKSB7XG4gICAgY29uc3QgZmxhdCA9IFtiZWdpblgsIGJlZ2luWSwgZW5kWCwgZW5kWV07XG4gICAgcm90YXRlKGZsYXQsIDAsIDQsIDIsIHJvdGF0aW9uLCBmbGF0LCBmbGF0KTtcbiAgICByZXZlcnNlID0gZmxhdFswXSA+IGZsYXRbMl07XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IGJlZ2luWCA+IGVuZFg7XG4gIH1cblxuICBjb25zdCBQSSA9IE1hdGguUEk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzaW5nbGVTZWdtZW50ID0gc3RhcnRPZmZzZXQgKyBzdHJpZGUgPT09IG9mZnNldDtcblxuICBvZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgc2VnbWVudExlbmd0aCA9IDA7XG4gIHNlZ21lbnRNID0gc3RhcnRMZW5ndGg7XG4gIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuXG4gIGxldCBwcmV2aW91c0FuZ2xlO1xuICAvLyBBbGwgb24gdGhlIHNhbWUgc2VnbWVudFxuICBpZiAoc2luZ2xlU2VnbWVudCkge1xuICAgIGFkdmFuY2UoKTtcblxuICAgIHByZXZpb3VzQW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBwcmV2aW91c0FuZ2xlICs9IHByZXZpb3VzQW5nbGUgPiAwID8gLVBJIDogUEk7XG4gICAgfVxuICAgIGNvbnN0IHggPSAoZW5kWCArIGJlZ2luWCkgLyAyO1xuICAgIGNvbnN0IHkgPSAoZW5kWSArIGJlZ2luWSkgLyAyO1xuICAgIHJlc3VsdFswXSA9IFt4LCB5LCAoZW5kTSAtIHN0YXJ0TSkgLyAyLCBwcmV2aW91c0FuZ2xlLCB0ZXh0XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gcmVuZGVyaW5nIGFjcm9zcyBsaW5lIHNlZ21lbnRzXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9nLCAnICcpOyAvLyBlbnN1cmUgcmVuZGVyaW5nIGluIHNpbmdsZS1saW5lIGFzIGFsbCBjYWxjdWxhdGlvbnMgYmVsb3cgZG9uJ3QgaGFuZGxlIG11bHRpLWxpbmVzXG5cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGV4dC5sZW5ndGg7IGkgPCBpaTsgKSB7XG4gICAgYWR2YW5jZSgpO1xuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGFuZ2xlICs9IGFuZ2xlID4gMCA/IC1QSSA6IFBJO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZGVsdGEgPSBhbmdsZSAtIHByZXZpb3VzQW5nbGU7XG4gICAgICBkZWx0YSArPSBkZWx0YSA+IFBJID8gLTIgKiBQSSA6IGRlbHRhIDwgLVBJID8gMiAqIFBJIDogMDtcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBtYXhBbmdsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldmlvdXNBbmdsZSA9IGFuZ2xlO1xuXG4gICAgY29uc3QgaVN0YXJ0ID0gaTtcbiAgICBsZXQgY2hhckxlbmd0aCA9IDA7XG4gICAgZm9yICg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJldmVyc2UgPyBpaSAtIGkgLSAxIDogaTtcbiAgICAgIGNvbnN0IGxlbiA9IHNjYWxlICogbWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoKGZvbnQsIHRleHRbaW5kZXhdLCBjYWNoZSk7XG4gICAgICBpZiAoXG4gICAgICAgIG9mZnNldCArIHN0cmlkZSA8IGVuZCAmJlxuICAgICAgICBzZWdtZW50TSArIHNlZ21lbnRMZW5ndGggPCBzdGFydE0gKyBjaGFyTGVuZ3RoICsgbGVuIC8gMlxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2hhckxlbmd0aCArPSBsZW47XG4gICAgfVxuICAgIGlmIChpID09PSBpU3RhcnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IHJldmVyc2VcbiAgICAgID8gdGV4dC5zdWJzdHJpbmcoaWkgLSBpU3RhcnQsIGlpIC0gaSlcbiAgICAgIDogdGV4dC5zdWJzdHJpbmcoaVN0YXJ0LCBpKTtcbiAgICBpbnRlcnBvbGF0ZSA9XG4gICAgICBzZWdtZW50TGVuZ3RoID09PSAwXG4gICAgICAgID8gMFxuICAgICAgICA6IChzdGFydE0gKyBjaGFyTGVuZ3RoIC8gMiAtIHNlZ21lbnRNKSAvIHNlZ21lbnRMZW5ndGg7XG4gICAgY29uc3QgeCA9IGxlcnAoeDEsIHgyLCBpbnRlcnBvbGF0ZSk7XG4gICAgY29uc3QgeSA9IGxlcnAoeTEsIHkyLCBpbnRlcnBvbGF0ZSk7XG4gICAgcmVzdWx0LnB1c2goW3gsIHksIGNoYXJMZW5ndGggLyAyLCBhbmdsZSwgY2hhcnNdKTtcbiAgICBzdGFydE0gKz0gY2hhckxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yXG4gKi9cbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7VEVYVF9BTElHTn0gZnJvbSAnLi9UZXh0QnVpbGRlci5qcyc7XG5pbXBvcnQge1xuICBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSxcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxuICBzZXRGcm9tQXJyYXkgYXMgdHJhbnNmb3JtU2V0RnJvbUFycmF5LFxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtjcmVhdGVFbXB0eSwgY3JlYXRlT3JVcGRhdGUsIGludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0UGFkZGluZyxcbiAgZGVmYXVsdFRleHRBbGlnbixcbiAgZGVmYXVsdFRleHRCYXNlbGluZSxcbiAgZHJhd0ltYWdlT3JMYWJlbCxcbiAgZ2V0VGV4dERpbWVuc2lvbnMsXG4gIG1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aCxcbn0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCB7ZHJhd1RleHRPblBhdGh9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90ZXh0cGF0aC5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtsaW5lU3RyaW5nTGVuZ3RofSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvbGVuZ3RoLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJCb3hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5YIE1pbmltYWwgeC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5ZIE1pbmltYWwgeS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhYIE1heGltYWwgeC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhZIE1heGltYWwgeVxuICogQHByb3BlcnR5IHsqfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEltYWdlT3JMYWJlbERpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmF3SW1hZ2VYIERyYXdJbWFnZVguXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHJhd0ltYWdlWSBEcmF3SW1hZ2VZLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYXdJbWFnZVcgRHJhd0ltYWdlVy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmF3SW1hZ2VIIERyYXdJbWFnZUguXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3JpZ2luWCBPcmlnaW5YLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9yaWdpblkgT3JpZ2luWS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gc2NhbGUgU2NhbGUuXG4gKiBAcHJvcGVydHkge0JCb3h9IGRlY2x1dHRlckJveCBEZWNsdXR0ZXJCb3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IGNhbnZhc1RyYW5zZm9ybSBDYW52YXNUcmFuc2Zvcm0uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ezA6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgMTogbnVtYmVyLCAyOiBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuTGFiZWx8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50LCAzOiBJbWFnZU9yTGFiZWxEaW1lbnNpb25zLCA0OiBudW1iZXIsIDU6IEFycmF5PCo+LCA2OiBBcnJheTwqPn19IFJlcGxheUltYWdlT3JMYWJlbEFyZ3NcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgaW1wb3J0KFwiLi4vLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0KTogVH0gRmVhdHVyZUNhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuY29uc3QgdG1wRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG5jb25zdCBwMSA9IFtdO1xuLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG5jb25zdCBwMiA9IFtdO1xuLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG5jb25zdCBwMyA9IFtdO1xuLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG5jb25zdCBwNCA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVwbGF5SW1hZ2VPckxhYmVsQXJnc30gcmVwbGF5SW1hZ2VPckxhYmVsQXJncyBBcmd1bWVudHMgdG8gcmVwbGF5SW1hZ2VPckxhYmVsXG4gKiBAcmV0dXJuIHtCQm94fSBEZWNsdXR0ZXIgYmJveC5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVjbHV0dGVyQm94KHJlcGxheUltYWdlT3JMYWJlbEFyZ3MpIHtcbiAgcmV0dXJuIHJlcGxheUltYWdlT3JMYWJlbEFyZ3NbM10uZGVjbHV0dGVyQm94O1xufVxuXG5jb25zdCBydGxSZWdFeCA9IG5ldyBSZWdFeHAoXG4gIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyICovXG4gICdbJyArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwNTkxKSArICctJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMDhmZikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwZmIxZCkgKyAnLScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MGZkZmYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MGZlNzApICsgJy0nICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweDBmZWZjKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweDEwODAwKSArICctJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgxMGZmZikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgxZTgwMCkgKyAnLScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MWVmZmYpICtcbiAgJ10nXG4gIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIgKi9cbik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAqIEBwYXJhbSB7Q2FudmFzVGV4dEFsaWdufSBhbGlnbiBBbGlnbm1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRleHQgYWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiBob3Jpem9udGFsVGV4dEFsaWduKHRleHQsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgIGFsaWduID0gcnRsUmVnRXgudGVzdCh0ZXh0KSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgYWxpZ24gPSBydGxSZWdFeC50ZXN0KHRleHQpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfVxuICByZXR1cm4gVEVYVF9BTElHTlthbGlnbl07XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhY2MgQWNjdW11bGF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZSBMaW5lIG9mIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gaSBJbmRleFxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQWNjdW11bGF0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHRDaHVua3MoYWNjLCBsaW5lLCBpKSB7XG4gIGlmIChpID4gMCkge1xuICAgIGFjYy5wdXNoKCdcXG4nLCAnJyk7XG4gIH1cbiAgYWNjLnB1c2gobGluZSwgJycpO1xuICByZXR1cm4gYWNjO1xufVxuXG5jbGFzcyBFeGVjdXRvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGFwcyBUaGUgcmVwbGF5IGNhbiBoYXZlIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9uc30gaW5zdHJ1Y3Rpb25zIFRoZSBzZXJpYWxpemFibGUgaW5zdHJ1Y3Rpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxhcHMgPSBvdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsaWduRmlsbF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLmluc3RydWN0aW9ucztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gaW5zdHJ1Y3Rpb25zLmNvb3JkaW5hdGVzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxudW1iZXIsaW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZUNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxTdGF0ZXMgPSBpbnN0cnVjdGlvbnMuZmlsbFN0YXRlcyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVN0YXRlcyA9IGluc3RydWN0aW9ucy5zdHJva2VTdGF0ZXMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0YXRlcyA9IGluc3RydWN0aW9ucy50ZXh0U3RhdGVzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgbnVtYmVyPj59XG4gICAgICovXG4gICAgdGhpcy53aWR0aHNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuTGFiZWw+fVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxzXyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHRleHQgVGV4dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRLZXkgVGV4dCBzdHlsZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsS2V5IEZpbGwgc3R5bGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3Ryb2tlS2V5IFN0cm9rZSBzdHlsZSBrZXkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5MYWJlbH0gTGFiZWwuXG4gICAqL1xuICBjcmVhdGVMYWJlbCh0ZXh0LCB0ZXh0S2V5LCBmaWxsS2V5LCBzdHJva2VLZXkpIHtcbiAgICBjb25zdCBrZXkgPSB0ZXh0ICsgdGV4dEtleSArIGZpbGxLZXkgKyBzdHJva2VLZXk7XG4gICAgaWYgKHRoaXMubGFiZWxzX1trZXldKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbHNfW2tleV07XG4gICAgfVxuICAgIGNvbnN0IHN0cm9rZVN0YXRlID0gc3Ryb2tlS2V5ID8gdGhpcy5zdHJva2VTdGF0ZXNbc3Ryb2tlS2V5XSA6IG51bGw7XG4gICAgY29uc3QgZmlsbFN0YXRlID0gZmlsbEtleSA/IHRoaXMuZmlsbFN0YXRlc1tmaWxsS2V5XSA6IG51bGw7XG4gICAgY29uc3QgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVzW3RleHRLZXldO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgc2NhbGUgPSBbXG4gICAgICB0ZXh0U3RhdGUuc2NhbGVbMF0gKiBwaXhlbFJhdGlvLFxuICAgICAgdGV4dFN0YXRlLnNjYWxlWzFdICogcGl4ZWxSYXRpbyxcbiAgICBdO1xuICAgIGNvbnN0IHRleHRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0ZXh0KTtcbiAgICBjb25zdCBhbGlnbiA9IHRleHRTdGF0ZS5qdXN0aWZ5XG4gICAgICA/IFRFWFRfQUxJR05bdGV4dFN0YXRlLmp1c3RpZnldXG4gICAgICA6IGhvcml6b250YWxUZXh0QWxpZ24oXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0ZXh0KSA/IHRleHRbMF0gOiB0ZXh0LFxuICAgICAgICAgIHRleHRTdGF0ZS50ZXh0QWxpZ24gfHwgZGVmYXVsdFRleHRBbGlnblxuICAgICAgICApO1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID1cbiAgICAgIHN0cm9rZUtleSAmJiBzdHJva2VTdGF0ZS5saW5lV2lkdGggPyBzdHJva2VTdGF0ZS5saW5lV2lkdGggOiAwO1xuXG4gICAgY29uc3QgY2h1bmtzID0gdGV4dElzQXJyYXlcbiAgICAgID8gdGV4dFxuICAgICAgOiB0ZXh0LnNwbGl0KCdcXG4nKS5yZWR1Y2UoY3JlYXRlVGV4dENodW5rcywgW10pO1xuXG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIHdpZHRocywgaGVpZ2h0cywgbGluZVdpZHRoc30gPSBnZXRUZXh0RGltZW5zaW9ucyhcbiAgICAgIHRleHRTdGF0ZSxcbiAgICAgIGNodW5rc1xuICAgICk7XG4gICAgY29uc3QgcmVuZGVyV2lkdGggPSB3aWR0aCArIHN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IGNvbnRleHRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAvLyBtYWtlIGNhbnZhcyAyIHBpeGVscyB3aWRlciB0byBhY2NvdW50IGZvciBpdGFsaWMgdGV4dCB3aWR0aCBtZWFzdXJlbWVudCBlcnJvcnNcbiAgICBjb25zdCB3ID0gKHJlbmRlcldpZHRoICsgMikgKiBzY2FsZVswXTtcbiAgICBjb25zdCBoID0gKGhlaWdodCArIHN0cm9rZVdpZHRoKSAqIHNjYWxlWzFdO1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkxhYmVsfSAqL1xuICAgIGNvbnN0IGxhYmVsID0ge1xuICAgICAgd2lkdGg6IHcgPCAwID8gTWF0aC5mbG9vcih3KSA6IE1hdGguY2VpbCh3KSxcbiAgICAgIGhlaWdodDogaCA8IDAgPyBNYXRoLmZsb29yKGgpIDogTWF0aC5jZWlsKGgpLFxuICAgICAgY29udGV4dEluc3RydWN0aW9uczogY29udGV4dEluc3RydWN0aW9ucyxcbiAgICB9O1xuICAgIGlmIChzY2FsZVswXSAhPSAxIHx8IHNjYWxlWzFdICE9IDEpIHtcbiAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgnc2NhbGUnLCBzY2FsZSk7XG4gICAgfVxuICAgIGlmIChzdHJva2VLZXkpIHtcbiAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgnc3Ryb2tlU3R5bGUnLCBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSk7XG4gICAgICBjb250ZXh0SW5zdHJ1Y3Rpb25zLnB1c2goJ2xpbmVXaWR0aCcsIHN0cm9rZVdpZHRoKTtcbiAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgnbGluZUNhcCcsIHN0cm9rZVN0YXRlLmxpbmVDYXApO1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdsaW5lSm9pbicsIHN0cm9rZVN0YXRlLmxpbmVKb2luKTtcbiAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgnbWl0ZXJMaW1pdCcsIHN0cm9rZVN0YXRlLm1pdGVyTGltaXQpO1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdzZXRMaW5lRGFzaCcsIFtzdHJva2VTdGF0ZS5saW5lRGFzaF0pO1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdsaW5lRGFzaE9mZnNldCcsIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKGZpbGxLZXkpIHtcbiAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgnZmlsbFN0eWxlJywgZmlsbFN0YXRlLmZpbGxTdHlsZSk7XG4gICAgfVxuICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpO1xuICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgndGV4dEFsaWduJywgJ2NlbnRlcicpO1xuICAgIGNvbnN0IGxlZnRSaWdodCA9IDAuNSAtIGFsaWduO1xuICAgIGxldCB4ID0gYWxpZ24gKiByZW5kZXJXaWR0aCArIGxlZnRSaWdodCAqIHN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IHN0cm9rZUluc3RydWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGZpbGxJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBsZXQgbGluZUhlaWdodCA9IDA7XG4gICAgbGV0IGxpbmVPZmZzZXQgPSAwO1xuICAgIGxldCB3aWR0aEhlaWdodEluZGV4ID0gMDtcbiAgICBsZXQgbGluZVdpZHRoSW5kZXggPSAwO1xuICAgIGxldCBwcmV2aW91c0ZvbnQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2h1bmtzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVua3NbaV07XG4gICAgICBpZiAodGV4dCA9PT0gJ1xcbicpIHtcbiAgICAgICAgbGluZU9mZnNldCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgeCA9IGFsaWduICogcmVuZGVyV2lkdGggKyBsZWZ0UmlnaHQgKiBzdHJva2VXaWR0aDtcbiAgICAgICAgKytsaW5lV2lkdGhJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmb250ID0gY2h1bmtzW2kgKyAxXSB8fCB0ZXh0U3RhdGUuZm9udDtcbiAgICAgIGlmIChmb250ICE9PSBwcmV2aW91c0ZvbnQpIHtcbiAgICAgICAgaWYgKHN0cm9rZUtleSkge1xuICAgICAgICAgIHN0cm9rZUluc3RydWN0aW9ucy5wdXNoKCdmb250JywgZm9udCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGxLZXkpIHtcbiAgICAgICAgICBmaWxsSW5zdHJ1Y3Rpb25zLnB1c2goJ2ZvbnQnLCBmb250KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0ZvbnQgPSBmb250O1xuICAgICAgfVxuICAgICAgbGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGhlaWdodHNbd2lkdGhIZWlnaHRJbmRleF0pO1xuICAgICAgY29uc3QgZmlsbFN0cm9rZUFyZ3MgPSBbXG4gICAgICAgIHRleHQsXG4gICAgICAgIHggK1xuICAgICAgICAgIGxlZnRSaWdodCAqIHdpZHRoc1t3aWR0aEhlaWdodEluZGV4XSArXG4gICAgICAgICAgYWxpZ24gKiAod2lkdGhzW3dpZHRoSGVpZ2h0SW5kZXhdIC0gbGluZVdpZHRoc1tsaW5lV2lkdGhJbmRleF0pLFxuICAgICAgICAwLjUgKiAoc3Ryb2tlV2lkdGggKyBsaW5lSGVpZ2h0KSArIGxpbmVPZmZzZXQsXG4gICAgICBdO1xuICAgICAgeCArPSB3aWR0aHNbd2lkdGhIZWlnaHRJbmRleF07XG4gICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgIHN0cm9rZUluc3RydWN0aW9ucy5wdXNoKCdzdHJva2VUZXh0JywgZmlsbFN0cm9rZUFyZ3MpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxLZXkpIHtcbiAgICAgICAgZmlsbEluc3RydWN0aW9ucy5wdXNoKCdmaWxsVGV4dCcsIGZpbGxTdHJva2VBcmdzKTtcbiAgICAgIH1cbiAgICAgICsrd2lkdGhIZWlnaHRJbmRleDtcbiAgICB9XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY29udGV4dEluc3RydWN0aW9ucywgc3Ryb2tlSW5zdHJ1Y3Rpb25zKTtcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjb250ZXh0SW5zdHJ1Y3Rpb25zLCBmaWxsSW5zdHJ1Y3Rpb25zKTtcbiAgICB0aGlzLmxhYmVsc19ba2V5XSA9IGxhYmVsO1xuICAgIHJldHVybiBsYWJlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcDEgMXN0IHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHAyIDJuZCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwMyAzcmQgcG9pbnQgb2YgdGhlIGJhY2tncm91bmQgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcDQgNHRoIHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gZmlsbEluc3RydWN0aW9uIEZpbGwgaW5zdHJ1Y3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IHN0cm9rZUluc3RydWN0aW9uIFN0cm9rZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIHJlcGxheVRleHRCYWNrZ3JvdW5kXyhcbiAgICBjb250ZXh0LFxuICAgIHAxLFxuICAgIHAyLFxuICAgIHAzLFxuICAgIHA0LFxuICAgIGZpbGxJbnN0cnVjdGlvbixcbiAgICBzdHJva2VJbnN0cnVjdGlvblxuICApIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvLmFwcGx5KGNvbnRleHQsIHAxKTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMik7XG4gICAgY29udGV4dC5saW5lVG8uYXBwbHkoY29udGV4dCwgcDMpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHA0KTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMSk7XG4gICAgaWYgKGZpbGxJbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5hbGlnbkZpbGxfID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoZmlsbEluc3RydWN0aW9uWzJdKTtcbiAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHJva2VJbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5zZXRTdHJva2VTdHlsZV8oXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChzdHJva2VJbnN0cnVjdGlvbilcbiAgICAgICk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRXaWR0aCBXaWR0aCBvZiB0aGUgc3ByaXRlIHNoZWV0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2hlZXRIZWlnaHQgSGVpZ2h0IG9mIHRoZSBzcHJpdGUgc2hlZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJYIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJZIFkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmNob3JYIEFuY2hvciBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5jaG9yWSBBbmNob3IgWS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblggT3JpZ2luIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc2l6ZS5qc1wiKS5TaXplfSBzY2FsZSBTY2FsZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHRvIHBpeGVsLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQHBhcmFtIHtib29sZWFufSBmaWxsU3Ryb2tlIEJhY2tncm91bmQgZmlsbCBvciBzdHJva2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtJbWFnZU9yTGFiZWxEaW1lbnNpb25zfSBEaW1lbnNpb25zIGZvciBwb3NpdGlvbmluZyBhbmQgZGVjbHV0dGVyaW5nIHRoZSBpbWFnZSBvciBsYWJlbC5cbiAgICovXG4gIGNhbGN1bGF0ZUltYWdlT3JMYWJlbERpbWVuc2lvbnNfKFxuICAgIHNoZWV0V2lkdGgsXG4gICAgc2hlZXRIZWlnaHQsXG4gICAgY2VudGVyWCxcbiAgICBjZW50ZXJZLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBhbmNob3JYLFxuICAgIGFuY2hvclksXG4gICAgb3JpZ2luWCxcbiAgICBvcmlnaW5ZLFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIHBhZGRpbmcsXG4gICAgZmlsbFN0cm9rZSxcbiAgICBmZWF0dXJlXG4gICkge1xuICAgIGFuY2hvclggKj0gc2NhbGVbMF07XG4gICAgYW5jaG9yWSAqPSBzY2FsZVsxXTtcbiAgICBsZXQgeCA9IGNlbnRlclggLSBhbmNob3JYO1xuICAgIGxldCB5ID0gY2VudGVyWSAtIGFuY2hvclk7XG5cbiAgICBjb25zdCB3ID0gd2lkdGggKyBvcmlnaW5YID4gc2hlZXRXaWR0aCA/IHNoZWV0V2lkdGggLSBvcmlnaW5YIDogd2lkdGg7XG4gICAgY29uc3QgaCA9IGhlaWdodCArIG9yaWdpblkgPiBzaGVldEhlaWdodCA/IHNoZWV0SGVpZ2h0IC0gb3JpZ2luWSA6IGhlaWdodDtcbiAgICBjb25zdCBib3hXID0gcGFkZGluZ1szXSArIHcgKiBzY2FsZVswXSArIHBhZGRpbmdbMV07XG4gICAgY29uc3QgYm94SCA9IHBhZGRpbmdbMF0gKyBoICogc2NhbGVbMV0gKyBwYWRkaW5nWzJdO1xuICAgIGNvbnN0IGJveFggPSB4IC0gcGFkZGluZ1szXTtcbiAgICBjb25zdCBib3hZID0geSAtIHBhZGRpbmdbMF07XG5cbiAgICBpZiAoZmlsbFN0cm9rZSB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgcDFbMF0gPSBib3hYO1xuICAgICAgcDRbMF0gPSBib3hYO1xuICAgICAgcDFbMV0gPSBib3hZO1xuICAgICAgcDJbMV0gPSBib3hZO1xuICAgICAgcDJbMF0gPSBib3hYICsgYm94VztcbiAgICAgIHAzWzBdID0gcDJbMF07XG4gICAgICBwM1sxXSA9IGJveFkgKyBib3hIO1xuICAgICAgcDRbMV0gPSBwM1sxXTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNmb3JtO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgICAgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybShcbiAgICAgICAgY3JlYXRlVHJhbnNmb3JtKCksXG4gICAgICAgIGNlbnRlclgsXG4gICAgICAgIGNlbnRlclksXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAtY2VudGVyWCxcbiAgICAgICAgLWNlbnRlcllcbiAgICAgICk7XG5cbiAgICAgIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSwgcDEpO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtLCBwMik7XG4gICAgICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0sIHAzKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSwgcDQpO1xuICAgICAgY3JlYXRlT3JVcGRhdGUoXG4gICAgICAgIE1hdGgubWluKHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSxcbiAgICAgICAgTWF0aC5taW4ocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pLFxuICAgICAgICBNYXRoLm1heChwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksXG4gICAgICAgIE1hdGgubWF4KHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSxcbiAgICAgICAgdG1wRXh0ZW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVPclVwZGF0ZShcbiAgICAgICAgTWF0aC5taW4oYm94WCwgYm94WCArIGJveFcpLFxuICAgICAgICBNYXRoLm1pbihib3hZLCBib3hZICsgYm94SCksXG4gICAgICAgIE1hdGgubWF4KGJveFgsIGJveFggKyBib3hXKSxcbiAgICAgICAgTWF0aC5tYXgoYm94WSwgYm94WSArIGJveEgpLFxuICAgICAgICB0bXBFeHRlbnRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzbmFwVG9QaXhlbCkge1xuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRyYXdJbWFnZVg6IHgsXG4gICAgICBkcmF3SW1hZ2VZOiB5LFxuICAgICAgZHJhd0ltYWdlVzogdyxcbiAgICAgIGRyYXdJbWFnZUg6IGgsXG4gICAgICBvcmlnaW5YOiBvcmlnaW5YLFxuICAgICAgb3JpZ2luWTogb3JpZ2luWSxcbiAgICAgIGRlY2x1dHRlckJveDoge1xuICAgICAgICBtaW5YOiB0bXBFeHRlbnRbMF0sXG4gICAgICAgIG1pblk6IHRtcEV4dGVudFsxXSxcbiAgICAgICAgbWF4WDogdG1wRXh0ZW50WzJdLFxuICAgICAgICBtYXhZOiB0bXBFeHRlbnRbM10sXG4gICAgICAgIHZhbHVlOiBmZWF0dXJlLFxuICAgICAgfSxcbiAgICAgIGNhbnZhc1RyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbnRleHRTY2FsZSBTY2FsZSBvZiB0aGUgY29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuTGFiZWx8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBpbWFnZU9yTGFiZWwgSW1hZ2UuXG4gICAqIEBwYXJhbSB7SW1hZ2VPckxhYmVsRGltZW5zaW9uc30gZGltZW5zaW9ucyBEaW1lbnNpb25zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBmaWxsSW5zdHJ1Y3Rpb24gRmlsbCBpbnN0cnVjdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gc3Ryb2tlSW5zdHJ1Y3Rpb24gU3Ryb2tlIGluc3RydWN0aW9uLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgaW1hZ2Ugb3IgbGFiZWwgd2FzIHJlbmRlcmVkLlxuICAgKi9cbiAgcmVwbGF5SW1hZ2VPckxhYmVsXyhcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHRTY2FsZSxcbiAgICBpbWFnZU9yTGFiZWwsXG4gICAgZGltZW5zaW9ucyxcbiAgICBvcGFjaXR5LFxuICAgIGZpbGxJbnN0cnVjdGlvbixcbiAgICBzdHJva2VJbnN0cnVjdGlvblxuICApIHtcbiAgICBjb25zdCBmaWxsU3Ryb2tlID0gISEoZmlsbEluc3RydWN0aW9uIHx8IHN0cm9rZUluc3RydWN0aW9uKTtcblxuICAgIGNvbnN0IGJveCA9IGRpbWVuc2lvbnMuZGVjbHV0dGVyQm94O1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IHN0cm9rZVBhZGRpbmcgPSBzdHJva2VJbnN0cnVjdGlvblxuICAgICAgPyAoc3Ryb2tlSW5zdHJ1Y3Rpb25bMl0gKiBkaW1lbnNpb25zLnNjYWxlWzBdKSAvIDJcbiAgICAgIDogMDtcbiAgICBjb25zdCBpbnRlcnNlY3RzID1cbiAgICAgIGJveC5taW5YIC0gc3Ryb2tlUGFkZGluZyA8PSBjYW52YXMud2lkdGggLyBjb250ZXh0U2NhbGUgJiZcbiAgICAgIGJveC5tYXhYICsgc3Ryb2tlUGFkZGluZyA+PSAwICYmXG4gICAgICBib3gubWluWSAtIHN0cm9rZVBhZGRpbmcgPD0gY2FudmFzLmhlaWdodCAvIGNvbnRleHRTY2FsZSAmJlxuICAgICAgYm94Lm1heFkgKyBzdHJva2VQYWRkaW5nID49IDA7XG5cbiAgICBpZiAoaW50ZXJzZWN0cykge1xuICAgICAgaWYgKGZpbGxTdHJva2UpIHtcbiAgICAgICAgdGhpcy5yZXBsYXlUZXh0QmFja2dyb3VuZF8oXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBwMSxcbiAgICAgICAgICBwMixcbiAgICAgICAgICBwMyxcbiAgICAgICAgICBwNCxcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAoZmlsbEluc3RydWN0aW9uKSxcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAoc3Ryb2tlSW5zdHJ1Y3Rpb24pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkcmF3SW1hZ2VPckxhYmVsKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBkaW1lbnNpb25zLmNhbnZhc1RyYW5zZm9ybSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgaW1hZ2VPckxhYmVsLFxuICAgICAgICBkaW1lbnNpb25zLm9yaWdpblgsXG4gICAgICAgIGRpbWVuc2lvbnMub3JpZ2luWSxcbiAgICAgICAgZGltZW5zaW9ucy5kcmF3SW1hZ2VXLFxuICAgICAgICBkaW1lbnNpb25zLmRyYXdJbWFnZUgsXG4gICAgICAgIGRpbWVuc2lvbnMuZHJhd0ltYWdlWCxcbiAgICAgICAgZGltZW5zaW9ucy5kcmF3SW1hZ2VZLFxuICAgICAgICBkaW1lbnNpb25zLnNjYWxlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKi9cbiAgZmlsbF8oY29udGV4dCkge1xuICAgIGlmICh0aGlzLmFsaWduRmlsbF8pIHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IGFwcGx5VHJhbnNmb3JtKHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fLCBbMCwgMF0pO1xuICAgICAgY29uc3QgcmVwZWF0U2l6ZSA9IDUxMiAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUob3JpZ2luWzBdICUgcmVwZWF0U2l6ZSwgb3JpZ2luWzFdICUgcmVwZWF0U2l6ZSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0aGlzLnZpZXdSb3RhdGlvbl8pO1xuICAgIH1cbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBpZiAodGhpcy5hbGlnbkZpbGxfKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb24gSW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBzZXRTdHJva2VTdHlsZV8oY29udGV4dCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb250ZXh0WydzdHJva2VTdHlsZSddID1cbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pO1xuICAgIGNvbnRleHQubGluZUNhcCA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUNhcH0gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lSm9pbn0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzVdKTtcbiAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls3XSk7XG4gICAgY29udGV4dC5zZXRMaW5lRGFzaCgvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChpbnN0cnVjdGlvbls2XSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHRleHQgVGhlIHRleHQgdG8gZHJhdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRLZXkgVGhlIGtleSBvZiB0aGUgdGV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZUtleSBUaGUga2V5IGZvciB0aGUgc3Ryb2tlIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsbEtleSBUaGUga2V5IGZvciB0aGUgZmlsbCBzdGF0ZS5cbiAgICogQHJldHVybiB7e2xhYmVsOiBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuTGFiZWwsIGFuY2hvclg6IG51bWJlciwgYW5jaG9yWTogbnVtYmVyfX0gVGhlIHRleHQgaW1hZ2UgYW5kIGl0cyBhbmNob3IuXG4gICAqL1xuICBkcmF3TGFiZWxXaXRoUG9pbnRQbGFjZW1lbnRfKHRleHQsIHRleHRLZXksIHN0cm9rZUtleSwgZmlsbEtleSkge1xuICAgIGNvbnN0IHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlc1t0ZXh0S2V5XTtcblxuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5jcmVhdGVMYWJlbCh0ZXh0LCB0ZXh0S2V5LCBmaWxsS2V5LCBzdHJva2VLZXkpO1xuXG4gICAgY29uc3Qgc3Ryb2tlU3RhdGUgPSB0aGlzLnN0cm9rZVN0YXRlc1tzdHJva2VLZXldO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgY29uc3QgYWxpZ24gPSBob3Jpem9udGFsVGV4dEFsaWduKFxuICAgICAgQXJyYXkuaXNBcnJheSh0ZXh0KSA/IHRleHRbMF0gOiB0ZXh0LFxuICAgICAgdGV4dFN0YXRlLnRleHRBbGlnbiB8fCBkZWZhdWx0VGV4dEFsaWduXG4gICAgKTtcbiAgICBjb25zdCBiYXNlbGluZSA9IFRFWFRfQUxJR05bdGV4dFN0YXRlLnRleHRCYXNlbGluZSB8fCBkZWZhdWx0VGV4dEJhc2VsaW5lXTtcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9XG4gICAgICBzdHJva2VTdGF0ZSAmJiBzdHJva2VTdGF0ZS5saW5lV2lkdGggPyBzdHJva2VTdGF0ZS5saW5lV2lkdGggOiAwO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSAyIHBpeGVscyB3ZSBhZGRlZCBpbiBjcmVhdGVMYWJlbCgpIGZvciB0aGUgYW5jaG9yXG4gICAgY29uc3Qgd2lkdGggPSBsYWJlbC53aWR0aCAvIHBpeGVsUmF0aW8gLSAyICogdGV4dFN0YXRlLnNjYWxlWzBdO1xuICAgIGNvbnN0IGFuY2hvclggPSBhbGlnbiAqIHdpZHRoICsgMiAqICgwLjUgLSBhbGlnbikgKiBzdHJva2VXaWR0aDtcbiAgICBjb25zdCBhbmNob3JZID1cbiAgICAgIChiYXNlbGluZSAqIGxhYmVsLmhlaWdodCkgLyBwaXhlbFJhdGlvICtcbiAgICAgIDIgKiAoMC41IC0gYmFzZWxpbmUpICogc3Ryb2tlV2lkdGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgYW5jaG9yWDogYW5jaG9yWCxcbiAgICAgIGFuY2hvclk6IGFuY2hvclksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFNjYWxlIFNjYWxlIG9mIHRoZSBjb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGluc3RydWN0aW9ucyBJbnN0cnVjdGlvbnMgYXJyYXkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0IHRvIGludGVnZXIgcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0ZlYXR1cmVDYWxsYmFjazxUPn0gW2ZlYXR1cmVDYWxsYmFja10gRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBbaGl0RXh0ZW50XSBPbmx5IGNoZWNrXG4gICAqICAgICBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCB0aGlzIGV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCJyYnVzaFwiKS5kZWZhdWx0fSBbZGVjbHV0dGVyVHJlZV0gRGVjbHV0dGVyIHRyZWUuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBleGVjdXRlXyhcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHRTY2FsZSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgaW5zdHJ1Y3Rpb25zLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIGZlYXR1cmVDYWxsYmFjayxcbiAgICBoaXRFeHRlbnQsXG4gICAgZGVjbHV0dGVyVHJlZVxuICApIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgbGV0IHBpeGVsQ29vcmRpbmF0ZXM7XG4gICAgaWYgKHRoaXMucGl4ZWxDb29yZGluYXRlc18gJiYgZXF1YWxzKHRyYW5zZm9ybSwgdGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8pKSB7XG4gICAgICBwaXhlbENvb3JkaW5hdGVzID0gdGhpcy5waXhlbENvb3JkaW5hdGVzXztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKSB7XG4gICAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc18gPSBbXTtcbiAgICAgIH1cbiAgICAgIHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIDIsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzX1xuICAgICAgKTtcbiAgICAgIHRyYW5zZm9ybVNldEZyb21BcnJheSh0aGlzLnJlbmRlcmVkVHJhbnNmb3JtXywgdHJhbnNmb3JtKTtcbiAgICB9XG4gICAgbGV0IGkgPSAwOyAvLyBpbnN0cnVjdGlvbiBpbmRleFxuICAgIGNvbnN0IGlpID0gaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgLy8gZW5kIG9mIGluc3RydWN0aW9uc1xuICAgIGxldCBkID0gMDsgLy8gZGF0YSBpbmRleFxuICAgIGxldCBkZDsgLy8gZW5kIG9mIHBlci1pbnN0cnVjdGlvbiBkYXRhXG4gICAgbGV0IGFuY2hvclgsXG4gICAgICBhbmNob3JZLFxuICAgICAgcHJldlgsXG4gICAgICBwcmV2WSxcbiAgICAgIHJvdW5kWCxcbiAgICAgIHJvdW5kWSxcbiAgICAgIGltYWdlLFxuICAgICAgdGV4dCxcbiAgICAgIHRleHRLZXksXG4gICAgICBzdHJva2VLZXksXG4gICAgICBmaWxsS2V5O1xuICAgIGxldCBwZW5kaW5nRmlsbCA9IDA7XG4gICAgbGV0IHBlbmRpbmdTdHJva2UgPSAwO1xuICAgIGxldCBsYXN0RmlsbEluc3RydWN0aW9uID0gbnVsbDtcbiAgICBsZXQgbGFzdFN0cm9rZUluc3RydWN0aW9uID0gbnVsbDtcbiAgICBjb25zdCBjb29yZGluYXRlQ2FjaGUgPSB0aGlzLmNvb3JkaW5hdGVDYWNoZV87XG4gICAgY29uc3Qgdmlld1JvdGF0aW9uID0gdGhpcy52aWV3Um90YXRpb25fO1xuICAgIGNvbnN0IHZpZXdSb3RhdGlvbkZyb21UcmFuc2Zvcm0gPVxuICAgICAgTWF0aC5yb3VuZChNYXRoLmF0YW4yKC10cmFuc2Zvcm1bMV0sIHRyYW5zZm9ybVswXSkgKiAxZTEyKSAvIDFlMTI7XG5cbiAgICBjb25zdCBzdGF0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyLmpzXCIpLlN0YXRlfSAqLyAoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgIHJlc29sdXRpb246IHRoaXMucmVzb2x1dGlvbixcbiAgICAgIHJvdGF0aW9uOiB2aWV3Um90YXRpb24sXG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIHRoZSBiYXRjaCBzaXplIGdldHMgdG9vIGJpZywgcGVyZm9ybWFuY2UgZGVjcmVhc2VzLiAyMDAgaXMgYSBnb29kXG4gICAgLy8gYmFsYW5jZSBiZXR3ZWVuIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBmaWxsL3N0cm9rZSBpbnN0cnVjdGlvbnMuXG4gICAgY29uc3QgYmF0Y2hTaXplID1cbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zICE9IGluc3RydWN0aW9ucyB8fCB0aGlzLm92ZXJsYXBzID8gMCA6IDIwMDtcbiAgICBsZXQgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSAqLyBmZWF0dXJlO1xuICAgIGxldCB4LCB5LCBjdXJyZW50R2VvbWV0cnk7XG4gICAgd2hpbGUgKGkgPCBpaSkge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0luc3RydWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgaW5zdHJ1Y3Rpb25bMF1cbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5CRUdJTl9HRU9NRVRSWTpcbiAgICAgICAgICBmZWF0dXJlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSAqLyAoXG4gICAgICAgICAgICBpbnN0cnVjdGlvblsxXVxuICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudEdlb21ldHJ5ID0gaW5zdHJ1Y3Rpb25bM107XG4gICAgICAgICAgaWYgKCFmZWF0dXJlLmdldEdlb21ldHJ5KCkpIHtcbiAgICAgICAgICAgIGkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgaGl0RXh0ZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFpbnRlcnNlY3RzKGhpdEV4dGVudCwgY3VycmVudEdlb21ldHJ5LmdldEV4dGVudCgpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5CRUdJTl9QQVRIOlxuICAgICAgICAgIGlmIChwZW5kaW5nRmlsbCA+IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICAgICAgICAgIHBlbmRpbmdGaWxsID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBlbmRpbmdTdHJva2UgPiBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICBwZW5kaW5nU3Ryb2tlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwZW5kaW5nRmlsbCAmJiAhcGVuZGluZ1N0cm9rZSkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHByZXZYID0gTmFOO1xuICAgICAgICAgICAgcHJldlkgPSBOYU47XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5DSVJDTEU6XG4gICAgICAgICAgZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGNvbnN0IHgxID0gcGl4ZWxDb29yZGluYXRlc1tkXTtcbiAgICAgICAgICBjb25zdCB5MSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgIGNvbnN0IHgyID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMl07XG4gICAgICAgICAgY29uc3QgeTIgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAzXTtcbiAgICAgICAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgICAgICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgICAgICAgIGNvbnN0IHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgxICsgciwgeTEpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHgxLCB5MSwgciwgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5DTE9TRV9QQVRIOlxuICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTTpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgZGQgPSBpbnN0cnVjdGlvblsyXTtcbiAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgICBpbnN0cnVjdGlvblszXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCByZW5kZXJlciA9IGluc3RydWN0aW9uWzRdO1xuICAgICAgICAgIGNvbnN0IGZuID0gaW5zdHJ1Y3Rpb24ubGVuZ3RoID09IDYgPyBpbnN0cnVjdGlvbls1XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBzdGF0ZS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgIHN0YXRlLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgIGlmICghKGkgaW4gY29vcmRpbmF0ZUNhY2hlKSkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZUNhY2hlW2ldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGNvb3JkaW5hdGVDYWNoZVtpXTtcbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIGZuKHBpeGVsQ29vcmRpbmF0ZXMsIGQsIGRkLCAyLCBjb29yZHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb29yZHNbMF0gPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgICAgY29vcmRzWzFdID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgICBjb29yZHMubGVuZ3RoID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVuZGVyZXIoY29vcmRzLCBzdGF0ZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0U6XG4gICAgICAgICAgZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGRkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgaW1hZ2UgPVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9ICovIChcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bM11cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIGluIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgICAgIGFuY2hvclggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICAgICAgICBhbmNob3JZID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls1XSk7XG4gICAgICAgICAgbGV0IGhlaWdodCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNl0pO1xuICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzddKTtcbiAgICAgICAgICBjb25zdCBvcmlnaW5YID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls4XSk7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luWSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bOV0pO1xuICAgICAgICAgIGNvbnN0IHJvdGF0ZVdpdGhWaWV3ID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMTBdKTtcbiAgICAgICAgICBsZXQgcm90YXRpb24gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzExXSk7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZX0gKi8gKFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bMTJdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgd2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzEzXSk7XG4gICAgICAgICAgY29uc3QgZGVjbHV0dGVyTW9kZSA9XG4gICAgICAgICAgICAvKiogQHR5cGUge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH0gKi8gKFxuICAgICAgICAgICAgICBpbnN0cnVjdGlvblsxNF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCA9XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJJbWFnZVdpdGhUZXh0fSAqLyAoXG4gICAgICAgICAgICAgIGluc3RydWN0aW9uWzE1XVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghaW1hZ2UgJiYgaW5zdHJ1Y3Rpb24ubGVuZ3RoID49IDIwKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgbGFiZWwgaW1hZ2VzXG4gICAgICAgICAgICB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxOV0pO1xuICAgICAgICAgICAgdGV4dEtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bMjBdKTtcbiAgICAgICAgICAgIHN0cm9rZUtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bMjFdKTtcbiAgICAgICAgICAgIGZpbGxLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzIyXSk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFdpdGhBbmNob3IgPSB0aGlzLmRyYXdMYWJlbFdpdGhQb2ludFBsYWNlbWVudF8oXG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIHRleHRLZXksXG4gICAgICAgICAgICAgIHN0cm9rZUtleSxcbiAgICAgICAgICAgICAgZmlsbEtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGltYWdlID0gbGFiZWxXaXRoQW5jaG9yLmxhYmVsO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bM10gPSBpbWFnZTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRPZmZzZXRYID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyM10pO1xuICAgICAgICAgICAgYW5jaG9yWCA9IChsYWJlbFdpdGhBbmNob3IuYW5jaG9yWCAtIHRleHRPZmZzZXRYKSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGluc3RydWN0aW9uWzRdID0gYW5jaG9yWDtcbiAgICAgICAgICAgIGNvbnN0IHRleHRPZmZzZXRZID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyNF0pO1xuICAgICAgICAgICAgYW5jaG9yWSA9IChsYWJlbFdpdGhBbmNob3IuYW5jaG9yWSAtIHRleHRPZmZzZXRZKSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGluc3RydWN0aW9uWzVdID0gYW5jaG9yWTtcbiAgICAgICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGluc3RydWN0aW9uWzZdID0gaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIGluc3RydWN0aW9uWzEzXSA9IHdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBnZW9tZXRyeVdpZHRocztcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubGVuZ3RoID4gMjUpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5V2lkdGhzID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyNV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwYWRkaW5nLCBiYWNrZ3JvdW5kRmlsbCwgYmFja2dyb3VuZFN0cm9rZTtcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubGVuZ3RoID4gMTcpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChpbnN0cnVjdGlvblsxNl0pO1xuICAgICAgICAgICAgYmFja2dyb3VuZEZpbGwgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpbnN0cnVjdGlvblsxN10pO1xuICAgICAgICAgICAgYmFja2dyb3VuZFN0cm9rZSA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGluc3RydWN0aW9uWzE4XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSBkZWZhdWx0UGFkZGluZztcbiAgICAgICAgICAgIGJhY2tncm91bmRGaWxsID0gZmFsc2U7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvdGF0ZVdpdGhWaWV3ICYmIHZpZXdSb3RhdGlvbkZyb21UcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIENhbnZhcyBpcyBleHBlY3RlZCB0byBiZSByb3RhdGVkIHRvIHJldmVyc2UgdmlldyByb3RhdGlvbi5cbiAgICAgICAgICAgIHJvdGF0aW9uICs9IHZpZXdSb3RhdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFyb3RhdGVXaXRoVmlldyAmJiAhdmlld1JvdGF0aW9uRnJvbVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQ2FudmFzIGlzIG5vdCByb3RhdGVkLCBpbWFnZXMgbmVlZCB0byBiZSByb3RhdGVkIGJhY2sgdG8gYmUgbm9ydGgtdXAuXG4gICAgICAgICAgICByb3RhdGlvbiAtPSB2aWV3Um90YXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB3aWR0aEluZGV4ID0gMDtcbiAgICAgICAgICBmb3IgKDsgZCA8IGRkOyBkICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZ2VvbWV0cnlXaWR0aHMgJiZcbiAgICAgICAgICAgICAgZ2VvbWV0cnlXaWR0aHNbd2lkdGhJbmRleCsrXSA8IHdpZHRoIC8gdGhpcy5waXhlbFJhdGlvXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5jYWxjdWxhdGVJbWFnZU9yTGFiZWxEaW1lbnNpb25zXyhcbiAgICAgICAgICAgICAgaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICAgIGltYWdlLmhlaWdodCxcbiAgICAgICAgICAgICAgcGl4ZWxDb29yZGluYXRlc1tkXSxcbiAgICAgICAgICAgICAgcGl4ZWxDb29yZGluYXRlc1tkICsgMV0sXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIGFuY2hvclgsXG4gICAgICAgICAgICAgIGFuY2hvclksXG4gICAgICAgICAgICAgIG9yaWdpblgsXG4gICAgICAgICAgICAgIG9yaWdpblksXG4gICAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgICAgc25hcFRvUGl4ZWwsXG4gICAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRGaWxsIHx8IGJhY2tncm91bmRTdHJva2UsXG4gICAgICAgICAgICAgIGZlYXR1cmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvKiogQHR5cGUge1JlcGxheUltYWdlT3JMYWJlbEFyZ3N9ICovXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBjb250ZXh0U2NhbGUsXG4gICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbFxuICAgICAgICAgICAgICAgID8gLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKGxhc3RGaWxsSW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlXG4gICAgICAgICAgICAgICAgPyAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAobGFzdFN0cm9rZUluc3RydWN0aW9uKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoZGVjbHV0dGVyVHJlZSkge1xuICAgICAgICAgICAgICBpZiAoZGVjbHV0dGVyTW9kZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IHJlbmRlcmVkIGluIGRlY2x1dHRlciBncm91cFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlY2x1dHRlck1vZGUgPT09ICdvYnN0YWNsZScpIHtcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGFsd2F5cyBiZSBkcmF3biwgdGh1cyBubyBjb2xsaXNpb24gZGV0ZWN0aW9uLCBidXQgaW5zZXJ0IGFzIG9ic3RhY2xlXG4gICAgICAgICAgICAgICAgZGVjbHV0dGVyVHJlZS5pbnNlcnQoZGltZW5zaW9ucy5kZWNsdXR0ZXJCb3gpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpbWFnZUFyZ3M7XG4gICAgICAgICAgICAgICAgbGV0IGltYWdlRGVjbHV0dGVyQm94O1xuICAgICAgICAgICAgICAgIGlmIChkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGRkIC0gZDtcbiAgICAgICAgICAgICAgICAgIGlmICghZGVjbHV0dGVySW1hZ2VXaXRoVGV4dFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugbm93IGhhdmUgdGhlIGltYWdlIGZvciBhbiBpbWFnZSt0ZXh0IGNvbWJpbmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0W2luZGV4XSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlbmRlciBhbnl0aGluZyBmb3Igbm93LCB3YWl0IGZvciB0aGUgdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbWFnZUFyZ3MgPSBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGltYWdlRGVjbHV0dGVyQm94ID0gZ2V0RGVjbHV0dGVyQm94KGltYWdlQXJncyk7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVjbHV0dGVyVHJlZS5jb2xsaWRlcyhpbWFnZURlY2x1dHRlckJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWNsdXR0ZXJUcmVlLmNvbGxpZGVzKGRpbWVuc2lvbnMuZGVjbHV0dGVyQm94KSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWFnZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlIG5vdyBoYXZlIGltYWdlIGFuZCB0ZXh0IGZvciBhbiBpbWFnZSt0ZXh0IGNvbWJpbmF0aW9uLlxuICAgICAgICAgICAgICAgICAgZGVjbHV0dGVyVHJlZS5pbnNlcnQoaW1hZ2VEZWNsdXR0ZXJCb3gpO1xuICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBpbWFnZSBiZWZvcmUgd2UgcmVuZGVyIHRoZSB0ZXh0LlxuICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYXlJbWFnZU9yTGFiZWxfLmFwcGx5KHRoaXMsIGltYWdlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY2x1dHRlclRyZWUuaW5zZXJ0KGRpbWVuc2lvbnMuZGVjbHV0dGVyQm94KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYXlJbWFnZU9yTGFiZWxfLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUzpcbiAgICAgICAgICBjb25zdCBiZWdpbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGNvbnN0IGVuZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICAgIGNvbnN0IGJhc2VsaW5lID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblszXSk7XG4gICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICAgICAgICBmaWxsS2V5ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvbls1XSk7XG4gICAgICAgICAgY29uc3QgbWF4QW5nbGUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzZdKTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlUGl4ZWxSYXRpbyA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzhdKTtcbiAgICAgICAgICBzdHJva2VLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzldKTtcbiAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTBdKTtcbiAgICAgICAgICB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxMV0pO1xuICAgICAgICAgIHRleHRLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzEyXSk7XG4gICAgICAgICAgY29uc3QgcGl4ZWxSYXRpb1NjYWxlID0gW1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxM10pLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxM10pLFxuICAgICAgICAgIF07XG5cbiAgICAgICAgICBjb25zdCB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZXNbdGV4dEtleV07XG4gICAgICAgICAgY29uc3QgZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgICAgICAgIGNvbnN0IHRleHRTY2FsZSA9IFtcbiAgICAgICAgICAgIHRleHRTdGF0ZS5zY2FsZVswXSAqIG1lYXN1cmVQaXhlbFJhdGlvLFxuICAgICAgICAgICAgdGV4dFN0YXRlLnNjYWxlWzFdICogbWVhc3VyZVBpeGVsUmF0aW8sXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGxldCBjYWNoZWRXaWR0aHM7XG4gICAgICAgICAgaWYgKGZvbnQgaW4gdGhpcy53aWR0aHNfKSB7XG4gICAgICAgICAgICBjYWNoZWRXaWR0aHMgPSB0aGlzLndpZHRoc19bZm9udF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFdpZHRocyA9IHt9O1xuICAgICAgICAgICAgdGhpcy53aWR0aHNfW2ZvbnRdID0gY2FjaGVkV2lkdGhzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHBhdGhMZW5ndGggPSBsaW5lU3RyaW5nTGVuZ3RoKHBpeGVsQ29vcmRpbmF0ZXMsIGJlZ2luLCBlbmQsIDIpO1xuICAgICAgICAgIGNvbnN0IHRleHRMZW5ndGggPVxuICAgICAgICAgICAgTWF0aC5hYnModGV4dFNjYWxlWzBdKSAqXG4gICAgICAgICAgICBtZWFzdXJlQW5kQ2FjaGVUZXh0V2lkdGgoZm9udCwgdGV4dCwgY2FjaGVkV2lkdGhzKTtcbiAgICAgICAgICBpZiAob3ZlcmZsb3cgfHwgdGV4dExlbmd0aCA8PSBwYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QWxpZ24gPSB0aGlzLnRleHRTdGF0ZXNbdGV4dEtleV0udGV4dEFsaWduO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRNID1cbiAgICAgICAgICAgICAgKHBhdGhMZW5ndGggLSB0ZXh0TGVuZ3RoKSAqIGhvcml6b250YWxUZXh0QWxpZ24odGV4dCwgdGV4dEFsaWduKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZHJhd1RleHRPblBhdGgoXG4gICAgICAgICAgICAgIHBpeGVsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgIGJlZ2luLFxuICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIHN0YXJ0TSxcbiAgICAgICAgICAgICAgbWF4QW5nbGUsXG4gICAgICAgICAgICAgIE1hdGguYWJzKHRleHRTY2FsZVswXSksXG4gICAgICAgICAgICAgIG1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aCxcbiAgICAgICAgICAgICAgZm9udCxcbiAgICAgICAgICAgICAgY2FjaGVkV2lkdGhzLFxuICAgICAgICAgICAgICB2aWV3Um90YXRpb25Gcm9tVHJhbnNmb3JtID8gMCA6IHRoaXMudmlld1JvdGF0aW9uX1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRyYXdDaGFyczogaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8UmVwbGF5SW1hZ2VPckxhYmVsQXJncz59ICovXG4gICAgICAgICAgICAgIGNvbnN0IHJlcGxheUltYWdlT3JMYWJlbEFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgbGV0IGMsIGNjLCBjaGFycywgbGFiZWwsIHBhcnQ7XG4gICAgICAgICAgICAgIGlmIChzdHJva2VLZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGMgPSAwLCBjYyA9IHBhcnRzLmxlbmd0aDsgYyA8IGNjOyArK2MpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tjXTsgLy8geCwgeSwgYW5jaG9yWCwgcm90YXRpb24sIGNodW5rXG4gICAgICAgICAgICAgICAgICBjaGFycyA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGFydFs0XSk7XG4gICAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMuY3JlYXRlTGFiZWwoY2hhcnMsIHRleHRLZXksICcnLCBzdHJva2VLZXkpO1xuICAgICAgICAgICAgICAgICAgYW5jaG9yWCA9XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFsyXSkgK1xuICAgICAgICAgICAgICAgICAgICAodGV4dFNjYWxlWzBdIDwgMCA/IC1zdHJva2VXaWR0aCA6IHN0cm9rZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclkgPVxuICAgICAgICAgICAgICAgICAgICBiYXNlbGluZSAqIGxhYmVsLmhlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICgoMC41IC0gYmFzZWxpbmUpICogMiAqIHN0cm9rZVdpZHRoICogdGV4dFNjYWxlWzFdKSAvXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dFNjYWxlWzBdIC1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmNhbGN1bGF0ZUltYWdlT3JMYWJlbERpbWVuc2lvbnNfKFxuICAgICAgICAgICAgICAgICAgICBsYWJlbC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBwYXJ0WzBdLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0WzFdLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JYLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JZLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0WzNdLFxuICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvU2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGRlY2x1dHRlclRyZWUgJiZcbiAgICAgICAgICAgICAgICAgICAgZGVjbHV0dGVyVHJlZS5jb2xsaWRlcyhkaW1lbnNpb25zLmRlY2x1dHRlckJveClcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBkcmF3Q2hhcnM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXBsYXlJbWFnZU9yTGFiZWxBcmdzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmaWxsS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjID0gMCwgY2MgPSBwYXJ0cy5sZW5ndGg7IGMgPCBjYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbY107IC8vIHgsIHksIGFuY2hvclgsIHJvdGF0aW9uLCBjaHVua1xuICAgICAgICAgICAgICAgICAgY2hhcnMgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhcnRbNF0pO1xuICAgICAgICAgICAgICAgICAgbGFiZWwgPSB0aGlzLmNyZWF0ZUxhYmVsKGNoYXJzLCB0ZXh0S2V5LCBmaWxsS2V5LCAnJyk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JYID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzJdKTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclkgPSBiYXNlbGluZSAqIGxhYmVsLmhlaWdodCAtIG9mZnNldFk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5jYWxjdWxhdGVJbWFnZU9yTGFiZWxEaW1lbnNpb25zXyhcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcGFydFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFydFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yWCxcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yWSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgcGFydFszXSxcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpb1NjYWxlLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJUcmVlICYmXG4gICAgICAgICAgICAgICAgICAgIGRlY2x1dHRlclRyZWUuY29sbGlkZXMoZGltZW5zaW9ucy5kZWNsdXR0ZXJCb3gpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZHJhd0NoYXJzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVwbGF5SW1hZ2VPckxhYmVsQXJncy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGVjbHV0dGVyVHJlZSkge1xuICAgICAgICAgICAgICAgIGRlY2x1dHRlclRyZWUubG9hZChyZXBsYXlJbWFnZU9yTGFiZWxBcmdzLm1hcChnZXREZWNsdXR0ZXJCb3gpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSByZXBsYXlJbWFnZU9yTGFiZWxBcmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxheUltYWdlT3JMYWJlbF8uYXBwbHkodGhpcywgcmVwbGF5SW1hZ2VPckxhYmVsQXJnc1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkVORF9HRU9NRVRSWTpcbiAgICAgICAgICBpZiAoZmVhdHVyZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9ICovIChcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmZWF0dXJlQ2FsbGJhY2soZmVhdHVyZSwgY3VycmVudEdlb21ldHJ5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkZJTEw6XG4gICAgICAgICAgaWYgKGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgcGVuZGluZ0ZpbGwrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLk1PVkVfVE9fTElORV9UTzpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgZGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICB4ID0gcGl4ZWxDb29yZGluYXRlc1tkXTtcbiAgICAgICAgICB5ID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgcm91bmRYID0gKHggKyAwLjUpIHwgMDtcbiAgICAgICAgICByb3VuZFkgPSAoeSArIDAuNSkgfCAwO1xuICAgICAgICAgIGlmIChyb3VuZFggIT09IHByZXZYIHx8IHJvdW5kWSAhPT0gcHJldlkpIHtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgcHJldlggPSByb3VuZFg7XG4gICAgICAgICAgICBwcmV2WSA9IHJvdW5kWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChkICs9IDI7IGQgPCBkZDsgZCArPSAyKSB7XG4gICAgICAgICAgICB4ID0gcGl4ZWxDb29yZGluYXRlc1tkXTtcbiAgICAgICAgICAgIHkgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICAgIHJvdW5kWCA9ICh4ICsgMC41KSB8IDA7XG4gICAgICAgICAgICByb3VuZFkgPSAoeSArIDAuNSkgfCAwO1xuICAgICAgICAgICAgaWYgKGQgPT0gZGQgLSAyIHx8IHJvdW5kWCAhPT0gcHJldlggfHwgcm91bmRZICE9PSBwcmV2WSkge1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgcHJldlggPSByb3VuZFg7XG4gICAgICAgICAgICAgIHByZXZZID0gcm91bmRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEU6XG4gICAgICAgICAgbGFzdEZpbGxJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAgIHRoaXMuYWxpZ25GaWxsXyA9IGluc3RydWN0aW9uWzJdO1xuXG4gICAgICAgICAgaWYgKHBlbmRpbmdGaWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgICAgICAgICAgcGVuZGluZ0ZpbGwgPSAwO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdTdHJva2UpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSAqLyAoXG4gICAgICAgICAgICAgIGluc3RydWN0aW9uWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFOlxuICAgICAgICAgIGxhc3RTdHJva2VJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlU3R5bGVfKGNvbnRleHQsIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TVFJPS0U6XG4gICAgICAgICAgaWYgKGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIGNvbnN1bWUgdGhlIGluc3RydWN0aW9uIGFueXdheSwgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBlbmRpbmdGaWxsKSB7XG4gICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAocGVuZGluZ1N0cm9rZSkge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFNjYWxlIFNjYWxlIG9mIHRoZSBjb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Um90YXRpb24gVmlldyByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRleHQgdG8gaW50ZWdlciBwaXhlbHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwicmJ1c2hcIikuZGVmYXVsdH0gW2RlY2x1dHRlclRyZWVdIERlY2x1dHRlciB0cmVlLlxuICAgKi9cbiAgZXhlY3V0ZShcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHRTY2FsZSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld1JvdGF0aW9uLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIGRlY2x1dHRlclRyZWVcbiAgKSB7XG4gICAgdGhpcy52aWV3Um90YXRpb25fID0gdmlld1JvdGF0aW9uO1xuICAgIHRoaXMuZXhlY3V0ZV8oXG4gICAgICBjb250ZXh0LFxuICAgICAgY29udGV4dFNjYWxlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMsXG4gICAgICBzbmFwVG9QaXhlbCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGRlY2x1dHRlclRyZWVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdSb3RhdGlvbiBWaWV3IHJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge0ZlYXR1cmVDYWxsYmFjazxUPn0gW2ZlYXR1cmVDYWxsYmFja10gRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBbaGl0RXh0ZW50XSBPbmx5IGNoZWNrXG4gICAqICAgICBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCB0aGlzIGV4dGVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGV4ZWN1dGVIaXREZXRlY3Rpb24oXG4gICAgY29udGV4dCxcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld1JvdGF0aW9uLFxuICAgIGZlYXR1cmVDYWxsYmFjayxcbiAgICBoaXRFeHRlbnRcbiAgKSB7XG4gICAgdGhpcy52aWV3Um90YXRpb25fID0gdmlld1JvdGF0aW9uO1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVfKFxuICAgICAgY29udGV4dCxcbiAgICAgIDEsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucyxcbiAgICAgIHRydWUsXG4gICAgICBmZWF0dXJlQ2FsbGJhY2ssXG4gICAgICBoaXRFeHRlbnRcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4ZWN1dG9yO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yR3JvdXBcbiAqL1xuXG5pbXBvcnQgRXhlY3V0b3IgZnJvbSAnLi9FeGVjdXRvci5qcyc7XG5pbXBvcnQge2FzY2VuZGluZ30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtidWZmZXIsIGNyZWF0ZUVtcHR5LCBleHRlbmRDb29yZGluYXRlfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uLy4uL29iai5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybTJEfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuQnVpbGRlclR5cGU+fVxuICovXG5jb25zdCBPUkRFUiA9IFsnUG9seWdvbicsICdDaXJjbGUnLCAnTGluZVN0cmluZycsICdJbWFnZScsICdUZXh0JywgJ0RlZmF1bHQnXTtcblxuY2xhc3MgRXhlY3V0b3JHcm91cCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IG1heEV4dGVudCBNYXggZXh0ZW50IGZvciBjbGlwcGluZy4gV2hlbiBhXG4gICAqIGBtYXhFeHRlbnRgIHdhcyBzZXQgb24gdGhlIEJ1aWxkZXIgZm9yIHRoaXMgZXhlY3V0b3IgZ3JvdXAsIHRoZSBzYW1lIGBtYXhFeHRlbnRgXG4gICAqIHNob3VsZCBiZSBzZXQgaGVyZSwgdW5sZXNzIHRoZSB0YXJnZXQgY29udGV4dCBkb2VzIG5vdCBleGNlZWQgdGhhdCBleHRlbnQgKHdoaWNoXG4gICAqIGNhbiBiZSB0aGUgY2FzZSB3aGVuIHJlbmRlcmluZyB0byB0aWxlcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXBzIFRoZSBleGVjdXRvciBncm91cCBjYW4gaGF2ZSBvdmVybGFwcGluZyBnZW9tZXRyaWVzLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5CdWlsZGVyVHlwZSwgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9ucz4+fSBhbGxJbnN0cnVjdGlvbnNcbiAgICogVGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVuZGVyQnVmZmVyXSBPcHRpb25hbCByZW5kZXJpbmcgYnVmZmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgbWF4RXh0ZW50LFxuICAgIHJlc29sdXRpb24sXG4gICAgcGl4ZWxSYXRpbyxcbiAgICBvdmVybGFwcyxcbiAgICBhbGxJbnN0cnVjdGlvbnMsXG4gICAgcmVuZGVyQnVmZmVyXG4gICkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5tYXhFeHRlbnRfID0gbWF4RXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXBzXyA9IG92ZXJsYXBzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckJ1ZmZlcl8gPSByZW5kZXJCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU9iamVjdDxpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuQnVpbGRlclR5cGUsIGltcG9ydChcIi4vRXhlY3V0b3JcIikuZGVmYXVsdD4+fVxuICAgICAqL1xuICAgIHRoaXMuZXhlY3V0b3JzQnlaSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25Db250ZXh0XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgdGhpcy5jcmVhdGVFeGVjdXRvcnNfKGFsbEluc3RydWN0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKi9cbiAgY2xpcChjb250ZXh0LCB0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBmbGF0Q2xpcENvb3JkcyA9IHRoaXMuZ2V0Q2xpcENvb3Jkcyh0cmFuc2Zvcm0pO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oZmxhdENsaXBDb29yZHNbMF0sIGZsYXRDbGlwQ29vcmRzWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhmbGF0Q2xpcENvb3Jkc1syXSwgZmxhdENsaXBDb29yZHNbM10pO1xuICAgIGNvbnRleHQubGluZVRvKGZsYXRDbGlwQ29vcmRzWzRdLCBmbGF0Q2xpcENvb3Jkc1s1XSk7XG4gICAgY29udGV4dC5saW5lVG8oZmxhdENsaXBDb29yZHNbNl0sIGZsYXRDbGlwQ29vcmRzWzddKTtcbiAgICBjb250ZXh0LmNsaXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZXhlY3V0b3JzIGFuZCBwb3B1bGF0ZSB0aGVtIHVzaW5nIHRoZSBwcm92aWRlZCBpbnN0cnVjdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFPYmplY3Q8aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkJ1aWxkZXJUeXBlLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU2VyaWFsaXphYmxlSW5zdHJ1Y3Rpb25zPj59IGFsbEluc3RydWN0aW9ucyBUaGUgc2VyaWFsaXphYmxlIGluc3RydWN0aW9uc1xuICAgKi9cbiAgY3JlYXRlRXhlY3V0b3JzXyhhbGxJbnN0cnVjdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IHpJbmRleCBpbiBhbGxJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGxldCBleGVjdXRvcnMgPSB0aGlzLmV4ZWN1dG9yc0J5WkluZGV4X1t6SW5kZXhdO1xuICAgICAgaWYgKGV4ZWN1dG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4ZWN1dG9ycyA9IHt9O1xuICAgICAgICB0aGlzLmV4ZWN1dG9yc0J5WkluZGV4X1t6SW5kZXhdID0gZXhlY3V0b3JzO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25CeVppbmRleCA9IGFsbEluc3RydWN0aW9uc1t6SW5kZXhdO1xuICAgICAgZm9yIChjb25zdCBidWlsZGVyVHlwZSBpbiBpbnN0cnVjdGlvbkJ5WmluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IGluc3RydWN0aW9uQnlaaW5kZXhbYnVpbGRlclR5cGVdO1xuICAgICAgICBleGVjdXRvcnNbYnVpbGRlclR5cGVdID0gbmV3IEV4ZWN1dG9yKFxuICAgICAgICAgIHRoaXMucmVzb2x1dGlvbl8sXG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgICB0aGlzLm92ZXJsYXBzXyxcbiAgICAgICAgICBpbnN0cnVjdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuQnVpbGRlclR5cGU+fSBleGVjdXRvcnMgRXhlY3V0b3JzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBIYXMgZXhlY3V0b3JzIG9mIHRoZSBwcm92aWRlZCB0eXBlcy5cbiAgICovXG4gIGhhc0V4ZWN1dG9ycyhleGVjdXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHpJbmRleCBpbiB0aGlzLmV4ZWN1dG9yc0J5WkluZGV4Xykge1xuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuZXhlY3V0b3JzQnlaSW5kZXhfW3pJbmRleF07XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBleGVjdXRvcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAoZXhlY3V0b3JzW2ldIGluIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIGltcG9ydChcIi4uLy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdCwgbnVtYmVyKTogVH0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlPn0gZGVjbHV0dGVyZWRGZWF0dXJlcyBEZWNsdXR0ZXJlZCBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgcmVzb2x1dGlvbixcbiAgICByb3RhdGlvbixcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgY2FsbGJhY2ssXG4gICAgZGVjbHV0dGVyZWRGZWF0dXJlc1xuICApIHtcbiAgICBoaXRUb2xlcmFuY2UgPSBNYXRoLnJvdW5kKGhpdFRvbGVyYW5jZSk7XG4gICAgY29uc3QgY29udGV4dFNpemUgPSBoaXRUb2xlcmFuY2UgKiAyICsgMTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgdGhpcy5oaXREZXRlY3Rpb25UcmFuc2Zvcm1fLFxuICAgICAgaGl0VG9sZXJhbmNlICsgMC41LFxuICAgICAgaGl0VG9sZXJhbmNlICsgMC41LFxuICAgICAgMSAvIHJlc29sdXRpb24sXG4gICAgICAtMSAvIHJlc29sdXRpb24sXG4gICAgICAtcm90YXRpb24sXG4gICAgICAtY29vcmRpbmF0ZVswXSxcbiAgICAgIC1jb29yZGluYXRlWzFdXG4gICAgKTtcblxuICAgIGNvbnN0IG5ld0NvbnRleHQgPSAhdGhpcy5oaXREZXRlY3Rpb25Db250ZXh0XztcbiAgICBpZiAobmV3Q29udGV4dCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25Db250ZXh0XyA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICAgICAgY29udGV4dFNpemUsXG4gICAgICAgIGNvbnRleHRTaXplLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHt3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWV9XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5oaXREZXRlY3Rpb25Db250ZXh0XztcblxuICAgIGlmIChcbiAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoICE9PSBjb250ZXh0U2l6ZSB8fFxuICAgICAgY29udGV4dC5jYW52YXMuaGVpZ2h0ICE9PSBjb250ZXh0U2l6ZVxuICAgICkge1xuICAgICAgY29udGV4dC5jYW52YXMud2lkdGggPSBjb250ZXh0U2l6ZTtcbiAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IGNvbnRleHRTaXplO1xuICAgIH0gZWxzZSBpZiAoIW5ld0NvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNvbnRleHRTaXplLCBjb250ZXh0U2l6ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgbGV0IGhpdEV4dGVudDtcbiAgICBpZiAodGhpcy5yZW5kZXJCdWZmZXJfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhpdEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGhpdEV4dGVudCwgY29vcmRpbmF0ZSk7XG4gICAgICBidWZmZXIoXG4gICAgICAgIGhpdEV4dGVudCxcbiAgICAgICAgcmVzb2x1dGlvbiAqICh0aGlzLnJlbmRlckJ1ZmZlcl8gKyBoaXRUb2xlcmFuY2UpLFxuICAgICAgICBoaXRFeHRlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXhlcyA9IGdldFBpeGVsSW5kZXhBcnJheShoaXRUb2xlcmFuY2UpO1xuXG4gICAgbGV0IGJ1aWxkZXJUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmVhdHVyZUNhbGxiYWNrKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY29udGV4dFNpemUsXG4gICAgICAgIGNvbnRleHRTaXplXG4gICAgICApLmRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgaWYgKGltYWdlRGF0YVtpbmRleGVzW2ldXSA+IDApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZGVjbHV0dGVyZWRGZWF0dXJlcyB8fFxuICAgICAgICAgICAgKGJ1aWxkZXJUeXBlICE9PSAnSW1hZ2UnICYmIGJ1aWxkZXJUeXBlICE9PSAnVGV4dCcpIHx8XG4gICAgICAgICAgICBkZWNsdXR0ZXJlZEZlYXR1cmVzLmluY2x1ZGVzKGZlYXR1cmUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSAoaW5kZXhlc1tpXSAtIDMpIC8gNDtcbiAgICAgICAgICAgIGNvbnN0IHggPSBoaXRUb2xlcmFuY2UgLSAoaWR4ICUgY29udGV4dFNpemUpO1xuICAgICAgICAgICAgY29uc3QgeSA9IGhpdFRvbGVyYW5jZSAtICgoaWR4IC8gY29udGV4dFNpemUpIHwgMCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayhmZWF0dXJlLCBnZW9tZXRyeSwgeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNvbnRleHRTaXplLCBjb250ZXh0U2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHpzID0gT2JqZWN0LmtleXModGhpcy5leGVjdXRvcnNCeVpJbmRleF8pLm1hcChOdW1iZXIpO1xuICAgIHpzLnNvcnQoYXNjZW5kaW5nKTtcblxuICAgIGxldCBpLCBqLCBleGVjdXRvcnMsIGV4ZWN1dG9yLCByZXN1bHQ7XG4gICAgZm9yIChpID0genMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHpJbmRleEtleSA9IHpzW2ldLnRvU3RyaW5nKCk7XG4gICAgICBleGVjdXRvcnMgPSB0aGlzLmV4ZWN1dG9yc0J5WkluZGV4X1t6SW5kZXhLZXldO1xuICAgICAgZm9yIChqID0gT1JERVIubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgYnVpbGRlclR5cGUgPSBPUkRFUltqXTtcbiAgICAgICAgZXhlY3V0b3IgPSBleGVjdXRvcnNbYnVpbGRlclR5cGVdO1xuICAgICAgICBpZiAoZXhlY3V0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IGV4ZWN1dG9yLmV4ZWN1dGVIaXREZXRlY3Rpb24oXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICBmZWF0dXJlQ2FsbGJhY2ssXG4gICAgICAgICAgICBoaXRFeHRlbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IENsaXAgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRDbGlwQ29vcmRzKHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IG1heEV4dGVudCA9IHRoaXMubWF4RXh0ZW50XztcbiAgICBpZiAoIW1heEV4dGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1pblggPSBtYXhFeHRlbnRbMF07XG4gICAgY29uc3QgbWluWSA9IG1heEV4dGVudFsxXTtcbiAgICBjb25zdCBtYXhYID0gbWF4RXh0ZW50WzJdO1xuICAgIGNvbnN0IG1heFkgPSBtYXhFeHRlbnRbM107XG4gICAgY29uc3QgZmxhdENsaXBDb29yZHMgPSBbbWluWCwgbWluWSwgbWluWCwgbWF4WSwgbWF4WCwgbWF4WSwgbWF4WCwgbWluWV07XG4gICAgdHJhbnNmb3JtMkQoZmxhdENsaXBDb29yZHMsIDAsIDgsIDIsIHRyYW5zZm9ybSwgZmxhdENsaXBDb29yZHMpO1xuICAgIHJldHVybiBmbGF0Q2xpcENvb3JkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzRW1wdHkodGhpcy5leGVjdXRvcnNCeVpJbmRleF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0U2NhbGUgU2NhbGUgb2YgdGhlIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdSb3RhdGlvbiBWaWV3IHJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgcG9pbnQgc3ltYm9scyBhbmQgdGVzdCB0byBpbnRlZ2VyIHBpeGVsLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5CdWlsZGVyVHlwZT59IFtidWlsZGVyVHlwZXNdIE9yZGVyZWQgcmVwbGF5IHR5cGVzIHRvIHJlcGxheS5cbiAgICogICAgIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvcmVwbGF5fk9SREVSfVxuICAgKiBAcGFyYW0ge2ltcG9ydChcInJidXNoXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJUcmVlXSBEZWNsdXR0ZXIgdHJlZS5cbiAgICovXG4gIGV4ZWN1dGUoXG4gICAgY29udGV4dCxcbiAgICBjb250ZXh0U2NhbGUsXG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdSb3RhdGlvbixcbiAgICBzbmFwVG9QaXhlbCxcbiAgICBidWlsZGVyVHlwZXMsXG4gICAgZGVjbHV0dGVyVHJlZVxuICApIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgenMgPSBPYmplY3Qua2V5cyh0aGlzLmV4ZWN1dG9yc0J5WkluZGV4XykubWFwKE51bWJlcik7XG4gICAgenMuc29ydChhc2NlbmRpbmcpO1xuXG4gICAgLy8gc2V0dXAgY2xpcHBpbmcgc28gdGhhdCB0aGUgcGFydHMgb2Ygb3Zlci1zaW1wbGlmaWVkIGdlb21ldHJpZXMgYXJlIG5vdFxuICAgIC8vIHZpc2libGUgb3V0c2lkZSB0aGUgY3VycmVudCBleHRlbnQgd2hlbiBwYW5uaW5nXG4gICAgaWYgKHRoaXMubWF4RXh0ZW50Xykge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICB0aGlzLmNsaXAoY29udGV4dCwgdHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICBidWlsZGVyVHlwZXMgPSBidWlsZGVyVHlwZXMgPyBidWlsZGVyVHlwZXMgOiBPUkRFUjtcbiAgICBsZXQgaSwgaWksIGosIGpqLCByZXBsYXlzLCByZXBsYXk7XG4gICAgaWYgKGRlY2x1dHRlclRyZWUpIHtcbiAgICAgIHpzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWkgPSB6cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCB6SW5kZXhLZXkgPSB6c1tpXS50b1N0cmluZygpO1xuICAgICAgcmVwbGF5cyA9IHRoaXMuZXhlY3V0b3JzQnlaSW5kZXhfW3pJbmRleEtleV07XG4gICAgICBmb3IgKGogPSAwLCBqaiA9IGJ1aWxkZXJUeXBlcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXJUeXBlID0gYnVpbGRlclR5cGVzW2pdO1xuICAgICAgICByZXBsYXkgPSByZXBsYXlzW2J1aWxkZXJUeXBlXTtcbiAgICAgICAgaWYgKHJlcGxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVwbGF5LmV4ZWN1dGUoXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgY29udGV4dFNjYWxlLFxuICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgdmlld1JvdGF0aW9uLFxuICAgICAgICAgICAgc25hcFRvUGl4ZWwsXG4gICAgICAgICAgICBkZWNsdXR0ZXJUcmVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1heEV4dGVudF8pIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY2FjaGUgaXMgdXNlZCB0byBzdG9yZSBhcnJheXMgb2YgaW5kZXhlcyBmb3IgY2FsY3VsYXRlZCBwaXhlbCBjaXJjbGVzXG4gKiB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZS5cbiAqIEl0IGlzIGEgc3RhdGljIHByb3BlcnR5IHRvIGFsbG93IGVhY2ggUmVwbGF5Z3JvdXAgdG8gYWNjZXNzIGl0LlxuICogQHR5cGUge09iamVjdDxudW1iZXIsIEFycmF5PG51bWJlcj4+fVxuICovXG5jb25zdCBjaXJjbGVQaXhlbEluZGV4QXJyYXlDYWNoZSA9IHt9O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kcyBjcmVhdGVzIGFuIGFycmF5IHdpdGggaW5kZXhlcyBvZiBhbGwgcGl4ZWxzIHdpdGhpbiBhIGNpcmNsZSxcbiAqIG9yZGVyZWQgYnkgaG93IGNsb3NlIHRoZXkgYXJlIHRvIHRoZSBjZW50ZXIuXG4gKiBBIGNhY2hlIGlzIHVzZWQgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IHdpdGggaW5kZXhlcyB3aXRoaW4gYSBjaXJjbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaXhlbEluZGV4QXJyYXkocmFkaXVzKSB7XG4gIGlmIChjaXJjbGVQaXhlbEluZGV4QXJyYXlDYWNoZVtyYWRpdXNdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2lyY2xlUGl4ZWxJbmRleEFycmF5Q2FjaGVbcmFkaXVzXTtcbiAgfVxuXG4gIGNvbnN0IHNpemUgPSByYWRpdXMgKiAyICsgMTtcbiAgY29uc3QgbWF4RGlzdGFuY2VTcSA9IHJhZGl1cyAqIHJhZGl1cztcbiAgY29uc3QgZGlzdGFuY2VzID0gbmV3IEFycmF5KG1heERpc3RhbmNlU3EgKyAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcmFkaXVzOyArK2kpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8PSByYWRpdXM7ICsraikge1xuICAgICAgY29uc3QgZGlzdGFuY2VTcSA9IGkgKiBpICsgaiAqIGo7XG4gICAgICBpZiAoZGlzdGFuY2VTcSA+IG1heERpc3RhbmNlU3EpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgZGlzdGFuY2UgPSBkaXN0YW5jZXNbZGlzdGFuY2VTcV07XG4gICAgICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgICAgIGRpc3RhbmNlID0gW107XG4gICAgICAgIGRpc3RhbmNlc1tkaXN0YW5jZVNxXSA9IGRpc3RhbmNlO1xuICAgICAgfVxuICAgICAgZGlzdGFuY2UucHVzaCgoKHJhZGl1cyArIGkpICogc2l6ZSArIChyYWRpdXMgKyBqKSkgKiA0ICsgMyk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgZGlzdGFuY2UucHVzaCgoKHJhZGl1cyAtIGkpICogc2l6ZSArIChyYWRpdXMgKyBqKSkgKiA0ICsgMyk7XG4gICAgICB9XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgZGlzdGFuY2UucHVzaCgoKHJhZGl1cyArIGkpICogc2l6ZSArIChyYWRpdXMgLSBqKSkgKiA0ICsgMyk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGRpc3RhbmNlLnB1c2goKChyYWRpdXMgLSBpKSAqIHNpemUgKyAocmFkaXVzIC0gaikpICogNCArIDMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGl4ZWxJbmRleCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBkaXN0YW5jZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChkaXN0YW5jZXNbaV0pIHtcbiAgICAgIHBpeGVsSW5kZXgucHVzaCguLi5kaXN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGNpcmNsZVBpeGVsSW5kZXhBcnJheUNhY2hlW3JhZGl1c10gPSBwaXhlbEluZGV4O1xuICByZXR1cm4gcGl4ZWxJbmRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhlY3V0b3JHcm91cDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGVcbiAqL1xuLy8gRklYTUUgdGVzdCwgZXNwZWNpYWxseSBwb2x5Z29ucyB3aXRoIGhvbGVzIGFuZCBtdWx0aXBvbHlnb25zXG4vLyBGSVhNRSBuZWVkIHRvIGhhbmRsZSBsYXJnZSB0aGljayBmZWF0dXJlcyAod2hlcmUgcGl4ZWwgc2l6ZSBtYXR0ZXJzKVxuLy8gRklYTUUgYWRkIG9mZnNldCBhbmQgZW5kIHRvIG9sL2dlb20vZmxhdC90cmFuc2Zvcm1+dHJhbnNmb3JtMkQ/XG5cbmltcG9ydCBWZWN0b3JDb250ZXh0IGZyb20gJy4uL1ZlY3RvckNvbnRleHQuanMnO1xuaW1wb3J0IHthc0NvbG9yTGlrZX0gZnJvbSAnLi4vLi4vY29sb3JsaWtlLmpzJztcbmltcG9ydCB7XG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7XG4gIGRlZmF1bHRGaWxsU3R5bGUsXG4gIGRlZmF1bHRGb250LFxuICBkZWZhdWx0TGluZUNhcCxcbiAgZGVmYXVsdExpbmVEYXNoLFxuICBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gIGRlZmF1bHRMaW5lSm9pbixcbiAgZGVmYXVsdExpbmVXaWR0aCxcbiAgZGVmYXVsdE1pdGVyTGltaXQsXG4gIGRlZmF1bHRTdHJva2VTdHlsZSxcbiAgZGVmYXVsdFRleHRBbGlnbixcbiAgZGVmYXVsdFRleHRCYXNlbGluZSxcbn0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge3RvRml4ZWR9IGZyb20gJy4uLy4uL21hdGguanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybUdlb20yRH0gZnJvbSAnLi4vLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb25jcmV0ZSBzdWJjbGFzcyBvZiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9WZWN0b3JDb250ZXh0flZlY3RvckNvbnRleHR9IHRoYXQgaW1wbGVtZW50c1xuICogZGlyZWN0IHJlbmRlcmluZyBvZiBmZWF0dXJlcyBhbmQgZ2VvbWV0cmllcyB0byBhbiBIVE1MNSBDYW52YXMgY29udGV4dC5cbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjcmVhdGVkIGludGVybmFsbHkgYnkgdGhlIGxpYnJhcnkgYW5kXG4gKiBwcm92aWRlZCB0byBhcHBsaWNhdGlvbiBjb2RlIGFzIHZlY3RvckNvbnRleHQgbWVtYmVyIG9mIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnR9IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcG9zdGNvbXBvc2UsIHByZWNvbXBvc2UgYW5kXG4gKiByZW5kZXIgZXZlbnRzIGVtaXR0ZWQgYnkgbGF5ZXJzIGFuZCBtYXBzLlxuICovXG5jbGFzcyBDYW52YXNJbW1lZGlhdGVSZW5kZXJlciBleHRlbmRzIFZlY3RvckNvbnRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3F1YXJlZFRvbGVyYW5jZV0gT3B0aW9uYWwgc3F1YXJlZCB0b2xlcmFuY2UgZm9yIHNpbXBsaWZpY2F0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IFt1c2VyVHJhbnNmb3JtXSBUcmFuc2Zvcm0gZnJvbSB1c2VyIHRvIHZpZXcgcHJvamVjdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvbnRleHQsXG4gICAgcGl4ZWxSYXRpbyxcbiAgICBleHRlbnQsXG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdSb3RhdGlvbixcbiAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgIHVzZXJUcmFuc2Zvcm1cbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRfID0gY29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybV8gPSB0cmFuc2Zvcm07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1Sb3RhdGlvbl8gPSB0cmFuc2Zvcm1cbiAgICAgID8gdG9GaXhlZChNYXRoLmF0YW4yKHRyYW5zZm9ybVsxXSwgdHJhbnNmb3JtWzBdKSwgMTApXG4gICAgICA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy52aWV3Um90YXRpb25fID0gdmlld1JvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8gPSBzcXVhcmVkVG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJUcmFuc2Zvcm1fID0gdXNlclRyYW5zZm9ybTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dEZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0VGV4dFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlQW5jaG9yWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VBbmNob3JZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZUhlaWdodF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VPcGFjaXR5XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZU9yaWdpblhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlT3JpZ2luWV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlUm90YXRlV2l0aFZpZXdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVJvdGF0aW9uXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVNjYWxlXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlV2lkdGhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTY2FsZV8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50bXBMb2NhbFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICB0aGlzLnRyYW5zZm9ybV8sXG4gICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfXG4gICAgKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICBjb25zdCBsb2NhbFRyYW5zZm9ybSA9IHRoaXMudG1wTG9jYWxUcmFuc2Zvcm1fO1xuICAgIGNvbnN0IGFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICBpZiAodGhpcy5pbWFnZU9wYWNpdHlfICE9IDEpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIHRoaXMuaW1hZ2VPcGFjaXR5XztcbiAgICB9XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy5pbWFnZVJvdGF0aW9uXztcbiAgICBpZiAodGhpcy50cmFuc2Zvcm1Sb3RhdGlvbl8gPT09IDApIHtcbiAgICAgIHJvdGF0aW9uIC09IHRoaXMudmlld1JvdGF0aW9uXztcbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2VSb3RhdGVXaXRoVmlld18pIHtcbiAgICAgIHJvdGF0aW9uICs9IHRoaXMudmlld1JvdGF0aW9uXztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGl4ZWxDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gcGl4ZWxDb29yZGluYXRlc1tpXSAtIHRoaXMuaW1hZ2VBbmNob3JYXztcbiAgICAgIGNvbnN0IHkgPSBwaXhlbENvb3JkaW5hdGVzW2kgKyAxXSAtIHRoaXMuaW1hZ2VBbmNob3JZXztcbiAgICAgIGlmIChcbiAgICAgICAgcm90YXRpb24gIT09IDAgfHxcbiAgICAgICAgdGhpcy5pbWFnZVNjYWxlX1swXSAhPSAxIHx8XG4gICAgICAgIHRoaXMuaW1hZ2VTY2FsZV9bMV0gIT0gMVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSB4ICsgdGhpcy5pbWFnZUFuY2hvclhfO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIHRoaXMuaW1hZ2VBbmNob3JZXztcbiAgICAgICAgY29tcG9zZVRyYW5zZm9ybShcbiAgICAgICAgICBsb2NhbFRyYW5zZm9ybSxcbiAgICAgICAgICBjZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclksXG4gICAgICAgICAgMSxcbiAgICAgICAgICAxLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIC1jZW50ZXJYLFxuICAgICAgICAgIC1jZW50ZXJZXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybS5hcHBseShjb250ZXh0LCBsb2NhbFRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMuaW1hZ2VTY2FsZV9bMF0sIHRoaXMuaW1hZ2VTY2FsZV9bMV0pO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICB0aGlzLmltYWdlXyxcbiAgICAgICAgICB0aGlzLmltYWdlT3JpZ2luWF8sXG4gICAgICAgICAgdGhpcy5pbWFnZU9yaWdpbllfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VXaWR0aF8sXG4gICAgICAgICAgdGhpcy5pbWFnZUhlaWdodF8sXG4gICAgICAgICAgLXRoaXMuaW1hZ2VBbmNob3JYXyxcbiAgICAgICAgICAtdGhpcy5pbWFnZUFuY2hvcllfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VXaWR0aF8sXG4gICAgICAgICAgdGhpcy5pbWFnZUhlaWdodF9cbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICB0aGlzLmltYWdlXyxcbiAgICAgICAgICB0aGlzLmltYWdlT3JpZ2luWF8sXG4gICAgICAgICAgdGhpcy5pbWFnZU9yaWdpbllfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VXaWR0aF8sXG4gICAgICAgICAgdGhpcy5pbWFnZUhlaWdodF8sXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHRoaXMuaW1hZ2VXaWR0aF8sXG4gICAgICAgICAgdGhpcy5pbWFnZUhlaWdodF9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2VPcGFjaXR5XyAhPSAxKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkcmF3VGV4dF8oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgaWYgKCF0aGlzLnRleHRTdGF0ZV8gfHwgdGhpcy50ZXh0XyA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dEZpbGxTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy50ZXh0RmlsbFN0YXRlXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRTdHJva2VTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnRleHRTdHJva2VTdGF0ZV8pO1xuICAgIH1cbiAgICB0aGlzLnNldENvbnRleHRUZXh0U3RhdGVfKHRoaXMudGV4dFN0YXRlXyk7XG4gICAgY29uc3QgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzX1xuICAgICk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy50ZXh0Um90YXRpb25fO1xuICAgIGlmICh0aGlzLnRyYW5zZm9ybVJvdGF0aW9uXyA9PT0gMCkge1xuICAgICAgcm90YXRpb24gLT0gdGhpcy52aWV3Um90YXRpb25fO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfKSB7XG4gICAgICByb3RhdGlvbiArPSB0aGlzLnZpZXdSb3RhdGlvbl87XG4gICAgfVxuICAgIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgIGNvbnN0IHggPSBwaXhlbENvb3JkaW5hdGVzW29mZnNldF0gKyB0aGlzLnRleHRPZmZzZXRYXztcbiAgICAgIGNvbnN0IHkgPSBwaXhlbENvb3JkaW5hdGVzW29mZnNldCArIDFdICsgdGhpcy50ZXh0T2Zmc2V0WV87XG4gICAgICBpZiAoXG4gICAgICAgIHJvdGF0aW9uICE9PSAwIHx8XG4gICAgICAgIHRoaXMudGV4dFNjYWxlX1swXSAhPSAxIHx8XG4gICAgICAgIHRoaXMudGV4dFNjYWxlX1sxXSAhPSAxXG4gICAgICApIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHggLSB0aGlzLnRleHRPZmZzZXRYXywgeSAtIHRoaXMudGV4dE9mZnNldFlfKTtcbiAgICAgICAgY29udGV4dC5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0aGlzLnRleHRPZmZzZXRYXywgdGhpcy50ZXh0T2Zmc2V0WV8pO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMudGV4dFNjYWxlX1swXSwgdGhpcy50ZXh0U2NhbGVfWzFdKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dFN0cm9rZVN0YXRlXykge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnRleHRfLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZXh0RmlsbFN0YXRlXykge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy50ZXh0XywgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy50ZXh0U3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRoaXMudGV4dF8sIHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRleHRGaWxsU3RhdGVfKSB7XG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dCh0aGlzLnRleHRfLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlIENsb3NlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqL1xuICBtb3ZlVG9MaW5lVG9fKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY2xvc2UpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICBjb25zdCBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICB0aGlzLnRyYW5zZm9ybV8sXG4gICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfXG4gICAgKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhwaXhlbENvb3JkaW5hdGVzWzBdLCBwaXhlbENvb3JkaW5hdGVzWzFdKTtcbiAgICBsZXQgbGVuZ3RoID0gcGl4ZWxDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgaWYgKGNsb3NlKSB7XG4gICAgICBsZW5ndGggLT0gMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29udGV4dC5saW5lVG8ocGl4ZWxDb29yZGluYXRlc1tpXSwgcGl4ZWxDb29yZGluYXRlc1tpICsgMV0pO1xuICAgIH1cbiAgICBpZiAoY2xvc2UpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gICAqL1xuICBkcmF3UmluZ3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMubW92ZVRvTGluZVRvXyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGVuZHNbaV0sXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBjaXJjbGUgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBmaWxsIGFuZCBzdHJva2Ugc3R5bGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IENpcmNsZSBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgZHJhd0NpcmNsZShnZW9tZXRyeSkge1xuICAgIGlmICh0aGlzLnNxdWFyZWRUb2xlcmFuY2VfKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeS5zaW1wbGlmeVRyYW5zZm9ybWVkKFxuICAgICAgICAgIHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8sXG4gICAgICAgICAgdGhpcy51c2VyVHJhbnNmb3JtX1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsbFN0YXRlXyB8fCB0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRGaWxsU3RhdGVfKHRoaXMuZmlsbFN0YXRlXyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0U3Ryb2tlU3RhdGVfKHRoaXMuc3Ryb2tlU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm1HZW9tMkQoXG4gICAgICAgIGdlb21ldHJ5LFxuICAgICAgICB0aGlzLnRyYW5zZm9ybV8sXG4gICAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc19cbiAgICAgICk7XG4gICAgICBjb25zdCBkeCA9IHBpeGVsQ29vcmRpbmF0ZXNbMl0gLSBwaXhlbENvb3JkaW5hdGVzWzBdO1xuICAgICAgY29uc3QgZHkgPSBwaXhlbENvb3JkaW5hdGVzWzNdIC0gcGl4ZWxDb29yZGluYXRlc1sxXTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgcGl4ZWxDb29yZGluYXRlc1swXSxcbiAgICAgICAgcGl4ZWxDb29yZGluYXRlc1sxXSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICAwLFxuICAgICAgICAyICogTWF0aC5QSVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhnZW9tZXRyeS5nZXRDZW50ZXIoKSwgMCwgMiwgMik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVuZGVyaW5nIHN0eWxlLiAgTm90ZSB0aGF0IHNpbmNlIHRoaXMgaXMgYW4gaW1tZWRpYXRlIHJlbmRlcmluZyBBUEksXG4gICAqIGFueSBgekluZGV4YCBvbiB0aGUgcHJvdmlkZWQgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGUoc3R5bGUuZ2V0RmlsbCgpLCBzdHlsZS5nZXRTdHJva2UoKSk7XG4gICAgdGhpcy5zZXRJbWFnZVN0eWxlKHN0eWxlLmdldEltYWdlKCkpO1xuICAgIHRoaXMuc2V0VGV4dFN0eWxlKHN0eWxlLmdldFRleHQoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKi9cbiAgc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIHRoaXMudHJhbnNmb3JtXyA9IHRyYW5zZm9ybTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBDYWxsXG4gICAqIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGV+Q2FudmFzSW1tZWRpYXRlUmVuZGVyZXIjc2V0U3R5bGUgcmVuZGVyZXIuc2V0U3R5bGUoKX0gZmlyc3QgdG8gc2V0IHRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IHRvIHJlbmRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgZHJhd0dlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgdGhpcy5kcmF3UG9pbnQoXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgdGhpcy5kcmF3TGluZVN0cmluZyhcbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIHRoaXMuZHJhd1BvbHlnb24oXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICB0aGlzLmRyYXdNdWx0aVBvaW50KFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICB0aGlzLmRyYXdNdWx0aUxpbmVTdHJpbmcoXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICB0aGlzLmRyYXdNdWx0aVBvbHlnb24oXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgICAgdGhpcy5kcmF3R2VvbWV0cnlDb2xsZWN0aW9uKFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQ2lyY2xlJzpcbiAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGZlYXR1cmUgaW50byB0aGUgY2FudmFzLiAgTm90ZSB0aGF0IGFueSBgekluZGV4YCBvbiB0aGUgcHJvdmlkZWRcbiAgICogc3R5bGUgd2lsbCBiZSBpZ25vcmVkIC0gZmVhdHVyZXMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGluIHRoZSBvcmRlciB0aGF0XG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC4gIElmIHlvdSBuZWVkIGB6SW5kZXhgIHN1cHBvcnQsIHlvdSBzaG91bGQgYmUgdXNpbmcgYW5cbiAgICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9WZWN0b3J+VmVjdG9yTGF5ZXJ9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGRyYXdGZWF0dXJlKGZlYXR1cmUsIHN0eWxlKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gICAgaWYgKCFnZW9tZXRyeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbiAgICB0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyeSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgR2VvbWV0cnlDb2xsZWN0aW9uIHRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZFxuICAgKiB1c2VzIHRoZSBjdXJyZW50IHN0eWxlcyBhcHByb3ByaWF0ZSBmb3IgZWFjaCBnZW9tZXRyeSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZHJhd0dlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyeSkge1xuICAgIGNvbnN0IGdlb21ldHJpZXMgPSBnZW9tZXRyeS5nZXRHZW9tZXRyaWVzQXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHRoaXMuZHJhd0dlb21ldHJ5KGdlb21ldHJpZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBQb2ludCBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFBvaW50IGdlb21ldHJ5LlxuICAgKi9cbiAgZHJhd1BvaW50KGdlb21ldHJ5KSB7XG4gICAgaWYgKHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8pIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnkuc2ltcGxpZnlUcmFuc2Zvcm1lZChcbiAgICAgICAgICB0aGlzLnNxdWFyZWRUb2xlcmFuY2VfLFxuICAgICAgICAgIHRoaXMudXNlclRyYW5zZm9ybV9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgaWYgKHRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmRyYXdJbWFnZXNfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIE11bHRpUG9pbnQgZ2VvbWV0cnkgIGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kXG4gICAqIHVzZXMgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBNdWx0aVBvaW50IGdlb21ldHJ5LlxuICAgKi9cbiAgZHJhd011bHRpUG9pbnQoZ2VvbWV0cnkpIHtcbiAgICBpZiAodGhpcy5zcXVhcmVkVG9sZXJhbmNlXykge1xuICAgICAgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5LnNpbXBsaWZ5VHJhbnNmb3JtZWQoXG4gICAgICAgICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXyxcbiAgICAgICAgICB0aGlzLnVzZXJUcmFuc2Zvcm1fXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIGlmICh0aGlzLmltYWdlXykge1xuICAgICAgdGhpcy5kcmF3SW1hZ2VzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBMaW5lU3RyaW5nIGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKi9cbiAgZHJhd0xpbmVTdHJpbmcoZ2VvbWV0cnkpIHtcbiAgICBpZiAodGhpcy5zcXVhcmVkVG9sZXJhbmNlXykge1xuICAgICAgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5LnNpbXBsaWZ5VHJhbnNmb3JtZWQoXG4gICAgICAgICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXyxcbiAgICAgICAgICB0aGlzLnVzZXJUcmFuc2Zvcm1fXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvTGluZVRvXyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAwLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICBnZW9tZXRyeS5nZXRTdHJpZGUoKSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZsYXRNaWRwb2ludCA9IGdlb21ldHJ5LmdldEZsYXRNaWRwb2ludCgpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdE1pZHBvaW50LCAwLCAyLCAyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgTXVsdGlMaW5lU3RyaW5nIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGVcbiAgICogYW5kIHVzZXMgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IE11bHRpTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICovXG4gIGRyYXdNdWx0aUxpbmVTdHJpbmcoZ2VvbWV0cnkpIHtcbiAgICBpZiAodGhpcy5zcXVhcmVkVG9sZXJhbmNlXykge1xuICAgICAgZ2VvbWV0cnkgPVxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeS5zaW1wbGlmeVRyYW5zZm9ybWVkKFxuICAgICAgICAgICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXyxcbiAgICAgICAgICAgIHRoaXMudXNlclRyYW5zZm9ybV9cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5RXh0ZW50ID0gZ2VvbWV0cnkuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnlFeHRlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgdGhpcy5zZXRDb250ZXh0U3Ryb2tlU3RhdGVfKHRoaXMuc3Ryb2tlU3RhdGVfKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IGVuZHMgPSAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChnZW9tZXRyeS5nZXRFbmRzKCkpO1xuICAgICAgY29uc3Qgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMubW92ZVRvTGluZVRvXyhcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGVuZHNbaV0sXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZsYXRNaWRwb2ludHMgPSBnZW9tZXRyeS5nZXRGbGF0TWlkcG9pbnRzKCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0TWlkcG9pbnRzLCAwLCBmbGF0TWlkcG9pbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIFBvbHlnb24gZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFBvbHlnb24gZ2VvbWV0cnkuXG4gICAqL1xuICBkcmF3UG9seWdvbihnZW9tZXRyeSkge1xuICAgIGlmICh0aGlzLnNxdWFyZWRUb2xlcmFuY2VfKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnkuc2ltcGxpZnlUcmFuc2Zvcm1lZChcbiAgICAgICAgICB0aGlzLnNxdWFyZWRUb2xlcmFuY2VfLFxuICAgICAgICAgIHRoaXMudXNlclRyYW5zZm9ybV9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXyB8fCB0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLmZpbGxTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmRyYXdSaW5nc18oXG4gICAgICAgIGdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAgIDAsXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGdlb21ldHJ5LmdldEVuZHMoKSksXG4gICAgICAgIGdlb21ldHJ5LmdldFN0cmlkZSgpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZsYXRJbnRlcmlvclBvaW50ID0gZ2VvbWV0cnkuZ2V0RmxhdEludGVyaW9yUG9pbnQoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRJbnRlcmlvclBvaW50LCAwLCAyLCAyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIE11bHRpUG9seWdvbiBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZFxuICAgKiB1c2VzIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IE11bHRpUG9seWdvbiBnZW9tZXRyeS5cbiAgICovXG4gIGRyYXdNdWx0aVBvbHlnb24oZ2VvbWV0cnkpIHtcbiAgICBpZiAodGhpcy5zcXVhcmVkVG9sZXJhbmNlXykge1xuICAgICAgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnkuc2ltcGxpZnlUcmFuc2Zvcm1lZChcbiAgICAgICAgICB0aGlzLnNxdWFyZWRUb2xlcmFuY2VfLFxuICAgICAgICAgIHRoaXMudXNlclRyYW5zZm9ybV9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXyB8fCB0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLmZpbGxTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IGVuZHNzID0gZ2VvbWV0cnkuZ2V0RW5kc3MoKTtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmRyYXdSaW5nc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgY29uc3QgZmxhdEludGVyaW9yUG9pbnRzID0gZ2VvbWV0cnkuZ2V0RmxhdEludGVyaW9yUG9pbnRzKCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0SW50ZXJpb3JQb2ludHMsIDAsIGZsYXRJbnRlcmlvclBvaW50cy5sZW5ndGgsIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9IGZpbGxTdGF0ZSBGaWxsIHN0YXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0Q29udGV4dEZpbGxTdGF0ZV8oZmlsbFN0YXRlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgY29uc3QgY29udGV4dEZpbGxTdGF0ZSA9IHRoaXMuY29udGV4dEZpbGxTdGF0ZV87XG4gICAgaWYgKCFjb250ZXh0RmlsbFN0YXRlKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdGF0ZS5maWxsU3R5bGU7XG4gICAgICB0aGlzLmNvbnRleHRGaWxsU3RhdGVfID0ge1xuICAgICAgICBmaWxsU3R5bGU6IGZpbGxTdGF0ZS5maWxsU3R5bGUsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dEZpbGxTdGF0ZS5maWxsU3R5bGUgIT0gZmlsbFN0YXRlLmZpbGxTdHlsZSkge1xuICAgICAgICBjb250ZXh0RmlsbFN0YXRlLmZpbGxTdHlsZSA9IGZpbGxTdGF0ZS5maWxsU3R5bGU7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0YXRlLmZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9IHN0cm9rZVN0YXRlIFN0cm9rZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldENvbnRleHRTdHJva2VTdGF0ZV8oc3Ryb2tlU3RhdGUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICBjb25zdCBjb250ZXh0U3Ryb2tlU3RhdGUgPSB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV87XG4gICAgaWYgKCFjb250ZXh0U3Ryb2tlU3RhdGUpIHtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IHN0cm9rZVN0YXRlLmxpbmVDYXA7XG4gICAgICBjb250ZXh0LnNldExpbmVEYXNoKHN0cm9rZVN0YXRlLmxpbmVEYXNoKTtcbiAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldDtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSBzdHJva2VTdGF0ZS5saW5lSm9pbjtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlU3RhdGUubGluZVdpZHRoO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZTtcbiAgICAgIHRoaXMuY29udGV4dFN0cm9rZVN0YXRlXyA9IHtcbiAgICAgICAgbGluZUNhcDogc3Ryb2tlU3RhdGUubGluZUNhcCxcbiAgICAgICAgbGluZURhc2g6IHN0cm9rZVN0YXRlLmxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldDogc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQsXG4gICAgICAgIGxpbmVKb2luOiBzdHJva2VTdGF0ZS5saW5lSm9pbixcbiAgICAgICAgbGluZVdpZHRoOiBzdHJva2VTdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIG1pdGVyTGltaXQ6IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZUNhcCAhPSBzdHJva2VTdGF0ZS5saW5lQ2FwKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5saW5lQ2FwID0gc3Ryb2tlU3RhdGUubGluZUNhcDtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gc3Ryb2tlU3RhdGUubGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmICghZXF1YWxzKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lRGFzaCwgc3Ryb2tlU3RhdGUubGluZURhc2gpKSB7XG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goXG4gICAgICAgICAgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lRGFzaCA9IHN0cm9rZVN0YXRlLmxpbmVEYXNoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCAhPSBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgPSBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldDtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lSm9pbiAhPSBzdHJva2VTdGF0ZS5saW5lSm9pbikge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZUpvaW4gPSBzdHJva2VTdGF0ZS5saW5lSm9pbjtcbiAgICAgICAgY29udGV4dC5saW5lSm9pbiA9IHN0cm9rZVN0YXRlLmxpbmVKb2luO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lV2lkdGggIT0gc3Ryb2tlU3RhdGUubGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5saW5lV2lkdGggPSBzdHJva2VTdGF0ZS5saW5lV2lkdGg7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlU3RhdGUubGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5taXRlckxpbWl0ICE9IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQpIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLm1pdGVyTGltaXQgPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0O1xuICAgICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5zdHJva2VTdHlsZSAhPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9IHRleHRTdGF0ZSBUZXh0IHN0YXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0Q29udGV4dFRleHRTdGF0ZV8odGV4dFN0YXRlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgY29uc3QgY29udGV4dFRleHRTdGF0ZSA9IHRoaXMuY29udGV4dFRleHRTdGF0ZV87XG4gICAgY29uc3QgdGV4dEFsaWduID0gdGV4dFN0YXRlLnRleHRBbGlnblxuICAgICAgPyB0ZXh0U3RhdGUudGV4dEFsaWduXG4gICAgICA6IGRlZmF1bHRUZXh0QWxpZ247XG4gICAgaWYgKCFjb250ZXh0VGV4dFN0YXRlKSB7XG4gICAgICBjb250ZXh0LmZvbnQgPSB0ZXh0U3RhdGUuZm9udDtcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lO1xuICAgICAgdGhpcy5jb250ZXh0VGV4dFN0YXRlXyA9IHtcbiAgICAgICAgZm9udDogdGV4dFN0YXRlLmZvbnQsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRTdGF0ZS50ZXh0QmFzZWxpbmUsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dFRleHRTdGF0ZS5mb250ICE9IHRleHRTdGF0ZS5mb250KSB7XG4gICAgICAgIGNvbnRleHRUZXh0U3RhdGUuZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgICAgICBjb250ZXh0LmZvbnQgPSB0ZXh0U3RhdGUuZm9udDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0VGV4dFN0YXRlLnRleHRBbGlnbiAhPSB0ZXh0QWxpZ24pIHtcbiAgICAgICAgY29udGV4dFRleHRTdGF0ZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUudGV4dEJhc2VsaW5lICE9IHRleHRTdGF0ZS50ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY29udGV4dFRleHRTdGF0ZS50ZXh0QmFzZWxpbmUgPSB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lO1xuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IHRleHRTdGF0ZS50ZXh0QmFzZWxpbmU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmlsbCBhbmQgc3Ryb2tlIHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFRvIGNsZWFyXG4gICAqIGVpdGhlciBmaWxsIG9yIHN0cm9rZSBzdHlsZXMsIHBhc3MgbnVsbCBmb3IgdGhlIGFwcHJvcHJpYXRlIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGxTdHlsZSBGaWxsIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2VTdHlsZSBTdHJva2Ugc3R5bGUuXG4gICAqL1xuICBzZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge1xuICAgIGlmICghZmlsbFN0eWxlKSB7XG4gICAgICB0aGlzLmZpbGxTdGF0ZV8gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaWxsU3R5bGVDb2xvciA9IGZpbGxTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgdGhpcy5maWxsU3RhdGVfID0ge1xuICAgICAgICBmaWxsU3R5bGU6IGFzQ29sb3JMaWtlKFxuICAgICAgICAgIGZpbGxTdHlsZUNvbG9yID8gZmlsbFN0eWxlQ29sb3IgOiBkZWZhdWx0RmlsbFN0eWxlXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXN0cm9rZVN0eWxlKSB7XG4gICAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlQ29sb3IgPSBzdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lQ2FwID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lRGFzaCA9IHN0cm9rZVN0eWxlLmdldExpbmVEYXNoKCk7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZUpvaW4gPSBzdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVXaWR0aCA9IHN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZU1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICBjb25zdCBsaW5lRGFzaCA9IHN0cm9rZVN0eWxlTGluZURhc2hcbiAgICAgICAgPyBzdHJva2VTdHlsZUxpbmVEYXNoXG4gICAgICAgIDogZGVmYXVsdExpbmVEYXNoO1xuICAgICAgdGhpcy5zdHJva2VTdGF0ZV8gPSB7XG4gICAgICAgIGxpbmVDYXA6XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gc3Ryb2tlU3R5bGVMaW5lQ2FwXG4gICAgICAgICAgICA6IGRlZmF1bHRMaW5lQ2FwLFxuICAgICAgICBsaW5lRGFzaDpcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW9fID09PSAxXG4gICAgICAgICAgICA/IGxpbmVEYXNoXG4gICAgICAgICAgICA6IGxpbmVEYXNoLm1hcCgobikgPT4gbiAqIHRoaXMucGl4ZWxSYXRpb18pLFxuICAgICAgICBsaW5lRGFzaE9mZnNldDpcbiAgICAgICAgICAoc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldFxuICAgICAgICAgICAgPyBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0XG4gICAgICAgICAgICA6IGRlZmF1bHRMaW5lRGFzaE9mZnNldCkgKiB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgICBsaW5lSm9pbjpcbiAgICAgICAgICBzdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gc3Ryb2tlU3R5bGVMaW5lSm9pblxuICAgICAgICAgICAgOiBkZWZhdWx0TGluZUpvaW4sXG4gICAgICAgIGxpbmVXaWR0aDpcbiAgICAgICAgICAoc3Ryb2tlU3R5bGVXaWR0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHN0cm9rZVN0eWxlV2lkdGhcbiAgICAgICAgICAgIDogZGVmYXVsdExpbmVXaWR0aCkgKiB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgICBtaXRlckxpbWl0OlxuICAgICAgICAgIHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHN0cm9rZVN0eWxlTWl0ZXJMaW1pdFxuICAgICAgICAgICAgOiBkZWZhdWx0TWl0ZXJMaW1pdCxcbiAgICAgICAgc3Ryb2tlU3R5bGU6IGFzQ29sb3JMaWtlKFxuICAgICAgICAgIHN0cm9rZVN0eWxlQ29sb3IgPyBzdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltYWdlIHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFBhc3MgbnVsbCB0byByZW1vdmVcbiAgICogdGhlIGltYWdlIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlU3R5bGUgSW1hZ2Ugc3R5bGUuXG4gICAqL1xuICBzZXRJbWFnZVN0eWxlKGltYWdlU3R5bGUpIHtcbiAgICBsZXQgaW1hZ2VTaXplO1xuICAgIGlmICghaW1hZ2VTdHlsZSB8fCAhKGltYWdlU2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpKSkge1xuICAgICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZVBpeGVsUmF0aW8gPSBpbWFnZVN0eWxlLmdldFBpeGVsUmF0aW8odGhpcy5waXhlbFJhdGlvXyk7XG4gICAgY29uc3QgaW1hZ2VBbmNob3IgPSBpbWFnZVN0eWxlLmdldEFuY2hvcigpO1xuICAgIGNvbnN0IGltYWdlT3JpZ2luID0gaW1hZ2VTdHlsZS5nZXRPcmlnaW4oKTtcbiAgICB0aGlzLmltYWdlXyA9IGltYWdlU3R5bGUuZ2V0SW1hZ2UodGhpcy5waXhlbFJhdGlvXyk7XG4gICAgdGhpcy5pbWFnZUFuY2hvclhfID0gaW1hZ2VBbmNob3JbMF0gKiBpbWFnZVBpeGVsUmF0aW87XG4gICAgdGhpcy5pbWFnZUFuY2hvcllfID0gaW1hZ2VBbmNob3JbMV0gKiBpbWFnZVBpeGVsUmF0aW87XG4gICAgdGhpcy5pbWFnZUhlaWdodF8gPSBpbWFnZVNpemVbMV0gKiBpbWFnZVBpeGVsUmF0aW87XG4gICAgdGhpcy5pbWFnZU9wYWNpdHlfID0gaW1hZ2VTdHlsZS5nZXRPcGFjaXR5KCk7XG4gICAgdGhpcy5pbWFnZU9yaWdpblhfID0gaW1hZ2VPcmlnaW5bMF07XG4gICAgdGhpcy5pbWFnZU9yaWdpbllfID0gaW1hZ2VPcmlnaW5bMV07XG4gICAgdGhpcy5pbWFnZVJvdGF0ZVdpdGhWaWV3XyA9IGltYWdlU3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICB0aGlzLmltYWdlUm90YXRpb25fID0gaW1hZ2VTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IGltYWdlU2NhbGUgPSBpbWFnZVN0eWxlLmdldFNjYWxlQXJyYXkoKTtcbiAgICB0aGlzLmltYWdlU2NhbGVfID0gW1xuICAgICAgKGltYWdlU2NhbGVbMF0gKiB0aGlzLnBpeGVsUmF0aW9fKSAvIGltYWdlUGl4ZWxSYXRpbyxcbiAgICAgIChpbWFnZVNjYWxlWzFdICogdGhpcy5waXhlbFJhdGlvXykgLyBpbWFnZVBpeGVsUmF0aW8sXG4gICAgXTtcbiAgICB0aGlzLmltYWdlV2lkdGhfID0gaW1hZ2VTaXplWzBdICogaW1hZ2VQaXhlbFJhdGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBzdHlsZSBmb3Igc3Vic2VxdWVudCBkcmF3IG9wZXJhdGlvbnMuICBQYXNzIG51bGwgdG9cbiAgICogcmVtb3ZlIHRoZSB0ZXh0IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dFN0eWxlIFRleHQgc3R5bGUuXG4gICAqL1xuICBzZXRUZXh0U3R5bGUodGV4dFN0eWxlKSB7XG4gICAgaWYgKCF0ZXh0U3R5bGUpIHtcbiAgICAgIHRoaXMudGV4dF8gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGV4dEZpbGxTdHlsZSA9IHRleHRTdHlsZS5nZXRGaWxsKCk7XG4gICAgICBpZiAoIXRleHRGaWxsU3R5bGUpIHtcbiAgICAgICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0RmlsbFN0eWxlQ29sb3IgPSB0ZXh0RmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICAgIHRoaXMudGV4dEZpbGxTdGF0ZV8gPSB7XG4gICAgICAgICAgZmlsbFN0eWxlOiBhc0NvbG9yTGlrZShcbiAgICAgICAgICAgIHRleHRGaWxsU3R5bGVDb2xvciA/IHRleHRGaWxsU3R5bGVDb2xvciA6IGRlZmF1bHRGaWxsU3R5bGVcbiAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlID0gdGV4dFN0eWxlLmdldFN0cm9rZSgpO1xuICAgICAgaWYgKCF0ZXh0U3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZUNvbG9yID0gdGV4dFN0cm9rZVN0eWxlLmdldENvbG9yKCk7XG4gICAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZUxpbmVDYXAgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpO1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA9XG4gICAgICAgICAgdGV4dFN0cm9rZVN0eWxlLmdldExpbmVEYXNoT2Zmc2V0KCk7XG4gICAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZUxpbmVKb2luID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVKb2luKCk7XG4gICAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZVdpZHRoID0gdGV4dFN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZU1pdGVyTGltaXQgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSB7XG4gICAgICAgICAgbGluZUNhcDpcbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZUxpbmVDYXAgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IHRleHRTdHJva2VTdHlsZUxpbmVDYXBcbiAgICAgICAgICAgICAgOiBkZWZhdWx0TGluZUNhcCxcbiAgICAgICAgICBsaW5lRGFzaDogdGV4dFN0cm9rZVN0eWxlTGluZURhc2hcbiAgICAgICAgICAgID8gdGV4dFN0cm9rZVN0eWxlTGluZURhc2hcbiAgICAgICAgICAgIDogZGVmYXVsdExpbmVEYXNoLFxuICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldFxuICAgICAgICAgICAgPyB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldFxuICAgICAgICAgICAgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICAgICAgbGluZUpvaW46XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lSm9pbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gdGV4dFN0cm9rZVN0eWxlTGluZUpvaW5cbiAgICAgICAgICAgICAgOiBkZWZhdWx0TGluZUpvaW4sXG4gICAgICAgICAgbGluZVdpZHRoOlxuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlV2lkdGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IHRleHRTdHJva2VTdHlsZVdpZHRoXG4gICAgICAgICAgICAgIDogZGVmYXVsdExpbmVXaWR0aCxcbiAgICAgICAgICBtaXRlckxpbWl0OlxuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTWl0ZXJMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gdGV4dFN0cm9rZVN0eWxlTWl0ZXJMaW1pdFxuICAgICAgICAgICAgICA6IGRlZmF1bHRNaXRlckxpbWl0LFxuICAgICAgICAgIHN0cm9rZVN0eWxlOiBhc0NvbG9yTGlrZShcbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZUNvbG9yID8gdGV4dFN0cm9rZVN0eWxlQ29sb3IgOiBkZWZhdWx0U3Ryb2tlU3R5bGVcbiAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dEZvbnQgPSB0ZXh0U3R5bGUuZ2V0Rm9udCgpO1xuICAgICAgY29uc3QgdGV4dE9mZnNldFggPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WCgpO1xuICAgICAgY29uc3QgdGV4dE9mZnNldFkgPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WSgpO1xuICAgICAgY29uc3QgdGV4dFJvdGF0ZVdpdGhWaWV3ID0gdGV4dFN0eWxlLmdldFJvdGF0ZVdpdGhWaWV3KCk7XG4gICAgICBjb25zdCB0ZXh0Um90YXRpb24gPSB0ZXh0U3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICAgIGNvbnN0IHRleHRTY2FsZSA9IHRleHRTdHlsZS5nZXRTY2FsZUFycmF5KCk7XG4gICAgICBjb25zdCB0ZXh0VGV4dCA9IHRleHRTdHlsZS5nZXRUZXh0KCk7XG4gICAgICBjb25zdCB0ZXh0VGV4dEFsaWduID0gdGV4dFN0eWxlLmdldFRleHRBbGlnbigpO1xuICAgICAgY29uc3QgdGV4dFRleHRCYXNlbGluZSA9IHRleHRTdHlsZS5nZXRUZXh0QmFzZWxpbmUoKTtcbiAgICAgIHRoaXMudGV4dFN0YXRlXyA9IHtcbiAgICAgICAgZm9udDogdGV4dEZvbnQgIT09IHVuZGVmaW5lZCA/IHRleHRGb250IDogZGVmYXVsdEZvbnQsXG4gICAgICAgIHRleHRBbGlnbjpcbiAgICAgICAgICB0ZXh0VGV4dEFsaWduICE9PSB1bmRlZmluZWQgPyB0ZXh0VGV4dEFsaWduIDogZGVmYXVsdFRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOlxuICAgICAgICAgIHRleHRUZXh0QmFzZWxpbmUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0ZXh0VGV4dEJhc2VsaW5lXG4gICAgICAgICAgICA6IGRlZmF1bHRUZXh0QmFzZWxpbmUsXG4gICAgICB9O1xuICAgICAgdGhpcy50ZXh0XyA9XG4gICAgICAgIHRleHRUZXh0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IEFycmF5LmlzQXJyYXkodGV4dFRleHQpXG4gICAgICAgICAgICA/IHRleHRUZXh0LnJlZHVjZSgoYWNjLCB0LCBpKSA9PiAoYWNjICs9IGkgJSAyID8gJyAnIDogdCksICcnKVxuICAgICAgICAgICAgOiB0ZXh0VGV4dFxuICAgICAgICAgIDogJyc7XG4gICAgICB0aGlzLnRleHRPZmZzZXRYXyA9XG4gICAgICAgIHRleHRPZmZzZXRYICE9PSB1bmRlZmluZWQgPyB0aGlzLnBpeGVsUmF0aW9fICogdGV4dE9mZnNldFggOiAwO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WV8gPVxuICAgICAgICB0ZXh0T2Zmc2V0WSAhPT0gdW5kZWZpbmVkID8gdGhpcy5waXhlbFJhdGlvXyAqIHRleHRPZmZzZXRZIDogMDtcbiAgICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9XG4gICAgICAgIHRleHRSb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gdGV4dFJvdGF0ZVdpdGhWaWV3IDogZmFsc2U7XG4gICAgICB0aGlzLnRleHRSb3RhdGlvbl8gPSB0ZXh0Um90YXRpb24gIT09IHVuZGVmaW5lZCA/IHRleHRSb3RhdGlvbiA6IDA7XG4gICAgICB0aGlzLnRleHRTY2FsZV8gPSBbXG4gICAgICAgIHRoaXMucGl4ZWxSYXRpb18gKiB0ZXh0U2NhbGVbMF0sXG4gICAgICAgIHRoaXMucGl4ZWxSYXRpb18gKiB0ZXh0U2NhbGVbMV0sXG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGVcbiAqL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgQ2lyY2xlfSBmcm9tICcuL3N0eWxlL0NpcmNsZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRmlsbH0gZnJvbSAnLi9zdHlsZS9GaWxsLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJY29ufSBmcm9tICcuL3N0eWxlL0ljb24uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEljb25JbWFnZX0gZnJvbSAnLi9zdHlsZS9JY29uSW1hZ2UuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEltYWdlfSBmcm9tICcuL3N0eWxlL0ltYWdlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBSZWd1bGFyU2hhcGV9IGZyb20gJy4vc3R5bGUvUmVndWxhclNoYXBlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTdHJva2V9IGZyb20gJy4vc3R5bGUvU3Ryb2tlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTdHlsZX0gZnJvbSAnLi9zdHlsZS9TdHlsZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgVGV4dH0gZnJvbSAnLi9zdHlsZS9UZXh0LmpzJztcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9oaXRkZXRlY3RcbiAqL1xuXG5pbXBvcnQgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgZnJvbSAnLi9JbW1lZGlhdGUuanMnO1xuaW1wb3J0IHtJY29ufSBmcm9tICcuLi8uLi9zdHlsZS5qcyc7XG5pbXBvcnQge2FzY2VuZGluZ30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuZXhwb3J0IGNvbnN0IEhJVF9ERVRFQ1RfUkVTT0xVVElPTiA9IDAuNTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBDYW52YXMgc2l6ZSBpbiBjc3MgcGl4ZWxzLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtPn0gdHJhbnNmb3JtcyBUcmFuc2Zvcm1zXG4gKiBmb3IgcmVuZGVyaW5nIGZlYXR1cmVzIHRvIGFsbCB3b3JsZHMgb2YgdGhlIHZpZXdwb3J0LCBmcm9tIGNvb3JkaW5hdGVzIHRvIGNzc1xuICogcGl4ZWxzLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlPn0gZmVhdHVyZXNcbiAqIEZlYXR1cmVzIHRvIGNvbnNpZGVyIGZvciBoaXQgZGV0ZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gc3R5bGVGdW5jdGlvblxuICogTGF5ZXIgc3R5bGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHJldHVybiB7SW1hZ2VEYXRhfSBIaXQgZGV0ZWN0aW9uIGltYWdlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIaXREZXRlY3Rpb25JbWFnZURhdGEoXG4gIHNpemUsXG4gIHRyYW5zZm9ybXMsXG4gIGZlYXR1cmVzLFxuICBzdHlsZUZ1bmN0aW9uLFxuICBleHRlbnQsXG4gIHJlc29sdXRpb24sXG4gIHJvdGF0aW9uXG4pIHtcbiAgY29uc3Qgd2lkdGggPSBzaXplWzBdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICBjb25zdCBoZWlnaHQgPSBzaXplWzFdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgY29uc3QgcmVuZGVyZXIgPSBuZXcgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIoXG4gICAgY29udGV4dCxcbiAgICBISVRfREVURUNUX1JFU09MVVRJT04sXG4gICAgZXh0ZW50LFxuICAgIG51bGwsXG4gICAgcm90YXRpb25cbiAgKTtcbiAgY29uc3QgZmVhdHVyZUNvdW50ID0gZmVhdHVyZXMubGVuZ3RoO1xuICAvLyBTdHJldGNoIGhpdCBkZXRlY3Rpb24gaW5kZXggdG8gdXNlIHRoZSB3aG9sZSBhdmFpbGFibGUgY29sb3IgcmFuZ2VcbiAgY29uc3QgaW5kZXhGYWN0b3IgPSBNYXRoLmZsb29yKCgyNTYgKiAyNTYgKiAyNTYgLSAxKSAvIGZlYXR1cmVDb3VudCk7XG4gIGNvbnN0IGZlYXR1cmVzQnlaSW5kZXggPSB7fTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZmVhdHVyZUNvdW50OyArK2kpIHtcbiAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXNbaSAtIDFdO1xuICAgIGNvbnN0IGZlYXR1cmVTdHlsZUZ1bmN0aW9uID0gZmVhdHVyZS5nZXRTdHlsZUZ1bmN0aW9uKCkgfHwgc3R5bGVGdW5jdGlvbjtcbiAgICBpZiAoIWZlYXR1cmVTdHlsZUZ1bmN0aW9uKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHN0eWxlcyA9IGZlYXR1cmVTdHlsZUZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pO1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgIHN0eWxlcyA9IFtzdHlsZXNdO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGkgKiBpbmRleEZhY3RvcjtcbiAgICBjb25zdCBjb2xvciA9IGluZGV4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg3LCAnIzAwMDAwJyk7XG4gICAgZm9yIChsZXQgaiA9IDAsIGpqID0gc3R5bGVzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsU3R5bGUgPSBzdHlsZXNbal07XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IG9yaWdpbmFsU3R5bGUuZ2V0R2VvbWV0cnlGdW5jdGlvbigpKGZlYXR1cmUpO1xuICAgICAgaWYgKCFnZW9tZXRyeSB8fCAhaW50ZXJzZWN0cyhleHRlbnQsIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlID0gb3JpZ2luYWxTdHlsZS5jbG9uZSgpO1xuICAgICAgY29uc3QgZmlsbCA9IHN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGZpbGwuc2V0Q29sb3IoY29sb3IpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIHN0cm9rZS5zZXRDb2xvcihjb2xvcik7XG4gICAgICAgIHN0cm9rZS5zZXRMaW5lRGFzaChudWxsKTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IGltYWdlID0gb3JpZ2luYWxTdHlsZS5nZXRJbWFnZSgpO1xuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIGNvbnN0IGltZ1NpemUgPSBpbWFnZS5nZXRJbWFnZVNpemUoKTtcbiAgICAgICAgaWYgKCFpbWdTaXplKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbWdDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgICAgIGltZ1NpemVbMF0sXG4gICAgICAgICAgaW1nU2l6ZVsxXSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAge2FscGhhOiBmYWxzZX1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW1nID0gaW1nQ29udGV4dC5jYW52YXM7XG4gICAgICAgIGltZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGltZ0NvbnRleHQuZmlsbFJlY3QoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgICAgICAgc3R5bGUuc2V0SW1hZ2UoXG4gICAgICAgICAgbmV3IEljb24oe1xuICAgICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgICBhbmNob3I6IGltYWdlLmdldEFuY2hvcigpLFxuICAgICAgICAgICAgYW5jaG9yWFVuaXRzOiAncGl4ZWxzJyxcbiAgICAgICAgICAgIGFuY2hvcllVbml0czogJ3BpeGVscycsXG4gICAgICAgICAgICBvZmZzZXQ6IGltYWdlLmdldE9yaWdpbigpLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNpemU6IGltYWdlLmdldFNpemUoKSxcbiAgICAgICAgICAgIHNjYWxlOiBpbWFnZS5nZXRTY2FsZSgpLFxuICAgICAgICAgICAgcm90YXRpb246IGltYWdlLmdldFJvdGF0aW9uKCksXG4gICAgICAgICAgICByb3RhdGVXaXRoVmlldzogaW1hZ2UuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgekluZGV4ID0gc3R5bGUuZ2V0WkluZGV4KCkgfHwgMDtcbiAgICAgIGxldCBieUdlb21ldHJ5VHlwZSA9IGZlYXR1cmVzQnlaSW5kZXhbekluZGV4XTtcbiAgICAgIGlmICghYnlHZW9tZXRyeVR5cGUpIHtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGUgPSB7fTtcbiAgICAgICAgZmVhdHVyZXNCeVpJbmRleFt6SW5kZXhdID0gYnlHZW9tZXRyeVR5cGU7XG4gICAgICAgIGJ5R2VvbWV0cnlUeXBlWydQb2x5Z29uJ10gPSBbXTtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGVbJ0NpcmNsZSddID0gW107XG4gICAgICAgIGJ5R2VvbWV0cnlUeXBlWydMaW5lU3RyaW5nJ10gPSBbXTtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGVbJ1BvaW50J10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgICBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cmllcyA9XG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICkuZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgICBieUdlb21ldHJ5VHlwZVtnZW9tZXRyeS5nZXRUeXBlKCkucmVwbGFjZSgnTXVsdGknLCAnJyldLnB1c2goXG4gICAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGVbdHlwZS5yZXBsYWNlKCdNdWx0aScsICcnKV0ucHVzaChnZW9tZXRyeSwgc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHpJbmRleEtleXMgPSBPYmplY3Qua2V5cyhmZWF0dXJlc0J5WkluZGV4KS5tYXAoTnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHpJbmRleEtleXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGJ5R2VvbWV0cnlUeXBlID0gZmVhdHVyZXNCeVpJbmRleFt6SW5kZXhLZXlzW2ldXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gYnlHZW9tZXRyeVR5cGUpIHtcbiAgICAgIGNvbnN0IGdlb21BbmRTdHlsZSA9IGJ5R2VvbWV0cnlUeXBlW3R5cGVdO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gZ2VvbUFuZFN0eWxlLmxlbmd0aDsgaiA8IGpqOyBqICs9IDIpIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0U3R5bGUoZ2VvbUFuZFN0eWxlW2ogKyAxXSk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBrayA9IHRyYW5zZm9ybXMubGVuZ3RoOyBrIDwga2s7ICsraykge1xuICAgICAgICAgIHJlbmRlcmVyLnNldFRyYW5zZm9ybSh0cmFuc2Zvcm1zW2tdKTtcbiAgICAgICAgICByZW5kZXJlci5kcmF3R2VvbWV0cnkoZ2VvbUFuZFN0eWxlW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbCBjb29yZGluYXRlIG9uIHRoZSBoaXRcbiAqIGRldGVjdGlvbiBjYW52YXMgaW4gY3NzIHBpeGVscy5cbiAqIEBwYXJhbSB7QXJyYXk8Rj59IGZlYXR1cmVzIEZlYXR1cmVzLiBIYXMgdG9cbiAqIG1hdGNoIHRoZSBgZmVhdHVyZXNgIGFycmF5IHRoYXQgd2FzIHBhc3NlZCB0byBgY3JlYXRlSGl0RGV0ZWN0aW9uSW1hZ2VEYXRhKClgLlxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YSBIaXQgZGV0ZWN0aW9uIGltYWdlIGRhdGEgZ2VuZXJhdGVkIGJ5XG4gKiBgY3JlYXRlSGl0RGV0ZWN0aW9uSW1hZ2VEYXRhKClgLlxuICogQHJldHVybiB7QXJyYXk8Rj59IEZlYXR1cmVzLlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBGXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoaXREZXRlY3QocGl4ZWwsIGZlYXR1cmVzLCBpbWFnZURhdGEpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxGPn0gKi9cbiAgY29uc3QgcmVzdWx0RmVhdHVyZXMgPSBbXTtcbiAgaWYgKGltYWdlRGF0YSkge1xuICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKE1hdGgucm91bmQocGl4ZWxbMF0pICogSElUX0RFVEVDVF9SRVNPTFVUSU9OKTtcbiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihNYXRoLnJvdW5kKHBpeGVsWzFdKSAqIEhJVF9ERVRFQ1RfUkVTT0xVVElPTik7XG4gICAgLy8gVGhlIHBpeGVsIGNvb3JkaW5hdGUgaXMgY2xhbXBlZCBkb3duIHRvIHRoZSBoaXQtZGV0ZWN0IGNhbnZhcycgc2l6ZSB0byBhY2NvdW50XG4gICAgLy8gZm9yIGJyb3dzZXJzIHJldHVybmluZyBjb29yZGluYXRlcyBzbGlnaHRseSBsYXJnZXIgdGhhbiB0aGUgYWN0dWFsIGNhbnZhcyBzaXplXG4gICAgLy8gZHVlIHRvIGEgbm9uLWludGVnZXIgcGl4ZWwgcmF0aW8uXG4gICAgY29uc3QgaW5kZXggPVxuICAgICAgKGNsYW1wKHgsIDAsIGltYWdlRGF0YS53aWR0aCAtIDEpICtcbiAgICAgICAgY2xhbXAoeSwgMCwgaW1hZ2VEYXRhLmhlaWdodCAtIDEpICogaW1hZ2VEYXRhLndpZHRoKSAqXG4gICAgICA0O1xuICAgIGNvbnN0IHIgPSBpbWFnZURhdGEuZGF0YVtpbmRleF07XG4gICAgY29uc3QgZyA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV07XG4gICAgY29uc3QgYiA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl07XG4gICAgY29uc3QgaSA9IGIgKyAyNTYgKiAoZyArIDI1NiAqIHIpO1xuICAgIGNvbnN0IGluZGV4RmFjdG9yID0gTWF0aC5mbG9vcigoMjU2ICogMjU2ICogMjU2IC0gMSkgLyBmZWF0dXJlcy5sZW5ndGgpO1xuICAgIGlmIChpICYmIGkgJSBpbmRleEZhY3RvciA9PT0gMCkge1xuICAgICAgcmVzdWx0RmVhdHVyZXMucHVzaChmZWF0dXJlc1tpIC8gaW5kZXhGYWN0b3IgLSAxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRGZWF0dXJlcztcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvdmVjdG9yXG4gKi9cbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEZlYXR1cmUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50cy4gVGhlIGZpcnN0XG4gKiBhcmd1bWVudCBpcyBvbmUge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUgZmVhdHVyZX0gb3Ige0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX5SZW5kZXJGZWF0dXJlIHJlbmRlciBmZWF0dXJlfVxuICogYXQgdGhlIHBpeGVsLCB0aGUgc2Vjb25kIGlzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyIGxheWVyfSBvZiB0aGUgZmVhdHVyZSBhbmQgd2lsbCBiZSBudWxsIGZvclxuICogdW5tYW5hZ2VkIGxheWVycy4gVGhlIHRoaXJkIGlzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl+U2ltcGxlR2VvbWV0cnl9IG9mIHRoZSBmZWF0dXJlLiBGb3IgZmVhdHVyZXNcbiAqIHdpdGggYSBHZW9tZXRyeUNvbGxlY3Rpb24gZ2VvbWV0cnksIGl0IHdpbGwgYmUgdGhlIGZpcnN0IGRldGVjdGVkIGdlb21ldHJ5IGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZVwiKS5kZWZhdWx0PiwgaW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0KTogVH0gRmVhdHVyZUNhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiBUb2xlcmFuY2UgZm9yIGdlb21ldHJ5IHNpbXBsaWZpY2F0aW9uIGluIGRldmljZSBwaXhlbHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBTSU1QTElGWV9UT0xFUkFOQ0UgPSAwLjU7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuVHlwZSxcbiAqICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQsIE9iamVjdCk6IHZvaWQ+fVxuICovXG5jb25zdCBHRU9NRVRSWV9SRU5ERVJFUlMgPSB7XG4gICdQb2ludCc6IHJlbmRlclBvaW50R2VvbWV0cnksXG4gICdMaW5lU3RyaW5nJzogcmVuZGVyTGluZVN0cmluZ0dlb21ldHJ5LFxuICAnUG9seWdvbic6IHJlbmRlclBvbHlnb25HZW9tZXRyeSxcbiAgJ011bHRpUG9pbnQnOiByZW5kZXJNdWx0aVBvaW50R2VvbWV0cnksXG4gICdNdWx0aUxpbmVTdHJpbmcnOiByZW5kZXJNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSxcbiAgJ011bHRpUG9seWdvbic6IHJlbmRlck11bHRpUG9seWdvbkdlb21ldHJ5LFxuICAnR2VvbWV0cnlDb2xsZWN0aW9uJzogcmVuZGVyR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnksXG4gICdDaXJjbGUnOiByZW5kZXJDaXJjbGVHZW9tZXRyeSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlMSBGZWF0dXJlIDEuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUyIEZlYXR1cmUgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gT3JkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0T3JkZXIoZmVhdHVyZTEsIGZlYXR1cmUyKSB7XG4gIHJldHVybiBwYXJzZUludChnZXRVaWQoZmVhdHVyZTEpLCAxMCkgLSBwYXJzZUludChnZXRVaWQoZmVhdHVyZTIpLCAxMCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIHBpeGVsIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWFyZWRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICBjb25zdCB0b2xlcmFuY2UgPSBnZXRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG4gIHJldHVybiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7bnVtYmVyfSBQaXhlbCB0b2xlcmFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICByZXR1cm4gKFNJTVBMSUZZX1RPTEVSQU5DRSAqIHJlc29sdXRpb24pIC8gcGl4ZWxSYXRpbztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IGJ1aWxkZXJHcm91cCBCdWlsZGVyIGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNpcmNsZUdlb21ldHJ5KFxuICBidWlsZGVyR3JvdXAsXG4gIGdlb21ldHJ5LFxuICBzdHlsZSxcbiAgZmVhdHVyZSxcbiAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4pIHtcbiAgY29uc3QgZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbCgpO1xuICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoZmlsbFN0eWxlIHx8IHN0cm9rZVN0eWxlKSB7XG4gICAgY29uc3QgY2lyY2xlUmVwbGF5ID0gYnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoc3R5bGUuZ2V0WkluZGV4KCksICdDaXJjbGUnKTtcbiAgICBjaXJjbGVSZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICAgIGNpcmNsZVJlcGxheS5kcmF3Q2lyY2xlKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUgJiYgdGV4dFN0eWxlLmdldFRleHQoKSkge1xuICAgIGNvbnN0IHRleHRSZXBsYXkgPSAoZGVjbHV0dGVyQnVpbGRlckdyb3VwIHx8IGJ1aWxkZXJHcm91cCkuZ2V0QnVpbGRlcihcbiAgICAgIHN0eWxlLmdldFpJbmRleCgpLFxuICAgICAgJ1RleHQnXG4gICAgKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gW3RyYW5zZm9ybV0gVHJhbnNmb3JtIGZyb20gdXNlciB0byB2aWV3IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBzdHlsZSBpcyBsb2FkaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRmVhdHVyZShcbiAgcmVwbGF5R3JvdXAsXG4gIGZlYXR1cmUsXG4gIHN0eWxlLFxuICBzcXVhcmVkVG9sZXJhbmNlLFxuICBsaXN0ZW5lcixcbiAgdHJhbnNmb3JtLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBsZXQgbG9hZGluZyA9IGZhbHNlO1xuICBjb25zdCBpbWFnZVN0eWxlID0gc3R5bGUuZ2V0SW1hZ2UoKTtcbiAgaWYgKGltYWdlU3R5bGUpIHtcbiAgICBjb25zdCBpbWFnZVN0YXRlID0gaW1hZ2VTdHlsZS5nZXRJbWFnZVN0YXRlKCk7XG4gICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5MT0FERUQgfHwgaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkVSUk9SKSB7XG4gICAgICBpbWFnZVN0eWxlLnVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgICAgaW1hZ2VTdHlsZS5sb2FkKCk7XG4gICAgICB9XG4gICAgICBpbWFnZVN0eWxlLmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKTtcbiAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZW5kZXJGZWF0dXJlSW50ZXJuYWwoXG4gICAgcmVwbGF5R3JvdXAsXG4gICAgZmVhdHVyZSxcbiAgICBzdHlsZSxcbiAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgIHRyYW5zZm9ybSxcbiAgICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbiAgKTtcblxuICByZXR1cm4gbG9hZGluZztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdHJhbnNmb3JtXSBPcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyRmVhdHVyZUludGVybmFsKFxuICByZXBsYXlHcm91cCxcbiAgZmVhdHVyZSxcbiAgc3R5bGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHRyYW5zZm9ybSxcbiAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4pIHtcbiAgY29uc3QgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gIGlmICghZ2VvbWV0cnkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZEdlb21ldHJ5ID0gZ2VvbWV0cnkuc2ltcGxpZnlUcmFuc2Zvcm1lZChcbiAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgIHRyYW5zZm9ybVxuICApO1xuICBjb25zdCByZW5kZXJlciA9IHN0eWxlLmdldFJlbmRlcmVyKCk7XG4gIGlmIChyZW5kZXJlcikge1xuICAgIHJlbmRlckdlb21ldHJ5KHJlcGxheUdyb3VwLCBzaW1wbGlmaWVkR2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBnZW9tZXRyeVJlbmRlcmVyID0gR0VPTUVUUllfUkVOREVSRVJTW3NpbXBsaWZpZWRHZW9tZXRyeS5nZXRUeXBlKCldO1xuICAgIGdlb21ldHJ5UmVuZGVyZXIoXG4gICAgICByZXBsYXlHcm91cCxcbiAgICAgIHNpbXBsaWZpZWRHZW9tZXRyeSxcbiAgICAgIHN0eWxlLFxuICAgICAgZmVhdHVyZSxcbiAgICAgIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgPT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID1cbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICByZW5kZXJHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cmllc1tpXSwgc3R5bGUsIGZlYXR1cmUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0QnVpbGRlcihzdHlsZS5nZXRaSW5kZXgoKSwgJ0RlZmF1bHQnKTtcbiAgcmVwbGF5LmRyYXdDdXN0b20oXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSksXG4gICAgZmVhdHVyZSxcbiAgICBzdHlsZS5nZXRSZW5kZXJlcigpLFxuICAgIHN0eWxlLmdldEhpdERldGVjdGlvblJlbmRlcmVyKClcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gW2RlY2x1dHRlckJ1aWxkZXJHcm91cF0gQnVpbGRlciBmb3IgZGVjbHV0dGVyaW5nLlxuICovXG5mdW5jdGlvbiByZW5kZXJHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeShcbiAgcmVwbGF5R3JvdXAsXG4gIGdlb21ldHJ5LFxuICBzdHlsZSxcbiAgZmVhdHVyZSxcbiAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4pIHtcbiAgY29uc3QgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpO1xuICBsZXQgaSwgaWk7XG4gIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZ2VvbWV0cnlSZW5kZXJlciA9IEdFT01FVFJZX1JFTkRFUkVSU1tnZW9tZXRyaWVzW2ldLmdldFR5cGUoKV07XG4gICAgZ2VvbWV0cnlSZW5kZXJlcihcbiAgICAgIHJlcGxheUdyb3VwLFxuICAgICAgZ2VvbWV0cmllc1tpXSxcbiAgICAgIHN0eWxlLFxuICAgICAgZmVhdHVyZSxcbiAgICAgIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IGJ1aWxkZXJHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpbmVTdHJpbmdHZW9tZXRyeShcbiAgYnVpbGRlckdyb3VwLFxuICBnZW9tZXRyeSxcbiAgc3R5bGUsXG4gIGZlYXR1cmUsXG4gIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuKSB7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSkge1xuICAgIGNvbnN0IGxpbmVTdHJpbmdSZXBsYXkgPSBidWlsZGVyR3JvdXAuZ2V0QnVpbGRlcihcbiAgICAgIHN0eWxlLmdldFpJbmRleCgpLFxuICAgICAgJ0xpbmVTdHJpbmcnXG4gICAgKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShudWxsLCBzdHJva2VTdHlsZSk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5kcmF3TGluZVN0cmluZyhnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgY29uc3QgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlICYmIHRleHRTdHlsZS5nZXRUZXh0KCkpIHtcbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gKGRlY2x1dHRlckJ1aWxkZXJHcm91cCB8fCBidWlsZGVyR3JvdXApLmdldEJ1aWxkZXIoXG4gICAgICBzdHlsZS5nZXRaSW5kZXgoKSxcbiAgICAgICdUZXh0J1xuICAgICk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gYnVpbGRlckdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gW2RlY2x1dHRlckJ1aWxkZXJHcm91cF0gQnVpbGRlciBmb3IgZGVjbHV0dGVyaW5nLlxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeShcbiAgYnVpbGRlckdyb3VwLFxuICBnZW9tZXRyeSxcbiAgc3R5bGUsXG4gIGZlYXR1cmUsXG4gIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuKSB7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSkge1xuICAgIGNvbnN0IGxpbmVTdHJpbmdSZXBsYXkgPSBidWlsZGVyR3JvdXAuZ2V0QnVpbGRlcihcbiAgICAgIHN0eWxlLmdldFpJbmRleCgpLFxuICAgICAgJ0xpbmVTdHJpbmcnXG4gICAgKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShudWxsLCBzdHJva2VTdHlsZSk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5kcmF3TXVsdGlMaW5lU3RyaW5nKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUgJiYgdGV4dFN0eWxlLmdldFRleHQoKSkge1xuICAgIGNvbnN0IHRleHRSZXBsYXkgPSAoZGVjbHV0dGVyQnVpbGRlckdyb3VwIHx8IGJ1aWxkZXJHcm91cCkuZ2V0QnVpbGRlcihcbiAgICAgIHN0eWxlLmdldFpJbmRleCgpLFxuICAgICAgJ1RleHQnXG4gICAgKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBidWlsZGVyR3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck11bHRpUG9seWdvbkdlb21ldHJ5KFxuICBidWlsZGVyR3JvdXAsXG4gIGdlb21ldHJ5LFxuICBzdHlsZSxcbiAgZmVhdHVyZSxcbiAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4pIHtcbiAgY29uc3QgZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbCgpO1xuICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoc3Ryb2tlU3R5bGUgfHwgZmlsbFN0eWxlKSB7XG4gICAgY29uc3QgcG9seWdvblJlcGxheSA9IGJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKHN0eWxlLmdldFpJbmRleCgpLCAnUG9seWdvbicpO1xuICAgIHBvbHlnb25SZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICAgIHBvbHlnb25SZXBsYXkuZHJhd011bHRpUG9seWdvbihnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgY29uc3QgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlICYmIHRleHRTdHlsZS5nZXRUZXh0KCkpIHtcbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gKGRlY2x1dHRlckJ1aWxkZXJHcm91cCB8fCBidWlsZGVyR3JvdXApLmdldEJ1aWxkZXIoXG4gICAgICBzdHlsZS5nZXRaSW5kZXgoKSxcbiAgICAgICdUZXh0J1xuICAgICk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gYnVpbGRlckdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclBvaW50R2VvbWV0cnkoXG4gIGJ1aWxkZXJHcm91cCxcbiAgZ2VvbWV0cnksXG4gIHN0eWxlLFxuICBmZWF0dXJlLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBjb25zdCBpbWFnZVN0eWxlID0gc3R5bGUuZ2V0SW1hZ2UoKTtcbiAgY29uc3QgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMuanNcIikuRGVjbHV0dGVySW1hZ2VXaXRoVGV4dH0gKi9cbiAgbGV0IGRlY2x1dHRlckltYWdlV2l0aFRleHQ7XG4gIGlmIChpbWFnZVN0eWxlKSB7XG4gICAgaWYgKGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpICE9IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBpbWFnZUJ1aWxkZXJHcm91cCA9IGJ1aWxkZXJHcm91cDtcbiAgICBpZiAoZGVjbHV0dGVyQnVpbGRlckdyb3VwKSB7XG4gICAgICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gaW1hZ2VTdHlsZS5nZXREZWNsdXR0ZXJNb2RlKCk7XG4gICAgICBpZiAoZGVjbHV0dGVyTW9kZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGltYWdlQnVpbGRlckdyb3VwID0gZGVjbHV0dGVyQnVpbGRlckdyb3VwO1xuICAgICAgICBpZiAoZGVjbHV0dGVyTW9kZSA9PT0gJ29ic3RhY2xlJykge1xuICAgICAgICAgIC8vIGRyYXcgaW4gbm9uLWRlY2x1dHRlciBncm91cDpcbiAgICAgICAgICBjb25zdCBpbWFnZVJlcGxheSA9IGJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKFxuICAgICAgICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAgICAgICAnSW1hZ2UnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbWFnZVJlcGxheS5zZXRJbWFnZVN0eWxlKGltYWdlU3R5bGUsIGRlY2x1dHRlckltYWdlV2l0aFRleHQpO1xuICAgICAgICAgIGltYWdlUmVwbGF5LmRyYXdQb2ludChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dFN0eWxlICYmIHRleHRTdHlsZS5nZXRUZXh0KCkpIHtcbiAgICAgICAgICBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1hZ2VSZXBsYXkgPSBpbWFnZUJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKFxuICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAnSW1hZ2UnXG4gICAgKTtcbiAgICBpbWFnZVJlcGxheS5zZXRJbWFnZVN0eWxlKGltYWdlU3R5bGUsIGRlY2x1dHRlckltYWdlV2l0aFRleHQpO1xuICAgIGltYWdlUmVwbGF5LmRyYXdQb2ludChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgaWYgKHRleHRTdHlsZSAmJiB0ZXh0U3R5bGUuZ2V0VGV4dCgpKSB7XG4gICAgbGV0IHRleHRCdWlsZGVyR3JvdXAgPSBidWlsZGVyR3JvdXA7XG4gICAgaWYgKGRlY2x1dHRlckJ1aWxkZXJHcm91cCkge1xuICAgICAgdGV4dEJ1aWxkZXJHcm91cCA9IGRlY2x1dHRlckJ1aWxkZXJHcm91cDtcbiAgICB9XG4gICAgY29uc3QgdGV4dFJlcGxheSA9IHRleHRCdWlsZGVyR3JvdXAuZ2V0QnVpbGRlcihzdHlsZS5nZXRaSW5kZXgoKSwgJ1RleHQnKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIGRlY2x1dHRlckltYWdlV2l0aFRleHQpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBidWlsZGVyR3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gW2RlY2x1dHRlckJ1aWxkZXJHcm91cF0gQnVpbGRlciBmb3IgZGVjbHV0dGVyaW5nLlxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aVBvaW50R2VvbWV0cnkoXG4gIGJ1aWxkZXJHcm91cCxcbiAgZ2VvbWV0cnksXG4gIHN0eWxlLFxuICBmZWF0dXJlLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBjb25zdCBpbWFnZVN0eWxlID0gc3R5bGUuZ2V0SW1hZ2UoKTtcbiAgY29uc3QgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMuanNcIikuRGVjbHV0dGVySW1hZ2VXaXRoVGV4dH0gKi9cbiAgbGV0IGRlY2x1dHRlckltYWdlV2l0aFRleHQ7XG4gIGlmIChpbWFnZVN0eWxlKSB7XG4gICAgaWYgKGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpICE9IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBpbWFnZUJ1aWxkZXJHcm91cCA9IGJ1aWxkZXJHcm91cDtcbiAgICBpZiAoZGVjbHV0dGVyQnVpbGRlckdyb3VwKSB7XG4gICAgICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gaW1hZ2VTdHlsZS5nZXREZWNsdXR0ZXJNb2RlKCk7XG4gICAgICBpZiAoZGVjbHV0dGVyTW9kZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGltYWdlQnVpbGRlckdyb3VwID0gZGVjbHV0dGVyQnVpbGRlckdyb3VwO1xuICAgICAgICBpZiAoZGVjbHV0dGVyTW9kZSA9PT0gJ29ic3RhY2xlJykge1xuICAgICAgICAgIC8vIGRyYXcgaW4gbm9uLWRlY2x1dHRlciBncm91cDpcbiAgICAgICAgICBjb25zdCBpbWFnZVJlcGxheSA9IGJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKFxuICAgICAgICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAgICAgICAnSW1hZ2UnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbWFnZVJlcGxheS5zZXRJbWFnZVN0eWxlKGltYWdlU3R5bGUsIGRlY2x1dHRlckltYWdlV2l0aFRleHQpO1xuICAgICAgICAgIGltYWdlUmVwbGF5LmRyYXdNdWx0aVBvaW50KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0U3R5bGUgJiYgdGV4dFN0eWxlLmdldFRleHQoKSkge1xuICAgICAgICAgIGRlY2x1dHRlckltYWdlV2l0aFRleHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWFnZVJlcGxheSA9IGltYWdlQnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoXG4gICAgICBzdHlsZS5nZXRaSW5kZXgoKSxcbiAgICAgICdJbWFnZSdcbiAgICApO1xuICAgIGltYWdlUmVwbGF5LnNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCk7XG4gICAgaW1hZ2VSZXBsYXkuZHJhd011bHRpUG9pbnQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIGlmICh0ZXh0U3R5bGUgJiYgdGV4dFN0eWxlLmdldFRleHQoKSkge1xuICAgIGxldCB0ZXh0QnVpbGRlckdyb3VwID0gYnVpbGRlckdyb3VwO1xuICAgIGlmIChkZWNsdXR0ZXJCdWlsZGVyR3JvdXApIHtcbiAgICAgIHRleHRCdWlsZGVyR3JvdXAgPSBkZWNsdXR0ZXJCdWlsZGVyR3JvdXA7XG4gICAgfVxuICAgIGNvbnN0IHRleHRSZXBsYXkgPSB0ZXh0QnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoc3R5bGUuZ2V0WkluZGV4KCksICdUZXh0Jyk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0KTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gYnVpbGRlckdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyUG9seWdvbkdlb21ldHJ5KFxuICBidWlsZGVyR3JvdXAsXG4gIGdlb21ldHJ5LFxuICBzdHlsZSxcbiAgZmVhdHVyZSxcbiAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4pIHtcbiAgY29uc3QgZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbCgpO1xuICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoZmlsbFN0eWxlIHx8IHN0cm9rZVN0eWxlKSB7XG4gICAgY29uc3QgcG9seWdvblJlcGxheSA9IGJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKHN0eWxlLmdldFpJbmRleCgpLCAnUG9seWdvbicpO1xuICAgIHBvbHlnb25SZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICAgIHBvbHlnb25SZXBsYXkuZHJhd1BvbHlnb24oZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIGNvbnN0IHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSAmJiB0ZXh0U3R5bGUuZ2V0VGV4dCgpKSB7XG4gICAgY29uc3QgdGV4dFJlcGxheSA9IChkZWNsdXR0ZXJCdWlsZGVyR3JvdXAgfHwgYnVpbGRlckdyb3VwKS5nZXRCdWlsZGVyKFxuICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAnVGV4dCdcbiAgICApO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyXG4gKi9cbmltcG9ydCBDYW52YXNCdWlsZGVyR3JvdXAgZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanMnO1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIsIHtjYW52YXNQb29sfSBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBFeGVjdXRvckdyb3VwIGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvRXhlY3V0b3JHcm91cC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uLy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7XG4gIEhJVF9ERVRFQ1RfUkVTT0xVVElPTixcbiAgY3JlYXRlSGl0RGV0ZWN0aW9uSW1hZ2VEYXRhLFxuICBoaXREZXRlY3QsXG59IGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvaGl0ZGV0ZWN0LmpzJztcbmltcG9ydCB7XG4gIGFwcGx5LFxuICBtYWtlSW52ZXJzZSxcbiAgbWFrZVNjYWxlLFxuICB0b1N0cmluZyBhcyB0cmFuc2Zvcm1Ub1N0cmluZyxcbn0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7XG4gIGJ1ZmZlcixcbiAgY29udGFpbnNFeHRlbnQsXG4gIGNyZWF0ZUVtcHR5LFxuICBnZXRXaWR0aCxcbiAgaW50ZXJzZWN0cyBhcyBpbnRlcnNlY3RzRXh0ZW50LFxuICB3cmFwWCBhcyB3cmFwRXh0ZW50WCxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJELCByZWxlYXNlQ2FudmFzfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtcbiAgZGVmYXVsdE9yZGVyIGFzIGRlZmF1bHRSZW5kZXJPcmRlcixcbiAgZ2V0VG9sZXJhbmNlIGFzIGdldFJlbmRlclRvbGVyYW5jZSxcbiAgZ2V0U3F1YXJlZFRvbGVyYW5jZSBhcyBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlLFxuICByZW5kZXJGZWF0dXJlLFxufSBmcm9tICcuLi92ZWN0b3IuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7XG4gIGZyb21Vc2VyRXh0ZW50LFxuICBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMsXG4gIGdldFVzZXJQcm9qZWN0aW9uLFxuICB0b1VzZXJFeHRlbnQsXG4gIHRvVXNlclJlc29sdXRpb24sXG59IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHt3cmFwWCBhcyB3cmFwQ29vcmRpbmF0ZVh9IGZyb20gJy4uLy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdmVjdG9yIGxheWVycy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciBleHRlbmRzIENhbnZhc0xheWVyUmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9CYXNlVmVjdG9yLmpzXCIpLmRlZmF1bHR9IHZlY3RvckxheWVyIFZlY3RvciBsYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZlY3RvckxheWVyKSB7XG4gICAgc3VwZXIodmVjdG9yTGF5ZXIpO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfID0gdGhpcy5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJbWFnZURhdGF8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEZlYXR1cmVzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9IE5hTjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBwZWRSZW5kZXJlZEV4dGVudF8gPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSb3RhdGlvbl87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb25fID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogbnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlbmRlck9yZGVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yR3JvdXBcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGxheUdyb3VwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIG5ldyByZXBsYXkgZ3JvdXAgaGFkIHRvIGJlIGNyZWF0ZWQgYnkgYHByZXBhcmVGcmFtZSgpYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yR3JvdXBcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2xpcHBpbmcgdG8gYmUgcGVyZm9ybWVkIGJ5IGByZW5kZXJGcmFtZSgpYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY2xpcHBpbmcgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29tcG9zaXRpb25Db250ZXh0XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IDE7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFeGVjdXRvckdyb3VwfSBleGVjdXRvckdyb3VwIEV4ZWN1dG9yIGdyb3VwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcInJidXNoXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJUcmVlXSBEZWNsdXR0ZXIgdHJlZS5cbiAgICovXG4gIHJlbmRlcldvcmxkcyhleGVjdXRvckdyb3VwLCBmcmFtZVN0YXRlLCBkZWNsdXR0ZXJUcmVlKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3QgY2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgIGNvbnN0IHZlY3RvclNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKTtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIGNvbnN0IHZpZXdIaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgIGNvbnN0IHNuYXBUb1BpeGVsID0gIShcbiAgICAgIHZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IHZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR11cbiAgICApO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF87XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lU3RhdGUuc2l6ZVswXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbyk7XG5cbiAgICBjb25zdCBtdWx0aVdvcmxkID0gdmVjdG9yU291cmNlLmdldFdyYXBYKCkgJiYgcHJvamVjdGlvbi5jYW5XcmFwWCgpO1xuICAgIGNvbnN0IHdvcmxkV2lkdGggPSBtdWx0aVdvcmxkID8gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCkgOiBudWxsO1xuICAgIGNvbnN0IGVuZFdvcmxkID0gbXVsdGlXb3JsZFxuICAgICAgPyBNYXRoLmNlaWwoKGV4dGVudFsyXSAtIHByb2plY3Rpb25FeHRlbnRbMl0pIC8gd29ybGRXaWR0aCkgKyAxXG4gICAgICA6IDE7XG4gICAgbGV0IHdvcmxkID0gbXVsdGlXb3JsZFxuICAgICAgPyBNYXRoLmZsb29yKChleHRlbnRbMF0gLSBwcm9qZWN0aW9uRXh0ZW50WzBdKSAvIHdvcmxkV2lkdGgpXG4gICAgICA6IDA7XG4gICAgZG8ge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHBpeGVsUmF0aW8sXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdvcmxkICogd29ybGRXaWR0aFxuICAgICAgKTtcbiAgICAgIGV4ZWN1dG9yR3JvdXAuZXhlY3V0ZShcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgMSxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgc25hcFRvUGl4ZWwsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZGVjbHV0dGVyVHJlZVxuICAgICAgKTtcbiAgICB9IHdoaWxlICgrK3dvcmxkIDwgZW5kV29ybGQpO1xuICB9XG5cbiAgc2V0dXBDb21wb3NpdGlvbkNvbnRleHRfKCkge1xuICAgIGlmICh0aGlzLm9wYWNpdHlfICE9PSAxKSB7XG4gICAgICBjb25zdCBjb21wb3NpdGlvbkNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXMud2lkdGgsXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICBjYW52YXNQb29sXG4gICAgICApO1xuICAgICAgdGhpcy5jb21wb3NpdGlvbkNvbnRleHRfID0gY29tcG9zaXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF8gPSB0aGlzLmNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgcmVsZWFzZUNvbXBvc2l0aW9uQ29udGV4dF8oKSB7XG4gICAgaWYgKHRoaXMub3BhY2l0eV8gIT09IDEpIHtcbiAgICAgIGNvbnN0IGFscGhhID0gdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5XztcbiAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jb21wb3NpdGlvbkNvbnRleHRfLmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgIHJlbGVhc2VDYW52YXModGhpcy5jb21wb3NpdGlvbkNvbnRleHRfKTtcbiAgICAgIGNhbnZhc1Bvb2wucHVzaCh0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF8uY2FudmFzKTtcbiAgICAgIHRoaXMuY29tcG9zaXRpb25Db250ZXh0XyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBkZWNsdXR0ZXIgaXRlbXMgZm9yIHRoaXMgbGF5ZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIHJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlKSB7XG4gICAgaWYgKHRoaXMuZGVjbHV0dGVyRXhlY3V0b3JHcm91cCkge1xuICAgICAgdGhpcy5zZXR1cENvbXBvc2l0aW9uQ29udGV4dF8oKTtcbiAgICAgIHRoaXMucmVuZGVyV29ybGRzKFxuICAgICAgICB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAsXG4gICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgIGZyYW1lU3RhdGUuZGVjbHV0dGVyVHJlZVxuICAgICAgKTtcbiAgICAgIHRoaXMucmVsZWFzZUNvbXBvc2l0aW9uQ29udGV4dF8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxudWxsfSB0YXJnZXQgVGFyZ2V0IHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgdG8uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCBsYXllclN0YXRlID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5W2ZyYW1lU3RhdGUubGF5ZXJJbmRleF07XG5cbiAgICAvLyBzZXQgZm9yd2FyZCBhbmQgaW52ZXJzZSBwaXhlbCB0cmFuc2Zvcm1zXG4gICAgbWFrZVNjYWxlKHRoaXMucGl4ZWxUcmFuc2Zvcm0sIDEgLyBwaXhlbFJhdGlvLCAxIC8gcGl4ZWxSYXRpbyk7XG4gICAgbWFrZUludmVyc2UodGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0sIHRoaXMucGl4ZWxUcmFuc2Zvcm0pO1xuXG4gICAgY29uc3QgY2FudmFzVHJhbnNmb3JtID0gdHJhbnNmb3JtVG9TdHJpbmcodGhpcy5waXhlbFRyYW5zZm9ybSk7XG5cbiAgICB0aGlzLnVzZUNvbnRhaW5lcih0YXJnZXQsIGNhbnZhc1RyYW5zZm9ybSwgdGhpcy5nZXRCYWNrZ3JvdW5kKGZyYW1lU3RhdGUpKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuXG4gICAgY29uc3QgcmVwbGF5R3JvdXAgPSB0aGlzLnJlcGxheUdyb3VwXztcbiAgICBjb25zdCBkZWNsdXR0ZXJFeGVjdXRvckdyb3VwID0gdGhpcy5kZWNsdXR0ZXJFeGVjdXRvckdyb3VwO1xuICAgIGxldCByZW5kZXIgPVxuICAgICAgKHJlcGxheUdyb3VwICYmICFyZXBsYXlHcm91cC5pc0VtcHR5KCkpIHx8XG4gICAgICAoZGVjbHV0dGVyRXhlY3V0b3JHcm91cCAmJiAhZGVjbHV0dGVyRXhlY3V0b3JHcm91cC5pc0VtcHR5KCkpO1xuICAgIGlmICghcmVuZGVyKSB7XG4gICAgICBjb25zdCBoYXNSZW5kZXJMaXN0ZW5lcnMgPVxuICAgICAgICB0aGlzLmdldExheWVyKCkuaGFzTGlzdGVuZXIoUmVuZGVyRXZlbnRUeXBlLlBSRVJFTkRFUikgfHxcbiAgICAgICAgdGhpcy5nZXRMYXllcigpLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5QT1NUUkVOREVSKTtcbiAgICAgIGlmICghaGFzUmVuZGVyTGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc2l6ZSBhbmQgY2xlYXJcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbyk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChmcmFtZVN0YXRlLnNpemVbMV0gKiBwaXhlbFJhdGlvKTtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAoY2FudmFzLnN0eWxlLnRyYW5zZm9ybSAhPT0gY2FudmFzVHJhbnNmb3JtKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50cmFuc2Zvcm0gPSBjYW52YXNUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucHJlUmVuZGVyKGNvbnRleHQsIGZyYW1lU3RhdGUpO1xuXG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuXG4gICAgdGhpcy5vcGFjaXR5XyA9IGxheWVyU3RhdGUub3BhY2l0eTtcbiAgICB0aGlzLnNldHVwQ29tcG9zaXRpb25Db250ZXh0XygpO1xuXG4gICAgLy8gY2xpcHBlZCByZW5kZXJpbmcgaWYgbGF5ZXIgZXh0ZW50IGlzIHNldFxuICAgIGxldCBjbGlwcGVkID0gZmFsc2U7XG4gICAgaWYgKHJlbmRlciAmJiBsYXllclN0YXRlLmV4dGVudCAmJiB0aGlzLmNsaXBwaW5nKSB7XG4gICAgICBjb25zdCBsYXllckV4dGVudCA9IGZyb21Vc2VyRXh0ZW50KGxheWVyU3RhdGUuZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICAgIHJlbmRlciA9IGludGVyc2VjdHNFeHRlbnQobGF5ZXJFeHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KTtcbiAgICAgIGNsaXBwZWQgPSByZW5kZXIgJiYgIWNvbnRhaW5zRXh0ZW50KGxheWVyRXh0ZW50LCBmcmFtZVN0YXRlLmV4dGVudCk7XG4gICAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgICB0aGlzLmNsaXBVbnJvdGF0ZWQodGhpcy5jb21wb3NpdGlvbkNvbnRleHRfLCBmcmFtZVN0YXRlLCBsYXllckV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlcikge1xuICAgICAgdGhpcy5yZW5kZXJXb3JsZHMocmVwbGF5R3JvdXAsIGZyYW1lU3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICB0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF8ucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVsZWFzZUNvbXBvc2l0aW9uQ29udGV4dF8oKTtcblxuICAgIHRoaXMucG9zdFJlbmRlcihjb250ZXh0LCBmcmFtZVN0YXRlKTtcblxuICAgIGlmICh0aGlzLnJlbmRlcmVkUm90YXRpb25fICE9PSB2aWV3U3RhdGUucm90YXRpb24pIHtcbiAgICAgIHRoaXMucmVuZGVyZWRSb3RhdGlvbl8gPSB2aWV3U3RhdGUucm90YXRpb247XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlRGF0YV8gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGxheWVyIGxldmVsIGhpdCBkZXRlY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGltcG9ydChcIi4uLy4uL0ZlYXR1cmVcIikuZGVmYXVsdD4+fSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBmZWF0dXJlcy5cbiAgICovXG4gIGdldEZlYXR1cmVzKHBpeGVsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VEYXRhXyAmJiAhdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXykge1xuICAgICAgICBjb25zdCBzaXplID0gW3RoaXMuY29udGV4dC5jYW52YXMud2lkdGgsIHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0XTtcbiAgICAgICAgYXBwbHkodGhpcy5waXhlbFRyYW5zZm9ybSwgc2l6ZSk7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMucmVuZGVyZWRDZW50ZXJfO1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlZFJlc29sdXRpb25fO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMucmVuZGVyZWRSb3RhdGlvbl87XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLnJlbmRlcmVkUHJvamVjdGlvbl87XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IHRoaXMud3JhcHBlZFJlbmRlcmVkRXh0ZW50XztcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybXMgPSBbXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzaXplWzBdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBzaXplWzFdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICAgICAgICB0cmFuc2Zvcm1zLnB1c2goXG4gICAgICAgICAgdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgICAgICBjZW50ZXIsXG4gICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICBISVRfREVURUNUX1JFU09MVVRJT04sXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApLnNsaWNlKClcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc291cmNlLmdldFdyYXBYKCkgJiZcbiAgICAgICAgICBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAgICAgICAhY29udGFpbnNFeHRlbnQocHJvamVjdGlvbkV4dGVudCwgZXh0ZW50KVxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgc3RhcnRYID0gZXh0ZW50WzBdO1xuICAgICAgICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgICAgICBsZXQgd29ybGQgPSAwO1xuICAgICAgICAgIGxldCBvZmZzZXRYO1xuICAgICAgICAgIHdoaWxlIChzdGFydFggPCBwcm9qZWN0aW9uRXh0ZW50WzBdKSB7XG4gICAgICAgICAgICAtLXdvcmxkO1xuICAgICAgICAgICAgb2Zmc2V0WCA9IHdvcmxkV2lkdGggKiB3b3JsZDtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgICAgSElUX0RFVEVDVF9SRVNPTFVUSU9OLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBvZmZzZXRYXG4gICAgICAgICAgICAgICkuc2xpY2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0YXJ0WCArPSB3b3JsZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JsZCA9IDA7XG4gICAgICAgICAgc3RhcnRYID0gZXh0ZW50WzJdO1xuICAgICAgICAgIHdoaWxlIChzdGFydFggPiBwcm9qZWN0aW9uRXh0ZW50WzJdKSB7XG4gICAgICAgICAgICArK3dvcmxkO1xuICAgICAgICAgICAgb2Zmc2V0WCA9IHdvcmxkV2lkdGggKiB3b3JsZDtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgICAgSElUX0RFVEVDVF9SRVNPTFVUSU9OLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBvZmZzZXRYXG4gICAgICAgICAgICAgICkuc2xpY2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0YXJ0WCAtPSB3b3JsZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VEYXRhXyA9IGNyZWF0ZUhpdERldGVjdGlvbkltYWdlRGF0YShcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHRyYW5zZm9ybXMsXG4gICAgICAgICAgdGhpcy5yZW5kZXJlZEZlYXR1cmVzXyxcbiAgICAgICAgICBsYXllci5nZXRTdHlsZUZ1bmN0aW9uKCksXG4gICAgICAgICAgZXh0ZW50LFxuICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgcm90YXRpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoXG4gICAgICAgIGhpdERldGVjdChwaXhlbCwgdGhpcy5yZW5kZXJlZEZlYXR1cmVzXywgdGhpcy5oaXREZXRlY3Rpb25JbWFnZURhdGFfKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3ZlY3Rvci5qc1wiKS5GZWF0dXJlQ2FsbGJhY2s8VD59IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkhpdE1hdGNoPFQ+Pn0gbWF0Y2hlcyBUaGUgaGl0IGRldGVjdGVkIG1hdGNoZXMgd2l0aCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNhbGxiYWNrLFxuICAgIG1hdGNoZXNcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnJlcGxheUdyb3VwXykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcblxuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL01hcC5qc1wiKS5IaXRNYXRjaDxUPnx0cnVlPn0gKi9cbiAgICBjb25zdCBmZWF0dXJlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVNxIFRoZSBzcXVhcmVkIGRpc3RhbmNlIHRvIHRoZSBjbGljayBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAgICovXG4gICAgY29uc3QgZmVhdHVyZUNhbGxiYWNrID0gZnVuY3Rpb24gKGZlYXR1cmUsIGdlb21ldHJ5LCBkaXN0YW5jZVNxKSB7XG4gICAgICBjb25zdCBrZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICBjb25zdCBtYXRjaCA9IGZlYXR1cmVzW2tleV07XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZVNxID09PSAwKSB7XG4gICAgICAgICAgZmVhdHVyZXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZlYXR1cmUsIGxheWVyLCBnZW9tZXRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIChmZWF0dXJlc1trZXldID0ge1xuICAgICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgIGRpc3RhbmNlU3E6IGRpc3RhbmNlU3EsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggIT09IHRydWUgJiYgZGlzdGFuY2VTcSA8IG1hdGNoLmRpc3RhbmNlU3EpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlU3EgPT09IDApIHtcbiAgICAgICAgICBmZWF0dXJlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICBtYXRjaGVzLnNwbGljZShtYXRjaGVzLmxhc3RJbmRleE9mKG1hdGNoKSwgMSk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZlYXR1cmUsIGxheWVyLCBnZW9tZXRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2guZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgbWF0Y2guZGlzdGFuY2VTcSA9IGRpc3RhbmNlU3E7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IGV4ZWN1dG9yR3JvdXBzID0gW3RoaXMucmVwbGF5R3JvdXBfXTtcbiAgICBpZiAodGhpcy5kZWNsdXR0ZXJFeGVjdXRvckdyb3VwKSB7XG4gICAgICBleGVjdXRvckdyb3Vwcy5wdXNoKHRoaXMuZGVjbHV0dGVyRXhlY3V0b3JHcm91cCk7XG4gICAgfVxuICAgIGV4ZWN1dG9yR3JvdXBzLnNvbWUoKGV4ZWN1dG9yR3JvdXApID0+IHtcbiAgICAgIHJldHVybiAocmVzdWx0ID0gZXhlY3V0b3JHcm91cC5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgICAgY29vcmRpbmF0ZSxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgICAgZmVhdHVyZUNhbGxiYWNrLFxuICAgICAgICBleGVjdXRvckdyb3VwID09PSB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAgJiZcbiAgICAgICAgICBmcmFtZVN0YXRlLmRlY2x1dHRlclRyZWVcbiAgICAgICAgICA/IGZyYW1lU3RhdGUuZGVjbHV0dGVyVHJlZS5hbGwoKS5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWUpXG4gICAgICAgICAgOiBudWxsXG4gICAgICApKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhY3Rpb24gbmVjZXNzYXJ5IHRvIGdldCB0aGUgbGF5ZXIgcmVuZGVyZWQgYWZ0ZXIgbmV3IGZvbnRzIGhhdmUgbG9hZGVkXG4gICAqL1xuICBoYW5kbGVGb250c0NoYW5nZWQoKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgaWYgKGxheWVyLmdldFZpc2libGUoKSAmJiB0aGlzLnJlcGxheUdyb3VwXykge1xuICAgICAgbGF5ZXIuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdHlsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgSW1hZ2Ugc3R5bGUgY2hhbmdlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8oZXZlbnQpIHtcbiAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgcmVuZGVyIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVyIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCB2ZWN0b3JMYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBjb25zdCB2ZWN0b3JTb3VyY2UgPSB2ZWN0b3JMYXllci5nZXRTb3VyY2UoKTtcbiAgICBpZiAoIXZlY3RvclNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGluZyA9IGZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LkFOSU1BVElOR107XG4gICAgY29uc3QgaW50ZXJhY3RpbmcgPSBmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR107XG4gICAgY29uc3QgdXBkYXRlV2hpbGVBbmltYXRpbmcgPSB2ZWN0b3JMYXllci5nZXRVcGRhdGVXaGlsZUFuaW1hdGluZygpO1xuICAgIGNvbnN0IHVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgPSB2ZWN0b3JMYXllci5nZXRVcGRhdGVXaGlsZUludGVyYWN0aW5nKCk7XG5cbiAgICBpZiAoXG4gICAgICAodGhpcy5yZWFkeSAmJiAhdXBkYXRlV2hpbGVBbmltYXRpbmcgJiYgYW5pbWF0aW5nKSB8fFxuICAgICAgKCF1cGRhdGVXaGlsZUludGVyYWN0aW5nICYmIGludGVyYWN0aW5nKVxuICAgICkge1xuICAgICAgdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXyA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXyA9IGZhbHNlO1xuXG4gICAgY29uc3QgZnJhbWVTdGF0ZUV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCB2ZWN0b3JMYXllclJldmlzaW9uID0gdmVjdG9yTGF5ZXIuZ2V0UmV2aXNpb24oKTtcbiAgICBjb25zdCB2ZWN0b3JMYXllclJlbmRlckJ1ZmZlciA9IHZlY3RvckxheWVyLmdldFJlbmRlckJ1ZmZlcigpO1xuICAgIGxldCB2ZWN0b3JMYXllclJlbmRlck9yZGVyID0gdmVjdG9yTGF5ZXIuZ2V0UmVuZGVyT3JkZXIoKTtcblxuICAgIGlmICh2ZWN0b3JMYXllclJlbmRlck9yZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZlY3RvckxheWVyUmVuZGVyT3JkZXIgPSBkZWZhdWx0UmVuZGVyT3JkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gdmlld1N0YXRlLmNlbnRlci5zbGljZSgpO1xuICAgIGNvbnN0IGV4dGVudCA9IGJ1ZmZlcihcbiAgICAgIGZyYW1lU3RhdGVFeHRlbnQsXG4gICAgICB2ZWN0b3JMYXllclJlbmRlckJ1ZmZlciAqIHJlc29sdXRpb25cbiAgICApO1xuICAgIGNvbnN0IHJlbmRlcmVkRXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgY29uc3QgbG9hZEV4dGVudHMgPSBbZXh0ZW50LnNsaWNlKCldO1xuICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuXG4gICAgaWYgKFxuICAgICAgdmVjdG9yU291cmNlLmdldFdyYXBYKCkgJiZcbiAgICAgIHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgICAgIWNvbnRhaW5zRXh0ZW50KHByb2plY3Rpb25FeHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KVxuICAgICkge1xuICAgICAgLy8gRm9yIHRoZSByZXBsYXkgZ3JvdXAsIHdlIG5lZWQgYW4gZXh0ZW50IHRoYXQgaW50ZXJzZWN0cyB0aGUgcmVhbCB3b3JsZFxuICAgICAgLy8gKC0xODBcdTAwQjAgdG8gKzE4MFx1MDBCMCkuIFRvIHN1cHBvcnQgZ2VvbWV0cmllcyBpbiBhIGNvb3JkaW5hdGUgcmFuZ2UgZnJvbSAtNTQwXHUwMEIwXG4gICAgICAvLyB0byArNTQwXHUwMEIwLCB3ZSBhZGQgYXQgbGVhc3QgMSB3b3JsZCB3aWR0aCBvbiBlYWNoIHNpZGUgb2YgdGhlIHByb2plY3Rpb25cbiAgICAgIC8vIGV4dGVudC4gSWYgdGhlIHZpZXdwb3J0IGlzIHdpZGVyIHRoYW4gdGhlIHdvcmxkLCB3ZSBuZWVkIHRvIGFkZCBoYWxmIG9mXG4gICAgICAvLyB0aGUgdmlld3BvcnQgd2lkdGggdG8gbWFrZSBzdXJlIHdlIGNvdmVyIHRoZSB3aG9sZSB2aWV3cG9ydC5cbiAgICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgIGNvbnN0IGd1dHRlciA9IE1hdGgubWF4KGdldFdpZHRoKGV4dGVudCkgLyAyLCB3b3JsZFdpZHRoKTtcbiAgICAgIGV4dGVudFswXSA9IHByb2plY3Rpb25FeHRlbnRbMF0gLSBndXR0ZXI7XG4gICAgICBleHRlbnRbMl0gPSBwcm9qZWN0aW9uRXh0ZW50WzJdICsgZ3V0dGVyO1xuICAgICAgd3JhcENvb3JkaW5hdGVYKGNlbnRlciwgcHJvamVjdGlvbik7XG4gICAgICBjb25zdCBsb2FkRXh0ZW50ID0gd3JhcEV4dGVudFgobG9hZEV4dGVudHNbMF0sIHByb2plY3Rpb24pO1xuICAgICAgLy8gSWYgdGhlIGV4dGVudCBjcm9zc2VzIHRoZSBkYXRlIGxpbmUsIHdlIGxvYWQgZGF0YSBmb3IgYm90aCBlZGdlcyBvZiB0aGUgd29ybGRzXG4gICAgICBpZiAoXG4gICAgICAgIGxvYWRFeHRlbnRbMF0gPCBwcm9qZWN0aW9uRXh0ZW50WzBdICYmXG4gICAgICAgIGxvYWRFeHRlbnRbMl0gPCBwcm9qZWN0aW9uRXh0ZW50WzJdXG4gICAgICApIHtcbiAgICAgICAgbG9hZEV4dGVudHMucHVzaChbXG4gICAgICAgICAgbG9hZEV4dGVudFswXSArIHdvcmxkV2lkdGgsXG4gICAgICAgICAgbG9hZEV4dGVudFsxXSxcbiAgICAgICAgICBsb2FkRXh0ZW50WzJdICsgd29ybGRXaWR0aCxcbiAgICAgICAgICBsb2FkRXh0ZW50WzNdLFxuICAgICAgICBdKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGxvYWRFeHRlbnRbMF0gPiBwcm9qZWN0aW9uRXh0ZW50WzBdICYmXG4gICAgICAgIGxvYWRFeHRlbnRbMl0gPiBwcm9qZWN0aW9uRXh0ZW50WzJdXG4gICAgICApIHtcbiAgICAgICAgbG9hZEV4dGVudHMucHVzaChbXG4gICAgICAgICAgbG9hZEV4dGVudFswXSAtIHdvcmxkV2lkdGgsXG4gICAgICAgICAgbG9hZEV4dGVudFsxXSxcbiAgICAgICAgICBsb2FkRXh0ZW50WzJdIC0gd29ybGRXaWR0aCxcbiAgICAgICAgICBsb2FkRXh0ZW50WzNdLFxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5ICYmXG4gICAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbl8gPT0gcmVzb2x1dGlvbiAmJlxuICAgICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9PSB2ZWN0b3JMYXllclJldmlzaW9uICYmXG4gICAgICB0aGlzLnJlbmRlcmVkUmVuZGVyT3JkZXJfID09IHZlY3RvckxheWVyUmVuZGVyT3JkZXIgJiZcbiAgICAgIGNvbnRhaW5zRXh0ZW50KHRoaXMud3JhcHBlZFJlbmRlcmVkRXh0ZW50XywgZXh0ZW50KVxuICAgICkge1xuICAgICAgaWYgKCFlcXVhbHModGhpcy5yZW5kZXJlZEV4dGVudF8sIHJlbmRlcmVkRXh0ZW50KSkge1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlRGF0YV8gPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IHJlbmRlcmVkRXh0ZW50O1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJlZENlbnRlcl8gPSBjZW50ZXI7XG4gICAgICB0aGlzLnJlcGxheUdyb3VwQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5yZXBsYXlHcm91cF8gPSBudWxsO1xuXG4gICAgY29uc3QgcmVwbGF5R3JvdXAgPSBuZXcgQ2FudmFzQnVpbGRlckdyb3VwKFxuICAgICAgZ2V0UmVuZGVyVG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pLFxuICAgICAgZXh0ZW50LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHBpeGVsUmF0aW9cbiAgICApO1xuXG4gICAgbGV0IGRlY2x1dHRlckJ1aWxkZXJHcm91cDtcbiAgICBpZiAodGhpcy5nZXRMYXllcigpLmdldERlY2x1dHRlcigpKSB7XG4gICAgICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXAgPSBuZXcgQ2FudmFzQnVpbGRlckdyb3VwKFxuICAgICAgICBnZXRSZW5kZXJUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyksXG4gICAgICAgIGV4dGVudCxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcGl4ZWxSYXRpb1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG4gICAgbGV0IHVzZXJUcmFuc2Zvcm07XG4gICAgaWYgKHVzZXJQcm9qZWN0aW9uKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsb2FkRXh0ZW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IGxvYWRFeHRlbnRzW2ldO1xuICAgICAgICBjb25zdCB1c2VyRXh0ZW50ID0gdG9Vc2VyRXh0ZW50KGV4dGVudCwgcHJvamVjdGlvbik7XG4gICAgICAgIHZlY3RvclNvdXJjZS5sb2FkRmVhdHVyZXMoXG4gICAgICAgICAgdXNlckV4dGVudCxcbiAgICAgICAgICB0b1VzZXJSZXNvbHV0aW9uKHJlc29sdXRpb24sIHByb2plY3Rpb24pLFxuICAgICAgICAgIHVzZXJQcm9qZWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB1c2VyVHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHVzZXJQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbG9hZEV4dGVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2ZWN0b3JTb3VyY2UubG9hZEZlYXR1cmVzKGxvYWRFeHRlbnRzW2ldLCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcXVhcmVkVG9sZXJhbmNlID0gZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKTtcbiAgICBsZXQgcmVhZHkgPSB0cnVlO1xuICAgIGNvbnN0IHJlbmRlciA9XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgKi9cbiAgICAgIChmZWF0dXJlKSA9PiB7XG4gICAgICAgIGxldCBzdHlsZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlRnVuY3Rpb24gPVxuICAgICAgICAgIGZlYXR1cmUuZ2V0U3R5bGVGdW5jdGlvbigpIHx8IHZlY3RvckxheWVyLmdldFN0eWxlRnVuY3Rpb24oKTtcbiAgICAgICAgaWYgKHN0eWxlRnVuY3Rpb24pIHtcbiAgICAgICAgICBzdHlsZXMgPSBzdHlsZUZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICBjb25zdCBkaXJ0eSA9IHRoaXMucmVuZGVyRmVhdHVyZShcbiAgICAgICAgICAgIGZlYXR1cmUsXG4gICAgICAgICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgcmVwbGF5R3JvdXAsXG4gICAgICAgICAgICB1c2VyVHJhbnNmb3JtLFxuICAgICAgICAgICAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWFkeSA9IHJlYWR5ICYmICFkaXJ0eTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNvbnN0IHVzZXJFeHRlbnQgPSB0b1VzZXJFeHRlbnQoZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59ICovXG4gICAgY29uc3QgZmVhdHVyZXMgPSB2ZWN0b3JTb3VyY2UuZ2V0RmVhdHVyZXNJbkV4dGVudCh1c2VyRXh0ZW50KTtcbiAgICBpZiAodmVjdG9yTGF5ZXJSZW5kZXJPcmRlcikge1xuICAgICAgZmVhdHVyZXMuc29ydCh2ZWN0b3JMYXllclJlbmRlck9yZGVyKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcmVuZGVyKGZlYXR1cmVzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlZEZlYXR1cmVzXyA9IGZlYXR1cmVzO1xuICAgIHRoaXMucmVhZHkgPSByZWFkeTtcblxuICAgIGNvbnN0IHJlcGxheUdyb3VwSW5zdHJ1Y3Rpb25zID0gcmVwbGF5R3JvdXAuZmluaXNoKCk7XG4gICAgY29uc3QgZXhlY3V0b3JHcm91cCA9IG5ldyBFeGVjdXRvckdyb3VwKFxuICAgICAgZXh0ZW50LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHBpeGVsUmF0aW8sXG4gICAgICB2ZWN0b3JTb3VyY2UuZ2V0T3ZlcmxhcHMoKSxcbiAgICAgIHJlcGxheUdyb3VwSW5zdHJ1Y3Rpb25zLFxuICAgICAgdmVjdG9yTGF5ZXIuZ2V0UmVuZGVyQnVmZmVyKClcbiAgICApO1xuXG4gICAgaWYgKGRlY2x1dHRlckJ1aWxkZXJHcm91cCkge1xuICAgICAgdGhpcy5kZWNsdXR0ZXJFeGVjdXRvckdyb3VwID0gbmV3IEV4ZWN1dG9yR3JvdXAoXG4gICAgICAgIGV4dGVudCxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgICAgdmVjdG9yU291cmNlLmdldE92ZXJsYXBzKCksXG4gICAgICAgIGRlY2x1dHRlckJ1aWxkZXJHcm91cC5maW5pc2goKSxcbiAgICAgICAgdmVjdG9yTGF5ZXIuZ2V0UmVuZGVyQnVmZmVyKClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb25fID0gdmVjdG9yTGF5ZXJSZXZpc2lvbjtcbiAgICB0aGlzLnJlbmRlcmVkUmVuZGVyT3JkZXJfID0gdmVjdG9yTGF5ZXJSZW5kZXJPcmRlcjtcbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IHJlbmRlcmVkRXh0ZW50O1xuICAgIHRoaXMud3JhcHBlZFJlbmRlcmVkRXh0ZW50XyA9IGV4dGVudDtcbiAgICB0aGlzLnJlbmRlcmVkQ2VudGVyXyA9IGNlbnRlcjtcbiAgICB0aGlzLnJlbmRlcmVkUHJvamVjdGlvbl8gPSBwcm9qZWN0aW9uO1xuICAgIHRoaXMucmVwbGF5R3JvdXBfID0gZXhlY3V0b3JHcm91cDtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlRGF0YV8gPSBudWxsO1xuXG4gICAgdGhpcy5yZXBsYXlHcm91cENoYW5nZWQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgcmVuZGVyIHRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fEFycmF5PGltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fSBzdHlsZXMgVGhlIHN0eWxlIG9yIGFycmF5IG9mIHN0eWxlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBidWlsZGVyR3JvdXAgQnVpbGRlciBncm91cC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdHJhbnNmb3JtXSBUcmFuc2Zvcm0gZnJvbSB1c2VyIHRvIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBhbiBpbWFnZSBpcyBsb2FkaW5nLlxuICAgKi9cbiAgcmVuZGVyRmVhdHVyZShcbiAgICBmZWF0dXJlLFxuICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgc3R5bGVzLFxuICAgIGJ1aWxkZXJHcm91cCxcbiAgICB0cmFuc2Zvcm0sXG4gICAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4gICkge1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBsb2FkaW5nID0gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3R5bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbG9hZGluZyA9XG4gICAgICAgICAgcmVuZGVyRmVhdHVyZShcbiAgICAgICAgICAgIGJ1aWxkZXJHcm91cCxcbiAgICAgICAgICAgIGZlYXR1cmUsXG4gICAgICAgICAgICBzdHlsZXNbaV0sXG4gICAgICAgICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgICAgICAgdGhpcy5ib3VuZEhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLFxuICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4gICAgICAgICAgKSB8fCBsb2FkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkaW5nID0gcmVuZGVyRmVhdHVyZShcbiAgICAgICAgYnVpbGRlckdyb3VwLFxuICAgICAgICBmZWF0dXJlLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgIHRoaXMuYm91bmRIYW5kbGVTdHlsZUltYWdlQ2hhbmdlXyxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBsb2FkaW5nO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1ZlY3RvclxuICovXG5pbXBvcnQgQmFzZVZlY3RvckxheWVyIGZyb20gJy4vQmFzZVZlY3Rvci5qcyc7XG5pbXBvcnQgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciBmcm9tICcuLi9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXIuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFZlY3RvciBkYXRhIGlzIHJlbmRlcmVkIGNsaWVudC1zaWRlLCBhcyB2ZWN0b3JzLiBUaGlzIGxheWVyIHR5cGUgcHJvdmlkZXMgbW9zdCBhY2N1cmF0ZSByZW5kZXJpbmdcbiAqIGV2ZW4gZHVyaW5nIGFuaW1hdGlvbnMuIFBvaW50cyBhbmQgbGFiZWxzIHN0YXkgdXByaWdodCBvbiByb3RhdGVkIHZpZXdzLiBGb3IgdmVyeSBsYXJnZVxuICogYW1vdW50cyBvZiB2ZWN0b3IgZGF0YSwgcGVyZm9ybWFuY2UgbWF5IHN1ZmZlciBkdXJpbmcgcGFuIGFuZCB6b29tIGFuaW1hdGlvbnMuIEluIHRoaXMgY2FzZSxcbiAqIHRyeSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1ZlY3RvckltYWdlflZlY3RvckltYWdlTGF5ZXJ9LlxuICpcbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gVmVjdG9yU291cmNlVHlwZVxuICogQGV4dGVuZHMge0Jhc2VWZWN0b3JMYXllcjxWZWN0b3JTb3VyY2VUeXBlLCBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyPn1cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVmVjdG9yTGF5ZXIgZXh0ZW5kcyBCYXNlVmVjdG9yTGF5ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0Jhc2VWZWN0b3IuanNcIikuT3B0aW9uczxWZWN0b3JTb3VyY2VUeXBlPn0gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gbmV3IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIodGhpcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVjdG9yTGF5ZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvUkJ1c2hcbiAqL1xuaW1wb3J0IFJCdXNoXyBmcm9tICdyYnVzaCc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBlcXVhbHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uL29iai5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRW50cnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5YIE1pblguXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWSBNaW5ZLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFggTWF4WC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhZIE1heFkuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3ZhbHVlXSBWYWx1ZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFdyYXBwZXIgYXJvdW5kIHRoZSBSQnVzaCBieSBWbGFkaW1pciBBZ2Fmb25raW4uXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2guXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUkJ1c2gge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhFbnRyaWVzXSBNYXggZW50cmllcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1heEVudHJpZXMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmJ1c2hfID0gbmV3IFJCdXNoXyhtYXhFbnRyaWVzKTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBvYmplY3RzIGFkZGVkIHRvIHRoaXMgcmJ1c2ggd3JhcHBlclxuICAgICAqIGFuZCB0aGUgb2JqZWN0cyB0aGF0IGFyZSBhY3R1YWxseSBhZGRlZCB0byB0aGUgaW50ZXJuYWwgcmJ1c2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgRW50cnk+fVxuICAgICAqL1xuICAgIHRoaXMuaXRlbXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGEgdmFsdWUgaW50byB0aGUgUkJ1c2guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIGluc2VydChleHRlbnQsIHZhbHVlKSB7XG4gICAgLyoqIEB0eXBlIHtFbnRyeX0gKi9cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgbWluWDogZXh0ZW50WzBdLFxuICAgICAgbWluWTogZXh0ZW50WzFdLFxuICAgICAgbWF4WDogZXh0ZW50WzJdLFxuICAgICAgbWF4WTogZXh0ZW50WzNdLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgIH07XG5cbiAgICB0aGlzLnJidXNoXy5pbnNlcnQoaXRlbSk7XG4gICAgdGhpcy5pdGVtc19bZ2V0VWlkKHZhbHVlKV0gPSBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1bGstaW5zZXJ0IHZhbHVlcyBpbnRvIHRoZSBSQnVzaC5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gZXh0ZW50cyBFeHRlbnRzLlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKi9cbiAgbG9hZChleHRlbnRzLCB2YWx1ZXMpIHtcbiAgICBjb25zdCBpdGVtcyA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IGV4dGVudHNbaV07XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgLyoqIEB0eXBlIHtFbnRyeX0gKi9cbiAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIG1pblg6IGV4dGVudFswXSxcbiAgICAgICAgbWluWTogZXh0ZW50WzFdLFxuICAgICAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgICAgIG1heFk6IGV4dGVudFszXSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgfTtcbiAgICAgIGl0ZW1zW2ldID0gaXRlbTtcbiAgICAgIHRoaXMuaXRlbXNfW2dldFVpZCh2YWx1ZSldID0gaXRlbTtcbiAgICB9XG4gICAgdGhpcy5yYnVzaF8ubG9hZChpdGVtcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFsdWUgZnJvbSB0aGUgUkJ1c2guXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUodmFsdWUpIHtcbiAgICBjb25zdCB1aWQgPSBnZXRVaWQodmFsdWUpO1xuXG4gICAgLy8gZ2V0IHRoZSBvYmplY3QgaW4gd2hpY2ggdGhlIHZhbHVlIHdhcyB3cmFwcGVkIHdoZW4gYWRkaW5nIHRvIHRoZVxuICAgIC8vIGludGVybmFsIHJidXNoLiB0aGVuIHVzZSB0aGF0IG9iamVjdCB0byBkbyB0aGUgcmVtb3ZhbC5cbiAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc19bdWlkXTtcbiAgICBkZWxldGUgdGhpcy5pdGVtc19bdWlkXTtcbiAgICByZXR1cm4gdGhpcy5yYnVzaF8ucmVtb3ZlKGl0ZW0pICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZXh0ZW50IG9mIGEgdmFsdWUgaW4gdGhlIFJCdXNoLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICB1cGRhdGUoZXh0ZW50LCB2YWx1ZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zX1tnZXRVaWQodmFsdWUpXTtcbiAgICBjb25zdCBiYm94ID0gW2l0ZW0ubWluWCwgaXRlbS5taW5ZLCBpdGVtLm1heFgsIGl0ZW0ubWF4WV07XG4gICAgaWYgKCFlcXVhbHMoYmJveCwgZXh0ZW50KSkge1xuICAgICAgdGhpcy5yZW1vdmUodmFsdWUpO1xuICAgICAgdGhpcy5pbnNlcnQoZXh0ZW50LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdmFsdWVzIGluIHRoZSBSQnVzaC5cbiAgICogQHJldHVybiB7QXJyYXk8VD59IEFsbC5cbiAgICovXG4gIGdldEFsbCgpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMucmJ1c2hfLmFsbCgpO1xuICAgIHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdmFsdWVzIGluIHRoZSBnaXZlbiBleHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7QXJyYXk8VD59IEFsbCBpbiBleHRlbnQuXG4gICAqL1xuICBnZXRJbkV4dGVudChleHRlbnQpIHtcbiAgICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICAgIGNvbnN0IGJib3ggPSB7XG4gICAgICBtaW5YOiBleHRlbnRbMF0sXG4gICAgICBtaW5ZOiBleHRlbnRbMV0sXG4gICAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgICBtYXhZOiBleHRlbnRbM10sXG4gICAgfTtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMucmJ1c2hfLnNlYXJjaChiYm94KTtcbiAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZWFjaCB2YWx1ZSBpbiB0aGUgdHJlZS5cbiAgICogSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsIHRoaXMgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dFxuICAgKiBjaGVja2luZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihUKTogKn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gICAqIEByZXR1cm4geyp9IENhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEFsbCgpLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGVhY2ggdmFsdWUgaW4gdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKi9cbiAgZm9yRWFjaEluRXh0ZW50KGV4dGVudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEluRXh0ZW50KGV4dGVudCksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKi9cbiAgZm9yRWFjaF8odmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZXNbaV0pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gaXNFbXB0eSh0aGlzLml0ZW1zXyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB2YWx1ZXMgZnJvbSB0aGUgUkJ1c2guXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnJidXNoXy5jbGVhcigpO1xuICAgIHRoaXMuaXRlbXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICovXG4gIGdldEV4dGVudChleHRlbnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yYnVzaF8udG9KU09OKCk7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKGRhdGEubWluWCwgZGF0YS5taW5ZLCBkYXRhLm1heFgsIGRhdGEubWF4WSwgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JCdXNofSByYnVzaCBSLVRyZWUuXG4gICAqL1xuICBjb25jYXQocmJ1c2gpIHtcbiAgICB0aGlzLnJidXNoXy5sb2FkKHJidXNoLnJidXNoXy5hbGwoKSk7XG4gICAgZm9yIChjb25zdCBpIGluIHJidXNoLml0ZW1zXykge1xuICAgICAgdGhpcy5pdGVtc19baV0gPSByYnVzaC5pdGVtc19baV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJCdXNoO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvY2VudGVyXG4gKi9cbmltcG9ydCB7Y3JlYXRlRW1wdHksIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlc30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBjZW50ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlKSB7XG4gIGNvbnN0IGZsYXRDZW50ZXJzID0gW107XG4gIGxldCBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZHNbMF0sXG4gICAgICBzdHJpZGVcbiAgICApO1xuICAgIGZsYXRDZW50ZXJzLnB1c2goKGV4dGVudFswXSArIGV4dGVudFsyXSkgLyAyLCAoZXh0ZW50WzFdICsgZXh0ZW50WzNdKSAvIDIpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gZmxhdENlbnRlcnM7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb21cbiAqL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgQ2lyY2xlfSBmcm9tICcuL2dlb20vQ2lyY2xlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBHZW9tZXRyeX0gZnJvbSAnLi9nZW9tL0dlb21ldHJ5LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBHZW9tZXRyeUNvbGxlY3Rpb259IGZyb20gJy4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIExpbmVhclJpbmd9IGZyb20gJy4vZ2VvbS9MaW5lYXJSaW5nLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBMaW5lU3RyaW5nfSBmcm9tICcuL2dlb20vTGluZVN0cmluZy5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgTXVsdGlMaW5lU3RyaW5nfSBmcm9tICcuL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNdWx0aVBvaW50fSBmcm9tICcuL2dlb20vTXVsdGlQb2ludC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgTXVsdGlQb2x5Z29ufSBmcm9tICcuL2dlb20vTXVsdGlQb2x5Z29uLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQb2ludH0gZnJvbSAnLi9nZW9tL1BvaW50LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQb2x5Z29ufSBmcm9tICcuL2dlb20vUG9seWdvbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgU2ltcGxlR2VvbWV0cnl9IGZyb20gJy4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9GZWF0dXJlXG4gKi9cbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IHtcbiAgTGluZVN0cmluZyxcbiAgTXVsdGlMaW5lU3RyaW5nLFxuICBNdWx0aVBvaW50LFxuICBNdWx0aVBvbHlnb24sXG4gIFBvaW50LFxuICBQb2x5Z29uLFxufSBmcm9tICcuLi9nZW9tLmpzJztcbmltcG9ydCB7XG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUsXG4gIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyxcbiAgZ2V0Q2VudGVyLFxuICBnZXRIZWlnaHQsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1xuICBkb3VnbGFzUGV1Y2tlcixcbiAgZG91Z2xhc1BldWNrZXJBcnJheSxcbiAgcXVhbnRpemVBcnJheSxcbn0gZnJvbSAnLi4vZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge1xuICBnZXRJbnRlcmlvclBvaW50T2ZBcnJheSxcbiAgZ2V0SW50ZXJpb3JQb2ludHNPZk11bHRpQXJyYXksXG59IGZyb20gJy4uL2dlb20vZmxhdC9pbnRlcmlvcnBvaW50LmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtpbmZsYXRlRW5kc30gZnJvbSAnLi4vZ2VvbS9mbGF0L29yaWVudC5qcyc7XG5pbXBvcnQge2ludGVycG9sYXRlUG9pbnR9IGZyb20gJy4uL2dlb20vZmxhdC9pbnRlcnBvbGF0ZS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzcyBhcyBsaW5lYXJSaW5nc3NDZW50ZXJ9IGZyb20gJy4uL2dlb20vZmxhdC9jZW50ZXIuanMnO1xuaW1wb3J0IHttZW1vaXplT25lfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi4vZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydQb2ludCcgfCAnTGluZVN0cmluZycgfCAnTGluZWFyUmluZycgfCAnUG9seWdvbicgfCAnTXVsdGlQb2ludCcgfCAnTXVsdGlMaW5lU3RyaW5nJ30gVHlwZVxuICogVGhlIGdlb21ldHJ5IHR5cGUuICBPbmUgb2YgYCdQb2ludCdgLCBgJ0xpbmVTdHJpbmcnYCwgYCdMaW5lYXJSaW5nJ2AsXG4gKiBgJ1BvbHlnb24nYCwgYCdNdWx0aVBvaW50J2Agb3IgJ011bHRpTGluZVN0cmluZydgLlxuICovXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gKi9cbmNvbnN0IHRtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4vKipcbiAqIExpZ2h0d2VpZ2h0LCByZWFkLW9ubHksIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlfSBhbmQge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBsaWtlXG4gKiBzdHJ1Y3R1cmUsIG9wdGltaXplZCBmb3IgdmVjdG9yIHRpbGUgcmVuZGVyaW5nIGFuZCBzdHlsaW5nLiBHZW9tZXRyeSBhY2Nlc3NcbiAqIHRocm91Z2ggdGhlIEFQSSBpcyBsaW1pdGVkIHRvIGdldHRpbmcgdGhlIHR5cGUgYW5kIGV4dGVudCBvZiB0aGUgZ2VvbWV0cnkuXG4gKi9cbmNsYXNzIFJlbmRlckZlYXR1cmUge1xuICAvKipcbiAgICogQHBhcmFtIHtUeXBlfSB0eXBlIEdlb21ldHJ5IHR5cGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuIFRoZXNlIGFsd2F5cyBuZWVkXG4gICAqICAgICB0byBiZSByaWdodC1oYW5kZWQgZm9yIHBvbHlnb25zLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj59IHByb3BlcnRpZXMgUHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gaWQgRmVhdHVyZSBpZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGZsYXRDb29yZGluYXRlcywgZW5kcywgc3RyaWRlLCBwcm9wZXJ0aWVzLCBpZCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmlkXyA9IGlkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VHlwZX1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGVfID0gdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRNaWRwb2ludHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5lbmRzXyA9IGVuZHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICB0aGlzLnByb3BlcnRpZXNfID0gcHJvcGVydGllcztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdHJpZGVfID0gc3RyaWRlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyRmVhdHVyZX1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgZmVhdHVyZSBwcm9wZXJ0eSBieSBpdHMga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxuICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBmb3IgdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzX1trZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IG9mIHRoaXMgZmVhdHVyZSdzIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV4dGVudCgpIHtcbiAgICBpZiAoIXRoaXMuZXh0ZW50Xykge1xuICAgICAgdGhpcy5leHRlbnRfID1cbiAgICAgICAgdGhpcy50eXBlXyA9PT0gJ1BvaW50J1xuICAgICAgICAgID8gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZSh0aGlzLmZsYXRDb29yZGluYXRlc18pXG4gICAgICAgICAgOiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoXG4gICAgICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzXyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXNfLmxlbmd0aCxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGludGVyaW9yIHBvaW50cy5cbiAgICovXG4gIGdldEZsYXRJbnRlcmlvclBvaW50KCkge1xuICAgIGlmICghdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfKSB7XG4gICAgICBjb25zdCBmbGF0Q2VudGVyID0gZ2V0Q2VudGVyKHRoaXMuZ2V0RXh0ZW50KCkpO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfID0gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzXyxcbiAgICAgICAgMCxcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAodGhpcy5lbmRzXyksXG4gICAgICAgIDIsXG4gICAgICAgIGZsYXRDZW50ZXIsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRJbnRlcmlvclBvaW50c187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBpbnRlcmlvciBwb2ludHMuXG4gICAqL1xuICBnZXRGbGF0SW50ZXJpb3JQb2ludHMoKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRJbnRlcmlvclBvaW50c18pIHtcbiAgICAgIGNvbnN0IGVuZHMgPSBpbmZsYXRlRW5kcyh0aGlzLmZsYXRDb29yZGluYXRlc18sIHRoaXMuZW5kc18pO1xuICAgICAgY29uc3QgZmxhdENlbnRlcnMgPSBsaW5lYXJSaW5nc3NDZW50ZXIodGhpcy5mbGF0Q29vcmRpbmF0ZXNfLCAwLCBlbmRzLCAyKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzXyA9IGdldEludGVyaW9yUG9pbnRzT2ZNdWx0aUFycmF5KFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlc18sXG4gICAgICAgIDAsXG4gICAgICAgIGVuZHMsXG4gICAgICAgIDIsXG4gICAgICAgIGZsYXRDZW50ZXJzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgbWlkcG9pbnQuXG4gICAqL1xuICBnZXRGbGF0TWlkcG9pbnQoKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRNaWRwb2ludHNfKSB7XG4gICAgICB0aGlzLmZsYXRNaWRwb2ludHNfID0gaW50ZXJwb2xhdGVQb2ludChcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXNfLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlc18ubGVuZ3RoLFxuICAgICAgICAyLFxuICAgICAgICAwLjVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRNaWRwb2ludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgbWlkcG9pbnRzLlxuICAgKi9cbiAgZ2V0RmxhdE1pZHBvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuZmxhdE1pZHBvaW50c18pIHtcbiAgICAgIHRoaXMuZmxhdE1pZHBvaW50c18gPSBbXTtcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzXztcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgY29uc3QgZW5kcyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKHRoaXMuZW5kc18pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgICAgIGNvbnN0IG1pZHBvaW50ID0gaW50ZXJwb2xhdGVQb2ludChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCAyLCAwLjUpO1xuICAgICAgICBleHRlbmQodGhpcy5mbGF0TWlkcG9pbnRzXywgbWlkcG9pbnQpO1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRNaWRwb2ludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZSBpZGVudGlmaWVyLiAgVGhpcyBpcyBhIHN0YWJsZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZSBhbmRcbiAgICogaXMgc2V0IHdoZW4gcmVhZGluZyBkYXRhIGZyb20gYSByZW1vdGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gSWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLmlkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgQVBJIGNvbXBhdGliaWxpdHkgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0sIHRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuXG4gICAqIGRldGVybWluaW5nIHRoZSBnZW9tZXRyeSB0eXBlIGluIHN0eWxlIGZ1bmN0aW9uIChzZWUge0BsaW5rICNnZXRUeXBlfSkuXG4gICAqIEByZXR1cm4ge1JlbmRlckZlYXR1cmV9IEZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJGZWF0dXJlfSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2Zvcm1lZCBhbmQgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gW3RyYW5zZm9ybV0gT3B0aW9uYWwgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJGZWF0dXJlfSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgc2ltcGxpZnlUcmFuc2Zvcm1lZChzcXVhcmVkVG9sZXJhbmNlLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUgcHJvcGVydGllcy5cbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgKj59IEZlYXR1cmUgcHJvcGVydGllcy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IG9mIGFsbCBwcm9wZXJ0eSBuYW1lcyBhbmQgdmFsdWVzLiAgVGhpcyBoYXMgdGhlIHNhbWUgYmVoYXZpb3IgYXMgZ2V0UHJvcGVydGllcyxcbiAgICogYnV0IGlzIGhlcmUgdG8gY29uZm9ybSB3aXRoIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gaW50ZXJmYWNlLlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCAqPj99IE9iamVjdC5cbiAgICovXG4gIGdldFByb3BlcnRpZXNJbnRlcm5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFN0cmlkZS5cbiAgICovXG4gIGdldFN0cmlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpZGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vc3R5bGUvU3R5bGUuanMnKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gU3R5bGVcbiAgICovXG4gIGdldFN0eWxlRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge1R5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZV87XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIGdlb21ldHJ5IGNvb3JkaW5hdGVzIGZyb20gdGlsZSBwaXhlbCBzcGFjZSB0byBwcm9qZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgZGF0YSBwcm9qZWN0aW9uXG4gICAqL1xuICB0cmFuc2Zvcm0ocHJvamVjdGlvbikge1xuICAgIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHBpeGVsRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgICBjb25zdCBwcm9qZWN0ZWRFeHRlbnQgPSBwcm9qZWN0aW9uLmdldFdvcmxkRXh0ZW50KCk7XG4gICAgaWYgKHBpeGVsRXh0ZW50ICYmIHByb2plY3RlZEV4dGVudCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBnZXRIZWlnaHQocHJvamVjdGVkRXh0ZW50KSAvIGdldEhlaWdodChwaXhlbEV4dGVudCk7XG4gICAgICBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgICB0bXBUcmFuc2Zvcm0sXG4gICAgICAgIHByb2plY3RlZEV4dGVudFswXSxcbiAgICAgICAgcHJvamVjdGVkRXh0ZW50WzNdLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgLXNjYWxlLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgdHJhbnNmb3JtMkQoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzXyxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXNfLmxlbmd0aCxcbiAgICAgICAgMixcbiAgICAgICAgdG1wVHJhbnNmb3JtLFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlc19cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRoZSBnZW9tZXRyeSBtb2RpZmllZCBpbiBwbGFjZSwgZmlyc3QgYGNsb25lKClgIGl0IGFuZFxuICAgKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIHRyYW5zZm9ybUZuKHRoaXMuZmxhdENvb3JkaW5hdGVzXywgdGhpcy5mbGF0Q29vcmRpbmF0ZXNfLCB0aGlzLnN0cmlkZV8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1JlbmRlckZlYXR1cmV9IEEgY2xvbmVkIHJlbmRlciBmZWF0dXJlLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJGZWF0dXJlKFxuICAgICAgdGhpcy50eXBlXyxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzXy5zbGljZSgpLFxuICAgICAgdGhpcy5lbmRzXy5zbGljZSgpLFxuICAgICAgdGhpcy5zdHJpZGVfLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wZXJ0aWVzXyksXG4gICAgICB0aGlzLmlkX1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAgICovXG4gIGdldEVuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc187XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRyYW5zZm9ybSBhbmQgcmVzb2x1dGlvbiBiYXNlZCBnZW9tZXRyeSBzaW1wbGlmaWNhdGlvbiB0byB0aGlzIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJGZWF0dXJlfSBUaGlzIHJlbmRlciBmZWF0dXJlLlxuICAgKi9cbiAgZW5hYmxlU2ltcGxpZnlUcmFuc2Zvcm1lZCgpIHtcbiAgICB0aGlzLnNpbXBsaWZ5VHJhbnNmb3JtZWQgPSBtZW1vaXplT25lKChzcXVhcmVkVG9sZXJhbmNlLCB0cmFuc2Zvcm0pID0+IHtcbiAgICAgIGlmIChzcXVhcmVkVG9sZXJhbmNlID09PSB0aGlzLnNxdWFyZWRUb2xlcmFuY2VfKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeV87XG4gICAgICB9XG4gICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeV8gPSB0aGlzLmNsb25lKCk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Xy5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9XG4gICAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Xy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGxldCBzaW1wbGlmaWVkRW5kcztcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlXykge1xuICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeV8uZmxhdENvb3JkaW5hdGVzXy5sZW5ndGgsXG4gICAgICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeV8uc3RyaWRlXyxcbiAgICAgICAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgMFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2ltcGxpZmllZEVuZHMgPSBbc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGhdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgIHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeV8uZW5kc18sXG4gICAgICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeV8uc3RyaWRlXyxcbiAgICAgICAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHNpbXBsaWZpZWRFbmRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICAgICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IHF1YW50aXplQXJyYXkoXG4gICAgICAgICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Xy5lbmRzXyxcbiAgICAgICAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Xy5zdHJpZGVfLFxuICAgICAgICAgICAgTWF0aC5zcXJ0KHNxdWFyZWRUb2xlcmFuY2UpLFxuICAgICAgICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBzaW1wbGlmaWVkRW5kc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgICBpZiAoc2ltcGxpZmllZEVuZHMpIHtcbiAgICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlfID0gbmV3IFJlbmRlckZlYXR1cmUoXG4gICAgICAgICAgdGhpcy50eXBlXyxcbiAgICAgICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIHNpbXBsaWZpZWRFbmRzLFxuICAgICAgICAgIDIsXG4gICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzXyxcbiAgICAgICAgICB0aGlzLmlkX1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXyA9IHNxdWFyZWRUb2xlcmFuY2U7XG4gICAgICByZXR1cm4gdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlfO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBjb29yZGluYXRlcy5cbiAqL1xuUmVuZGVyRmVhdHVyZS5wcm90b3R5cGUuZ2V0RmxhdENvb3JkaW5hdGVzID1cbiAgUmVuZGVyRmVhdHVyZS5wcm90b3R5cGUuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXM7XG5cbi8qKlxuICogQ3JlYXRlIGEgZ2VvbWV0cnkgZnJvbSBhbiBgb2wvcmVuZGVyL0ZlYXR1cmVgXG4gKiBAcGFyYW0ge1JlbmRlckZlYXR1cmV9IHJlbmRlckZlYXR1cmVcbiAqIFJlbmRlciBGZWF0dXJlXG4gKiBAcmV0dXJuIHtQb2ludHxNdWx0aVBvaW50fExpbmVTdHJpbmd8TXVsdGlMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlQb2x5Z29ufVxuICogTmV3IGdlb21ldHJ5IGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9HZW9tZXRyeShyZW5kZXJGZWF0dXJlKSB7XG4gIGNvbnN0IGdlb21ldHJ5VHlwZSA9IHJlbmRlckZlYXR1cmUuZ2V0VHlwZSgpO1xuICBzd2l0Y2ggKGdlb21ldHJ5VHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgIHJldHVybiBuZXcgUG9pbnQocmVuZGVyRmVhdHVyZS5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICByZXR1cm4gbmV3IE11bHRpUG9pbnQocmVuZGVyRmVhdHVyZS5nZXRGbGF0Q29vcmRpbmF0ZXMoKSwgJ1hZJyk7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcocmVuZGVyRmVhdHVyZS5nZXRGbGF0Q29vcmRpbmF0ZXMoKSwgJ1hZJyk7XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKFxuICAgICAgICByZW5kZXJGZWF0dXJlLmdldEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgICAnWFknLFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChyZW5kZXJGZWF0dXJlLmdldEVuZHMoKSlcbiAgICAgICk7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSByZW5kZXJGZWF0dXJlLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgY29uc3QgZW5kcyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKHJlbmRlckZlYXR1cmUuZ2V0RW5kcygpKTtcbiAgICAgIGNvbnN0IGVuZHNzID0gaW5mbGF0ZUVuZHMoZmxhdENvb3JkaW5hdGVzLCBlbmRzKTtcbiAgICAgIHJldHVybiBlbmRzcy5sZW5ndGggPiAxXG4gICAgICAgID8gbmV3IE11bHRpUG9seWdvbihmbGF0Q29vcmRpbmF0ZXMsICdYWScsIGVuZHNzKVxuICAgICAgICA6IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgJ1hZJywgZW5kcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBnZW9tZXRyeSB0eXBlOicgKyBnZW9tZXRyeVR5cGUpO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbC9GZWF0dXJlYCBmcm9tIGFuIGBvbC9yZW5kZXIvRmVhdHVyZWBcbiAqIEBwYXJhbSB7UmVuZGVyRmVhdHVyZX0gcmVuZGVyRmVhdHVyZSBSZW5kZXJGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2dlb21ldHJ5TmFtZT0nZ2VvbWV0cnknXSBHZW9tZXRyeSBuYW1lIHRvIHVzZVxuICogd2hlbiBjcmVhdGluZyB0aGUgRmVhdHVyZS5cbiAqIEByZXR1cm4ge0ZlYXR1cmV9IE5ld2x5IGNvbnN0cnVjdGVkIGBvbC9GZWF0dXJlYCB3aXRoIHByb3BlcnRpZXMsXG4gKiBnZW9tZXRyeSwgYW5kIGlkIGNvcGllZCBvdmVyLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GZWF0dXJlKHJlbmRlckZlYXR1cmUsIGdlb21ldHJ5TmFtZSkge1xuICBjb25zdCBpZCA9IHJlbmRlckZlYXR1cmUuZ2V0SWQoKTtcbiAgY29uc3QgZ2VvbWV0cnkgPSB0b0dlb21ldHJ5KHJlbmRlckZlYXR1cmUpO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gcmVuZGVyRmVhdHVyZS5nZXRQcm9wZXJ0aWVzKCk7XG4gIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZSgpO1xuICBpZiAoZ2VvbWV0cnlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBmZWF0dXJlLnNldEdlb21ldHJ5TmFtZShnZW9tZXRyeU5hbWUpO1xuICB9XG4gIGZlYXR1cmUuc2V0R2VvbWV0cnkoZ2VvbWV0cnkpO1xuICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZlYXR1cmUuc2V0SWQoaWQpO1xuICB9XG4gIGZlYXR1cmUuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0cnVlKTtcbiAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckZlYXR1cmU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9WZWN0b3JFdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgZmVhdHVyZSBpcyBhZGRlZCB0byB0aGUgc291cmNlLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjYWRkZmVhdHVyZVxuICAgKiBAYXBpXG4gICAqL1xuICBBRERGRUFUVVJFOiAnYWRkZmVhdHVyZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgZmVhdHVyZSBpcyB1cGRhdGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjY2hhbmdlZmVhdHVyZVxuICAgKiBAYXBpXG4gICAqL1xuICBDSEFOR0VGRUFUVVJFOiAnY2hhbmdlZmVhdHVyZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBjbGVhciBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBzb3VyY2UuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNjbGVhclxuICAgKiBAYXBpXG4gICAqL1xuICBDTEVBUjogJ2NsZWFyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBmZWF0dXJlIGlzIHJlbW92ZWQgZnJvbSB0aGUgc291cmNlLlxuICAgKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNjbGVhciBzb3VyY2UuY2xlYXIoKX0gZm9yIGV4Y2VwdGlvbnMuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNyZW1vdmVmZWF0dXJlXG4gICAqIEBhcGlcbiAgICovXG4gIFJFTU9WRUZFQVRVUkU6ICdyZW1vdmVmZWF0dXJlJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gZmVhdHVyZXMgc3RhcnRzIGxvYWRpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNmZWF0dXJlc2xvYWRzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBGRUFUVVJFU0xPQURTVEFSVDogJ2ZlYXR1cmVzbG9hZHN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gZmVhdHVyZXMgZmluaXNoZXMgbG9hZGluZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I2ZlYXR1cmVzbG9hZGVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBGRUFUVVJFU0xPQURFTkQ6ICdmZWF0dXJlc2xvYWRlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgaWYgZmVhdHVyZSBsb2FkaW5nIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNmZWF0dXJlc2xvYWRlcnJvclxuICAgKiBAYXBpXG4gICAqL1xuICBGRUFUVVJFU0xPQURFUlJPUjogJ2ZlYXR1cmVzbG9hZGVycm9yJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeydhZGRmZWF0dXJlJ3wnY2hhbmdlZmVhdHVyZSd8J2NsZWFyJ3wncmVtb3ZlZmVhdHVyZSd8J2ZlYXR1cmVzbG9hZHN0YXJ0J3wnZmVhdHVyZXNsb2FkZW5kJ3wnZmVhdHVyZXNsb2FkZXJyb3InfSBWZWN0b3JTb3VyY2VFdmVudFR5cGVzXG4gKi9cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvbG9hZGluZ3N0cmF0ZWd5XG4gKi9cblxuaW1wb3J0IHtmcm9tVXNlckV4dGVudCwgZnJvbVVzZXJSZXNvbHV0aW9uLCB0b1VzZXJFeHRlbnR9IGZyb20gJy4vcHJvai5qcyc7XG5cbi8qKlxuICogU3RyYXRlZ3kgZnVuY3Rpb24gZm9yIGxvYWRpbmcgYWxsIGZlYXR1cmVzIHdpdGggYSBzaW5nbGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IEV4dGVudHMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGwoZXh0ZW50LCByZXNvbHV0aW9uKSB7XG4gIHJldHVybiBbWy1JbmZpbml0eSwgLUluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldXTtcbn1cblxuLyoqXG4gKiBTdHJhdGVneSBmdW5jdGlvbiBmb3IgbG9hZGluZyBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgdmlldydzIGV4dGVudCBhbmRcbiAqIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBFeHRlbnRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmJveChleHRlbnQsIHJlc29sdXRpb24pIHtcbiAgcmV0dXJuIFtleHRlbnRdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJhdGVneSBmdW5jdGlvbiBmb3IgbG9hZGluZyBmZWF0dXJlcyBiYXNlZCBvbiBhIHRpbGUgZ3JpZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlciwgaW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb24pOiBBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBMb2FkaW5nIHN0cmF0ZWd5LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGlsZSh0aWxlR3JpZCkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IEV4dGVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbikge1xuICAgICAgY29uc3QgeiA9IHRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKFxuICAgICAgICBmcm9tVXNlclJlc29sdXRpb24ocmVzb2x1dGlvbiwgcHJvamVjdGlvbilcbiAgICAgICk7XG4gICAgICBjb25zdCB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICBmcm9tVXNlckV4dGVudChleHRlbnQsIHByb2plY3Rpb24pLFxuICAgICAgICB6XG4gICAgICApO1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSAqL1xuICAgICAgY29uc3QgZXh0ZW50cyA9IFtdO1xuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9ICovXG4gICAgICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgMCwgMF07XG4gICAgICBmb3IgKFxuICAgICAgICB0aWxlQ29vcmRbMV0gPSB0aWxlUmFuZ2UubWluWDtcbiAgICAgICAgdGlsZUNvb3JkWzFdIDw9IHRpbGVSYW5nZS5tYXhYO1xuICAgICAgICArK3RpbGVDb29yZFsxXVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdGlsZUNvb3JkWzJdID0gdGlsZVJhbmdlLm1pblk7XG4gICAgICAgICAgdGlsZUNvb3JkWzJdIDw9IHRpbGVSYW5nZS5tYXhZO1xuICAgICAgICAgICsrdGlsZUNvb3JkWzJdXG4gICAgICAgICkge1xuICAgICAgICAgIGV4dGVudHMucHVzaChcbiAgICAgICAgICAgIHRvVXNlckV4dGVudCh0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkKSwgcHJvamVjdGlvbilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXh0ZW50cztcbiAgICB9XG4gICk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ZlYXR1cmVsb2FkZXJcbiAqL1xuaW1wb3J0IHtWT0lEfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5cbi8qKlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xubGV0IHdpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG4vKipcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2V9IHNvdXJjZXMgdXNlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIHRvXG4gKiBsb2FkIGZlYXR1cmVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgdXAgdG8gNSBhcmd1bWVudHMuIFRoZXNlIGFyZSBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHJlcHJlc2VudGluZ1xuICogdGhlIGFyZWEgdG8gYmUgbG9hZGVkLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSByZXNvbHV0aW9uIChtYXAgdW5pdHMgcGVyIHBpeGVsKSwgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IGZvciB0aGUgcHJvamVjdGlvbiwgYW4gb3B0aW9uYWwgc3VjY2VzcyBjYWxsYmFjayB0aGF0IHNob3VsZCBnZXRcbiAqIHRoZSBsb2FkZWQgZmVhdHVyZXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IGFuZCBhbiBvcHRpb25hbCBmYWlsdXJlIGNhbGxiYWNrIHdpdGggbm8gYXJndW1lbnRzLiBJZlxuICogdGhlIGNhbGxiYWNrcyBhcmUgbm90IHVzZWQsIHRoZSBjb3JyZXNwb25kaW5nIHZlY3RvciBzb3VyY2Ugd2lsbCBub3QgZmlyZSBgJ2ZlYXR1cmVzbG9hZGVuZCdgIGFuZFxuICogYCdmZWF0dXJlc2xvYWRlcnJvcidgIGV2ZW50cy4gYHRoaXNgIHdpdGhpbiB0aGUgZnVuY3Rpb24gaXMgYm91bmQgdG8gdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlfSBpdCdzIGNhbGxlZCBmcm9tLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyB0aGUgZmVhdHVyZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZVxuICogc291cmNlLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKHRoaXM6KGltcG9ydChcIi4vc291cmNlL1ZlY3RvclwiKS5kZWZhdWx0fGltcG9ydChcIi4vVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0KSxcbiAqICAgICAgICAgICBpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsXG4gKiAgICAgICAgICAgbnVtYmVyLFxuICogICAgICAgICAgIGltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQsXG4gKiAgICAgICAgICAgZnVuY3Rpb24oQXJyYXk8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+KTogdm9pZD0sXG4gKiAgICAgICAgICAgZnVuY3Rpb24oKTogdm9pZD0pOiB2b2lkfSBGZWF0dXJlTG9hZGVyXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0b1xuICogZ2V0IHRoZSB1cmwgdG8gbG9hZCBmZWF0dXJlcyBmcm9tLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSByZXByZXNlbnRpbmcgdGhlIGFyZWFcbiAqIHRvIGJlIGxvYWRlZCwgYSBge251bWJlcn1gIHJlcHJlc2VudGluZyB0aGUgcmVzb2x1dGlvbiAobWFwIHVuaXRzIHBlciBwaXhlbClcbiAqIGFuZCBhbiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24gIGFzXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBge3N0cmluZ31gIHJlcHJlc2VudGluZyB0aGUgVVJMLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyLCBpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0KTogc3RyaW5nfSBGZWF0dXJlVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEZlYXR1cmVVcmxGdW5jdGlvbn0gdXJsIEZlYXR1cmUgVVJMIHNlcnZpY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZm9ybWF0IEZlYXR1cmUgZm9ybWF0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PiwgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCk6IHZvaWR9IHN1Y2Nlc3MgU3VjY2Vzc1xuICogICAgICBGdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbG9hZGVkIGZlYXR1cmVzIGFuZCBvcHRpb25hbGx5IHdpdGggdGhlIGRhdGEgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gZmFpbHVyZSBGYWlsdXJlXG4gKiAgICAgIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGxvYWRpbmcgZmFpbGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZEZlYXR1cmVzWGhyKFxuICB1cmwsXG4gIGZvcm1hdCxcbiAgZXh0ZW50LFxuICByZXNvbHV0aW9uLFxuICBwcm9qZWN0aW9uLFxuICBzdWNjZXNzLFxuICBmYWlsdXJlXG4pIHtcbiAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHhoci5vcGVuKFxuICAgICdHRVQnLFxuICAgIHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicgPyB1cmwoZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSA6IHVybCxcbiAgICB0cnVlXG4gICk7XG4gIGlmIChmb3JtYXQuZ2V0VHlwZSgpID09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuICB4aHIud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzO1xuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB4aHIub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gc3RhdHVzIHdpbGwgYmUgMCBmb3IgZmlsZTovLyB1cmxzXG4gICAgaWYgKCF4aHIuc3RhdHVzIHx8ICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSkge1xuICAgICAgY29uc3QgdHlwZSA9IGZvcm1hdC5nZXRUeXBlKCk7XG4gICAgICAvKiogQHR5cGUge0RvY3VtZW50fE5vZGV8T2JqZWN0fHN0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICBsZXQgc291cmNlO1xuICAgICAgaWYgKHR5cGUgPT0gJ2pzb24nKSB7XG4gICAgICAgIHNvdXJjZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICAgIHNvdXJjZSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3htbCcpIHtcbiAgICAgICAgc291cmNlID0geGhyLnJlc3BvbnNlWE1MO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgIHNvdXJjZSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoXG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL3htbCdcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICBzb3VyY2UgPSAvKiogQHR5cGUge0FycmF5QnVmZmVyfSAqLyAoeGhyLnJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgc3VjY2VzcyhcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgICAgICAgICAoXG4gICAgICAgICAgICBmb3JtYXQucmVhZEZlYXR1cmVzKHNvdXJjZSwge1xuICAgICAgICAgICAgICBleHRlbnQ6IGV4dGVudCxcbiAgICAgICAgICAgICAgZmVhdHVyZVByb2plY3Rpb246IHByb2plY3Rpb24sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgZm9ybWF0LnJlYWRQcm9qZWN0aW9uKHNvdXJjZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhaWx1cmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmFpbHVyZSgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB4aHIub25lcnJvciA9IGZhaWx1cmU7XG4gIHhoci5zZW5kKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIFhIUiBmZWF0dXJlIGxvYWRlciBmb3IgYSBgdXJsYCBhbmQgYGZvcm1hdGAuIFRoZSBmZWF0dXJlIGxvYWRlclxuICogbG9hZHMgZmVhdHVyZXMgKHdpdGggWEhSKSwgcGFyc2VzIHRoZSBmZWF0dXJlcywgYW5kIGFkZHMgdGhlbSB0byB0aGVcbiAqIHZlY3RvciBzb3VyY2UuXG4gKiBAcGFyYW0ge3N0cmluZ3xGZWF0dXJlVXJsRnVuY3Rpb259IHVybCBGZWF0dXJlIFVSTCBzZXJ2aWNlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZvcm1hdCBGZWF0dXJlIGZvcm1hdC5cbiAqIEByZXR1cm4ge0ZlYXR1cmVMb2FkZXJ9IFRoZSBmZWF0dXJlIGxvYWRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHhocih1cmwsIGZvcm1hdCkge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pik6IHZvaWR9IFtzdWNjZXNzXSBTdWNjZXNzXG4gICAqICAgICAgRnVuY3Rpb24gY2FsbGVkIHdoZW4gbG9hZGluZyBzdWNjZWVkZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2ZhaWx1cmVdIEZhaWx1cmVcbiAgICogICAgICBGdW5jdGlvbiBjYWxsZWQgd2hlbiBsb2FkaW5nIGZhaWxlZC5cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAoZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgY29uc3Qgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3NvdXJjZS9WZWN0b3JcIikuZGVmYXVsdH0gKi8gKHRoaXMpO1xuICAgIGxvYWRGZWF0dXJlc1hocihcbiAgICAgIHVybCxcbiAgICAgIGZvcm1hdCxcbiAgICAgIGV4dGVudCxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBwcm9qZWN0aW9uLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgVGhlIGxvYWRlZCBmZWF0dXJlcy5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gZGF0YVByb2plY3Rpb24gRGF0YVxuICAgICAgICogcHJvamVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGZlYXR1cmVzLCBkYXRhUHJvamVjdGlvbikge1xuICAgICAgICBzb3VyY2UuYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xuICAgICAgICBpZiAoc3VjY2VzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3VjY2VzcyhmZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKiBGSVhNRSBoYW5kbGUgZXJyb3IgKi8gZmFpbHVyZSA/IGZhaWx1cmUgOiBWT0lEXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHRoZSB3aXRoQ3JlZGVudGlhbHMgY29uZmlndXJhdGlvbiBmb3IgdGhlIFhIUi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHhocldpdGhDcmVkZW50aWFscyBUaGUgdmFsdWUgb2Ygd2l0aENyZWRlbnRpYWxzIHRvIHNldC5cbiAqIENvbXBhcmUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L1xuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0V2l0aENyZWRlbnRpYWxzKHhocldpdGhDcmVkZW50aWFscykge1xuICB3aXRoQ3JlZGVudGlhbHMgPSB4aHJXaXRoQ3JlZGVudGlhbHM7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9WZWN0b3JcbiAqL1xuXG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IFJCdXNoIGZyb20gJy4uL3N0cnVjdHMvUkJ1c2guanMnO1xuaW1wb3J0IFJlbmRlckZlYXR1cmUgZnJvbSAnLi4vcmVuZGVyL0ZlYXR1cmUuanMnO1xuaW1wb3J0IFNvdXJjZSBmcm9tICcuL1NvdXJjZS5qcyc7XG5pbXBvcnQgVmVjdG9yRXZlbnRUeXBlIGZyb20gJy4vVmVjdG9yRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7VFJVRSwgVk9JRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7YWxsIGFzIGFsbFN0cmF0ZWd5fSBmcm9tICcuLi9sb2FkaW5nc3RyYXRlZ3kuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjb250YWluc0V4dGVudCwgZXF1YWxzLCB3cmFwQW5kU2xpY2VYfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IHt4aHJ9IGZyb20gJy4uL2ZlYXR1cmVsb2FkZXIuanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGFuZCBhIHJlc29sdXRpb24gYXMgYXJndW1lbnRzLCBhbmRcbiAqIHJldHVybnMgYW4gYXJyYXkgb2Yge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSB3aXRoIHRoZSBleHRlbnRzIHRvIGxvYWQuIFVzdWFsbHkgdGhpc1xuICogaXMgb25lIG9mIHRoZSBzdGFuZGFyZCB7QGxpbmsgbW9kdWxlOm9sL2xvYWRpbmdzdHJhdGVneX0gc3RyYXRlZ2llcy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyLCBpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCk6IEFycmF5PGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBMb2FkaW5nU3RyYXRlZ3lcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2V9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IFtGZWF0dXJlQ2xhc3M9aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0XVxuICovXG5leHBvcnQgY2xhc3MgVmVjdG9yU291cmNlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge0ZlYXR1cmVDbGFzc30gW2ZlYXR1cmVdIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7QXJyYXk8RmVhdHVyZUNsYXNzPn0gW2ZlYXR1cmVzXSBGZWF0dXJlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGZlYXR1cmUsIGZlYXR1cmVzKSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWRkZWQgb3IgcmVtb3ZlZCBmZWF0dXJlIGZvciB0aGUgYEFEREZFQVRVUkVgIGFuZCBgUkVNT1ZFRkVBVFVSRWAgZXZlbnRzLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAgICogQHR5cGUge0ZlYXR1cmVDbGFzc3x1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9hZGVkIGZlYXR1cmVzIGZvciB0aGUgYEZFQVRVUkVTTE9BREVEYCBldmVudCwgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtBcnJheTxGZWF0dXJlQ2xhc3M+fHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlcywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL1ZlY3RvckV2ZW50VHlwZVwiKS5WZWN0b3JTb3VyY2VFdmVudFR5cGVzLCBWZWN0b3JTb3VyY2VFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgIGltcG9ydChcIi4vVmVjdG9yRXZlbnRUeXBlXCIpLlZlY3RvclNvdXJjZUV2ZW50VHlwZXMsIFJldHVybj59IFZlY3RvclNvdXJjZU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IFtGZWF0dXJlQ2xhc3M9aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0XVxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RmVhdHVyZUNsYXNzPnxDb2xsZWN0aW9uPEZlYXR1cmVDbGFzcz59IFtmZWF0dXJlc11cbiAqIEZlYXR1cmVzLiBJZiBwcm92aWRlZCBhcyB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0sIHRoZSBmZWF0dXJlcyBpbiB0aGUgc291cmNlXG4gKiBhbmQgdGhlIGNvbGxlY3Rpb24gd2lsbCBzdGF5IGluIHN5bmMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IFtmb3JtYXRdIFRoZSBmZWF0dXJlIGZvcm1hdCB1c2VkIGJ5IHRoZSBYSFJcbiAqIGZlYXR1cmUgbG9hZGVyIHdoZW4gYHVybGAgaXMgc2V0LiBSZXF1aXJlZCBpZiBgdXJsYCBpcyBzZXQsIG90aGVyd2lzZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9IFtsb2FkZXJdXG4gKiBUaGUgbG9hZGVyIGZ1bmN0aW9uIHVzZWQgdG8gbG9hZCBmZWF0dXJlcywgZnJvbSBhIHJlbW90ZSBzb3VyY2UgZm9yIGV4YW1wbGUuXG4gKiBJZiB0aGlzIGlzIG5vdCBzZXQgYW5kIGB1cmxgIGlzIHNldCwgdGhlIHNvdXJjZSB3aWxsIGNyZWF0ZSBhbmQgdXNlIGFuIFhIUlxuICogZmVhdHVyZSBsb2FkZXIuIFRoZSBgJ2ZlYXR1cmVzbG9hZGVuZCdgIGFuZCBgJ2ZlYXR1cmVzbG9hZGVycm9yJ2AgZXZlbnRzXG4gKiB3aWxsIG9ubHkgZmlyZSBpZiB0aGUgYHN1Y2Nlc3NgIGFuZCBgZmFpbHVyZWAgY2FsbGJhY2tzIGFyZSB1c2VkLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBWZWN0b3IgZnJvbSAnb2wvc291cmNlL1ZlY3Rvci5qcyc7XG4gKiBpbXBvcnQgR2VvSlNPTiBmcm9tICdvbC9mb3JtYXQvR2VvSlNPTi5qcyc7XG4gKiBpbXBvcnQge2Jib3h9IGZyb20gJ29sL2xvYWRpbmdzdHJhdGVneS5qcyc7XG4gKlxuICogY29uc3QgdmVjdG9yU291cmNlID0gbmV3IFZlY3Rvcih7XG4gKiAgIGZvcm1hdDogbmV3IEdlb0pTT04oKSxcbiAqICAgbG9hZGVyOiBmdW5jdGlvbihleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24sIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAqICAgICAgY29uc3QgcHJvaiA9IHByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICogICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9haG9jZXZhci5jb20vZ2Vvc2VydmVyL3dmcz9zZXJ2aWNlPVdGUyYnICtcbiAqICAgICAgICAgICd2ZXJzaW9uPTEuMS4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlbmFtZT1vc206d2F0ZXJfYXJlYXMmJyArXG4gKiAgICAgICAgICAnb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24mc3JzbmFtZT0nICsgcHJvaiArICcmJyArXG4gKiAgICAgICAgICAnYmJveD0nICsgZXh0ZW50LmpvaW4oJywnKSArICcsJyArIHByb2o7XG4gKiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICogICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAqICAgICAgY29uc3Qgb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHZlY3RvclNvdXJjZS5yZW1vdmVMb2FkZWRFeHRlbnQoZXh0ZW50KTtcbiAqICAgICAgICBmYWlsdXJlKCk7XG4gKiAgICAgIH1cbiAqICAgICAgeGhyLm9uZXJyb3IgPSBvbkVycm9yO1xuICogICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwKSB7XG4gKiAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IHZlY3RvclNvdXJjZS5nZXRGb3JtYXQoKS5yZWFkRmVhdHVyZXMoeGhyLnJlc3BvbnNlVGV4dCk7XG4gKiAgICAgICAgICB2ZWN0b3JTb3VyY2UuYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xuICogICAgICAgICAgc3VjY2VzcyhmZWF0dXJlcyk7XG4gKiAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgIG9uRXJyb3IoKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgICAgeGhyLnNlbmQoKTtcbiAqICAgIH0sXG4gKiAgICBzdHJhdGVneTogYmJveCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmxhcHM9dHJ1ZV0gVGhpcyBzb3VyY2UgbWF5IGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAqIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIChlLmcuIGZvciBzb3VyY2VzIHdpdGggcG9seWdvbnMgdGhhdCByZXByZXNlbnQgYWRtaW5pc3RyYXRpdmVcbiAqIGJvdW5kYXJpZXMgb3IgVG9wb0pTT04gc291cmNlcykgYWxsb3dzIHRoZSByZW5kZXJlciB0byBvcHRpbWlzZSBmaWxsIGFuZFxuICogc3Ryb2tlIG9wZXJhdGlvbnMuXG4gKiBAcHJvcGVydHkge0xvYWRpbmdTdHJhdGVneX0gW3N0cmF0ZWd5XSBUaGUgbG9hZGluZyBzdHJhdGVneSB0byB1c2UuXG4gKiBCeSBkZWZhdWx0IGFuIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5LmFsbH1cbiAqIHN0cmF0ZWd5IGlzIHVzZWQsIGEgb25lLW9mZiBzdHJhdGVneSB3aGljaCBsb2FkcyBhbGwgZmVhdHVyZXMgYXQgb25jZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZVVybEZ1bmN0aW9ufSBbdXJsXVxuICogU2V0dGluZyB0aGlzIG9wdGlvbiBpbnN0cnVjdHMgdGhlIHNvdXJjZSB0byBsb2FkIGZlYXR1cmVzIHVzaW5nIGFuIFhIUiBsb2FkZXJcbiAqIChzZWUge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyLnhocn0pLiBVc2UgYSBgc3RyaW5nYCBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5LmFsbH0gZm9yIGEgb25lLW9mZiBkb3dubG9hZCBvZiBhbGwgZmVhdHVyZXMgZnJvbVxuICogdGhlIGdpdmVuIFVSTC4gVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVVcmxGdW5jdGlvbn0gdG8gZ2VuZXJhdGUgdGhlIHVybCB3aXRoXG4gKiBvdGhlciBsb2FkaW5nIHN0cmF0ZWdpZXMuXG4gKiBSZXF1aXJlcyBgZm9ybWF0YCB0byBiZSBzZXQgYXMgd2VsbC5cbiAqIFdoZW4gZGVmYXVsdCBYSFIgZmVhdHVyZSBsb2FkZXIgaXMgcHJvdmlkZWQsIHRoZSBmZWF0dXJlcyB3aWxsXG4gKiBiZSB0cmFuc2Zvcm1lZCBmcm9tIHRoZSBkYXRhIHByb2plY3Rpb24gdG8gdGhlIHZpZXcgcHJvamVjdGlvblxuICogZHVyaW5nIHBhcnNpbmcuIElmIHlvdXIgcmVtb3RlIGRhdGEgc291cmNlIGRvZXMgbm90IGFkdmVydGlzZSBpdHMgcHJvamVjdGlvblxuICogcHJvcGVybHksIHRoaXMgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBpbmNvcnJlY3QuIEZvciBzb21lIGZvcm1hdHMsIHRoZVxuICogZGVmYXVsdCBwcm9qZWN0aW9uICh1c3VhbGx5IEVQU0c6NDMyNikgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGVcbiAqIGRhdGFQcm9qZWN0aW9uIGNvbnN0cnVjdG9yIG9wdGlvbiBvbiB0aGUgZm9ybWF0LlxuICogTm90ZSB0aGF0IGlmIGEgc291cmNlIGNvbnRhaW5zIG5vbi1mZWF0dXJlIGRhdGEsIHN1Y2ggYXMgYSBHZW9KU09OIGdlb21ldHJ5XG4gKiBvciBhIEtNTCBOZXR3b3JrTGluaywgdGhlc2Ugd2lsbCBiZSBpZ25vcmVkLiBVc2UgYSBjdXN0b20gbG9hZGVyIHRvIGxvYWQgdGhlc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VTcGF0aWFsSW5kZXg9dHJ1ZV1cbiAqIEJ5IGRlZmF1bHQsIGFuIFJUcmVlIGlzIHVzZWQgYXMgc3BhdGlhbCBpbmRleC4gV2hlbiBmZWF0dXJlcyBhcmUgcmVtb3ZlZCBhbmRcbiAqIGFkZGVkIGZyZXF1ZW50bHksIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIGZlYXR1cmVzIGlzIGxvdywgc2V0dGluZyB0aGlzIHRvXG4gKiBgZmFsc2VgIG1heSBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICpcbiAqIE5vdGUgdGhhdFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRGZWF0dXJlc0luRXh0ZW50fSxcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0Q2xvc2VzdEZlYXR1cmVUb0Nvb3JkaW5hdGV9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRFeHRlbnR9IGNhbm5vdCBiZSB1c2VkIHdoZW4gYHVzZVNwYXRpYWxJbmRleGAgaXNcbiAqIHNldCB0byBgZmFsc2VgLCBhbmQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZUluRXh0ZW50fSB3aWxsIGxvb3BcbiAqIHRocm91Z2ggYWxsIGZlYXR1cmVzLlxuICpcbiAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHRoZSBmZWF0dXJlcyB3aWxsIGJlIG1haW50YWluZWQgaW4gYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSwgd2hpY2ggY2FuIGJlIHJldHJpZXZlZCB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldEZlYXR1cmVzQ29sbGVjdGlvbn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuIEZvciB2ZWN0b3IgZWRpdGluZyBhY3Jvc3MgdGhlXG4gKiAtMTgwXHUwMEIwIGFuZCAxODBcdTAwQjAgbWVyaWRpYW5zIHRvIHdvcmsgcHJvcGVybHksIHRoaXMgc2hvdWxkIGJlIHNldCB0byBgZmFsc2VgLiBUaGVcbiAqIHJlc3VsdGluZyBnZW9tZXRyeSBjb29yZGluYXRlcyB3aWxsIHRoZW4gZXhjZWVkIHRoZSB3b3JsZCBib3VuZHMuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm92aWRlcyBhIHNvdXJjZSBvZiBmZWF0dXJlcyBmb3IgdmVjdG9yIGxheWVycy4gVmVjdG9yIGZlYXR1cmVzIHByb3ZpZGVkXG4gKiBieSB0aGlzIHNvdXJjZSBhcmUgc3VpdGFibGUgZm9yIGVkaXRpbmcuIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3JUaWxlflZlY3RvclRpbGV9IGZvclxuICogdmVjdG9yIGRhdGEgdGhhdCBpcyBvcHRpbWl6ZWQgZm9yIHJlbmRlcmluZy5cbiAqXG4gKiBAZmlyZXMgVmVjdG9yU291cmNlRXZlbnRcbiAqIEBhcGlcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gW0ZlYXR1cmVDbGFzcz1pbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHRdXG4gKi9cbmNsYXNzIFZlY3RvclNvdXJjZSBleHRlbmRzIFNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM8RmVhdHVyZUNsYXNzPn0gW29wdGlvbnNdIFZlY3RvciBzb3VyY2Ugb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBpbnRlcnBvbGF0ZTogdHJ1ZSxcbiAgICAgIHByb2plY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIHN0YXRlOiAncmVhZHknLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtWZWN0b3JTb3VyY2VPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtWZWN0b3JTb3VyY2VPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZlY3RvclNvdXJjZU9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJfID0gVk9JRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0XyA9IG9wdGlvbnMuZm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXBzXyA9IG9wdGlvbnMub3ZlcmxhcHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLm92ZXJsYXBzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfGltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZVVybEZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnVybF8gPSBvcHRpb25zLnVybDtcblxuICAgIGlmIChvcHRpb25zLmxvYWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvYWRlcl8gPSBvcHRpb25zLmxvYWRlcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXJsXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQodGhpcy5mb3JtYXRfLCAnYGZvcm1hdGAgbXVzdCBiZSBzZXQgd2hlbiBgdXJsYCBpcyBzZXQnKTtcbiAgICAgIC8vIGNyZWF0ZSBhIFhIUiBmZWF0dXJlIGxvYWRlciBmb3IgXCJ1cmxcIiBhbmQgXCJmb3JtYXRcIlxuICAgICAgdGhpcy5sb2FkZXJfID0geGhyKFxuICAgICAgICB0aGlzLnVybF8sXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZm9ybWF0XylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TG9hZGluZ1N0cmF0ZWd5fVxuICAgICAqL1xuICAgIHRoaXMuc3RyYXRlZ3lfID1cbiAgICAgIG9wdGlvbnMuc3RyYXRlZ3kgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RyYXRlZ3kgOiBhbGxTdHJhdGVneTtcblxuICAgIGNvbnN0IHVzZVNwYXRpYWxJbmRleCA9XG4gICAgICBvcHRpb25zLnVzZVNwYXRpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51c2VTcGF0aWFsSW5kZXggOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UkJ1c2g8RmVhdHVyZUNsYXNzPn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzUnRyZWVfID0gdXNlU3BhdGlhbEluZGV4ID8gbmV3IFJCdXNoKCkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UkJ1c2g8e2V4dGVudDogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0+fVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkRXh0ZW50c1J0cmVlXyA9IG5ldyBSQnVzaCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZGluZ0V4dGVudHNDb3VudF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEZlYXR1cmVDbGFzcz59XG4gICAgICovXG4gICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9va3VwIG9mIGZlYXR1cmVzIGJ5IGlkICh0aGUgcmV0dXJuIGZyb20gZmVhdHVyZS5nZXRJZCgpKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgRmVhdHVyZUNsYXNzfEFycmF5PFJlbmRlckZlYXR1cmU+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmlkSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBmZWF0dXJlcyBieSB1aWQgKHVzaW5nIGdldFVpZChmZWF0dXJlKSkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEZlYXR1cmVDbGFzcz59XG4gICAgICovXG4gICAgdGhpcy51aWRJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxGZWF0dXJlQ2xhc3M+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fID0gbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxGZWF0dXJlQ2xhc3M+fSAqL1xuICAgIGxldCBjb2xsZWN0aW9uO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8RmVhdHVyZUNsYXNzPn0gKi9cbiAgICBsZXQgZmVhdHVyZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5mZWF0dXJlcykpIHtcbiAgICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZmVhdHVyZXMpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgICAgZmVhdHVyZXMgPSBjb2xsZWN0aW9uLmdldEFycmF5KCk7XG4gICAgfVxuICAgIGlmICghdXNlU3BhdGlhbEluZGV4ICYmIGNvbGxlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWRkRmVhdHVyZXNJbnRlcm5hbChmZWF0dXJlcyk7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYmluZEZlYXR1cmVzQ29sbGVjdGlvbl8oY29sbGVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBmZWF0dXJlIHRvIHRoZSBzb3VyY2UuICBJZiB5b3Ugd2FudCB0byBhZGQgYSBiYXRjaCBvZiBmZWF0dXJlc1xuICAgKiBhdCBvbmNlLCBjYWxsIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjYWRkRmVhdHVyZXMgI2FkZEZlYXR1cmVzKCl9XG4gICAqIGluc3RlYWQuIEEgZmVhdHVyZSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgc291cmNlIGlmIGZlYXR1cmUgd2l0aFxuICAgKiB0aGUgc2FtZSBpZCBpcyBhbHJlYWR5IHRoZXJlLiBUaGUgcmVhc29uIGZvciB0aGlzIGJlaGF2aW9yIGlzIHRvIGF2b2lkXG4gICAqIGZlYXR1cmUgZHVwbGljYXRpb24gd2hlbiB1c2luZyBiYm94IG9yIHRpbGUgbG9hZGluZyBzdHJhdGVnaWVzLlxuICAgKiBOb3RlOiB0aGlzIGFsc28gYXBwbGllcyBpZiBhbiB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaXMgdXNlZCBmb3IgZmVhdHVyZXMsXG4gICAqIG1lYW5pbmcgdGhhdCBpZiBhIGZlYXR1cmUgd2l0aCBhIGR1cGxpY2F0ZSBpZCBpcyBhZGRlZCBpbiB0aGUgY29sbGVjdGlvbiwgaXQgd2lsbFxuICAgKiBiZSByZW1vdmVkIGZyb20gaXQgcmlnaHQgYXdheS5cbiAgICogQHBhcmFtIHtGZWF0dXJlQ2xhc3N9IGZlYXR1cmUgRmVhdHVyZSB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZEZlYXR1cmUoZmVhdHVyZSkge1xuICAgIHRoaXMuYWRkRmVhdHVyZUludGVybmFsKGZlYXR1cmUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGZlYXR1cmUgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAgICogQHBhcmFtIHtGZWF0dXJlQ2xhc3N9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYWRkRmVhdHVyZUludGVybmFsKGZlYXR1cmUpIHtcbiAgICBjb25zdCBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuXG4gICAgaWYgKCF0aGlzLmFkZFRvSW5kZXhfKGZlYXR1cmVLZXksIGZlYXR1cmUpKSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5yZW1vdmUoZmVhdHVyZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cENoYW5nZUV2ZW50c18oZmVhdHVyZUtleSwgZmVhdHVyZSk7XG5cbiAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5pbnNlcnQoZXh0ZW50LCBmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSwgZmVhdHVyZSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlS2V5IFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtGZWF0dXJlQ2xhc3N9IGZlYXR1cmUgVGhlIGZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXR1cENoYW5nZUV2ZW50c18oZmVhdHVyZUtleSwgZmVhdHVyZSkge1xuICAgIGlmIChmZWF0dXJlIGluc3RhbmNlb2YgUmVuZGVyRmVhdHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XSA9IFtcbiAgICAgIGxpc3RlbihmZWF0dXJlLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLFxuICAgICAgICB0aGlzXG4gICAgICApLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVLZXkgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBmZWF0dXJlLlxuICAgKiBAcGFyYW0ge0ZlYXR1cmVDbGFzc30gZmVhdHVyZSBUaGUgZmVhdHVyZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGZlYXR1cmUgaXMgXCJ2YWxpZFwiLCBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBpcyBhbHNvIGFcbiAgICogICAgIGNhbmRpZGF0ZSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlIFJ0cmVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkVG9JbmRleF8oZmVhdHVyZUtleSwgZmVhdHVyZSkge1xuICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgaWYgKGZlYXR1cmUuZ2V0SWQoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpZCA9IFN0cmluZyhmZWF0dXJlLmdldElkKCkpO1xuICAgICAgaWYgKCEoaWQgaW4gdGhpcy5pZEluZGV4XykpIHtcbiAgICAgICAgdGhpcy5pZEluZGV4X1tpZF0gPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIGlmIChmZWF0dXJlIGluc3RhbmNlb2YgUmVuZGVyRmVhdHVyZSkge1xuICAgICAgICBjb25zdCBpbmRleGVkRmVhdHVyZSA9IHRoaXMuaWRJbmRleF9baWRdO1xuICAgICAgICBpZiAoIShpbmRleGVkRmVhdHVyZSBpbnN0YW5jZW9mIFJlbmRlckZlYXR1cmUpKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5kZXhlZEZlYXR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLmlkSW5kZXhfW2lkXSA9IFtpbmRleGVkRmVhdHVyZSwgZmVhdHVyZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ZWRGZWF0dXJlLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsaWQpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgIShmZWF0dXJlS2V5IGluIHRoaXMudWlkSW5kZXhfKSxcbiAgICAgICAgJ1RoZSBwYXNzZWQgYGZlYXR1cmVgIHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBzb3VyY2UnXG4gICAgICApO1xuICAgICAgdGhpcy51aWRJbmRleF9bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgYmF0Y2ggb2YgZmVhdHVyZXMgdG8gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtBcnJheTxGZWF0dXJlQ2xhc3M+fSBmZWF0dXJlcyBGZWF0dXJlcyB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZEZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gICAgdGhpcy5hZGRGZWF0dXJlc0ludGVybmFsKGZlYXR1cmVzKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZmVhdHVyZXMgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAgICogQHBhcmFtIHtBcnJheTxGZWF0dXJlQ2xhc3M+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYWRkRmVhdHVyZXNJbnRlcm5hbChmZWF0dXJlcykge1xuICAgIGNvbnN0IGV4dGVudHMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PEZlYXR1cmVDbGFzcz59ICovXG4gICAgY29uc3QgbmV3RmVhdHVyZXMgPSBbXTtcbiAgICAvKiogQHR5cGUgQXJyYXk8RmVhdHVyZUNsYXNzPiAqL1xuICAgIGNvbnN0IGdlb21ldHJ5RmVhdHVyZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgY29uc3QgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICAgIGlmICh0aGlzLmFkZFRvSW5kZXhfKGZlYXR1cmVLZXksIGZlYXR1cmUpKSB7XG4gICAgICAgIG5ld0ZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG5ld0ZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gbmV3RmVhdHVyZXNbaV07XG4gICAgICBjb25zdCBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgdGhpcy5zZXR1cENoYW5nZUV2ZW50c18oZmVhdHVyZUtleSwgZmVhdHVyZSk7XG5cbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgICAgICBleHRlbnRzLnB1c2goZXh0ZW50KTtcbiAgICAgICAgZ2VvbWV0cnlGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5sb2FkKGV4dGVudHMsIGdlb21ldHJ5RmVhdHVyZXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG5ld0ZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgVmVjdG9yU291cmNlRXZlbnQoVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsIG5ld0ZlYXR1cmVzW2ldKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDb2xsZWN0aW9uPEZlYXR1cmVDbGFzcz59IGNvbGxlY3Rpb24gQ29sbGVjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRGZWF0dXJlc0NvbGxlY3Rpb25fKGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1ZlY3RvclNvdXJjZUV2ZW50PEZlYXR1cmVDbGFzcz59IGV2dCBUaGUgdmVjdG9yIHNvdXJjZSBldmVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmICghbW9kaWZ5aW5nQ29sbGVjdGlvbikge1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChldnQuZmVhdHVyZSk7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBWZWN0b3JFdmVudFR5cGUuUkVNT1ZFRkVBVFVSRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtWZWN0b3JTb3VyY2VFdmVudDxGZWF0dXJlQ2xhc3M+fSBldnQgVGhlIHZlY3RvciBzb3VyY2UgZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb2xsZWN0aW9uLnJlbW92ZShldnQuZmVhdHVyZSk7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBjb2xsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxGZWF0dXJlQ2xhc3M+fSBldnQgVGhlIGNvbGxlY3Rpb24gZXZlbnRcbiAgICAgICAqL1xuICAgICAgKGV2dCkgPT4ge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZXZ0LmVsZW1lbnQpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgY29sbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8RmVhdHVyZUNsYXNzPn0gZXZ0IFRoZSBjb2xsZWN0aW9uIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIChldnQpID0+IHtcbiAgICAgICAgaWYgKCFtb2RpZnlpbmdDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlKGV2dC5lbGVtZW50KTtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXyA9IGNvbGxlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBmZWF0dXJlcyBmcm9tIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zhc3RdIFNraXAgZGlzcGF0Y2hpbmcgb2Yge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I2V2ZW50OnJlbW92ZWZlYXR1cmV9IGV2ZW50cy5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xlYXIoZmFzdCkge1xuICAgIGlmIChmYXN0KSB7XG4gICAgICBmb3IgKGNvbnN0IGZlYXR1cmVJZCBpbiB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzXykge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c19bZmVhdHVyZUlkXTtcbiAgICAgICAga2V5cy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c18gPSB7fTtcbiAgICAgICAgdGhpcy5pZEluZGV4XyA9IHt9O1xuICAgICAgICB0aGlzLnVpZEluZGV4XyA9IHt9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICBjb25zdCByZW1vdmVBbmRJZ25vcmVSZXR1cm4gPSAoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZUludGVybmFsKGZlYXR1cmUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2gocmVtb3ZlQW5kSWdub3JlUmV0dXJuKTtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZUludGVybmFsKHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18gPSB7fTtcblxuICAgIGNvbnN0IGNsZWFyRXZlbnQgPSBuZXcgVmVjdG9yU291cmNlRXZlbnQoVmVjdG9yRXZlbnRUeXBlLkNMRUFSKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xlYXJFdmVudCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyBvbiB0aGUgc291cmNlLCBjYWxsaW5nIHRoZSBwcm92aWRlZCBjYWxsYmFja1xuICAgKiB3aXRoIGVhY2ggb25lLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYW55IFwidHJ1dGh5XCIgdmFsdWUsIGl0ZXJhdGlvbiB3aWxsXG4gICAqIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBvbmx5IGl0ZXJhdGUgdGhyb3VnaCB0aGUgZmVhdHVyZSB0aGF0IGhhdmUgYSBkZWZpbmVkIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEZlYXR1cmVDbGFzcyk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgb24gdGhlIHNvdXJjZS4gIFJldHVybiBhIHRydXRoeSB2YWx1ZSB0byBzdG9wIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBjYWxsYmFjay5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmUoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyaWVzIGNvbnRhaW4gdGhlIHByb3ZpZGVkXG4gICAqIGNvb3JkaW5hdGUsIGNhbGxpbmcgdGhlIGNhbGxiYWNrIHdpdGggZWFjaCBmZWF0dXJlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICogYSBcInRydXRoeVwiIHZhbHVlLCBpdGVyYXRpb24gd2lsbCBzdG9wIGFuZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEZvciB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlflJlbmRlckZlYXR1cmV9IGZlYXR1cmVzLCB0aGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiBjYWxsZWQgZm9yIGFsbCBmZWF0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihGZWF0dXJlQ2xhc3MpOiBUfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoIGZlYXR1cmVcbiAgICogICAgIHdob3NlIGdvZW1ldHJ5IGNvbnRhaW5zIHRoZSBwcm92aWRlZCBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGVEaXJlY3QoY29vcmRpbmF0ZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBleHRlbnQgPSBbY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXV07XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChleHRlbnQsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIGlmIChcbiAgICAgICAgZ2VvbWV0cnkgaW5zdGFuY2VvZiBSZW5kZXJGZWF0dXJlIHx8XG4gICAgICAgIGdlb21ldHJ5LmludGVyc2VjdHNDb29yZGluYXRlKGNvb3JkaW5hdGUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZlYXR1cmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGZlYXR1cmVzIHdob3NlIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZFxuICAgKiBleHRlbnQgKG5vdGUgdGhhdCB0aGUgZmVhdHVyZSdzIGdlb21ldHJ5IG1heSBub3QgaW50ZXJzZWN0IHRoZSBleHRlbnQpLFxuICAgKiBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgXCJ0cnV0aHlcIlxuICAgKiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGwgc3RvcCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgKlxuICAgKiBJZiB5b3UgYXJlIGludGVyZXN0ZWQgaW4gZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyBhbiBleHRlbnQsIGNhbGxcbiAgICogdGhlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZm9yRWFjaEZlYXR1cmVJbnRlcnNlY3RpbmdFeHRlbnQgI2ZvckVhY2hGZWF0dXJlSW50ZXJzZWN0aW5nRXh0ZW50KCl9IG1ldGhvZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBXaGVuIGB1c2VTcGF0aWFsSW5kZXhgIGlzIHNldCB0byBmYWxzZSwgdGhpcyBtZXRob2Qgd2lsbCBsb29wIHRocm91Z2ggYWxsXG4gICAqIGZlYXR1cmVzLCBlcXVpdmFsZW50IHRvIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZm9yRWFjaEZlYXR1cmUgI2ZvckVhY2hGZWF0dXJlKCl9LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRmVhdHVyZUNsYXNzKTogVH0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaCBmZWF0dXJlXG4gICAqICAgICB3aG9zZSBib3VuZGluZyBib3ggaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUluRXh0ZW50KGV4dGVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaEluRXh0ZW50KGV4dGVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LFxuICAgKiBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgXCJ0cnV0aHlcIlxuICAgKiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGwgc3RvcCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgKlxuICAgKiBJZiB5b3Ugb25seSB3YW50IHRvIHRlc3QgZm9yIGJvdW5kaW5nIGJveCBpbnRlcnNlY3Rpb24sIGNhbGwgdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZm9yRWFjaEZlYXR1cmVJbkV4dGVudCAjZm9yRWFjaEZlYXR1cmVJbkV4dGVudCgpfSBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEZlYXR1cmVDbGFzcyk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudChleHRlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChcbiAgICAgIGV4dGVudCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtGZWF0dXJlQ2xhc3N9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZ2VvbWV0cnkgaW5zdGFuY2VvZiBSZW5kZXJGZWF0dXJlIHx8XG4gICAgICAgICAgZ2VvbWV0cnkuaW50ZXJzZWN0c0V4dGVudChleHRlbnQpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKGZlYXR1cmUpO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmVzIGNvbGxlY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLiBXaWxsIGJlIGBudWxsYFxuICAgKiB1bmxlc3MgdGhlIHNvdXJjZSB3YXMgY29uZmlndXJlZCB3aXRoIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLCBvclxuICAgKiB3aXRoIGFuIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBhcyBgZmVhdHVyZXNgLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPEZlYXR1cmVDbGFzcz58bnVsbH0gVGhlIGNvbGxlY3Rpb24gb2YgZmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzQ29sbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNuYXBzaG90IG9mIHRoZSBmZWF0dXJlcyBjdXJyZW50bHkgb24gdGhlIHNvdXJjZSBpbiByYW5kb20gb3JkZXIuIFRoZSByZXR1cm5lZCBhcnJheVxuICAgKiBpcyBhIGNvcHksIHRoZSBmZWF0dXJlcyBhcmUgcmVmZXJlbmNlcyB0byB0aGUgZmVhdHVyZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7QXJyYXk8RmVhdHVyZUNsYXNzPn0gRmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzKCkge1xuICAgIGxldCBmZWF0dXJlcztcbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5nZXRBcnJheSgpLnNsaWNlKDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEFsbCgpO1xuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSkge1xuICAgICAgICBleHRlbmQoZmVhdHVyZXMsIE9iamVjdC52YWx1ZXModGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzQXRDb29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGVEaXJlY3QoY29vcmRpbmF0ZSwgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgd2hvc2UgYm91bmRpbmcgYm94IGludGVyc2VjdHMgdGhlIHByb3ZpZGVkIGV4dGVudC4gIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgICogYWxsIGZlYXR1cmVzIGludGVyc2VjdGluZyB0aGUgZ2l2ZW4gZXh0ZW50IGluIHJhbmRvbSBvcmRlciAoc28gaXQgbWF5IGluY2x1ZGVcbiAgICogZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cmllcyBkbyBub3QgaW50ZXJzZWN0IHRoZSBleHRlbnQpLlxuICAgKlxuICAgKiBXaGVuIGB1c2VTcGF0aWFsSW5kZXhgIGlzIHNldCB0byBmYWxzZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYWxsXG4gICAqIGZlYXR1cmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFtwcm9qZWN0aW9uXSBJbmNsdWRlIGZlYXR1cmVzXG4gICAqIHdoZXJlIGBleHRlbnRgIGV4Y2VlZHMgdGhlIHgtYXhpcyBib3VuZHMgb2YgYHByb2plY3Rpb25gIGFuZCB3cmFwcyBhcm91bmQgdGhlIHdvcmxkLlxuICAgKiBAcmV0dXJuIHtBcnJheTxGZWF0dXJlQ2xhc3M+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmVhdHVyZXNJbkV4dGVudChleHRlbnQsIHByb2plY3Rpb24pIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgY29uc3QgbXVsdGlXb3JsZCA9IHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5jYW5XcmFwWCgpICYmIHRoaXMuZ2V0V3JhcFgoKTtcblxuICAgICAgaWYgKCFtdWx0aVdvcmxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEluRXh0ZW50KGV4dGVudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVudHMgPSB3cmFwQW5kU2xpY2VYKGV4dGVudCwgcHJvamVjdGlvbik7XG5cbiAgICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAgIC4uLmV4dGVudHMubWFwKChhbkV4dGVudCkgPT4gdGhpcy5mZWF0dXJlc1J0cmVlXy5nZXRJbkV4dGVudChhbkV4dGVudCkpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmdldEFycmF5KCkuc2xpY2UoMCk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsb3Nlc3QgZmVhdHVyZSB0byB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gICAqIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgIGFuZCB0aGUgZmVhdHVyZXMgaW4gdGhpcyBzb3VyY2UgYXJlIG9mIHR5cGVcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmV9LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEZlYXR1cmVDbGFzcyk6Ym9vbGVhbn0gW2ZpbHRlcl0gRmVhdHVyZSBmaWx0ZXIgZnVuY3Rpb24uXG4gICAqICAgICBUaGUgZmlsdGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBvbmUgYXJndW1lbnQsIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSBmZWF0dXJlfVxuICAgKiAgICAgYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLiBCeSBkZWZhdWx0LCBubyBmaWx0ZXJpbmcgaXMgbWFkZS5cbiAgICogQHJldHVybiB7RmVhdHVyZUNsYXNzfSBDbG9zZXN0IGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENsb3Nlc3RGZWF0dXJlVG9Db29yZGluYXRlKGNvb3JkaW5hdGUsIGZpbHRlcikge1xuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgZmVhdHVyZSB1c2luZyBicmFuY2ggYW5kIGJvdW5kLiAgV2Ugc3RhcnQgc2VhcmNoaW5nIGFuXG4gICAgLy8gaW5maW5pdGUgZXh0ZW50LCBhbmQgZmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgZmlyc3QgZmVhdHVyZSBmb3VuZC4gIFRoaXNcbiAgICAvLyBiZWNvbWVzIHRoZSBjbG9zZXN0IGZlYXR1cmUuICBXZSB0aGVuIGNvbXB1dGUgYSBzbWFsbGVyIGV4dGVudCB3aGljaCBhbnlcbiAgICAvLyBjbG9zZXIgZmVhdHVyZSBtdXN0IGludGVyc2VjdC4gIFdlIGNvbnRpbnVlIHNlYXJjaGluZyB3aXRoIHRoaXMgc21hbGxlclxuICAgIC8vIGV4dGVudCwgdHJ5aW5nIHRvIGZpbmQgYSBjbG9zZXIgZmVhdHVyZS4gIEV2ZXJ5IHRpbWUgd2UgZmluZCBhIGNsb3NlclxuICAgIC8vIGZlYXR1cmUsIHdlIHVwZGF0ZSB0aGUgZXh0ZW50IGJlaW5nIHNlYXJjaGVkIHNvIHRoYXQgYW55IGV2ZW4gY2xvc2VyXG4gICAgLy8gZmVhdHVyZSBtdXN0IGludGVyc2VjdCBpdC4gIFdlIGNvbnRpbnVlIHVudGlsIHdlIHJ1biBvdXQgb2YgZmVhdHVyZXMuXG4gICAgY29uc3QgeCA9IGNvb3JkaW5hdGVbMF07XG4gICAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gICAgbGV0IGNsb3Nlc3RGZWF0dXJlID0gbnVsbDtcbiAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSBbTmFOLCBOYU5dO1xuICAgIGxldCBtaW5TcXVhcmVkRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBleHRlbnQgPSBbLUluZmluaXR5LCAtSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eV07XG4gICAgZmlsdGVyID0gZmlsdGVyID8gZmlsdGVyIDogVFJVRTtcbiAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2hJbkV4dGVudChcbiAgICAgIGV4dGVudCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtGZWF0dXJlQ2xhc3N9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZpbHRlcihmZWF0dXJlKSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzTWluU3F1YXJlZERpc3RhbmNlID0gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgICAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9XG4gICAgICAgICAgICBnZW9tZXRyeSBpbnN0YW5jZW9mIFJlbmRlckZlYXR1cmVcbiAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgIDogZ2VvbWV0cnkuY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICAgICAgICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBwcmV2aW91c01pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdEZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBzbmVha3kuICBSZWR1Y2UgdGhlIGV4dGVudCB0aGF0IGl0IGlzIGN1cnJlbnRseSBiZWluZ1xuICAgICAgICAgICAgLy8gc2VhcmNoZWQgd2hpbGUgdGhlIFItVHJlZSB0cmF2ZXJzYWwgdXNpbmcgdGhpcyBzYW1lIGV4dGVudCBvYmplY3RcbiAgICAgICAgICAgIC8vIGlzIHN0aWxsIGluIHByb2dyZXNzLiAgVGhpcyBpcyBzYWZlIGJlY2F1c2UgdGhlIG5ldyBleHRlbnQgaXNcbiAgICAgICAgICAgIC8vIHN0cmljdGx5IGNvbnRhaW5lZCBieSB0aGUgb2xkIGV4dGVudC5cbiAgICAgICAgICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pblNxdWFyZWREaXN0YW5jZSk7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSB4IC0gbWluRGlzdGFuY2U7XG4gICAgICAgICAgICBleHRlbnRbMV0gPSB5IC0gbWluRGlzdGFuY2U7XG4gICAgICAgICAgICBleHRlbnRbMl0gPSB4ICsgbWluRGlzdGFuY2U7XG4gICAgICAgICAgICBleHRlbnRbM10gPSB5ICsgbWluRGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY2xvc2VzdEZlYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgb2YgdGhlIGZlYXR1cmVzIGN1cnJlbnRseSBpbiB0aGUgc291cmNlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIHdoZW4gdGhlIHNvdXJjZSBpcyBjb25maWd1cmVkIHdpdGhcbiAgICogYHVzZVNwYXRpYWxJbmRleGAgc2V0IHRvIGBmYWxzZWAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRGVzdGluYXRpb24gZXh0ZW50LiBJZiBwcm92aWRlZCwgbm8gbmV3IGV4dGVudFxuICAgKiAgICAgd2lsbCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGF0IGV4dGVudCdzIGNvb3JkaW5hdGVzIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEV4dGVudChleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGZlYXR1cmUgYnkgaXRzIGlkZW50aWZpZXIgKHRoZSB2YWx1ZSByZXR1cm5lZCBieSBmZWF0dXJlLmdldElkKCkpLiBXaGVuIGBSZW5kZXJGZWF0dXJlYHNcbiAgICogYXJlIHVzZWQsIGBnZXRGZWF0dXJlQnlJZCgpYCBjYW4gcmV0dXJuIGFuIGFycmF5IG9mIGBSZW5kZXJGZWF0dXJlYHMuIFRoaXMgYWxsb3dzIGZvciBoYW5kbGluZ1xuICAgKiBvZiBgR2VvbWV0cnlDb2xsZWN0aW9uYCBnZW9tZXRyaWVzLCB3aGVyZSBmb3JtYXQgcmVhZGVycyBjcmVhdGUgb25lIGBSZW5kZXJGZWF0dXJlYCBwZXJcbiAgICogYEdlb21ldHJ5Q29sbGVjdGlvbmAgbWVtYmVyLlxuICAgKiBOb3RlIHRoYXQgdGhlIGluZGV4IHRyZWF0cyBzdHJpbmcgYW5kIG51bWVyaWMgaWRlbnRpZmllcnMgYXMgdGhlIHNhbWUuICBTb1xuICAgKiBgc291cmNlLmdldEZlYXR1cmVCeUlkKDIpYCB3aWxsIHJldHVybiBhIGZlYXR1cmUgd2l0aCBpZCBgJzInYCBvciBgMmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgRmVhdHVyZSBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtGZWF0dXJlQ2xhc3N8QXJyYXk8UmVuZGVyRmVhdHVyZT58bnVsbH0gVGhlIGZlYXR1cmUgKG9yIGBudWxsYCBpZiBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlQnlJZChpZCkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIHJldHVybiBmZWF0dXJlICE9PSB1bmRlZmluZWQgPyBmZWF0dXJlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBmZWF0dXJlIGJ5IGl0cyBpbnRlcm5hbCB1bmlxdWUgaWRlbnRpZmllciAodXNpbmcgYGdldFVpZGApLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIEZlYXR1cmUgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7RmVhdHVyZUNsYXNzfG51bGx9IFRoZSBmZWF0dXJlIChvciBgbnVsbGAgaWYgbm90IGZvdW5kKS5cbiAgICovXG4gIGdldEZlYXR1cmVCeVVpZCh1aWQpIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy51aWRJbmRleF9bdWlkXTtcbiAgICByZXR1cm4gZmVhdHVyZSAhPT0gdW5kZWZpbmVkID8gZmVhdHVyZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmb3JtYXQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIGZlYXR1cmUgZm9ybWF0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc291cmNlIGNhbiBoYXZlIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMuXG4gICAqL1xuICBnZXRPdmVybGFwcygpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGFwc187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1cmwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8aW1wb3J0KFwiLi4vZmVhdHVyZWxvYWRlci5qc1wiKS5GZWF0dXJlVXJsRnVuY3Rpb258dW5kZWZpbmVkfSBUaGUgdXJsLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUZlYXR1cmVDaGFuZ2VfKGV2ZW50KSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IC8qKiBAdHlwZSB7RmVhdHVyZUNsYXNzfSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmICghZ2VvbWV0cnkpIHtcbiAgICAgIGlmICghKGZlYXR1cmVLZXkgaW4gdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pKSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5yZW1vdmUoZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICAgIGlmIChmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XTtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmluc2VydChleHRlbnQsIGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8udXBkYXRlKGV4dGVudCwgZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHNpZCA9IGlkLnRvU3RyaW5nKCk7XG4gICAgICBpZiAodGhpcy5pZEluZGV4X1tzaWRdICE9PSBmZWF0dXJlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUlkSW5kZXhfKGZlYXR1cmUpO1xuICAgICAgICB0aGlzLmlkSW5kZXhfW3NpZF0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUZyb21JZEluZGV4XyhmZWF0dXJlKTtcbiAgICAgIHRoaXMudWlkSW5kZXhfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IFZlY3RvclNvdXJjZUV2ZW50KFZlY3RvckV2ZW50VHlwZS5DSEFOR0VGRUFUVVJFLCBmZWF0dXJlKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtGZWF0dXJlQ2xhc3N9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGhhc0ZlYXR1cmUoZmVhdHVyZSkge1xuICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaWQgaW4gdGhpcy5pZEluZGV4XztcbiAgICB9XG4gICAgcmV0dXJuIGdldFVpZChmZWF0dXJlKSBpbiB0aGlzLnVpZEluZGV4XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uaXNFbXB0eSgpICYmIGlzRW1wdHkodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmdldExlbmd0aCgpID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICovXG4gIGxvYWRGZWF0dXJlcyhleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIHtcbiAgICBjb25zdCBsb2FkZWRFeHRlbnRzUnRyZWUgPSB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV87XG4gICAgY29uc3QgZXh0ZW50c1RvTG9hZCA9IHRoaXMuc3RyYXRlZ3lfKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZXh0ZW50c1RvTG9hZC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBleHRlbnRUb0xvYWQgPSBleHRlbnRzVG9Mb2FkW2ldO1xuICAgICAgY29uc3QgYWxyZWFkeUxvYWRlZCA9IGxvYWRlZEV4dGVudHNSdHJlZS5mb3JFYWNoSW5FeHRlbnQoXG4gICAgICAgIGV4dGVudFRvTG9hZCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7e2V4dGVudDogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH19IG9iamVjdCBPYmplY3QuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluc0V4dGVudChvYmplY3QuZXh0ZW50LCBleHRlbnRUb0xvYWQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKCFhbHJlYWR5TG9hZGVkKSB7XG4gICAgICAgICsrdGhpcy5sb2FkaW5nRXh0ZW50c0NvdW50XztcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuRkVBVFVSRVNMT0FEU1RBUlQpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9hZGVyXy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgZXh0ZW50VG9Mb2FkLFxuICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgcHJvamVjdGlvbixcbiAgICAgICAgICAoZmVhdHVyZXMpID0+IHtcbiAgICAgICAgICAgIC0tdGhpcy5sb2FkaW5nRXh0ZW50c0NvdW50XztcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgbmV3IFZlY3RvclNvdXJjZUV2ZW50KFxuICAgICAgICAgICAgICAgIFZlY3RvckV2ZW50VHlwZS5GRUFUVVJFU0xPQURFTkQsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAtLXRoaXMubG9hZGluZ0V4dGVudHNDb3VudF87XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgIG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuRkVBVFVSRVNMT0FERVJST1IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgbG9hZGVkRXh0ZW50c1J0cmVlLmluc2VydChleHRlbnRUb0xvYWQsIHtleHRlbnQ6IGV4dGVudFRvTG9hZC5zbGljZSgpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGluZyA9XG4gICAgICB0aGlzLmxvYWRlcl8ubGVuZ3RoIDwgNCA/IGZhbHNlIDogdGhpcy5sb2FkaW5nRXh0ZW50c0NvdW50XyA+IDA7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2xlYXIodHJ1ZSk7XG4gICAgdGhpcy5sb2FkZWRFeHRlbnRzUnRyZWVfLmNsZWFyKCk7XG4gICAgc3VwZXIucmVmcmVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBleHRlbnQgZnJvbSB0aGUgbGlzdCBvZiBsb2FkZWQgZXh0ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVMb2FkZWRFeHRlbnQoZXh0ZW50KSB7XG4gICAgY29uc3QgbG9hZGVkRXh0ZW50c1J0cmVlID0gdGhpcy5sb2FkZWRFeHRlbnRzUnRyZWVfO1xuICAgIGxldCBvYmo7XG4gICAgbG9hZGVkRXh0ZW50c1J0cmVlLmZvckVhY2hJbkV4dGVudChleHRlbnQsIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChlcXVhbHMob2JqZWN0LmV4dGVudCwgZXh0ZW50KSkge1xuICAgICAgICBvYmogPSBvYmplY3Q7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvYmopIHtcbiAgICAgIGxvYWRlZEV4dGVudHNSdHJlZS5yZW1vdmUob2JqKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgc2luZ2xlIGZlYXR1cmUgZnJvbSB0aGUgc291cmNlLiAgSWYgeW91IHdhbnQgdG8gcmVtb3ZlIGFsbCBmZWF0dXJlc1xuICAgKiBhdCBvbmNlLCB1c2UgdGhlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjY2xlYXIgI2NsZWFyKCl9IG1ldGhvZFxuICAgKiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0ZlYXR1cmVDbGFzc30gZmVhdHVyZSBGZWF0dXJlIHRvIHJlbW92ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlRmVhdHVyZShmZWF0dXJlKSB7XG4gICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgaWYgKGZlYXR1cmVLZXkgaW4gdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5yZW1vdmUoZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVtb3ZlRmVhdHVyZUludGVybmFsKGZlYXR1cmUpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZmVhdHVyZSB3aXRob3V0IGZpcmluZyBhIGBjaGFuZ2VgIGV2ZW50LlxuICAgKiBAcGFyYW0ge0ZlYXR1cmVDbGFzc30gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtGZWF0dXJlQ2xhc3N8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBmZWF0dXJlXG4gICAqICAgICAob3IgdW5kZWZpbmVkIGlmIHRoZSBmZWF0dXJlIHdhcyBub3QgZm91bmQpLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZW1vdmVGZWF0dXJlSW50ZXJuYWwoZmVhdHVyZSkge1xuICAgIGNvbnN0IGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgY29uc3QgZmVhdHVyZUNoYW5nZUtleXMgPSB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XTtcbiAgICBpZiAoIWZlYXR1cmVDaGFuZ2VLZXlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZlYXR1cmVDaGFuZ2VLZXlzLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgZGVsZXRlIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfW2ZlYXR1cmVLZXldO1xuICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgdGhpcy5pZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMudWlkSW5kZXhfW2ZlYXR1cmVLZXldO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuUkVNT1ZFRkVBVFVSRSwgZmVhdHVyZSlcbiAgICApO1xuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZlYXR1cmUgZnJvbSB0aGUgaWQgaW5kZXguICBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBmZWF0dXJlIGlkXG4gICAqIG1heSBoYXZlIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7RmVhdHVyZUNsYXNzfSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZW1vdmVkIHRoZSBmZWF0dXJlIGZyb20gdGhlIGluZGV4LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlRnJvbUlkSW5kZXhfKGZlYXR1cmUpIHtcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5pZEluZGV4Xykge1xuICAgICAgY29uc3QgaW5kZXhlZEZlYXR1cmUgPSB0aGlzLmlkSW5kZXhfW2lkXTtcbiAgICAgIGlmIChcbiAgICAgICAgZmVhdHVyZSBpbnN0YW5jZW9mIFJlbmRlckZlYXR1cmUgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShpbmRleGVkRmVhdHVyZSkgJiZcbiAgICAgICAgaW5kZXhlZEZlYXR1cmUuaW5jbHVkZXMoZmVhdHVyZSlcbiAgICAgICkge1xuICAgICAgICBpbmRleGVkRmVhdHVyZS5zcGxpY2UoaW5kZXhlZEZlYXR1cmUuaW5kZXhPZihmZWF0dXJlKSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaWRJbmRleF9baWRdID09PSBmZWF0dXJlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlkSW5kZXhfW2lkXTtcbiAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG5ldyBsb2FkZXIgb2YgdGhlIHNvdXJjZS4gVGhlIG5leHQgcmVuZGVyIGN5Y2xlIHdpbGwgdXNlIHRoZVxuICAgKiBuZXcgbG9hZGVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZUxvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgdG8gc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMb2FkZXIobG9hZGVyKSB7XG4gICAgdGhpcy5sb2FkZXJfID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvaW50cyB0aGUgc291cmNlIHRvIGEgbmV3IHVybC4gVGhlIG5leHQgcmVuZGVyIGN5Y2xlIHdpbGwgdXNlIHRoZSBuZXcgdXJsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVVcmxGdW5jdGlvbn0gdXJsIFVybC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VXJsKHVybCkge1xuICAgIGFzc2VydCh0aGlzLmZvcm1hdF8sICdgZm9ybWF0YCBtdXN0IGJlIHNldCB3aGVuIGB1cmxgIGlzIHNldCcpO1xuICAgIHRoaXMudXJsXyA9IHVybDtcbiAgICB0aGlzLnNldExvYWRlcih4aHIodXJsLCB0aGlzLmZvcm1hdF8pKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JTb3VyY2U7XG4iLCAiaW1wb3J0ICogYXMgX1ZBUlNfIGZyb20gJy4vdmFycy5qc29uJztcblxuZXhwb3J0IGNvbnN0IFZBUlMgPSBfVkFSU187XG5cbmV4cG9ydCBjb25zdCBFVkVOVF9UWVBFID0ge1xuICBBRERSRVNTQ0hPU0VOOiAnYWRkcmVzc2Nob3NlbicsXG59O1xuXG5leHBvcnQgY29uc3QgQ09OVFJPTF9UWVBFID0ge1xuICBOT01JTkFUSU06ICdub21pbmF0aW0nLFxuICBSRVZFUlNFOiAncmV2ZXJzZScsXG59O1xuXG5leHBvcnQgY29uc3QgVEFSR0VUX1RZUEUgPSB7XG4gIEdMQVNTOiAnZ2xhc3MtYnV0dG9uJyxcbiAgSU5QVVQ6ICd0ZXh0LWlucHV0Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBGRUFUVVJFX1NSQyA9ICcvL2Nkbi5yYXdnaXQuY29tL2pvbmF0YXN3YWxrZXIvbWFwLXV0aWxzL21hc3Rlci9pbWFnZXMvbWFya2VyLnBuZyc7XG5cbmV4cG9ydCBjb25zdCBQUk9WSURFUlMgPSB7XG4gIE9TTTogJ29zbScsXG4gIE1BUFFVRVNUOiAnbWFwcXVlc3QnLFxuICBQSE9UT046ICdwaG90b24nLFxuICBCSU5HOiAnYmluZycsXG4gIE9QRU5DQUdFOiAnb3BlbmNhZ2UnLFxufTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcHJvdmlkZXI6IFBST1ZJREVSUy5PU00sXG4gIGxhYmVsOiAnJyxcbiAgcGxhY2Vob2xkZXI6ICdTZWFyY2ggZm9yIGFuIGFkZHJlc3MnLFxuICBmZWF0dXJlU3R5bGU6IG51bGwsXG4gIHRhcmdldFR5cGU6IFRBUkdFVF9UWVBFLkdMQVNTLFxuICBsYW5nOiAnZW4tVVMnLFxuICBsaW1pdDogNSxcbiAga2VlcE9wZW46IGZhbHNlLFxuICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gIHByZXZlbnRQYW5uaW5nOiBmYWxzZSxcbiAgcHJldmVudE1hcmtlcjogZmFsc2UsXG4gIGRlZmF1bHRGbHlSZXNvbHV0aW9uOiAxMCwgLy8gTWV0ZXJzIHBlciBwaXhlbFxuICBkZWJ1ZzogZmFsc2UsXG59OyIsICJleHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkJykge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIGlmICh0eXBlb2YgRXJyb3IgIT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cbiAgICB0aHJvdyBtZXNzYWdlOyAvLyBGYWxsYmFja1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIC8vIFBvbHlmaWxsIGZvciB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgLy8gQGxpY2Vuc2UgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICAvLyBjb3B5cmlnaHQgUGF1bCBJcmlzaCAyMDE1XG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81NDM4NjUwXG4gIGlmICgncGVyZm9ybWFuY2UnIGluIHdpbmRvdyA9PT0gZmFsc2UpIHtcbiAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcbiAgfVxuXG4gIGlmICgnbm93JyBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT09IGZhbHNlKSB7XG4gICAgbGV0IG5vd09mZnNldCA9IERhdGUubm93KCk7XG5cbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9ICgpID0+IERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSWQocHJlZml4KSB7XG4gIGNvbnN0IGlkID0gbm93KCkudG9TdHJpbmcoMzYpO1xuXG4gIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1lcmljKHN0cikge1xuICByZXR1cm4gL15cXGQrJC91LnRlc3Qoc3RyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoc3RyKSB7XG4gIHJldHVybiAhc3RyIHx8IHN0ci5sZW5ndGggPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUFycmF5KGFycmF5KSB7XG4gIHdoaWxlIChhcnJheS5sZW5ndGgpIGFycmF5LnBvcCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW55TWF0Y2hJbkFycmF5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiBzb3VyY2Uuc29tZSgoZWFjaCkgPT4gdGFyZ2V0LmluY2x1ZGVzKGVhY2gpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZXJ5TWF0Y2hJbkFycmF5KGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGFycjIuZXZlcnkoKGVhY2gpID0+IGFycjEuaW5jbHVkZXMoZWFjaCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW55SXRlbUhhc1ZhbHVlKG9iaiwgaGFzID0gZmFsc2UpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIWlzRW1wdHkob2JqW2tleV0pKSBoYXMgPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzO1xufSIsICIvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItbmFtZWQtY2FwdHVyZS1ncm91cCAqL1xuaW1wb3J0IHtcbiAgaXNOdW1lcmljXG59IGZyb20gJy4vbWl4JztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXk8RWxlbWVudD59IGVsZW1lbnQgRE9NIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxTdHJpbmc+fSBjbGFzc25hbWUgQ2xhc3Mgb3IgYXJyYXkgb2YgY2xhc3Nlcy5cbiAqIEZvciBleGFtcGxlOiAnY2xhc3MxIGNsYXNzMicgb3IgWydjbGFzczEnLCAnY2xhc3MyJ11cbiAqIEBwYXJhbSB7TnVtYmVyfHVuZGVmaW5lZH0gdGltZW91dCBUaW1lb3V0IHRvIHJlbW92ZSBhIGNsYXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lLCB0aW1lb3V0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudC5mb3JFYWNoKChlYWNoKSA9PiBhZGRDbGFzcyhlYWNoLCBjbGFzc25hbWUpKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheShjbGFzc25hbWUpID8gY2xhc3NuYW1lIDogY2xhc3NuYW1lLnNwbGl0KC9cXHMrL3UpO1xuXG4gIGxldCBpID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGFycmF5W2ldKSkge1xuICAgICAgX2FkZENsYXNzKGVsZW1lbnQsIGFycmF5W2ldLCB0aW1lb3V0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXk8RWxlbWVudD59IGVsZW1lbnQgRE9NIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxTdHJpbmc+fSBjbGFzc25hbWUgQ2xhc3Mgb3IgYXJyYXkgb2YgY2xhc3Nlcy5cbiAqIEZvciBleGFtcGxlOiAnY2xhc3MxIGNsYXNzMicgb3IgWydjbGFzczEnLCAnY2xhc3MyJ11cbiAqIEBwYXJhbSB7TnVtYmVyfHVuZGVmaW5lZH0gdGltZW91dCBUaW1lb3V0IHRvIGFkZCBhIGNsYXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lLCB0aW1lb3V0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudC5mb3JFYWNoKChlYWNoKSA9PiByZW1vdmVDbGFzcyhlYWNoLCBjbGFzc25hbWUsIHRpbWVvdXQpKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheShjbGFzc25hbWUpID8gY2xhc3NuYW1lIDogY2xhc3NuYW1lLnNwbGl0KC9cXHMrL3UpO1xuXG4gIGxldCBpID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoaGFzQ2xhc3MoZWxlbWVudCwgYXJyYXlbaV0pKSB7XG4gICAgICBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgYXJyYXlbaV0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBET00gbm9kZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc25hbWUgQ2xhc3NuYW1lLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGMpIHtcbiAgLy8gdXNlIG5hdGl2ZSBpZiBhdmFpbGFibGVcbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0ID8gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYykgOiBjbGFzc1JlZ2V4KGMpLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheTxFbGVtZW50Pn0gZWxlbWVudCBET00gbm9kZSBvciBhcnJheSBvZiBub2Rlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc25hbWUgQ2xhc3NlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudC5mb3JFYWNoKChlYWNoKSA9PiB0b2dnbGVDbGFzcyhlYWNoLCBjbGFzc25hbWUpKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHVzZSBuYXRpdmUgaWYgYXZhaWxhYmxlXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc25hbWUpO1xuICB9IGVsc2Uge1xuICAgIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzbmFtZSkgPyBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NuYW1lKSA6IF9hZGRDbGFzcyhlbGVtZW50LCBjbGFzc25hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gdG8gcXVlcnlTZWxlY3RvckFsbCBmb3IgaW5jcmVhc2VkXG4gKiBwZXJmb3JtYW5jZSBhbmQgZ3JlYXRlciB1c2FiaWxpdHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0IChvcHRpb25hbClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluZEFsbCAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIChmaW5kQWxsKSB7RWxlbWVudH0gOiB7QXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkKGlkKSB7XG4gIGlkID0gaWRbMF0gPT09ICcjJyA/IGlkLnNsaWNlKDEsIDEgKyBpZC5sZW5ndGgpIDogaWQ7XG5cbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgLy8gRE9NLCBMZXZlbDJcbiAgaWYgKCdIVE1MRWxlbWVudCcgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuICEhb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9XG5cbiAgLy8gT2xkZXIgYnJvd3NlcnNcbiAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5ub2RlVHlwZSA9PT0gMSAmJiAhIW9iai5ub2RlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKG5vZGUsIHRhZykge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsQ2hpbGRyZW4obm9kZSkge1xuICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSBub2RlLmZpcnN0Q2hpbGQucmVtb3ZlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoY29sbGVjdGlvbikge1xuICBsZXQgbm9kZTtcblxuICB3aGlsZSAoKG5vZGUgPSBjb2xsZWN0aW9uWzBdKSkgbm9kZS5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHRhZykge1xuICByZXR1cm4gW10uZmlsdGVyLmNhbGwobm9kZS5jaGlsZE5vZGVzLCAoZWwpID0+XG4gICAgdGFnID8gZWwubm9kZVR5cGUgPT09IDEgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcgOiBlbC5ub2RlVHlwZSA9PT0gMVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoaHRtbCwgcm93KSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoL1xce1xccyooW1xcdy1dKylcXHMqXFx9L2d1LCAoaHRtLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvd1trZXldID09PSB1bmRlZmluZWQgPyAnJyA6IHJvd1trZXldO1xuXG4gICAgcmV0dXJuIGh0bWxFc2NhcGUodmFsdWUpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh0bWxFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKVxuICAgIC5yZXBsYWNlQWxsKCcmJywgJyZhbXA7JylcbiAgICAucmVwbGFjZUFsbCgnPCcsICcmbHQ7JylcbiAgICAucmVwbGFjZUFsbCgnPicsICcmZ3Q7JylcbiAgICAucmVwbGFjZUFsbCgnXCInLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZUFsbChcIidcIiwgJyYjMDM5OycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudChub2RlLCBodG1sKSB7XG4gIGxldCBlbGVtO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZVswXSk7XG5cbiAgICBpZiAobm9kZVsxXS5pZCkgZWxlbS5pZCA9IG5vZGVbMV0uaWQ7XG5cbiAgICBpZiAobm9kZVsxXS5jbGFzc25hbWUpIGVsZW0uY2xhc3NOYW1lID0gbm9kZVsxXS5jbGFzc25hbWU7XG5cbiAgICBpZiAobm9kZVsxXS5hdHRyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dHJcbiAgICAgIH0gPSBub2RlWzFdO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSkge1xuICAgICAgICBsZXQgaSA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK2kgPCBhdHRyLmxlbmd0aCkge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGF0dHJbaV0ubmFtZSwgYXR0cltpXS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGUpO1xuICB9XG5cbiAgZWxlbS5pbm5lckhUTUwgPSBodG1sO1xuXG4gIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgd2hpbGUgKGVsZW0uY2hpbGROb2Rlc1swXSkgZnJhZy5hcHBlbmQoZWxlbS5jaGlsZE5vZGVzWzBdKTtcblxuICBlbGVtLmFwcGVuZChmcmFnKTtcblxuICByZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xhc3NSZWdleChjbGFzc25hbWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYChefFxcXFxzKykgJHtjbGFzc25hbWV9IChcXFxccyt8JClgLCAndScpO1xufVxuXG5mdW5jdGlvbiBfYWRkQ2xhc3MoZWwsIGtsYXNzLCB0aW1lb3V0KSB7XG4gIC8vIHVzZSBuYXRpdmUgaWYgYXZhaWxhYmxlXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGtsYXNzKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSBgJHtlbC5jbGFzc05hbWV9ICR7a2xhc3N9YC50cmltKCk7XG4gIH1cblxuICBpZiAodGltZW91dCAmJiBpc051bWVyaWModGltZW91dCkpIHtcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBfcmVtb3ZlQ2xhc3MoZWwsIGtsYXNzKSwgdGltZW91dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3JlbW92ZUNsYXNzKGVsLCBrbGFzcywgdGltZW91dCkge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShrbGFzcyk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UoY2xhc3NSZWdleChrbGFzcyksICcgJykudHJpbSgpO1xuICB9XG5cbiAgaWYgKHRpbWVvdXQgJiYgaXNOdW1lcmljKHRpbWVvdXQpKSB7XG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gX2FkZENsYXNzKGVsLCBrbGFzcyksIHRpbWVvdXQpO1xuICB9XG59IiwgImltcG9ydCB7XG4gIFZBUlMsXG4gIFRBUkdFVF9UWVBFXG59IGZyb20gJy4uL2tvbnN0YW50cyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnRcbn0gZnJvbSAnLi9oZWxwZXJzL2RvbSc7XG5cbmNvbnN0IGtsYXNzZXMgPSBWQVJTLmNzc0NsYXNzZXM7XG5cbi8qKlxuICogQGNsYXNzIEh0bWxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSHRtbCB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZWxzID0gdGhpcy5jcmVhdGVDb250cm9sKCk7XG4gIH1cblxuICBjcmVhdGVDb250cm9sKCkge1xuICAgIGxldCBjb250YWluZXI7XG4gICAgbGV0IGNvbnRhaW5lckNsYXNzO1xuICAgIGxldCBlbGVtZW50cztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0VHlwZSA9PT0gVEFSR0VUX1RZUEUuSU5QVVQpIHtcbiAgICAgIGNvbnRhaW5lckNsYXNzID0gYCR7a2xhc3Nlcy5uYW1lc3BhY2V9ICR7a2xhc3Nlcy5pbnB1dFRleHQuY29udGFpbmVyfWA7XG4gICAgICBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFxuICAgICAgICBbJ2RpdicsIHtcbiAgICAgICAgICBpZDogVkFSUy5jb250YWluZXJJZCxcbiAgICAgICAgICBjbGFzc25hbWU6IGNvbnRhaW5lckNsYXNzXG4gICAgICAgIH1dLFxuICAgICAgICBIdG1sLmlucHV0XG4gICAgICApO1xuICAgICAgZWxlbWVudHMgPSB7XG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgY29udHJvbDogY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC4ke2tsYXNzZXMuaW5wdXRUZXh0LmNvbnRyb2x9YCksXG4gICAgICAgIGxhYmVsOiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgLiR7a2xhc3Nlcy5pbnB1dFRleHQubGFiZWx9YCksXG4gICAgICAgIGlucHV0OiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgLiR7a2xhc3Nlcy5pbnB1dFRleHQuaW5wdXR9YCksXG4gICAgICAgIHNlYXJjaDogY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC4ke2tsYXNzZXMuaW5wdXRUZXh0LnNlYXJjaH1gKSxcbiAgICAgICAgcmVzdWx0OiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgLiR7a2xhc3Nlcy5pbnB1dFRleHQucmVzdWx0fWApLFxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRzLmxhYmVsLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5sYWJlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyQ2xhc3MgPSBgJHtrbGFzc2VzLm5hbWVzcGFjZX0gJHtrbGFzc2VzLmdsYXNzLmNvbnRhaW5lcn1gO1xuICAgICAgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcbiAgICAgICAgWydkaXYnLCB7XG4gICAgICAgICAgaWQ6IFZBUlMuY29udGFpbmVySWQsXG4gICAgICAgICAgY2xhc3NuYW1lOiBjb250YWluZXJDbGFzc1xuICAgICAgICB9XSxcbiAgICAgICAgSHRtbC5nbGFzc1xuICAgICAgKTtcbiAgICAgIGVsZW1lbnRzID0ge1xuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGNvbnRyb2w6IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHtrbGFzc2VzLmdsYXNzLmNvbnRyb2x9YCksXG4gICAgICAgIGJ1dHRvbjogY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC4ke2tsYXNzZXMuZ2xhc3MuYnV0dG9ufWApLFxuICAgICAgICBpbnB1dDogY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC4ke2tsYXNzZXMuZ2xhc3MuaW5wdXR9YCksXG4gICAgICAgIHNlYXJjaDogY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC4ke2tsYXNzZXMuZ2xhc3Muc2VhcmNofWApLFxuICAgICAgICByZXN1bHQ6IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHtrbGFzc2VzLmdsYXNzLnJlc3VsdH1gKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gc2V0IHBsYWNlaG9sZGVyIGZyb20gb3B0aW9uc1xuICAgIGVsZW1lbnRzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyO1xuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9XG59XG5cbkh0bWwuZ2xhc3MgPSBgXG4gIDxkaXYgY2xhc3M9XCIke2tsYXNzZXMuZ2xhc3MuY29udHJvbH0gJHtrbGFzc2VzLm9sQ29udHJvbH1cIj5cbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD1cIiR7VkFSUy5idXR0b25Db250cm9sSWR9XCIgY2xhc3M9XCIke2tsYXNzZXMuZ2xhc3MuYnV0dG9ufVwiPjwvYnV0dG9uPlxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiJHtWQVJTLmlucHV0UXVlcnlJZH1cIiBjbGFzcz1cIiR7a2xhc3Nlcy5nbGFzcy5pbnB1dH1cIiBhdXRvY29tcGxldGU9XCJvZmZcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaCAuLi5cIj5cbiAgICA8YSBpZD1cIiR7VkFSUy5pbnB1dFNlYXJjaElkfVwiIGNsYXNzPVwiJHtrbGFzc2VzLmdsYXNzLnNlYXJjaH0gJHtrbGFzc2VzLmhpZGRlbn1cIj48L2E+XG4gIDwvZGl2PlxuICA8dWwgY2xhc3M9XCIke2tsYXNzZXMuZ2xhc3MucmVzdWx0fVwiPjwvdWw+XG5gO1xuXG5IdG1sLmlucHV0ID0gYFxuICA8ZGl2IGNsYXNzPVwiJHtrbGFzc2VzLmlucHV0VGV4dC5jb250cm9sfVwiPlxuICAgIDxsYWJlbCB0eXBlPVwiYnV0dG9uXCIgaWQ9XCIke1ZBUlMuaW5wdXRTZWFyY2hJZH1cIiBjbGFzcz1cIiR7a2xhc3Nlcy5pbnB1dFRleHQubGFiZWx9XCI+PC9sYWJlbD5cbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cIiR7VkFSUy5pbnB1dFF1ZXJ5SWR9XCIgY2xhc3M9XCIke2tsYXNzZXMuaW5wdXRUZXh0LmlucHV0fVwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoIC4uLlwiPlxuICAgIDxzcGFuIGNsYXNzPVwiJHtrbGFzc2VzLmlucHV0VGV4dC5pY29ufVwiPjwvc3Bhbj5cbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD1cIiR7VkFSUy5pbnB1dFNlYXJjaElkfVwiIGNsYXNzPVwiJHtrbGFzc2VzLmlucHV0VGV4dC5zZWFyY2h9ICR7a2xhc3Nlcy5oaWRkZW59XCI+PC9idXR0b24+XG4gIDwvZGl2PlxuICA8dWwgY2xhc3M9XCIke2tsYXNzZXMuaW5wdXRUZXh0LnJlc3VsdH1cIj48L3VsPlxuYDsiLCAiZXhwb3J0IGZ1bmN0aW9uIGpzb24ob2JqKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgdXJsID0gZW5jb2RlVXJsWGhyKG9iai51cmwsIG9iai5kYXRhKTtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgfTtcblxuICAgIGlmIChvYmouanNvbnApIHtcbiAgICAgIGpzb25wKHVybCwgb2JqLmNhbGxiYWNrTmFtZSwgcmVzb2x2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZldGNoKHVybCwgY29uZmlnKVxuICAgICAgICAudGhlbigocikgPT4gci5qc29uKCkpXG4gICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgLnJlZHVjZSgoYWNjLCBrKSA9PiB7XG4gICAgICBhY2MucHVzaChcbiAgICAgICAgdHlwZW9mIG9ialtrXSA9PT0gJ29iamVjdCcgP1xuICAgICAgICB0b1F1ZXJ5U3RyaW5nKG9ialtrXSkgOlxuICAgICAgICBgJHtlbmNvZGVVUklDb21wb25lbnQoayl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrXSl9YFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgICAuam9pbignJicpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVVcmxYaHIodXJsLCBkYXRhKSB7XG4gIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIHVybCArPSAoL1xcPy91LnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyB0b1F1ZXJ5U3RyaW5nKGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZnVuY3Rpb24ganNvbnAodXJsLCBrZXksIGNhbGxiYWNrKSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GcmVzaGV5ZWJhbGwvbWljcm8tanNvbnAvYmxvYi9tYXN0ZXIvc3JjL2pzb25wLmpzXG4gIGNvbnN0IHtcbiAgICBoZWFkXG4gIH0gPSBkb2N1bWVudDtcbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIC8vIGdlbmVyYXRlIG1pbmltYWxseSB1bmlxdWUgbmFtZSBmb3IgY2FsbGJhY2sgZnVuY3Rpb25cbiAgY29uc3QgY2FsbGJhY2tOYW1lID0gYGYke01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIERhdGUubm93KCkpfWA7XG5cbiAgLy8gc2V0IHJlcXVlc3QgdXJsXG4gIHNjcmlwdC5zZXRBdHRyaWJ1dGUoXG4gICAgJ3NyYycsXG4gICAgLy8gYWRkIGNhbGxiYWNrIHBhcmFtZXRlciB0byB0aGUgdXJsXG4gICAgLy8gICAgd2hlcmUga2V5IGlzIHRoZSBwYXJhbWV0ZXIga2V5IHN1cHBsaWVkXG4gICAgLy8gICAgYW5kIGNhbGxiYWNrTmFtZSBpcyB0aGUgcGFyYW1ldGVyIHZhbHVlXG4gICAgYCR7dXJsICsgKHVybC5pbmRleE9mKCc/JykgPiAwID8gJyYnIDogJz8nKSArIGtleX09JHtjYWxsYmFja05hbWV9YFxuICApO1xuXG4gIC8vIHBsYWNlIGpzb25wIGNhbGxiYWNrIG9uIHdpbmRvdyxcbiAgLy8gIHRoZSBzY3JpcHQgc2VudCBieSB0aGUgc2VydmVyIHNob3VsZCBjYWxsIHRoaXNcbiAgLy8gIGZ1bmN0aW9uIGFzIGl0IHdhcyBwYXNzZWQgYXMgYSB1cmwgcGFyYW1ldGVyXG4gIHdpbmRvd1tjYWxsYmFja05hbWVdID0gKGRhdGEpID0+IHtcbiAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IHVuZGVmaW5lZDtcblxuICAgIC8vIGNsZWFuIHVwIHNjcmlwdCB0YWcgY3JlYXRlZCBmb3IgcmVxdWVzdFxuICAgIHNldFRpbWVvdXQoKCkgPT4gaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpLCAwKTtcblxuICAgIC8vIGhhbmQgZGF0YSBiYWNrIHRvIHRoZSB1c2VyXG4gICAgY2FsbGJhY2soZGF0YSk7XG4gIH07XG5cbiAgLy8gYWN0dWFsbHkgbWFrZSB0aGUgcmVxdWVzdFxuICBoZWFkLmFwcGVuZChzY3JpcHQpO1xufSIsICIvKipcbiAqIEBjbGFzcyBQaG90b25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGhvdG9uIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIHVybDogJ2h0dHBzOi8vcGhvdG9uLmtvbW9vdC5pby9hcGkvJyxcblxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHE6ICcnLFxuICAgICAgICBsaW1pdDogMTAsXG4gICAgICAgIGxhbmc6ICdlbicsXG4gICAgICB9LFxuXG4gICAgICBsYW5nczogWydkZScsICdpdCcsICdmcicsICdlbiddLFxuICAgIH07XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmxhbmcgPSBvcHRpb25zLmxhbmcudG9Mb3dlckNhc2UoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHRoaXMuc2V0dGluZ3MudXJsLFxuXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcTogb3B0aW9ucy5xdWVyeSxcbiAgICAgICAgbGltaXQ6IG9wdGlvbnMubGltaXQgfHwgdGhpcy5zZXR0aW5ncy5wYXJhbXMubGltaXQsXG5cbiAgICAgICAgbGFuZzogdGhpcy5zZXR0aW5ncy5sYW5ncy5pbmNsdWRlcyhvcHRpb25zLmxhbmcpID8gb3B0aW9ucy5sYW5nIDogdGhpcy5zZXR0aW5ncy5wYXJhbXMubGFuZyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGhhbmRsZVJlc3BvbnNlKHJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0cy5mZWF0dXJlcy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIHJldHVybiByZXN1bHRzLmZlYXR1cmVzLm1hcCgocmVzdWx0KSA9PiAoe1xuICAgICAgbG9uOiByZXN1bHQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICBsYXQ6IHJlc3VsdC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcblxuICAgICAgYWRkcmVzczoge1xuICAgICAgICBuYW1lOiByZXN1bHQucHJvcGVydGllcy5uYW1lLFxuICAgICAgICBwb3N0Y29kZTogcmVzdWx0LnByb3BlcnRpZXMucG9zdGNvZGUsXG4gICAgICAgIGNpdHk6IHJlc3VsdC5wcm9wZXJ0aWVzLmNpdHksXG4gICAgICAgIHN0YXRlOiByZXN1bHQucHJvcGVydGllcy5zdGF0ZSxcbiAgICAgICAgY291bnRyeTogcmVzdWx0LnByb3BlcnRpZXMuY291bnRyeSxcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgIGZvcm1hdHRlZDogcmVzdWx0LnByb3BlcnRpZXMubmFtZSxcbiAgICAgICAgZGV0YWlsczogcmVzdWx0LnByb3BlcnRpZXMsXG4gICAgICB9LFxuICAgIH0pKTtcbiAgfVxufSIsICIvKipcbiAqIEBjbGFzcyBPcGVuU3RyZWV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wZW5TdHJlZXQge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIHVybDogJ2h0dHBzOi8vbm9taW5hdGltLm9wZW5zdHJlZXRtYXAub3JnL3NlYXJjaCcsXG4gICAgICAuLi5vcHRpb25zLCAvLyBBbGxvdyBjdXN0b20gVVJMIGZvciBvc20gcHJvdmlkZXIgaHR0cHM6Ly9naXRodWIuY29tL0RvbWluaXF1ZTkyL29sLWdlb2NvZGVyL2lzc3Vlcy8yNjZcblxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHE6ICcnLFxuICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgYWRkcmVzc2RldGFpbHM6IDEsXG4gICAgICAgIGxpbWl0OiAxMCxcbiAgICAgICAgY291bnRyeWNvZGVzOiAnJyxcbiAgICAgICAgdmlld2JveDogJycsXG4gICAgICAgICdhY2NlcHQtbGFuZ3VhZ2UnOiAnZW4tVVMnLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVycyhvcHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiB0aGlzLnNldHRpbmdzLnVybCxcblxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHE6IG9wdC5xdWVyeSxcbiAgICAgICAgZm9ybWF0OiB0aGlzLnNldHRpbmdzLnBhcmFtcy5mb3JtYXQsXG4gICAgICAgIGFkZHJlc3NkZXRhaWxzOiB0aGlzLnNldHRpbmdzLnBhcmFtcy5hZGRyZXNzZGV0YWlscyxcbiAgICAgICAgbGltaXQ6IG9wdC5saW1pdCB8fCB0aGlzLnNldHRpbmdzLnBhcmFtcy5saW1pdCxcbiAgICAgICAgY291bnRyeWNvZGVzOiBvcHQuY291bnRyeWNvZGVzIHx8IHRoaXMuc2V0dGluZ3MucGFyYW1zLmNvdW50cnljb2RlcyxcbiAgICAgICAgdmlld2JveDogb3B0LnZpZXdib3ggfHwgdGhpcy5zZXR0aW5ncy5wYXJhbXMudmlld2JveCxcbiAgICAgICAgJ2FjY2VwdC1sYW5ndWFnZSc6IG9wdC5sYW5nIHx8IHRoaXMuc2V0dGluZ3MucGFyYW1zWydhY2NlcHQtbGFuZ3VhZ2UnXSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGhhbmRsZVJlc3BvbnNlKHJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiAoe1xuICAgICAgbG9uOiByZXN1bHQubG9uLFxuICAgICAgbGF0OiByZXN1bHQubGF0LFxuICAgICAgYmJveDogcmVzdWx0LmJvdW5kaW5nYm94LFxuXG4gICAgICBhZGRyZXNzOiB7XG4gICAgICAgIG5hbWU6IHJlc3VsdC5kaXNwbGF5X25hbWUsXG4gICAgICAgIHJvYWQ6IHJlc3VsdC5hZGRyZXNzLnJvYWQgfHwgJycsXG4gICAgICAgIGhvdXNlTnVtYmVyOiByZXN1bHQuYWRkcmVzcy5ob3VzZV9udW1iZXIgfHwgJycsXG4gICAgICAgIHBvc3Rjb2RlOiByZXN1bHQuYWRkcmVzcy5wb3N0Y29kZSxcbiAgICAgICAgY2l0eTogcmVzdWx0LmFkZHJlc3MuY2l0eSB8fCByZXN1bHQuYWRkcmVzcy50b3duLFxuICAgICAgICBzdGF0ZTogcmVzdWx0LmFkZHJlc3Muc3RhdGUsXG4gICAgICAgIGNvdW50cnk6IHJlc3VsdC5hZGRyZXNzLmNvdW50cnksXG4gICAgICB9LFxuXG4gICAgICBvcmlnaW5hbDoge1xuICAgICAgICBmb3JtYXR0ZWQ6IHJlc3VsdC5kaXNwbGF5X25hbWUsXG4gICAgICAgIGRldGFpbHM6IHJlc3VsdC5hZGRyZXNzLFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH1cbn0iLCAiLyoqXG4gKiBAY2xhc3MgTWFwUXVlc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwUXVlc3Qge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgdXJsOiAnaHR0cHM6Ly9vcGVuLm1hcHF1ZXN0YXBpLmNvbS9ub21pbmF0aW0vdjEvc2VhcmNoLnBocCcsXG5cbiAgICAgIHBhcmFtczoge1xuICAgICAgICBxOiAnJyxcbiAgICAgICAga2V5OiAnJyxcbiAgICAgICAgZm9ybWF0OiAnanNvbicsXG4gICAgICAgIGFkZHJlc3NkZXRhaWxzOiAxLFxuICAgICAgICBsaW1pdDogMTAsXG4gICAgICAgIGNvdW50cnljb2RlczogJycsXG4gICAgICAgICdhY2NlcHQtbGFuZ3VhZ2UnOiAnZW4tVVMnLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVycyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogdGhpcy5zZXR0aW5ncy51cmwsXG5cbiAgICAgIHBhcmFtczoge1xuICAgICAgICBxOiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgYWRkcmVzc2RldGFpbHM6IDEsXG4gICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0IHx8IHRoaXMuc2V0dGluZ3MucGFyYW1zLmxpbWl0LFxuICAgICAgICBjb3VudHJ5Y29kZXM6IG9wdGlvbnMuY291bnRyeWNvZGVzIHx8IHRoaXMuc2V0dGluZ3MucGFyYW1zLmNvdW50cnljb2RlcyxcblxuICAgICAgICAnYWNjZXB0LWxhbmd1YWdlJzogb3B0aW9ucy5sYW5nIHx8IHRoaXMuc2V0dGluZ3MucGFyYW1zWydhY2NlcHQtbGFuZ3VhZ2UnXSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGhhbmRsZVJlc3BvbnNlKHJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiAoe1xuICAgICAgbG9uOiByZXN1bHQubG9uLFxuICAgICAgbGF0OiByZXN1bHQubGF0LFxuXG4gICAgICBhZGRyZXNzOiB7XG4gICAgICAgIG5hbWU6IHJlc3VsdC5hZGRyZXNzLm5laWdoYm91cmhvb2QgfHwgJycsXG4gICAgICAgIHJvYWQ6IHJlc3VsdC5hZGRyZXNzLnJvYWQgfHwgJycsXG4gICAgICAgIHBvc3Rjb2RlOiByZXN1bHQuYWRkcmVzcy5wb3N0Y29kZSxcbiAgICAgICAgY2l0eTogcmVzdWx0LmFkZHJlc3MuY2l0eSB8fCByZXN1bHQuYWRkcmVzcy50b3duLFxuICAgICAgICBzdGF0ZTogcmVzdWx0LmFkZHJlc3Muc3RhdGUsXG4gICAgICAgIGNvdW50cnk6IHJlc3VsdC5hZGRyZXNzLmNvdW50cnksXG4gICAgICB9LFxuXG4gICAgICBvcmlnaW5hbDoge1xuICAgICAgICBmb3JtYXR0ZWQ6IHJlc3VsdC5kaXNwbGF5X25hbWUsXG4gICAgICAgIGRldGFpbHM6IHJlc3VsdC5hZGRyZXNzLFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH1cbn0iLCAiLyoqXG4gKiBAY2xhc3MgQmluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaW5nIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIHVybDogJ2h0dHBzOi8vZGV2LnZpcnR1YWxlYXJ0aC5uZXQvUkVTVC92MS9Mb2NhdGlvbnMnLFxuICAgICAgY2FsbGJhY2tOYW1lOiAnanNvbnAnLFxuXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcXVlcnk6ICcnLFxuICAgICAgICBrZXk6ICcnLFxuICAgICAgICBpbmNsdWRlTmVpZ2hib3Job29kOiAwLFxuICAgICAgICBtYXhSZXN1bHRzOiAxMCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnMob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHRoaXMuc2V0dGluZ3MudXJsLFxuICAgICAgY2FsbGJhY2tOYW1lOiB0aGlzLnNldHRpbmdzLmNhbGxiYWNrTmFtZSxcblxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHF1ZXJ5OiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuXG4gICAgICAgIGluY2x1ZGVOZWlnaGJvcmhvb2Q6IG9wdGlvbnMuaW5jbHVkZU5laWdoYm9yaG9vZCB8fCB0aGlzLnNldHRpbmdzLnBhcmFtcy5pbmNsdWRlTmVpZ2hib3Job29kLFxuXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdGlvbnMubWF4UmVzdWx0cyB8fCB0aGlzLnNldHRpbmdzLnBhcmFtcy5tYXhSZXN1bHRzLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgaGFuZGxlUmVzcG9uc2UocmVzdWx0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc291cmNlc1xuICAgIH0gPSByZXN1bHRzLnJlc291cmNlU2V0c1swXTtcblxuICAgIGlmIChyZXNvdXJjZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgICByZXR1cm4gcmVzb3VyY2VzLm1hcCgocmVzdWx0KSA9PiAoe1xuICAgICAgbG9uOiByZXN1bHQucG9pbnQuY29vcmRpbmF0ZXNbMV0sXG4gICAgICBsYXQ6IHJlc3VsdC5wb2ludC5jb29yZGluYXRlc1swXSxcblxuICAgICAgYWRkcmVzczoge1xuICAgICAgICBuYW1lOiByZXN1bHQubmFtZSxcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgIGZvcm1hdHRlZDogcmVzdWx0LmFkZHJlc3MuZm9ybWF0dGVkQWRkcmVzcyxcbiAgICAgICAgZGV0YWlsczogcmVzdWx0LmFkZHJlc3MsXG4gICAgICB9LFxuICAgIH0pKTtcbiAgfVxufSIsICIvKipcbiAqIEBjbGFzcyBPcGVuQ2FnZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGVuQ2FnZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICB1cmw6ICdodHRwczovL2FwaS5vcGVuY2FnZWRhdGEuY29tL2dlb2NvZGUvdjEvanNvbj8nLFxuXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcTogJycsXG4gICAgICAgIGtleTogJycsXG4gICAgICAgIGxpbWl0OiAxMCxcbiAgICAgICAgY291bnRyeWNvZGU6ICcnLFxuICAgICAgICBwcmV0dHk6IDEsXG4gICAgICAgIG5vX2Fubm90YXRpb25zOiAxLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVycyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogdGhpcy5zZXR0aW5ncy51cmwsXG5cbiAgICAgIHBhcmFtczoge1xuICAgICAgICBxOiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICBsaW1pdDogb3B0aW9ucy5saW1pdCB8fCB0aGlzLnNldHRpbmdzLnBhcmFtcy5saW1pdCxcbiAgICAgICAgY291bnRyeWNvZGU6IG9wdGlvbnMuY291bnRyeWNvZGVzIHx8IHRoaXMuc2V0dGluZ3MucGFyYW1zLmNvdW50cnljb2RlcyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGhhbmRsZVJlc3BvbnNlKHJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0cy5yZXN1bHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIHJlc3VsdHMucmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gKHtcbiAgICAgIGxvbjogcmVzdWx0Lmdlb21ldHJ5LmxuZyxcbiAgICAgIGxhdDogcmVzdWx0Lmdlb21ldHJ5LmxhdCxcblxuICAgICAgYWRkcmVzczoge1xuICAgICAgICBuYW1lOiByZXN1bHQuY29tcG9uZW50cy5ob3VzZV9udW1iZXIgfHwgJycsXG4gICAgICAgIHJvYWQ6IHJlc3VsdC5jb21wb25lbnRzLnJvYWQgfHwgJycsXG4gICAgICAgIHBvc3Rjb2RlOiByZXN1bHQuY29tcG9uZW50cy5wb3N0Y29kZSxcbiAgICAgICAgY2l0eTogcmVzdWx0LmNvbXBvbmVudHMuY2l0eSB8fCByZXN1bHQuY29tcG9uZW50cy50b3duLFxuICAgICAgICBzdGF0ZTogcmVzdWx0LmNvbXBvbmVudHMuc3RhdGUsXG4gICAgICAgIGNvdW50cnk6IHJlc3VsdC5jb21wb25lbnRzLmNvdW50cnksXG4gICAgICB9LFxuXG4gICAgICBvcmlnaW5hbDoge1xuICAgICAgICBmb3JtYXR0ZWQ6IHJlc3VsdC5mb3JtYXR0ZWQsXG4gICAgICAgIGRldGFpbHM6IHJlc3VsdC5jb21wb25lbnRzLFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH1cbn0iLCAiaW1wb3J0IExheWVyVmVjdG9yIGZyb20gJ29sL2xheWVyL1ZlY3Rvcic7XG5pbXBvcnQgU291cmNlVmVjdG9yIGZyb20gJ29sL3NvdXJjZS9WZWN0b3InO1xuaW1wb3J0IFBvaW50IGZyb20gJ29sL2dlb20vUG9pbnQnO1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnb2wvRmVhdHVyZSc7XG5pbXBvcnQgKiBhcyBwcm9qIGZyb20gJ29sL3Byb2onO1xuXG5pbXBvcnQge1xuICBWQVJTLFxuICBUQVJHRVRfVFlQRSxcbiAgUFJPVklERVJTLFxuICBFVkVOVF9UWVBFXG59IGZyb20gJy4uL2tvbnN0YW50cyc7XG5pbXBvcnQge1xuICBoYXNDbGFzcyxcbiAgYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzLFxuICBjcmVhdGVFbGVtZW50LFxuICB0ZW1wbGF0ZSxcbiAgcmVtb3ZlQWxsQ2hpbGRyZW4sXG59IGZyb20gJy4vaGVscGVycy9kb20nO1xuaW1wb3J0IHtcbiAgcmFuZG9tSWRcbn0gZnJvbSAnLi9oZWxwZXJzL21peCc7XG5pbXBvcnQge1xuICBqc29uXG59IGZyb20gJy4vaGVscGVycy9hamF4JztcblxuaW1wb3J0IFBob3RvbiBmcm9tICcuL3Byb3ZpZGVycy9waG90b24nO1xuaW1wb3J0IE9wZW5TdHJlZXQgZnJvbSAnLi9wcm92aWRlcnMvb3NtJztcbmltcG9ydCBNYXBRdWVzdCBmcm9tICcuL3Byb3ZpZGVycy9tYXBxdWVzdCc7XG5pbXBvcnQgQmluZyBmcm9tICcuL3Byb3ZpZGVycy9iaW5nJztcbmltcG9ydCBPcGVuQ2FnZSBmcm9tICcuL3Byb3ZpZGVycy9vcGVuY2FnZSc7XG5cbmNvbnN0IGtsYXNzZXMgPSBWQVJTLmNzc0NsYXNzZXM7XG5cbi8qKlxuICogQGNsYXNzIE5vbWluYXRpbVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb21pbmF0aW0ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2UgQmFzZSBjbGFzcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJhc2UsIGVscykge1xuICAgIHRoaXMuQmFzZSA9IGJhc2U7XG5cbiAgICB0aGlzLmxheWVyTmFtZSA9IHJhbmRvbUlkKCdnZW9jb2Rlci1sYXllci0nKTtcbiAgICB0aGlzLmxheWVyID0gbmV3IExheWVyVmVjdG9yKHtcbiAgICAgIG5hbWU6IHRoaXMubGF5ZXJOYW1lLFxuICAgICAgc291cmNlOiBuZXcgU291cmNlVmVjdG9yKCksXG4gICAgICBkaXNwbGF5SW5MYXllclN3aXRjaGVyOiBmYWxzZSwgLy8gUmVtb3ZlIHNlYXJjaCBsYXllciBmcm9tIGxlZ2VuZCBodHRwczovL2dpdGh1Yi5jb20vRG9taW5pcXVlOTIvb2wtZ2VvY29kZXIvaXNzdWVzLzI1NlxuICAgIH0pO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYmFzZS5vcHRpb25zO1xuICAgIC8vIHByb3ZpZGVyIGlzIGVpdGhlciB0aGUgbmFtZSBvZiBhIGJ1aWx0LWluIHByb3ZpZGVyIGFzIGEgc3RyaW5nIG9yIGFuXG4gICAgLy8gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgcHJvdmlkZXIgQVBJXG4gICAgdGhpcy5vcHRpb25zLnByb3ZpZGVyID1cbiAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMucHJvdmlkZXIgPT09ICdzdHJpbmcnID9cbiAgICAgIHRoaXMub3B0aW9ucy5wcm92aWRlci50b0xvd2VyQ2FzZSgpIDpcbiAgICAgIHRoaXMub3B0aW9ucy5wcm92aWRlcjtcbiAgICB0aGlzLnByb3ZpZGVyID0gdGhpcy5uZXdQcm92aWRlcigpO1xuXG4gICAgdGhpcy5lbHMgPSBlbHM7XG4gICAgdGhpcy5sYXN0UXVlcnkgPSAnJztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWxzLmNvbnRhaW5lcjtcbiAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMgPSB7XG4gICAgICBtYXBDbGljazogZmFsc2UsXG4gICAgfTtcbiAgICB0aGlzLnNldExpc3RlbmVycygpO1xuICB9XG5cbiAgc2V0TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IG9wZW5TZWFyY2ggPSAoZXZ0KSA9PiB7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBoYXNDbGFzcyh0aGlzLmVscy5jb250cm9sLCBrbGFzc2VzLmdsYXNzLmV4cGFuZGVkKSA/IHRoaXMuY29sbGFwc2UoKSA6IHRoaXMuZXhwYW5kKCk7XG4gICAgfTtcbiAgICBjb25zdCBxdWVyeSA9IChldnQpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZS50cmltKCk7XG4gICAgICBjb25zdCBoaXQgPSBldnQua2V5ID9cbiAgICAgICAgZXZ0LmtleSA9PT0gJ0VudGVyJyA6XG4gICAgICAgIGV2dC53aGljaCA/XG4gICAgICAgIGV2dC53aGljaCA9PT0gMTMgOlxuICAgICAgICBldnQua2V5Q29kZSA/XG4gICAgICAgIGV2dC5rZXlDb2RlID09PSAxMyA6XG4gICAgICAgIGZhbHNlO1xuXG4gICAgICBpZiAoaGl0KSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnF1ZXJ5KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0b3BCdWJibGluZyA9IChldnQpID0+IGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCBzZWFyY2ggPSAoKSA9PiB7XG4gICAgICB0aGlzLmVscy5pbnB1dC5mb2N1cygpO1xuICAgICAgdGhpcy5xdWVyeSh0aGlzLmVscy5pbnB1dC52YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVWYWx1ZSA9IChldnQpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZXZ0LnRhcmdldC52YWx1ZS50cmltKCk7XG5cbiAgICAgIHZhbHVlLmxlbmd0aCAhPT0gMCA/XG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxzLnNlYXJjaCwga2xhc3Nlcy5oaWRkZW4pIDpcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5lbHMuc2VhcmNoLCBrbGFzc2VzLmhpZGRlbik7XG4gICAgfTtcblxuICAgIHRoaXMuZWxzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgcXVlcnksIGZhbHNlKTtcbiAgICB0aGlzLmVscy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHN0b3BCdWJibGluZywgZmFsc2UpO1xuICAgIHRoaXMuZWxzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgaGFuZGxlVmFsdWUsIGZhbHNlKTtcbiAgICB0aGlzLmVscy5zZWFyY2guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWFyY2gsIGZhbHNlKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0VHlwZSA9PT0gVEFSR0VUX1RZUEUuR0xBU1MpIHtcbiAgICAgIHRoaXMuZWxzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9wZW5TZWFyY2gsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBxdWVyeShxKSB7XG4gICAgLy8gbGF6eSBwcm92aWRlclxuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgdGhpcy5wcm92aWRlciA9IHRoaXMubmV3UHJvdmlkZXIoKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5wcm92aWRlci5nZXRQYXJhbWV0ZXJzKHtcbiAgICAgIHF1ZXJ5OiBxLFxuICAgICAga2V5OiB0aGlzLm9wdGlvbnMua2V5LFxuICAgICAgbGFuZzogdGhpcy5vcHRpb25zLmxhbmcsXG4gICAgICBjb3VudHJ5Y29kZXM6IHRoaXMub3B0aW9ucy5jb3VudHJ5Y29kZXMsXG4gICAgICB2aWV3Ym94OiB0aGlzLm9wdGlvbnMudmlld2JveCxcbiAgICAgIGxpbWl0OiB0aGlzLm9wdGlvbnMubGltaXQsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5sYXN0UXVlcnkgPT09IHEgJiYgdGhpcy5lbHMucmVzdWx0LmZpcnN0Q2hpbGQpIHJldHVybjtcblxuICAgIHRoaXMubGFzdFF1ZXJ5ID0gcTtcbiAgICB0aGlzLmNsZWFyUmVzdWx0cygpO1xuICAgIGFkZENsYXNzKHRoaXMuZWxzLnNlYXJjaCwga2xhc3Nlcy5zcGluKTtcblxuICAgIGNvbnN0IGFqYXggPSB7XG4gICAgICB1cmw6IHBhcmFtZXRlcnMudXJsLFxuICAgICAgZGF0YTogcGFyYW1ldGVycy5wYXJhbXMsXG4gICAgfTtcblxuICAgIGlmIChwYXJhbWV0ZXJzLmNhbGxiYWNrTmFtZSkge1xuICAgICAgYWpheC5qc29ucCA9IHRydWU7XG4gICAgICBhamF4LmNhbGxiYWNrTmFtZSA9IHBhcmFtZXRlcnMuY2FsbGJhY2tOYW1lO1xuICAgIH1cblxuICAgIGpzb24oYWpheClcbiAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgdGhpcy5vcHRpb25zLmRlYnVnICYmIGNvbnNvbGUuaW5mbyhyZXMpO1xuXG4gICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxzLnNlYXJjaCwga2xhc3Nlcy5zcGluKTtcblxuICAgICAgICAvLyB3aWxsIGJlIGZ1bGxmaWxlZCBhY2NvcmRpbmcgdG8gcHJvdmlkZXJcbiAgICAgICAgY29uc3QgcmVzXyA9IHRoaXMucHJvdmlkZXIuaGFuZGxlUmVzcG9uc2UocmVzKTtcblxuICAgICAgICBpZiAocmVzXykge1xuICAgICAgICAgIHRoaXMuY3JlYXRlTGlzdChyZXNfKTtcbiAgICAgICAgICB0aGlzLmxpc3Rlbk1hcENsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmVscy5zZWFyY2gsIGtsYXNzZXMuc3Bpbik7XG5cbiAgICAgICAgY29uc3QgbGkgPSBjcmVhdGVFbGVtZW50KCdsaScsICc8aDU+RXJyb3IhIE5vIGludGVybmV0IGNvbm5lY3Rpb24/PC9oNT4nKTtcblxuICAgICAgICB0aGlzLmVscy5yZXN1bHQuYXBwZW5kKGxpKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlTGlzdChyZXNwb25zZSkge1xuICAgIGNvbnN0IHVsID0gdGhpcy5lbHMucmVzdWx0O1xuXG4gICAgcmVzcG9uc2UuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICBsZXQgYWRkcmVzc0h0bWw7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnByb3ZpZGVyKSB7XG4gICAgICAgIGNhc2UgUFJPVklERVJTLk9TTTpcbiAgICAgICAgICBhZGRyZXNzSHRtbCA9IGA8c3BhbiBjbGFzcz1cIiR7a2xhc3Nlcy5yb2FkfVwiPiR7cm93LmFkZHJlc3MubmFtZX08L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFkZHJlc3NIdG1sID0gdGhpcy5hZGRyZXNzVGVtcGxhdGUocm93LmFkZHJlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdGhpcy5jaG9zZW4ocm93LCBhZGRyZXNzSHRtbCwgcm93LmFkZHJlc3MsIHJvdy5vcmlnaW5hbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaSA9IGNyZWF0ZUVsZW1lbnQoJ2xpJywgYDxhIGhyZWY9XCIjXCI+JHthZGRyZXNzSHRtbH08L2E+YCk7XG5cbiAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgIChldnQpID0+IHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5jaG9zZW4ocm93LCBhZGRyZXNzSHRtbCwgcm93LmFkZHJlc3MsIHJvdy5vcmlnaW5hbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHVsLmFwcGVuZChsaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjaG9zZW4ocGxhY2UsIGFkZHJlc3NIdG1sLCBhZGRyZXNzT2JqLCBhZGRyZXNzT3JpZ2luYWwpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLkJhc2UuZ2V0TWFwKCk7XG4gICAgY29uc3QgY29vcmRfID0gW051bWJlci5wYXJzZUZsb2F0KHBsYWNlLmxvbiksIE51bWJlci5wYXJzZUZsb2F0KHBsYWNlLmxhdCldO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSBtYXAuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKTtcbiAgICBjb25zdCBjb29yZCA9IHByb2oudHJhbnNmb3JtKGNvb3JkXywgJ0VQU0c6NDMyNicsIHByb2plY3Rpb24pO1xuXG4gICAgbGV0IHtcbiAgICAgIGJib3hcbiAgICB9ID0gcGxhY2U7XG5cbiAgICBpZiAoYmJveCkge1xuICAgICAgYmJveCA9IHByb2oudHJhbnNmb3JtRXh0ZW50KFxuICAgICAgICAvLyBodHRwczovL25vbWluYXRpbS5vcmcvcmVsZWFzZS1kb2NzL2xhdGVzdC9hcGkvT3V0cHV0LyNib3VuZGluZ2JveFxuICAgICAgICAvLyBSZXF1aXJlcyBwYXJzZUZsb2F0IG9uIG5lZ2F0aXZlIGJib3ggZW50cmllc1xuICAgICAgICBbcGFyc2VGbG9hdChiYm94WzJdKSwgcGFyc2VGbG9hdChiYm94WzBdKSwgcGFyc2VGbG9hdChiYm94WzNdKSwgcGFyc2VGbG9hdChiYm94WzFdKV0sIC8vIFNOV0UgLT4gV1NFTlxuICAgICAgICAnRVBTRzo0MzI2JyxcbiAgICAgICAgcHJvamVjdGlvblxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzID0ge1xuICAgICAgZm9ybWF0dGVkOiBhZGRyZXNzSHRtbCxcbiAgICAgIGRldGFpbHM6IGFkZHJlc3NPYmosXG4gICAgICBvcmlnaW5hbDogYWRkcmVzc09yaWdpbmFsLFxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMua2VlcE9wZW4gPT09IGZhbHNlICYmIHRoaXMuY2xlYXJSZXN1bHRzKHRydWUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMucHJldmVudE1hcmtlciA9PT0gdHJ1ZSkge1xuICAgICAgLy8gTm8gZGlzcGxheSBjaGFuZ2VcbiAgICAgIHRoaXMuQmFzZS5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogRVZFTlRfVFlQRS5BRERSRVNTQ0hPU0VOLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjb29yZGluYXRlOiBjb29yZCxcbiAgICAgICAgYmJveCxcbiAgICAgICAgcGxhY2UsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGlzcGxheSBhIG1hcmtlclxuICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuY3JlYXRlRmVhdHVyZShjb29yZCwgYWRkcmVzcyk7XG5cbiAgICAgIHRoaXMuQmFzZS5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogRVZFTlRfVFlQRS5BRERSRVNTQ0hPU0VOLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBmZWF0dXJlLFxuICAgICAgICBjb29yZGluYXRlOiBjb29yZCxcbiAgICAgICAgYmJveCxcbiAgICAgICAgcGxhY2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ICE9PSB0cnVlICYmIHRoaXMub3B0aW9ucy5wcmV2ZW50UGFubmluZyAhPT0gdHJ1ZSkge1xuICAgICAgLy8gTW92ZSAmIHpvb20gdG8gdGhlIHBvc2l0aW9uXG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICBtYXAuZ2V0VmlldygpLmZpdChiYm94LCB7XG4gICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAuZ2V0VmlldygpLmFuaW1hdGUoe1xuICAgICAgICAgIGNlbnRlcjogY29vcmQsXG4gICAgICAgICAgLy8gb2wtZ2VvY29kZXIgcmVzdWx0cyBhcmUgdG9vIG11Y2ggem9vbWVkIC1pbiBEb21pbmlxdWU5Mi9vbC1nZW9jb2RlciMyMzVcbiAgICAgICAgICByZXNvbHV0aW9uOiB0aGlzLm9wdGlvbnMuZGVmYXVsdEZseVJlc29sdXRpb24sXG4gICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRmVhdHVyZShjb29yZCkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZShuZXcgUG9pbnQoY29vcmQpKTtcblxuICAgIHRoaXMuYWRkTGF5ZXIoKTtcbiAgICBmZWF0dXJlLnNldFN0eWxlKHRoaXMub3B0aW9ucy5mZWF0dXJlU3R5bGUpO1xuICAgIGZlYXR1cmUuc2V0SWQocmFuZG9tSWQoJ2dlb2NvZGVyLWZ0LScpKTtcbiAgICB0aGlzLmdldFNvdXJjZSgpLmFkZEZlYXR1cmUoZmVhdHVyZSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZTtcbiAgfVxuXG4gIGFkZHJlc3NUZW1wbGF0ZShhZGRyZXNzKSB7XG4gICAgY29uc3QgaHRtbCA9IFtdO1xuXG4gICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgaHRtbC5wdXNoKFsnPHNwYW4gY2xhc3M9XCInLCBrbGFzc2VzLnJvYWQsICdcIj57bmFtZX08L3NwYW4+J10uam9pbignJykpO1xuICAgIH1cblxuICAgIGlmIChhZGRyZXNzLnJvYWQgfHwgYWRkcmVzcy5idWlsZGluZyB8fCBhZGRyZXNzLmhvdXNlX251bWJlcikge1xuICAgICAgaHRtbC5wdXNoKFxuICAgICAgICBbJzxzcGFuIGNsYXNzPVwiJywga2xhc3Nlcy5yb2FkLCAnXCI+e2J1aWxkaW5nfSB7cm9hZH0ge2hvdXNlX251bWJlcn08L3NwYW4+J10uam9pbignJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFkZHJlc3MuY2l0eSB8fCBhZGRyZXNzLnRvd24gfHwgYWRkcmVzcy52aWxsYWdlKSB7XG4gICAgICBodG1sLnB1c2goXG4gICAgICAgIFsnPHNwYW4gY2xhc3M9XCInLCBrbGFzc2VzLmNpdHksICdcIj57cG9zdGNvZGV9IHtjaXR5fSB7dG93bn0ge3ZpbGxhZ2V9PC9zcGFuPiddLmpvaW4oJycpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhZGRyZXNzLnN0YXRlIHx8IGFkZHJlc3MuY291bnRyeSkge1xuICAgICAgaHRtbC5wdXNoKFsnPHNwYW4gY2xhc3M9XCInLCBrbGFzc2VzLmNvdW50cnksICdcIj57c3RhdGV9IHtjb3VudHJ5fTwvc3Bhbj4nXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlKGh0bWwuam9pbignPGJyPicpLCBhZGRyZXNzKTtcbiAgfVxuXG4gIG5ld1Byb3ZpZGVyKCkge1xuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnByb3ZpZGVyKSB7XG4gICAgICBjYXNlIFBST1ZJREVSUy5PU006XG4gICAgICAgIHJldHVybiBuZXcgT3BlblN0cmVldCh0aGlzLm9wdGlvbnMpO1xuICAgICAgY2FzZSBQUk9WSURFUlMuTUFQUVVFU1Q6XG4gICAgICAgIHJldHVybiBuZXcgTWFwUXVlc3QoKTtcbiAgICAgIGNhc2UgUFJPVklERVJTLlBIT1RPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBQaG90b24oKTtcbiAgICAgIGNhc2UgUFJPVklERVJTLkJJTkc6XG4gICAgICAgIHJldHVybiBuZXcgQmluZygpO1xuICAgICAgY2FzZSBQUk9WSURFUlMuT1BFTkNBR0U6XG4gICAgICAgIHJldHVybiBuZXcgT3BlbkNhZ2UoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wcm92aWRlcjtcbiAgICB9XG4gIH1cblxuICBleHBhbmQoKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbHMuaW5wdXQsIGtsYXNzZXMuc3Bpbik7XG4gICAgYWRkQ2xhc3ModGhpcy5lbHMuY29udHJvbCwga2xhc3Nlcy5nbGFzcy5leHBhbmRlZCk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbHMuaW5wdXQuZm9jdXMoKSwgMTAwKTtcbiAgICB0aGlzLmxpc3Rlbk1hcENsaWNrKCk7XG4gIH1cblxuICBjb2xsYXBzZSgpIHtcbiAgICB0aGlzLmVscy5pbnB1dC52YWx1ZSA9ICcnO1xuICAgIHRoaXMuZWxzLmlucHV0LmJsdXIoKTtcbiAgICBhZGRDbGFzcyh0aGlzLmVscy5zZWFyY2gsIGtsYXNzZXMuaGlkZGVuKTtcbiAgICByZW1vdmVDbGFzcyh0aGlzLmVscy5jb250cm9sLCBrbGFzc2VzLmdsYXNzLmV4cGFuZGVkKTtcbiAgICB0aGlzLmNsZWFyUmVzdWx0cygpO1xuICB9XG5cbiAgbGlzdGVuTWFwQ2xpY2soKSB7XG4gICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5tYXBDbGljaykgcmV0dXJuO1xuXG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgY29uc3QgbWFwRWxlbWVudCA9IHRoaXMuQmFzZS5nZXRNYXAoKS5nZXRUYXJnZXRFbGVtZW50KCk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMubWFwQ2xpY2sgPSB0cnVlO1xuXG4gICAgLy8gb25lLXRpbWUgZmlyZSBjbGlja1xuICAgIG1hcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdjbGljaycsIHtcbiAgICAgICAgaGFuZGxlRXZlbnQoZXZ0KSB7XG4gICAgICAgICAgdGhhdC5jbGVhclJlc3VsdHModHJ1ZSk7XG4gICAgICAgICAgbWFwRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dC50eXBlLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgdGhhdC5yZWdpc3RlcmVkTGlzdGVuZXJzLm1hcENsaWNrID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgY2xlYXJSZXN1bHRzKGNvbGxhcHNlKSB7XG4gICAgY29sbGFwc2UgJiYgdGhpcy5vcHRpb25zLnRhcmdldFR5cGUgPT09IFRBUkdFVF9UWVBFLkdMQVNTID9cbiAgICAgIHRoaXMuY29sbGFwc2UoKSA6XG4gICAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLmVscy5yZXN1bHQpO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyLmdldFNvdXJjZSgpO1xuICB9XG5cbiAgYWRkTGF5ZXIoKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICBjb25zdCBtYXAgPSB0aGlzLkJhc2UuZ2V0TWFwKCk7XG5cbiAgICBtYXAuZ2V0TGF5ZXJzKCkuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGlmIChsYXllciA9PT0gdGhpcy5sYXllcikgZm91bmQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFmb3VuZCkgbWFwLmFkZExheWVyKHRoaXMubGF5ZXIpO1xuICB9XG59IiwgImltcG9ydCBDb250cm9sIGZyb20gJ29sL2NvbnRyb2wvQ29udHJvbCc7XG5pbXBvcnQgU3R5bGUgZnJvbSAnb2wvc3R5bGUvU3R5bGUnO1xuaW1wb3J0IEljb24gZnJvbSAnb2wvc3R5bGUvSWNvbic7XG5cbmltcG9ydCB7XG4gIENPTlRST0xfVFlQRSxcbiAgREVGQVVMVF9PUFRJT05TLFxuICBGRUFUVVJFX1NSQ1xufSBmcm9tICcuLi9rb25zdGFudHMnO1xuXG5pbXBvcnQgSHRtbCBmcm9tICcuL2h0bWwnO1xuaW1wb3J0IE5vbWluYXRpbSBmcm9tICcuL25vbWluYXRpbSc7XG5pbXBvcnQge1xuICBhc3NlcnQsXG59IGZyb20gJy4vaGVscGVycy9taXgnO1xuXG4vKipcbiAqIEBjbGFzcyBCYXNlXG4gKiBAZXh0ZW5kcyB7b2wuY29udHJvbC5Db250cm9sfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgbm9taW5hdGltfHJldmVyc2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlID0gQ09OVFJPTF9UWVBFLk5PTUlOQVRJTSwgb3B0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgJ0BwYXJhbSBgdHlwZWAgc2hvdWxkIGJlIHN0cmluZyEnKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlID09PSBDT05UUk9MX1RZUEUuTk9NSU5BVElNIHx8IHR5cGUgPT09IENPTlRST0xfVFlQRS5SRVZFUlNFLFxuICAgICAgYEBwYXJhbSAndHlwZScgc2hvdWxkIGJlICcke0NPTlRST0xfVFlQRS5OT01JTkFUSU19J1xuICAgICAgb3IgJyR7Q09OVFJPTF9UWVBFLlJFVkVSU0V9JyFgXG4gICAgKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgZmVhdHVyZVN0eWxlOiBbXG4gICAgICAgIG5ldyBTdHlsZSh7XG4gICAgICAgICAgaW1hZ2U6IG5ldyBJY29uKHtcbiAgICAgICAgICAgIHNjYWxlOiAwLjcsXG4gICAgICAgICAgICBzcmM6IEZFQVRVUkVfU1JDXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICBdLFxuICAgICAgLi4ub3B0LFxuICAgIH07XG5cbiAgICBsZXQgY29udGFpbmVyO1xuICAgIGxldCAkbm9taW5hdGltO1xuICAgIGNvbnN0ICRodG1sID0gbmV3IEh0bWwob3B0aW9ucyk7XG5cbiAgICBpZiAodHlwZSA9PT0gQ09OVFJPTF9UWVBFLk5PTUlOQVRJTSkge1xuICAgICAgY29udGFpbmVyID0gJGh0bWwuZWxzLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBjb250YWluZXIsXG4gICAgICAuLi5vcHRpb25zLCAvLyBBbGxvd3MgdG8gYWRkIG9sLmNvbnRyb2wuQ29udHJvbCBvcHRpb25zIChhcyB0YXJnZXQ6KVxuICAgIH0pO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJhc2UpKSByZXR1cm4gbmV3IEJhc2UoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICBpZiAodHlwZSA9PT0gQ09OVFJPTF9UWVBFLk5PTUlOQVRJTSkge1xuICAgICAgJG5vbWluYXRpbSA9IG5ldyBOb21pbmF0aW0odGhpcywgJGh0bWwuZWxzKTtcbiAgICAgIHRoaXMubGF5ZXIgPSAkbm9taW5hdGltLmxheWVyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvbC5sYXllci5WZWN0b3J9IFJldHVybnMgdGhlIGxheWVyIGNyZWF0ZWQgYnkgdGhpcyBjb250cm9sXG4gICAqL1xuICBnZXRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvbC5zb3VyY2UuVmVjdG9yfSBSZXR1cm5zIHRoZSBzb3VyY2UgY3JlYXRlZCBieSB0aGlzIGNvbnRyb2xcbiAgICovXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldFNvdXJjZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBwcm92aWRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvdmlkZXJcbiAgICovXG4gIHNldFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5vcHRpb25zLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHByb3ZpZGVyIGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuICBzZXRQcm92aWRlcktleShrZXkpIHtcbiAgICB0aGlzLm9wdGlvbnMua2V5ID0ga2V5O1xuICB9XG59IiwgIi8qKlxuICogQG1vZHVsZSBvbC9NYXBcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgQ29tcG9zaXRlTWFwUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9Db21wb3NpdGUuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IExheWVyIGZyb20gJy4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IExheWVyR3JvdXAsIHtHcm91cEV2ZW50fSBmcm9tICcuL2xheWVyL0dyb3VwLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnQgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnQuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXIgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwRXZlbnQgZnJvbSAnLi9NYXBFdmVudC5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4vTWFwRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBQcm9wZXJ0eSBmcm9tICcuL01hcFByb3BlcnR5LmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IFBvaW50ZXJFdmVudFR5cGUgZnJvbSAnLi9wb2ludGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGlsZVF1ZXVlLCB7Z2V0VGlsZVByaW9yaXR5fSBmcm9tICcuL1RpbGVRdWV1ZS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuL1ZpZXcuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtERVZJQ0VfUElYRUxfUkFUSU8sIFBBU1NJVkVfRVZFTlRfTElTVEVORVJTfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLFxuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxufSBmcm9tICcuL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7XG4gIGNsb25lLFxuICBjcmVhdGVPclVwZGF0ZUVtcHR5LFxuICBlcXVhbHMgYXMgZXF1YWxzRXh0ZW50LFxuICBnZXRGb3JWaWV3QW5kU2l6ZSxcbiAgaXNFbXB0eSxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtkZWZhdWx0cyBhcyBkZWZhdWx0Q29udHJvbHN9IGZyb20gJy4vY29udHJvbC9kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2RlZmF1bHRzIGFzIGRlZmF1bHRJbnRlcmFjdGlvbnN9IGZyb20gJy4vaW50ZXJhY3Rpb24vZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4vYXJyYXkuanMnO1xuaW1wb3J0IHtmcm9tVXNlckNvb3JkaW5hdGUsIHRvVXNlckNvb3JkaW5hdGV9IGZyb20gJy4vcHJvai5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCB7aGFzQXJlYX0gZnJvbSAnLi9zaXplLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge3JlbW92ZU5vZGV9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7d2Fybn0gZnJvbSAnLi9jb25zb2xlLmpzJztcblxuLyoqXG4gKiBTdGF0ZSBvZiB0aGUgY3VycmVudCBmcmFtZS4gT25seSBgcGl4ZWxSYXRpb2AsIGB0aW1lYCBhbmQgYHZpZXdTdGF0ZWAgc2hvdWxkXG4gKiBiZSB1c2VkIGluIGFwcGxpY2F0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZyYW1lU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvIFRoZSBwaXhlbCByYXRpbyBvZiB0aGUgZnJhbWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZSBUaGUgdGltZSB3aGVuIHJlbmRlcmluZyBvZiB0aGUgZnJhbWUgd2FzIHJlcXVlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9WaWV3LmpzXCIpLlN0YXRlfSB2aWV3U3RhdGUgVGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFuaW1hdGUgQW5pbWF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSBDb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwicmJ1c2hcIikuZGVmYXVsdH0gZGVjbHV0dGVyVHJlZSBEZWNsdXR0ZXJUcmVlLlxuICogQHByb3BlcnR5IHtudWxsfGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudCAoaW4gdmlldyBwcm9qZWN0aW9uIGNvb3JkaW5hdGVzKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbmV4dEV4dGVudF0gTmV4dCBleHRlbnQgZHVyaW5nIGFuIGFuaW1hdGlvbiBzZXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggSW5kZXguXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGU+fSBsYXllclN0YXRlc0FycmF5IExheWVyU3RhdGVzQXJyYXkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGF5ZXJJbmRleCBMYXllckluZGV4LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtIFBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLlxuICogQHByb3BlcnR5IHtBcnJheTxQb3N0UmVuZGVyRnVuY3Rpb24+fSBwb3N0UmVuZGVyRnVuY3Rpb25zIFBvc3RSZW5kZXJGdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFNpemUuXG4gKiBAcHJvcGVydHkge1RpbGVRdWV1ZX0gdGlsZVF1ZXVlIFRpbGVRdWV1ZS5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGJvb2xlYW4+Pn0gdXNlZFRpbGVzIFVzZWRUaWxlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdmlld0hpbnRzIFZpZXdIaW50cy5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGJvb2xlYW4+Pn0gd2FudGVkVGlsZXMgV2FudGVkVGlsZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWFwSWQgVGhlIGlkIG9mIHRoZSBtYXAuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSByZW5kZXJUYXJnZXRzIElkZW50aWZpZXJzIG9mIHByZXZpb3VzbHkgcmVuZGVyZWQgZWxlbWVudHMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oTWFwLCA/RnJhbWVTdGF0ZSk6IGFueX0gUG9zdFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdFBpeGVsT3B0aW9uc1xuICogQHByb3BlcnR5IHt1bmRlZmluZWR8ZnVuY3Rpb24oaW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vc291cmNlL1NvdXJjZVwiKS5kZWZhdWx0Pik6IGJvb2xlYW59IFtsYXllckZpbHRlcl0gTGF5ZXIgZmlsdGVyXG4gKiBmdW5jdGlvbi4gVGhlIGZpbHRlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgb25lIGFyZ3VtZW50LCB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXItY2FuZGlkYXRlfSBhbmQgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4gdmFsdWUuXG4gKiBPbmx5IGxheWVycyB3aGljaCBhcmUgdmlzaWJsZSBhbmQgZm9yIHdoaWNoIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWBcbiAqIHdpbGwgYmUgdGVzdGVkIGZvciBmZWF0dXJlcy4gQnkgZGVmYXVsdCwgYWxsIHZpc2libGUgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaXRUb2xlcmFuY2U9MF0gSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UgaW4gY3NzIHBpeGVscy4gUGl4ZWxzXG4gKiBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjaGVja1dyYXBwZWQ9dHJ1ZV0gQ2hlY2stV3JhcHBlZCBXaWxsIGNoZWNrIGZvciB3cmFwcGVkIGdlb21ldHJpZXMgaW5zaWRlIHRoZSByYW5nZSBvZlxuICogICArLy0gMSB3b3JsZCB3aWR0aC4gV29ya3Mgb25seSBpZiBhIHByb2plY3Rpb24gaXMgdXNlZCB0aGF0IGNhbiBiZSB3cmFwcGVkLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWFwT3B0aW9uc0ludGVybmFsXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IFtjb250cm9sc10gQ29udHJvbHMuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gW2ludGVyYWN0aW9uc10gSW50ZXJhY3Rpb25zLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxEb2N1bWVudH0ga2V5Ym9hcmRFdmVudFRhcmdldCBLZXlib2FyZEV2ZW50VGFyZ2V0LlxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gb3ZlcmxheXMgT3ZlcmxheXMuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXMgVmFsdWVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfCdjaGFuZ2U6bGF5ZXJncm91cCd8J2NoYW5nZTpzaXplJ3wnY2hhbmdlOnRhcmdldCd8J2NoYW5nZTp2aWV3J30gTWFwT2JqZWN0RXZlbnRUeXBlc1xuICovXG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPE1hcE9iamVjdEV2ZW50VHlwZXMsIGltcG9ydChcIi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudFR5cGVcIikuVHlwZXMsIGltcG9ydChcIi4vTWFwQnJvd3NlckV2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vTWFwRXZlbnRUeXBlXCIpLlR5cGVzLCBpbXBvcnQoXCIuL01hcEV2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5NYXBSZW5kZXJFdmVudFR5cGVzLCBpbXBvcnQoXCIuL3JlbmRlci9FdmVudFwiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfE1hcE9iamVjdEV2ZW50VHlwZXN8XG4gKiAgICAgIGltcG9ydChcIi4vTWFwQnJvd3NlckV2ZW50VHlwZVwiKS5UeXBlc3xpbXBvcnQoXCIuL01hcEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAgaW1wb3J0KFwiLi9yZW5kZXIvRXZlbnRUeXBlXCIpLk1hcFJlbmRlckV2ZW50VHlwZXMsIFJldHVybj59IE1hcEV2ZW50SGFuZGxlclxuICovXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBjb25maWcgb3B0aW9ucyBmb3IgdGhlIG1hcC5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gW2NvbnRyb2xzXVxuICogQ29udHJvbHMgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvZGVmYXVsdHMuZGVmYXVsdHN9IGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsUmF0aW89d2luZG93LmRldmljZVBpeGVsUmF0aW9dIFRoZSByYXRpbyBiZXR3ZWVuXG4gKiBwaHlzaWNhbCBwaXhlbHMgYW5kIGRldmljZS1pbmRlcGVuZGVudCBwaXhlbHMgKGRpcHMpIG9uIHRoZSBkZXZpY2UuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBbaW50ZXJhY3Rpb25zXVxuICogSW50ZXJhY3Rpb25zIHRoYXQgYXJlIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBJZiBub3Qgc3BlY2lmaWVkLFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9kZWZhdWx0cy5kZWZhdWx0c30gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR8c3RyaW5nfSBba2V5Ym9hcmRFdmVudFRhcmdldF0gVGhlIGVsZW1lbnQgdG9cbiAqIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24uIFRoaXMgZGV0ZXJtaW5lcyB3aGVuIHRoZSBgS2V5Ym9hcmRQYW5gIGFuZFxuICogYEtleWJvYXJkWm9vbWAgaW50ZXJhY3Rpb25zIHRyaWdnZXIuIEZvciBleGFtcGxlLCBpZiB0aGlzIG9wdGlvbiBpcyBzZXQgdG9cbiAqIGBkb2N1bWVudGAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9ucyB3aWxsIGFsd2F5cyB0cmlnZ2VyLiBJZiB0aGlzIG9wdGlvbiBpc1xuICogbm90IHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgdGhlIGxpYnJhcnkgbGlzdGVucyB0byBrZXlib2FyZCBldmVudHMgb24gaXMgdGhlXG4gKiBtYXAgdGFyZ2V0IChpLmUuIHRoZSB1c2VyLXByb3ZpZGVkIGRpdiBmb3IgdGhlIG1hcCkuIElmIHRoaXMgaXMgbm90XG4gKiBgZG9jdW1lbnRgLCB0aGUgdGFyZ2V0IGVsZW1lbnQgbmVlZHMgdG8gYmUgZm9jdXNlZCBmb3Iga2V5IGV2ZW50cyB0byBiZVxuICogZW1pdHRlZCwgcmVxdWlyaW5nIHRoYXQgdGhlIHRhcmdldCBlbGVtZW50IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58TGF5ZXJHcm91cH0gW2xheWVyc11cbiAqIExheWVycy4gSWYgdGhpcyBpcyBub3QgZGVmaW5lZCwgYSBtYXAgd2l0aCBubyBsYXllcnMgd2lsbCBiZSByZW5kZXJlZC4gTm90ZVxuICogdGhhdCBsYXllcnMgYXJlIHJlbmRlcmVkIGluIHRoZSBvcmRlciBzdXBwbGllZCwgc28gaWYgeW91IHdhbnQsIGZvciBleGFtcGxlLFxuICogYSB2ZWN0b3IgbGF5ZXIgdG8gYXBwZWFyIG9uIHRvcCBvZiBhIHRpbGUgbGF5ZXIsIGl0IG11c3QgY29tZSBhZnRlciB0aGUgdGlsZVxuICogbGF5ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFRpbGVzTG9hZGluZz0xNl0gTWF4aW11bSBudW1iZXIgdGlsZXMgdG8gbG9hZFxuICogc2ltdWx0YW5lb3VzbHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21vdmVUb2xlcmFuY2U9MV0gVGhlIG1pbmltdW0gZGlzdGFuY2UgaW4gcGl4ZWxzIHRoZVxuICogY3Vyc29yIG11c3QgbW92ZSB0byBiZSBkZXRlY3RlZCBhcyBhIG1hcCBtb3ZlIGV2ZW50IGluc3RlYWQgb2YgYSBjbGljay5cbiAqIEluY3JlYXNpbmcgdGhpcyB2YWx1ZSBjYW4gbWFrZSBpdCBlYXNpZXIgdG8gY2xpY2sgb24gdGhlIG1hcC5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBbb3ZlcmxheXNdXG4gKiBPdmVybGF5cyBpbml0aWFsbHkgYWRkZWQgdG8gdGhlIG1hcC4gQnkgZGVmYXVsdCwgbm8gb3ZlcmxheXMgYXJlIGFkZGVkLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFRoZSBjb250YWluZXIgZm9yIHRoZSBtYXAsIGVpdGhlciB0aGVcbiAqIGVsZW1lbnQgaXRzZWxmIG9yIHRoZSBgaWRgIG9mIHRoZSBlbGVtZW50LiBJZiBub3Qgc3BlY2lmaWVkIGF0IGNvbnN0cnVjdGlvblxuICogdGltZSwge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwI3NldFRhcmdldH0gbXVzdCBiZSBjYWxsZWQgZm9yIHRoZSBtYXAgdG8gYmVcbiAqIHJlbmRlcmVkLiBJZiBwYXNzZWQgYnkgZWxlbWVudCwgdGhlIGNvbnRhaW5lciBjYW4gYmUgaW4gYSBzZWNvbmRhcnkgZG9jdW1lbnQuXG4gKiAqKk5vdGU6KiogQ1NTIGB0cmFuc2Zvcm1gIHN1cHBvcnQgZm9yIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBsaW1pdGVkIHRvIGBzY2FsZWAuXG4gKiBAcHJvcGVydHkge1ZpZXd8UHJvbWlzZTxpbXBvcnQoXCIuL1ZpZXcuanNcIikuVmlld09wdGlvbnM+fSBbdmlld10gVGhlIG1hcCdzIHZpZXcuICBObyBsYXllciBzb3VyY2VzIHdpbGwgYmVcbiAqIGZldGNoZWQgdW5sZXNzIHRoaXMgaXMgc3BlY2lmaWVkIGF0IGNvbnN0cnVjdGlvbiB0aW1lIG9yIHRocm91Z2hcbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcCNzZXRWaWV3fS5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICovXG5mdW5jdGlvbiByZW1vdmVMYXllck1hcFByb3BlcnR5KGxheWVyKSB7XG4gIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgbGF5ZXIuc2V0TWFwSW50ZXJuYWwobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICBsYXllci5nZXRMYXllcnMoKS5mb3JFYWNoKHJlbW92ZUxheWVyTWFwUHJvcGVydHkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gKiBAcGFyYW0ge01hcH0gbWFwIE1hcC5cbiAqL1xuZnVuY3Rpb24gc2V0TGF5ZXJNYXBQcm9wZXJ0eShsYXllciwgbWFwKSB7XG4gIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgbGF5ZXIuc2V0TWFwSW50ZXJuYWwobWFwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgIGNvbnN0IGxheWVycyA9IGxheWVyLmdldExheWVycygpLmdldEFycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHNldExheWVyTWFwUHJvcGVydHkobGF5ZXJzW2ldLCBtYXApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFRoZSBtYXAgaXMgdGhlIGNvcmUgY29tcG9uZW50IG9mIE9wZW5MYXllcnMuIEZvciBhIG1hcCB0byByZW5kZXIsIGEgdmlldyxcbiAqIG9uZSBvciBtb3JlIGxheWVycywgYW5kIGEgdGFyZ2V0IGNvbnRhaW5lciBhcmUgbmVlZGVkOlxuICpcbiAqICAgICBpbXBvcnQgTWFwIGZyb20gJ29sL01hcC5qcyc7XG4gKiAgICAgaW1wb3J0IFZpZXcgZnJvbSAnb2wvVmlldy5qcyc7XG4gKiAgICAgaW1wb3J0IFRpbGVMYXllciBmcm9tICdvbC9sYXllci9UaWxlLmpzJztcbiAqICAgICBpbXBvcnQgT1NNIGZyb20gJ29sL3NvdXJjZS9PU00uanMnO1xuICpcbiAqICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKHtcbiAqICAgICAgIHZpZXc6IG5ldyBWaWV3KHtcbiAqICAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gKiAgICAgICAgIHpvb206IDEsXG4gKiAgICAgICB9KSxcbiAqICAgICAgIGxheWVyczogW1xuICogICAgICAgICBuZXcgVGlsZUxheWVyKHtcbiAqICAgICAgICAgICBzb3VyY2U6IG5ldyBPU00oKSxcbiAqICAgICAgICAgfSksXG4gKiAgICAgICBdLFxuICogICAgICAgdGFyZ2V0OiAnbWFwJyxcbiAqICAgICB9KTtcbiAqXG4gKiBUaGUgYWJvdmUgc25pcHBldCBjcmVhdGVzIGEgbWFwIHVzaW5nIGEge0BsaW5rIG1vZHVsZTpvbC9sYXllci9UaWxlflRpbGVMYXllcn0gdG9cbiAqIGRpc3BsYXkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvT1NNfk9TTX0gT1NNIGRhdGEgYW5kIHJlbmRlciBpdCB0byBhIERPTVxuICogZWxlbWVudCB3aXRoIHRoZSBpZCBgbWFwYC5cbiAqXG4gKiBUaGUgY29uc3RydWN0b3IgcGxhY2VzIGEgdmlld3BvcnQgY29udGFpbmVyICh3aXRoIENTUyBjbGFzcyBuYW1lXG4gKiBgb2wtdmlld3BvcnRgKSBpbiB0aGUgdGFyZ2V0IGVsZW1lbnQgKHNlZSBgZ2V0Vmlld3BvcnQoKWApLCBhbmQgdGhlbiB0d29cbiAqIGZ1cnRoZXIgZWxlbWVudHMgd2l0aGluIHRoZSB2aWV3cG9ydDogb25lIHdpdGggQ1NTIGNsYXNzIG5hbWVcbiAqIGBvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudGAgZm9yIGNvbnRyb2xzIGFuZCBzb21lIG92ZXJsYXlzLCBhbmQgb25lIHdpdGhcbiAqIENTUyBjbGFzcyBuYW1lIGBvbC1vdmVybGF5Y29udGFpbmVyYCBmb3Igb3RoZXIgb3ZlcmxheXMgKHNlZSB0aGUgYHN0b3BFdmVudGBcbiAqIG9wdGlvbiBvZiB7QGxpbmsgbW9kdWxlOm9sL092ZXJsYXl+T3ZlcmxheX0gZm9yIHRoZSBkaWZmZXJlbmNlKS4gVGhlIG1hcFxuICogaXRzZWxmIGlzIHBsYWNlZCBpbiBhIGZ1cnRoZXIgZWxlbWVudCB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuICpcbiAqIExheWVycyBhcmUgc3RvcmVkIGFzIGEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IGluXG4gKiBsYXllckdyb3Vwcy4gQSB0b3AtbGV2ZWwgZ3JvdXAgaXMgcHJvdmlkZWQgYnkgdGhlIGxpYnJhcnkuIFRoaXMgaXMgd2hhdCBpc1xuICogYWNjZXNzZWQgYnkgYGdldExheWVyR3JvdXBgIGFuZCBgc2V0TGF5ZXJHcm91cGAuIExheWVycyBlbnRlcmVkIGluIHRoZVxuICogb3B0aW9ucyBhcmUgYWRkZWQgdG8gdGhpcyBncm91cCwgYW5kIGBhZGRMYXllcmAgYW5kIGByZW1vdmVMYXllcmAgY2hhbmdlIHRoZVxuICogbGF5ZXIgY29sbGVjdGlvbiBpbiB0aGUgZ3JvdXAuIGBnZXRMYXllcnNgIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yXG4gKiBgZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpYC4gTm90ZSB0aGF0IHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvR3JvdXB+TGF5ZXJHcm91cH1cbiAqIGlzIGEgc3ViY2xhc3Mgb2Yge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfkJhc2VMYXllcn0sIHNvIGxheWVycyBlbnRlcmVkIGluIHRoZVxuICogb3B0aW9ucyBvciBhZGRlZCB3aXRoIGBhZGRMYXllcmAgY2FuIGJlIGdyb3Vwcywgd2hpY2ggY2FuIGNvbnRhaW4gZnVydGhlclxuICogZ3JvdXBzLCBhbmQgc28gb24uXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLk1hcEJyb3dzZXJFdmVudFxuICogQGZpcmVzIGltcG9ydChcIi4vTWFwRXZlbnQuanNcIikuTWFwRXZlbnRcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL3JlbmRlci9FdmVudC5qc1wiKS5kZWZhdWx0I3ByZWNvbXBvc2VcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL3JlbmRlci9FdmVudC5qc1wiKS5kZWZhdWx0I3Bvc3Rjb21wb3NlXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9yZW5kZXIvRXZlbnQuanNcIikuZGVmYXVsdCNyZW5kZXJjb21wbGV0ZVxuICogQGFwaVxuICovXG5jbGFzcyBNYXAgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TWFwT3B0aW9uc30gW29wdGlvbnNdIE1hcCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7TWFwRXZlbnRIYW5kbGVyPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7TWFwRXZlbnRIYW5kbGVyPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNYXBFdmVudEhhbmRsZXI8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIGNvbnN0IG9wdGlvbnNJbnRlcm5hbCA9IGNyZWF0ZU9wdGlvbnNJbnRlcm5hbChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyQ29tcGxldGVfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZF8gPSB0cnVlO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF8gPSB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudC5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4VGlsZXNMb2FkaW5nXyA9XG4gICAgICBvcHRpb25zLm1heFRpbGVzTG9hZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhUaWxlc0xvYWRpbmcgOiAxNjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID1cbiAgICAgIG9wdGlvbnMucGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5waXhlbFJhdGlvXG4gICAgICAgIDogREVWSUNFX1BJWEVMX1JBVElPO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD59XG4gICAgICovXG4gICAgdGhpcy5wb3N0UmVuZGVyVGltZW91dEhhbmRsZV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvbkRlbGF5XyA9IHRoaXMuYW5pbWF0aW9uRGVsYXlfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVJbmRleF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0ZyYW1lU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXh0ZW50IGF0IHRoZSBwcmV2aW91cyAnbW92ZWVuZCcgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNFeHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdwb3J0XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMudmlld3BvcnRfLmNsYXNzTmFtZSA9XG4gICAgICAnb2wtdmlld3BvcnQnICsgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyA/ICcgb2wtdG91Y2gnIDogJycpO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5zdHlsZS56SW5kZXggPSAnMCc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXy5jbGFzc05hbWUgPSAnb2wtb3ZlcmxheWNvbnRhaW5lcic7XG4gICAgdGhpcy52aWV3cG9ydF8uYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5Q29udGFpbmVyXyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshSFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uc3R5bGUuekluZGV4ID0gJzAnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uY2xhc3NOYW1lID0gJ29sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50JztcbiAgICB0aGlzLnZpZXdwb3J0Xy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge01hcEJyb3dzZXJFdmVudEhhbmRsZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tb3ZlVG9sZXJhbmNlXyA9IG9wdGlvbnMubW92ZVRvbGVyYW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fERvY3VtZW50fVxuICAgICAqL1xuICAgIHRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF8gPSBvcHRpb25zSW50ZXJuYWwua2V5Ym9hcmRFdmVudFRhcmdldDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0Q2hhbmdlSGFuZGxlcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRFbGVtZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcl8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy51cGRhdGVTaXplKCkpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbHMgPSBvcHRpb25zSW50ZXJuYWwuY29udHJvbHMgfHwgZGVmYXVsdENvbnRyb2xzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmludGVyYWN0aW9ucyA9XG4gICAgICBvcHRpb25zSW50ZXJuYWwuaW50ZXJhY3Rpb25zIHx8XG4gICAgICBkZWZhdWx0SW50ZXJhY3Rpb25zKHtcbiAgICAgICAgb25Gb2N1c09ubHk6IHRydWUsXG4gICAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheXNfID0gb3B0aW9uc0ludGVybmFsLm92ZXJsYXlzO1xuXG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgb2Ygb3ZlcmxheXMgYnkgaWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUlkSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9yZW5kZXJlci9NYXAuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PFBvc3RSZW5kZXJGdW5jdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGlsZVF1ZXVlfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVF1ZXVlXyA9IG5ldyBUaWxlUXVldWUoXG4gICAgICB0aGlzLmdldFRpbGVQcmlvcml0eS5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5oYW5kbGVUaWxlQ2hhbmdlXy5iaW5kKHRoaXMpXG4gICAgKTtcblxuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoXG4gICAgICBNYXBQcm9wZXJ0eS5MQVlFUkdST1VQLFxuICAgICAgdGhpcy5oYW5kbGVMYXllckdyb3VwQ2hhbmdlZF9cbiAgICApO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoTWFwUHJvcGVydHkuVklFVywgdGhpcy5oYW5kbGVWaWV3Q2hhbmdlZF8pO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoTWFwUHJvcGVydHkuU0laRSwgdGhpcy5oYW5kbGVTaXplQ2hhbmdlZF8pO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoTWFwUHJvcGVydHkuVEFSR0VULCB0aGlzLmhhbmRsZVRhcmdldENoYW5nZWRfKTtcblxuICAgIC8vIHNldFByb3BlcnRpZXMgd2lsbCB0cmlnZ2VyIHRoZSByZW5kZXJpbmcgb2YgdGhlIG1hcCBpZiB0aGUgbWFwXG4gICAgLy8gaXMgXCJkZWZpbmVkXCIgYWxyZWFkeS5cbiAgICB0aGlzLnNldFByb3BlcnRpZXMob3B0aW9uc0ludGVybmFsLnZhbHVlcyk7XG5cbiAgICBjb25zdCBtYXAgPSB0aGlzO1xuICAgIGlmIChvcHRpb25zLnZpZXcgJiYgIShvcHRpb25zLnZpZXcgaW5zdGFuY2VvZiBWaWV3KSkge1xuICAgICAgb3B0aW9ucy52aWV3LnRoZW4oZnVuY3Rpb24gKHZpZXdPcHRpb25zKSB7XG4gICAgICAgIG1hcC5zZXRWaWV3KG5ldyBWaWV3KHZpZXdPcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnRcbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKHRoaXMpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLmNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAodGhpcyk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLm92ZXJsYXlzXy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuYWRkT3ZlcmxheUludGVybmFsXyhldmVudC5lbGVtZW50KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5vdmVybGF5c18uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGV2ZW50LmVsZW1lbnQuZ2V0SWQoKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAgICAgKi9cbiAgICAgIChjb250cm9sKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuc2V0TWFwKHRoaXMpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9ucy5mb3JFYWNoKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIChpbnRlcmFjdGlvbikgPT4ge1xuICAgICAgICBpbnRlcmFjdGlvbi5zZXRNYXAodGhpcyk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMub3ZlcmxheXNfLmZvckVhY2godGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR9IGNvbnRyb2wgQ29udHJvbC5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRkQ29udHJvbChjb250cm9sKSB7XG4gICAgdGhpcy5nZXRDb250cm9scygpLnB1c2goY29udHJvbCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBpbnRlcmFjdGlvbiB0byB0aGUgbWFwLiBJZiB5b3Ugd2FudCB0byBhZGQgYW4gaW50ZXJhY3Rpb25cbiAgICogYXQgYW5vdGhlciBwb2ludCBvZiB0aGUgY29sbGVjdGlvbiB1c2UgYGdldEludGVyYWN0aW9ucygpYCBhbmQgdGhlIG1ldGhvZHNcbiAgICogYXZhaWxhYmxlIG9uIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufS4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuICAgKiBzdG9wIHRoZSBldmVudCBwcm9wYWdhdGlvbiBmcm9tIHRoZSBoYW5kbGVFdmVudCBmdW5jdGlvbi4gVGhlIGludGVyYWN0aW9uc1xuICAgKiBnZXQgdG8gaGFuZGxlIHRoZSBldmVudHMgaW4gdGhlIHJldmVyc2Ugb3JkZXIgb2YgdGhpcyBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24gdG8gYWRkLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRJbnRlcmFjdGlvbihpbnRlcmFjdGlvbikge1xuICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkucHVzaChpbnRlcmFjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIHRvcCBvZiB0aGlzIG1hcC4gSWYgeW91IHdhbnQgdG8gYWRkIGEgbGF5ZXJcbiAgICogZWxzZXdoZXJlIGluIHRoZSBzdGFjaywgdXNlIGBnZXRMYXllcnMoKWAgYW5kIHRoZSBtZXRob2RzIGF2YWlsYWJsZSBvblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRMYXllcihsYXllcikge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpO1xuICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvR3JvdXAuanNcIikuR3JvdXBFdmVudH0gZXZlbnQgVGhlIGxheWVyIGFkZCBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyQWRkXyhldmVudCkge1xuICAgIHNldExheWVyTWFwUHJvcGVydHkoZXZlbnQubGF5ZXIsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gb3ZlcmxheSB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZE92ZXJsYXkob3ZlcmxheSkge1xuICAgIHRoaXMuZ2V0T3ZlcmxheXMoKS5wdXNoKG92ZXJsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGVhbHMgd2l0aCBtYXAncyBvdmVybGF5IGNvbGxlY3Rpb24gY2hhbmdlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gb3ZlcmxheSBPdmVybGF5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkT3ZlcmxheUludGVybmFsXyhvdmVybGF5KSB7XG4gICAgY29uc3QgaWQgPSBvdmVybGF5LmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldID0gb3ZlcmxheTtcbiAgICB9XG4gICAgb3ZlcmxheS5zZXRNYXAodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy5jb250cm9scy5jbGVhcigpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5vdmVybGF5c18uY2xlYXIoKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5zZXRUYXJnZXQobnVsbCk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LCBhbmQgZXhlY3V0ZSBhXG4gICAqIGNhbGxiYWNrIHdpdGggZWFjaCBpbnRlcnNlY3RpbmcgZmVhdHVyZS4gTGF5ZXJzIGluY2x1ZGVkIGluIHRoZSBkZXRlY3Rpb24gY2FuXG4gICAqIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaCB0aGUgYGxheWVyRmlsdGVyYCBvcHRpb24gaW4gYG9wdGlvbnNgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgaW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vc291cmNlL1NvdXJjZVwiKS5kZWZhdWx0PiwgaW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50cy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIG9uZVxuICAgKiAgICAge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUgZmVhdHVyZX0gb3JcbiAgICogICAgIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV+UmVuZGVyRmVhdHVyZSByZW5kZXIgZmVhdHVyZX0gYXQgdGhlIHBpeGVsLCB0aGUgc2Vjb25kIGlzXG4gICAqICAgICB0aGUge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciBsYXllcn0gb2YgdGhlIGZlYXR1cmUgYW5kIHdpbGwgYmUgbnVsbCBmb3JcbiAgICogICAgIHVubWFuYWdlZCBsYXllcnMuIFRvIHN0b3AgZGV0ZWN0aW9uLCBjYWxsYmFjayBmdW5jdGlvbnMgY2FuIHJldHVybiBhXG4gICAqICAgICB0cnV0aHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7QXRQaXhlbE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LCBpLmUuIHRoZSByZXR1cm4gdmFsdWUgb2YgbGFzdFxuICAgKiBjYWxsYmFjayBleGVjdXRpb24sIG9yIHRoZSBmaXJzdCB0cnV0aHkgY2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfIHx8ICF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG4gICAgY29uc3QgaGl0VG9sZXJhbmNlID1cbiAgICAgIG9wdGlvbnMuaGl0VG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG4gICAgY29uc3QgbGF5ZXJGaWx0ZXIgPVxuICAgICAgb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYXllckZpbHRlciA6IFRSVUU7XG4gICAgY29uc3QgY2hlY2tXcmFwcGVkID0gb3B0aW9ucy5jaGVja1dyYXBwZWQgIT09IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsXG4gICAgICB0aGlzLmZyYW1lU3RhdGVfLFxuICAgICAgaGl0VG9sZXJhbmNlLFxuICAgICAgY2hlY2tXcmFwcGVkLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBudWxsLFxuICAgICAgbGF5ZXJGaWx0ZXIsXG4gICAgICBudWxsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlPn0gVGhlIGRldGVjdGVkIGZlYXR1cmVzIG9yXG4gICAqIGFuIGVtcHR5IGFycmF5IGlmIG5vbmUgd2VyZSBmb3VuZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmVhdHVyZXNBdFBpeGVsKHBpeGVsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2hGZWF0dXJlQXRQaXhlbChcbiAgICAgIHBpeGVsLFxuICAgICAgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBsYXllcnMgZnJvbSBhbGwgbGF5ZXIgZ3JvdXBzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBMYXllcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFsbExheWVycygpIHtcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBhZGRMYXllcnNGcm9tKGxheWVyR3JvdXApIHtcbiAgICAgIGxheWVyR3JvdXAuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgICAgICAgIGFkZExheWVyc0Zyb20obGF5ZXIuZ2V0TGF5ZXJzKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExheWVyc0Zyb20odGhpcy5nZXRMYXllcnMoKSk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgZmVhdHVyZXMgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlXG4gICAqIGRldGVjdGlvbiBjYW4gYmUgY29uZmlndXJlZCB0aHJvdWdoIHRoZSBgbGF5ZXJGaWx0ZXJgIG9wdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRoZXJlIGEgZmVhdHVyZSBhdCB0aGUgZ2l2ZW4gcGl4ZWw/XG4gICAqIEBhcGlcbiAgICovXG4gIGhhc0ZlYXR1cmVBdFBpeGVsKHBpeGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfIHx8ICF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG4gICAgY29uc3QgbGF5ZXJGaWx0ZXIgPVxuICAgICAgb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYXllckZpbHRlciA6IFRSVUU7XG4gICAgY29uc3QgaGl0VG9sZXJhbmNlID1cbiAgICAgIG9wdGlvbnMuaGl0VG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG4gICAgY29uc3QgY2hlY2tXcmFwcGVkID0gb3B0aW9ucy5jaGVja1dyYXBwZWQgIT09IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5oYXNGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHRoaXMuZnJhbWVTdGF0ZV8sXG4gICAgICBoaXRUb2xlcmFuY2UsXG4gICAgICBjaGVja1dyYXBwZWQsXG4gICAgICBsYXllckZpbHRlcixcbiAgICAgIG51bGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgaW4gdXNlciBwcm9qZWN0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFdmVudENvb3JkaW5hdGUoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMuZ2V0RXZlbnRQaXhlbChldmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgaW4gdmlldyBwcm9qZWN0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKi9cbiAgZ2V0RXZlbnRDb29yZGluYXRlSW50ZXJuYWwoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwodGhpcy5nZXRFdmVudFBpeGVsKGV2ZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWFwIHBpeGVsIHBvc2l0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge1VJRXZlbnR8e2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfX0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IFBpeGVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFdmVudFBpeGVsKGV2ZW50KSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0XztcbiAgICBjb25zdCB2aWV3cG9ydFBvc2l0aW9uID0gdmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgdmlld3BvcnRTaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgY29uc3Qgc2NhbGVYID0gdmlld3BvcnRQb3NpdGlvbi53aWR0aCAvIHZpZXdwb3J0U2l6ZVswXTtcbiAgICBjb25zdCBzY2FsZVkgPSB2aWV3cG9ydFBvc2l0aW9uLmhlaWdodCAvIHZpZXdwb3J0U2l6ZVsxXTtcbiAgICBjb25zdCBldmVudFBvc2l0aW9uID1cbiAgICAgIC8vRklYTUUgQXJlIHdlIHJlYWxseSBjYWxsaW5nIHRoaXMgd2l0aCBhIFRvdWNoRXZlbnQgYW55d2hlcmU/XG4gICAgICAnY2hhbmdlZFRvdWNoZXMnIGluIGV2ZW50XG4gICAgICAgID8gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyAoZXZlbnQpLmNoYW5nZWRUb3VjaGVzWzBdXG4gICAgICAgIDogLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAoZXZlbnQpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIChldmVudFBvc2l0aW9uLmNsaWVudFggLSB2aWV3cG9ydFBvc2l0aW9uLmxlZnQpIC8gc2NhbGVYLFxuICAgICAgKGV2ZW50UG9zaXRpb24uY2xpZW50WSAtIHZpZXdwb3J0UG9zaXRpb24udG9wKSAvIHNjYWxlWSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFyZ2V0IGluIHdoaWNoIHRoaXMgbWFwIGlzIHJlbmRlcmVkLlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHdoYXQgaXMgZW50ZXJlZCBhcyBhbiBvcHRpb24gb3IgaW4gc2V0VGFyZ2V0OlxuICAgKiBpZiB0aGF0IHdhcyBhbiBlbGVtZW50LCBpdCByZXR1cm5zIGFuIGVsZW1lbnQ7IGlmIGEgc3RyaW5nLCBpdCByZXR1cm5zIHRoYXQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fHN0cmluZ3x1bmRlZmluZWR9IFRoZSBFbGVtZW50IG9yIGlkIG9mIHRoZSBFbGVtZW50IHRoYXQgdGhlXG4gICAqICAgICBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChNYXBQcm9wZXJ0eS5UQVJHRVQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIERPTSBlbGVtZW50IGludG8gd2hpY2ggdGhpcyBtYXAgaXMgcmVuZGVyZWQuIEluIGNvbnRyYXN0IHRvXG4gICAqIGBnZXRUYXJnZXRgIHRoaXMgbWV0aG9kIGFsd2F5cyByZXR1cm4gYW4gYEVsZW1lbnRgLCBvciBgbnVsbGAgaWYgdGhlXG4gICAqIG1hcCBoYXMgbm8gdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIGVsZW1lbnQgdGhhdCB0aGUgbWFwIGlzIHJlbmRlcmVkIGluLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUYXJnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldEVsZW1lbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBwaXhlbC4gIFRoaXMgcmV0dXJucyBhIGNvb3JkaW5hdGUgaW4gdGhlXG4gICAqIHVzZXIgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgZm9yIHRoZSBwaXhlbCBwb3NpdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0b1VzZXJDb29yZGluYXRlKFxuICAgICAgdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpLFxuICAgICAgdGhpcy5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gcGl4ZWwuICBUaGlzIHJldHVybnMgYSBjb29yZGluYXRlIGluIHRoZVxuICAgKiBtYXAgdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsIHBvc2l0aW9uIGluIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaGUgY29vcmRpbmF0ZSBmb3IgdGhlIHBpeGVsIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKHBpeGVsKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0sIHBpeGVsLnNsaWNlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGNvbnRyb2xzLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIGNvbnRyb2xzXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBDb250cm9scy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29udHJvbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgb3ZlcmxheXMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgb3ZlcmxheXNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBPdmVybGF5cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3ZlcmxheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvdmVybGF5IGJ5IGl0cyBpZGVudGlmaWVyICh0aGUgdmFsdWUgcmV0dXJuZWQgYnkgb3ZlcmxheS5nZXRJZCgpKS5cbiAgICogTm90ZSB0aGF0IHRoZSBpbmRleCB0cmVhdHMgc3RyaW5nIGFuZCBudW1lcmljIGlkZW50aWZpZXJzIGFzIHRoZSBzYW1lLiBTb1xuICAgKiBgbWFwLmdldE92ZXJsYXlCeUlkKDIpYCB3aWxsIHJldHVybiBhbiBvdmVybGF5IHdpdGggaWQgYCcyJ2Agb3IgYDJgLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIE92ZXJsYXkgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IE92ZXJsYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE92ZXJsYXlCeUlkKGlkKSB7XG4gICAgY29uc3Qgb3ZlcmxheSA9IHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIHJldHVybiBvdmVybGF5ICE9PSB1bmRlZmluZWQgPyBvdmVybGF5IDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBpbnRlcmFjdGlvbnMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgaW50ZXJhY3Rpb25zXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKlxuICAgKiBJbnRlcmFjdGlvbnMgYXJlIHVzZWQgZm9yIGUuZy4gcGFuLCB6b29tIGFuZCByb3RhdGUuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gSW50ZXJhY3Rpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbnRlcmFjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXJncm91cCBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXAuXG4gICAqIEByZXR1cm4ge0xheWVyR3JvdXB9IEEgbGF5ZXIgZ3JvdXAgY29udGFpbmluZyB0aGUgbGF5ZXJzIGluIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXllckdyb3VwKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge0xheWVyR3JvdXB9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5MQVlFUkdST1VQKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYW55IGV4aXN0aW5nIGxheWVycyBhbmQgYWRkIGxheWVycyB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0PnxDb2xsZWN0aW9uPGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIFRoZSBsYXllcnMgdG8gYmUgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGF5ZXJzKGxheWVycykge1xuICAgIGNvbnN0IGdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKGxheWVycyBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIGdyb3VwLnNldExheWVycyhsYXllcnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBncm91cC5nZXRMYXllcnMoKTtcbiAgICBjb2xsZWN0aW9uLmNsZWFyKCk7XG4gICAgY29sbGVjdGlvbi5leHRlbmQobGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gb2YgbGF5ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBMYXllcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExheWVycygpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVycyBoYXZlIHNvdXJjZXMgdGhhdCBhcmUgc3RpbGwgbG9hZGluZy5cbiAgICovXG4gIGdldExvYWRpbmdPck5vdFJlYWR5KCkge1xuICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXNBcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGxheWVyU3RhdGVzQXJyYXlbaV07XG4gICAgICBpZiAoIXN0YXRlLnZpc2libGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlciA9IHN0YXRlLmxheWVyLmdldFJlbmRlcmVyKCk7XG4gICAgICBpZiAocmVuZGVyZXIgJiYgIXJlbmRlcmVyLnJlYWR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc291cmNlID0gc3RhdGUubGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICBpZiAoc291cmNlICYmIHNvdXJjZS5sb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwaXhlbCBmb3IgYSBjb29yZGluYXRlLiAgVGhpcyB0YWtlcyBhIGNvb3JkaW5hdGUgaW4gdGhlIHVzZXJcbiAgICogcHJvamVjdGlvbiBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBBIG1hcCBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBBIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgIGNvbnN0IHZpZXdDb29yZGluYXRlID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHRoaXMuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZUludGVybmFsKHZpZXdDb29yZGluYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBpeGVsIGZvciBhIGNvb3JkaW5hdGUuICBUaGlzIHRha2VzIGEgY29vcmRpbmF0ZSBpbiB0aGUgbWFwIHZpZXdcbiAgICogcHJvamVjdGlvbiBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBBIG1hcCBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBBIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqL1xuICBnZXRQaXhlbEZyb21Db29yZGluYXRlSW50ZXJuYWwoY29vcmRpbmF0ZSkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhcHBseVRyYW5zZm9ybShcbiAgICAgIGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBjb29yZGluYXRlLnNsaWNlKDAsIDIpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCByZW5kZXJlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9yZW5kZXJlci9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBSZW5kZXJlclxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIG1hcCBpbiB0aGUgRE9NLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoTWFwUHJvcGVydHkuU0laRSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXAuIEEgdmlldyBtYW5hZ2VzIHByb3BlcnRpZXMgc3VjaCBhc1xuICAgKiBjZW50ZXIgYW5kIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge1ZpZXd9IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFZpZXcoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Vmlld30gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LlZJRVcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFZpZXdwb3J0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRWaWV3cG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHRoYXQgc2VydmVzIGFzIHRoZSBjb250YWluZXIgZm9yIG92ZXJsYXlzLiAgRWxlbWVudHMgYWRkZWQgdG9cbiAgICogdGhpcyBjb250YWluZXIgd2lsbCBsZXQgbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGV2ZW50cyB0aHJvdWdoIHRvIHRoZSBtYXAsXG4gICAqIHNvIGNsaWNrcyBhbmQgZ2VzdHVyZXMgb24gYW4gb3ZlcmxheSB3aWxsIHRyaWdnZXIge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fVxuICAgKiBldmVudHMuXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gVGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyLlxuICAgKi9cbiAgZ2V0T3ZlcmxheUNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgYSBjb250YWluZXIgZm9yIG92ZXJsYXlzIHRoYXQgZG9uJ3QgYWxsb3dcbiAgICogZXZlbnQgcHJvcGFnYXRpb24uIEVsZW1lbnRzIGFkZGVkIHRvIHRoaXMgY29udGFpbmVyIHdvbid0IGxldCBtb3VzZWRvd24gYW5kXG4gICAqIHRvdWNoc3RhcnQgZXZlbnRzIHRocm91Z2ggdG8gdGhlIG1hcCwgc28gY2xpY2tzIGFuZCBnZXN0dXJlcyBvbiBhbiBvdmVybGF5XG4gICAqIGRvbid0IHRyaWdnZXIgYW55IHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0uXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gVGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyIHRoYXQgc3RvcHMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0T3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRG9jdW1lbnR9IFRoZSBkb2N1bWVudCB3aGVyZSB0aGUgbWFwIGlzIGRpc3BsYXllZC5cbiAgICovXG4gIGdldE93bmVyRG9jdW1lbnQoKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuICAgIHJldHVybiB0YXJnZXRFbGVtZW50ID8gdGFyZ2V0RWxlbWVudC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGlsZVNvdXJjZUtleSBUaWxlIHNvdXJjZSBrZXkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRpbGVDZW50ZXIgVGlsZSBjZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlUmVzb2x1dGlvbiBUaWxlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwcmlvcml0eS5cbiAgICovXG4gIGdldFRpbGVQcmlvcml0eSh0aWxlLCB0aWxlU291cmNlS2V5LCB0aWxlQ2VudGVyLCB0aWxlUmVzb2x1dGlvbikge1xuICAgIHJldHVybiBnZXRUaWxlUHJpb3JpdHkoXG4gICAgICB0aGlzLmZyYW1lU3RhdGVfLFxuICAgICAgdGlsZSxcbiAgICAgIHRpbGVTb3VyY2VLZXksXG4gICAgICB0aWxlQ2VudGVyLFxuICAgICAgdGlsZVJlc29sdXRpb25cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VUlFdmVudH0gYnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVHlwZS5cbiAgICovXG4gIGhhbmRsZUJyb3dzZXJFdmVudChicm93c2VyRXZlbnQsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSB8fCBicm93c2VyRXZlbnQudHlwZTtcbiAgICBjb25zdCBtYXBCcm93c2VyRXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KHR5cGUsIHRoaXMsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5oYW5kbGVNYXBCcm93c2VyRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IFRoZSBldmVudCB0byBoYW5kbGUuXG4gICAqL1xuICBoYW5kbGVNYXBCcm93c2VyRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfKSB7XG4gICAgICAvLyBXaXRoIG5vIHZpZXcgZGVmaW5lZCwgd2UgY2Fubm90IHRyYW5zbGF0ZSBwaXhlbHMgaW50byBnZW9ncmFwaGljYWxcbiAgICAgIC8vIGNvb3JkaW5hdGVzIHNvIGludGVyYWN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7UG9pbnRlckV2ZW50fSAqLyAoXG4gICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICk7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gb3JpZ2luYWxFdmVudC50eXBlO1xuICAgIGlmIChcbiAgICAgIGV2ZW50VHlwZSA9PT0gUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRE9XTiB8fFxuICAgICAgZXZlbnRUeXBlID09PSBFdmVudFR5cGUuV0hFRUwgfHxcbiAgICAgIGV2ZW50VHlwZSA9PT0gRXZlbnRUeXBlLktFWURPV05cbiAgICApIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuZ2V0T3duZXJEb2N1bWVudCgpO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0aGlzLnZpZXdwb3J0Xy5nZXRSb290Tm9kZVxuICAgICAgICA/IHRoaXMudmlld3BvcnRfLmdldFJvb3ROb2RlKClcbiAgICAgICAgOiBkb2M7XG4gICAgICBjb25zdCB0YXJnZXQgPSAvKiogQHR5cGUge05vZGV9ICovIChvcmlnaW5hbEV2ZW50LnRhcmdldCk7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIEFib3J0IGlmIHRoZSB0YXJnZXQgaXMgYSBjaGlsZCBvZiB0aGUgY29udGFpbmVyIGZvciBlbGVtZW50cyB3aG9zZSBldmVudHMgYXJlIG5vdCBtZWFudFxuICAgICAgICAvLyB0byBiZSBoYW5kbGVkIGJ5IG1hcCBpbnRlcmFjdGlvbnMuXG4gICAgICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8uY29udGFpbnModGFyZ2V0KSB8fFxuICAgICAgICAvLyBBYm9ydCBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIGEgY2hpbGQgb2YgdGhlIGNvbnRhaW5lciB0aGF0IGlzIG5vIGxvbmdlciBpbiB0aGUgcGFnZS5cbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgdGhlIHRhcmdldCB0byBubyBsb25nZXIgYmUgaW4gdGhlIHBhZ2UgaWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBhblxuICAgICAgICAvLyBldmVudCBsaXN0ZW5lciwgdGhpcyBtaWdodCBoYXBwZW4gaW4gYSBDb250cm9sIHRoYXQgcmVjcmVhdGVzIGl0J3MgY29udGVudCBiYXNlZCBvblxuICAgICAgICAvLyB1c2VyIGludGVyYWN0aW9uIGVpdGhlciBtYW51YWxseSBvciB2aWEgYSByZW5kZXIgaW4gc29tZXRoaW5nIGxpa2UgaHR0cHM6Ly9yZWFjdGpzLm9yZy9cbiAgICAgICAgIShyb290Tm9kZSA9PT0gZG9jID8gZG9jLmRvY3VtZW50RWxlbWVudCA6IHJvb3ROb2RlKS5jb250YWlucyh0YXJnZXQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXBCcm93c2VyRXZlbnQuZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hFdmVudChtYXBCcm93c2VyRXZlbnQpICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgaW50ZXJhY3Rpb25zQXJyYXkgPSB0aGlzLmdldEludGVyYWN0aW9ucygpLmdldEFycmF5KCkuc2xpY2UoKTtcbiAgICAgIGZvciAobGV0IGkgPSBpbnRlcmFjdGlvbnNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uc0FycmF5W2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaW50ZXJhY3Rpb24uZ2V0TWFwKCkgIT09IHRoaXMgfHxcbiAgICAgICAgICAhaW50ZXJhY3Rpb24uZ2V0QWN0aXZlKCkgfHxcbiAgICAgICAgICAhdGhpcy5nZXRUYXJnZXRFbGVtZW50KClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udCA9IGludGVyYWN0aW9uLmhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIGlmICghY29udCB8fCBtYXBCcm93c2VyRXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlUG9zdFJlbmRlcigpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcblxuICAgIC8vIE1hbmFnZSB0aGUgdGlsZSBxdWV1ZVxuICAgIC8vIEltYWdlIGxvYWRzIGFyZSBleHBlbnNpdmUgYW5kIGEgbGltaXRlZCByZXNvdXJjZSwgc28gdHJ5IHRvIHVzZSB0aGVtXG4gICAgLy8gZWZmaWNpZW50bHk6XG4gICAgLy8gKiBXaGVuIHRoZSB2aWV3IGlzIHN0YXRpYyB3ZSBhbGxvdyBhIGxhcmdlIG51bWJlciBvZiBwYXJhbGxlbCB0aWxlIGxvYWRzXG4gICAgLy8gICB0byBjb21wbGV0ZSB0aGUgZnJhbWUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgICAvLyAqIFdoZW4gYW5pbWF0aW5nIG9yIGludGVyYWN0aW5nLCBpbWFnZSBsb2FkcyBjYW4gY2F1c2UgamFua3MsIHNvIHdlIHJlZHVjZVxuICAgIC8vICAgdGhlIG1heGltdW0gbnVtYmVyIG9mIGxvYWRzIHBlciBmcmFtZSBhbmQgbGltaXQgdGhlIG51bWJlciBvZiBwYXJhbGxlbFxuICAgIC8vICAgdGlsZSBsb2FkcyB0byByZW1haW4gcmVhY3RpdmUgdG8gdmlldyBjaGFuZ2VzIGFuZCB0byByZWR1Y2UgdGhlIGNoYW5jZSBvZlxuICAgIC8vICAgbG9hZGluZyB0aWxlcyB0aGF0IHdpbGwgcXVpY2tseSBkaXNhcHBlYXIgZnJvbSB2aWV3LlxuICAgIGNvbnN0IHRpbGVRdWV1ZSA9IHRoaXMudGlsZVF1ZXVlXztcbiAgICBpZiAoIXRpbGVRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIGxldCBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLm1heFRpbGVzTG9hZGluZ187XG4gICAgICBsZXQgbWF4TmV3TG9hZHMgPSBtYXhUb3RhbExvYWRpbmc7XG4gICAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgICBjb25zdCBoaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgICAgICBpZiAoaGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSB8fCBoaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pIHtcbiAgICAgICAgICBjb25zdCBsb3dPbkZyYW1lQnVkZ2V0ID0gRGF0ZS5ub3coKSAtIGZyYW1lU3RhdGUudGltZSA+IDg7XG4gICAgICAgICAgbWF4VG90YWxMb2FkaW5nID0gbG93T25GcmFtZUJ1ZGdldCA/IDAgOiA4O1xuICAgICAgICAgIG1heE5ld0xvYWRzID0gbG93T25GcmFtZUJ1ZGdldCA/IDAgOiAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGlsZVF1ZXVlLmdldFRpbGVzTG9hZGluZygpIDwgbWF4VG90YWxMb2FkaW5nKSB7XG4gICAgICAgIHRpbGVRdWV1ZS5yZXByaW9yaXRpemUoKTsgLy8gRklYTUUgb25seSBjYWxsIGlmIHZpZXcgaGFzIGNoYW5nZWRcbiAgICAgICAgdGlsZVF1ZXVlLmxvYWRNb3JlVGlsZXMobWF4VG90YWxMb2FkaW5nLCBtYXhOZXdMb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lU3RhdGUgJiYgdGhpcy5yZW5kZXJlcl8gJiYgIWZyYW1lU3RhdGUuYW5pbWF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyQ29tcGxldGVfID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5SRU5ERVJDT01QTEVURSkpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyXy5kaXNwYXRjaFJlbmRlckV2ZW50KFxuICAgICAgICAgICAgUmVuZGVyRXZlbnRUeXBlLlJFTkRFUkNPTVBMRVRFLFxuICAgICAgICAgICAgZnJhbWVTdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9hZGVkXyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlZF8gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTE9BREVORCwgdGhpcywgZnJhbWVTdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubG9hZGVkXyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvYWRlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTE9BRFNUQVJULCB0aGlzLCBmcmFtZVN0YXRlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBvc3RSZW5kZXJGdW5jdGlvbnMgPSB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc3RSZW5kZXJGdW5jdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uc1tpXSh0aGlzLCBmcmFtZVN0YXRlKTtcbiAgICB9XG4gICAgcG9zdFJlbmRlckZ1bmN0aW9ucy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTaXplQ2hhbmdlZF8oKSB7XG4gICAgaWYgKHRoaXMuZ2V0VmlldygpICYmICF0aGlzLmdldFZpZXcoKS5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5nZXRWaWV3KCkucmVzb2x2ZUNvbnN0cmFpbnRzKDApO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRhcmdldENoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLnRhcmdldENoYW5nZUhhbmRsZXJLZXlzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHVubGlzdGVuQnlLZXkodGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c19baV0pO1xuICAgICAgfVxuICAgICAgdGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c18gPSBudWxsO1xuICAgICAgdGhpcy52aWV3cG9ydF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLkNPTlRFWFRNRU5VLFxuICAgICAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50X1xuICAgICAgKTtcbiAgICAgIHRoaXMudmlld3BvcnRfLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEV2ZW50VHlwZS5XSEVFTCxcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF9cbiAgICAgICk7XG4gICAgICB0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8gPSBudWxsO1xuICAgICAgcmVtb3ZlTm9kZSh0aGlzLnZpZXdwb3J0Xyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0RWxlbWVudF8pIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLnVub2JzZXJ2ZSh0aGlzLnRhcmdldEVsZW1lbnRfKTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gdGhpcy50YXJnZXRFbGVtZW50Xy5nZXRSb290Tm9kZSgpO1xuICAgICAgaWYgKHJvb3ROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy51bm9ic2VydmUocm9vdE5vZGUuaG9zdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNpemUodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXQgbWF5IGJlIHVuZGVmaW5lZCwgbnVsbCwgYSBzdHJpbmcgb3IgYW4gRWxlbWVudC5cbiAgICAvLyBJZiBpdCdzIGEgc3RyaW5nIHdlIGNvbnZlcnQgaXQgdG8gYW4gRWxlbWVudCBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBJZiBpdCdzIG5vdCBub3cgYW4gRWxlbWVudCB3ZSByZW1vdmUgdGhlIHZpZXdwb3J0IGZyb20gdGhlIERPTS5cbiAgICAvLyBJZiBpdCdzIGFuIEVsZW1lbnQgd2UgYXBwZW5kIHRoZSB2aWV3cG9ydCBlbGVtZW50IHRvIGl0LlxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID1cbiAgICAgIHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KSA6IHRhcmdldDtcbiAgICB0aGlzLnRhcmdldEVsZW1lbnRfID0gdGFyZ2V0RWxlbWVudDtcbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3N0UmVuZGVyVGltZW91dEhhbmRsZV8pO1xuICAgICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnJlbmRlcmVyXy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXJfID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xykge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRfKTtcbiAgICAgIGlmICghdGhpcy5yZW5kZXJlcl8pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlcl8gPSBuZXcgQ29tcG9zaXRlTWFwUmVuZGVyZXIodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8gPSBuZXcgTWFwQnJvd3NlckV2ZW50SGFuZGxlcihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5tb3ZlVG9sZXJhbmNlX1xuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIE1hcEJyb3dzZXJFdmVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGVba2V5XSxcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hcEJyb3dzZXJFdmVudC5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLnZpZXdwb3J0Xy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBFdmVudFR5cGUuQ09OVEVYVE1FTlUsXG4gICAgICAgIHRoaXMuYm91bmRIYW5kbGVCcm93c2VyRXZlbnRfLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIHRoaXMudmlld3BvcnRfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEV2ZW50VHlwZS5XSEVFTCxcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF8sXG4gICAgICAgIFBBU1NJVkVfRVZFTlRfTElTVEVORVJTID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlXG4gICAgICApO1xuXG4gICAgICBjb25zdCBrZXlib2FyZEV2ZW50VGFyZ2V0ID0gIXRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF9cbiAgICAgICAgPyB0YXJnZXRFbGVtZW50XG4gICAgICAgIDogdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0XztcbiAgICAgIHRoaXMudGFyZ2V0Q2hhbmdlSGFuZGxlcktleXNfID0gW1xuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAga2V5Ym9hcmRFdmVudFRhcmdldCxcbiAgICAgICAgICBFdmVudFR5cGUuS0VZRE9XTixcbiAgICAgICAgICB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICksXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBrZXlib2FyZEV2ZW50VGFyZ2V0LFxuICAgICAgICAgIEV2ZW50VHlwZS5LRVlQUkVTUyxcbiAgICAgICAgICB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICksXG4gICAgICBdO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0YXJnZXRFbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICBpZiAocm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLm9ic2VydmUocm9vdE5vZGUuaG9zdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy5vYnNlcnZlKHRhcmdldEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIC8vIHVwZGF0ZVNpemUgY2FsbHMgc2V0U2l6ZSwgc28gbm8gbmVlZCB0byBjYWxsIHRoaXMucmVuZGVyXG4gICAgLy8gb3Vyc2VsdmVzIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRpbGVDaGFuZ2VfKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVZpZXdDaGFuZ2VkXygpIHtcbiAgICBpZiAodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gdGhpcy5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRTaXplXyh0aGlzLmdldFNpemUoKSk7XG5cbiAgICAgIHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgICB2aWV3LFxuICAgICAgICBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBsaXN0ZW4oXG4gICAgICAgIHZpZXcsXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIHZpZXcucmVzb2x2ZUNvbnN0cmFpbnRzKDApO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllckdyb3VwQ2hhbmdlZF8oKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXykge1xuICAgICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYXllckdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKGxheWVyR3JvdXApIHtcbiAgICAgIHRoaXMuaGFuZGxlTGF5ZXJBZGRfKG5ldyBHcm91cEV2ZW50KCdhZGRsYXllcicsIGxheWVyR3JvdXApKTtcbiAgICAgIHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuKGxheWVyR3JvdXAsIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSwgdGhpcy5yZW5kZXIsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXJHcm91cCwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5yZW5kZXIsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXJHcm91cCwgJ2FkZGxheWVyJywgdGhpcy5oYW5kbGVMYXllckFkZF8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXJHcm91cCwgJ3JlbW92ZWxheWVyJywgdGhpcy5oYW5kbGVMYXllclJlbW92ZV8sIHRoaXMpLFxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyByZW5kZXJlZC5cbiAgICovXG4gIGlzUmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFtZVN0YXRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYW5pbWF0aW9uRGVsYXlfKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVuZGVyRnJhbWVfKERhdGUubm93KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFuIGltbWVkaWF0ZSByZW5kZXIgaW4gYSBzeW5jaHJvbm91cyBtYW5uZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbmRlclN5bmMoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xyk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVkcmF3cyBhbGwgdGV4dCBhZnRlciBuZXcgZm9udHMgaGF2ZSBsb2FkZWRcbiAgICovXG4gIHJlZHJhd1RleHQoKSB7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZXMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlc1tpXS5sYXllcjtcbiAgICAgIGlmIChsYXllci5oYXNSZW5kZXJlcigpKSB7XG4gICAgICAgIGxheWVyLmdldFJlbmRlcmVyKCkuaGFuZGxlRm9udHNDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYSBtYXAgcmVuZGVyaW5nIChhdCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXJfICYmIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgY2FsbGVkIGluIGEgbGF5ZXIncyBgcHJlcmVuZGVyYCBsaXN0ZW5lci4gSXQgY2F1c2VzIGFsbCBjb2xsZWN0ZWRcbiAgICogZGVjbHV0dGVyIGl0ZW1zIHRvIGJlIGRlY2x1dHRlcmVkIGFuZCByZW5kZXJlZCBvbiB0aGUgbWFwIGltbWVkaWF0ZWx5LiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbGF5ZXJzIHRoYXQgbmVlZCB0byBhcHBlYXIgZW50aXJlbHkgYWJvdmUgdGhlIGRlY2x1dHRlcmVkIGl0ZW1zIG9mIGxheWVycyBsb3dlciBpbiB0aGUgbGF5ZXJcbiAgICogc3RhY2suXG4gICAqIEBhcGlcbiAgICovXG4gIGZsdXNoRGVjbHV0dGVySXRlbXMoKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXJfLmZsdXNoRGVjbHV0dGVySXRlbXMoZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBjb250cm9sIChvciB1bmRlZmluZWRcbiAgICogICAgIGlmIHRoZSBjb250cm9sIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVDb250cm9sKGNvbnRyb2wpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb250cm9scygpLnJlbW92ZShjb250cm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGludGVyYWN0aW9uIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR9IGludGVyYWN0aW9uIEludGVyYWN0aW9uIHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgaW50ZXJhY3Rpb24gKG9yXG4gICAqICAgICB1bmRlZmluZWQgaWYgdGhlIGludGVyYWN0aW9uIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVJbnRlcmFjdGlvbihpbnRlcmFjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldEludGVyYWN0aW9ucygpLnJlbW92ZShpbnRlcmFjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBsYXllciAob3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiAgICAgbGF5ZXIgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgcmV0dXJuIGxheWVycy5yZW1vdmUobGF5ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9Hcm91cC5qc1wiKS5Hcm91cEV2ZW50fSBldmVudCBUaGUgbGF5ZXIgcmVtb3ZlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJSZW1vdmVfKGV2ZW50KSB7XG4gICAgcmVtb3ZlTGF5ZXJNYXBQcm9wZXJ0eShldmVudC5sYXllcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBvdmVybGF5IGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gb3ZlcmxheSBPdmVybGF5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIG92ZXJsYXkgKG9yIHVuZGVmaW5lZFxuICAgKiAgICAgaWYgdGhlIG92ZXJsYXkgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZU92ZXJsYXkob3ZlcmxheSkge1xuICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXlzKCkucmVtb3ZlKG92ZXJsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW5kZXJGcmFtZV8odGltZSkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5nZXRWaWV3KCk7XG4gICAgY29uc3QgcHJldmlvdXNGcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICAvKiogQHR5cGUgez9GcmFtZVN0YXRlfSAqL1xuICAgIGxldCBmcmFtZVN0YXRlID0gbnVsbDtcbiAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGhhc0FyZWEoc2l6ZSkgJiYgdmlldyAmJiB2aWV3LmlzRGVmKCkpIHtcbiAgICAgIGNvbnN0IHZpZXdIaW50cyA9IHZpZXcuZ2V0SGludHMoXG4gICAgICAgIHRoaXMuZnJhbWVTdGF0ZV8gPyB0aGlzLmZyYW1lU3RhdGVfLnZpZXdIaW50cyA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZpZXdTdGF0ZSA9IHZpZXcuZ2V0U3RhdGUoKTtcbiAgICAgIGZyYW1lU3RhdGUgPSB7XG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTogdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8sXG4gICAgICAgIGRlY2x1dHRlclRyZWU6IG51bGwsXG4gICAgICAgIGV4dGVudDogZ2V0Rm9yVmlld0FuZFNpemUoXG4gICAgICAgICAgdmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgICB2aWV3U3RhdGUucmVzb2x1dGlvbixcbiAgICAgICAgICB2aWV3U3RhdGUucm90YXRpb24sXG4gICAgICAgICAgc2l6ZVxuICAgICAgICApLFxuICAgICAgICBpbmRleDogdGhpcy5mcmFtZUluZGV4XysrLFxuICAgICAgICBsYXllckluZGV4OiAwLFxuICAgICAgICBsYXllclN0YXRlc0FycmF5OiB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCksXG4gICAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtOiB0aGlzLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtXyxcbiAgICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uczogW10sXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHRpbGVRdWV1ZTogdGhpcy50aWxlUXVldWVfLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB1c2VkVGlsZXM6IHt9LFxuICAgICAgICB2aWV3U3RhdGU6IHZpZXdTdGF0ZSxcbiAgICAgICAgdmlld0hpbnRzOiB2aWV3SGludHMsXG4gICAgICAgIHdhbnRlZFRpbGVzOiB7fSxcbiAgICAgICAgbWFwSWQ6IGdldFVpZCh0aGlzKSxcbiAgICAgICAgcmVuZGVyVGFyZ2V0czoge30sXG4gICAgICB9O1xuICAgICAgaWYgKHZpZXdTdGF0ZS5uZXh0Q2VudGVyICYmIHZpZXdTdGF0ZS5uZXh0UmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGlzTmFOKHZpZXdTdGF0ZS5uZXh0Um90YXRpb24pXG4gICAgICAgICAgPyB2aWV3U3RhdGUucm90YXRpb25cbiAgICAgICAgICA6IHZpZXdTdGF0ZS5uZXh0Um90YXRpb247XG5cbiAgICAgICAgZnJhbWVTdGF0ZS5uZXh0RXh0ZW50ID0gZ2V0Rm9yVmlld0FuZFNpemUoXG4gICAgICAgICAgdmlld1N0YXRlLm5leHRDZW50ZXIsXG4gICAgICAgICAgdmlld1N0YXRlLm5leHRSZXNvbHV0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIHNpemVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lU3RhdGVfID0gZnJhbWVTdGF0ZTtcbiAgICB0aGlzLnJlbmRlcmVyXy5yZW5kZXJGcmFtZShmcmFtZVN0YXRlKTtcblxuICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICBpZiAoZnJhbWVTdGF0ZS5hbmltYXRlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXyxcbiAgICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zXG4gICAgICApO1xuXG4gICAgICBpZiAocHJldmlvdXNGcmFtZVN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG1vdmVTdGFydCA9XG4gICAgICAgICAgIXRoaXMucHJldmlvdXNFeHRlbnRfIHx8XG4gICAgICAgICAgKCFpc0VtcHR5KHRoaXMucHJldmlvdXNFeHRlbnRfKSAmJlxuICAgICAgICAgICAgIWVxdWFsc0V4dGVudChmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pKTtcbiAgICAgICAgaWYgKG1vdmVTdGFydCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRVNUQVJULCB0aGlzLCBwcmV2aW91c0ZyYW1lU3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkodGhpcy5wcmV2aW91c0V4dGVudF8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGUgPVxuICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyAmJlxuICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSAmJlxuICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddICYmXG4gICAgICAgICFlcXVhbHNFeHRlbnQoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcblxuICAgICAgaWYgKGlkbGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRUVORCwgdGhpcywgZnJhbWVTdGF0ZSlcbiAgICAgICAgKTtcbiAgICAgICAgY2xvbmUoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5QT1NUUkVOREVSLCB0aGlzLCBmcmFtZVN0YXRlKSk7XG5cbiAgICB0aGlzLnJlbmRlckNvbXBsZXRlXyA9XG4gICAgICB0aGlzLmhhc0xpc3RlbmVyKE1hcEV2ZW50VHlwZS5MT0FEU1RBUlQpIHx8XG4gICAgICB0aGlzLmhhc0xpc3RlbmVyKE1hcEV2ZW50VHlwZS5MT0FERU5EKSB8fFxuICAgICAgdGhpcy5oYXNMaXN0ZW5lcihSZW5kZXJFdmVudFR5cGUuUkVOREVSQ09NUExFVEUpXG4gICAgICAgID8gIXRoaXMudGlsZVF1ZXVlXy5nZXRUaWxlc0xvYWRpbmcoKSAmJlxuICAgICAgICAgICF0aGlzLnRpbGVRdWV1ZV8uZ2V0Q291bnQoKSAmJlxuICAgICAgICAgICF0aGlzLmdldExvYWRpbmdPck5vdFJlYWR5KClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXRoaXMucG9zdFJlbmRlclRpbWVvdXRIYW5kbGVfKSB7XG4gICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3N0UmVuZGVyKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXJncm91cCBvZiB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtMYXllckdyb3VwfSBsYXllckdyb3VwIEEgbGF5ZXIgZ3JvdXAgY29udGFpbmluZyB0aGUgbGF5ZXJzIGluIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllckdyb3VwKGxheWVyR3JvdXApIHtcbiAgICBjb25zdCBvbGRMYXllckdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKG9sZExheWVyR3JvdXApIHtcbiAgICAgIHRoaXMuaGFuZGxlTGF5ZXJSZW1vdmVfKG5ldyBHcm91cEV2ZW50KCdyZW1vdmVsYXllcicsIG9sZExheWVyR3JvdXApKTtcbiAgICB9XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuTEFZRVJHUk9VUCwgbGF5ZXJHcm91cCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2l6ZSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIG1hcCBpbiB0aGUgRE9NLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTaXplKHNpemUpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5TSVpFLCBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBlbGVtZW50IHRvIHJlbmRlciB0aGlzIG1hcCBpbnRvLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gVGhlIEVsZW1lbnQgb3IgaWQgb2YgdGhlIEVsZW1lbnRcbiAgICogICAgIHRoYXQgdGhlIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlRBUkdFVCwgdGFyZ2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZpZXcgZm9yIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge1ZpZXd8UHJvbWlzZTxpbXBvcnQoXCIuL1ZpZXcuanNcIikuVmlld09wdGlvbnM+fSB2aWV3IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcGFzcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBvcHRpb25zIGZvciBjb25zdHJ1Y3RpbmcgYSB2aWV3LiAgVGhpc1xuICAgKiBhbHRlcm5hdGl2ZSBhbGxvd3MgdmlldyBwcm9wZXJ0aWVzIHRvIGJlIHJlc29sdmVkIGJ5IHNvdXJjZXMgb3Igb3RoZXIgY29tcG9uZW50cyB0aGF0IGxvYWRcbiAgICogdmlldy1yZWxhdGVkIG1ldGFkYXRhLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRWaWV3KHZpZXcpIHtcbiAgICBpZiAoIXZpZXcgfHwgdmlldyBpbnN0YW5jZW9mIFZpZXcpIHtcbiAgICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlZJRVcsIHZpZXcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5WSUVXLCBuZXcgVmlldygpKTtcblxuICAgIGNvbnN0IG1hcCA9IHRoaXM7XG4gICAgdmlldy50aGVuKGZ1bmN0aW9uICh2aWV3T3B0aW9ucykge1xuICAgICAgbWFwLnNldFZpZXcobmV3IFZpZXcodmlld09wdGlvbnMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIG1hcCB2aWV3cG9ydCBzaXplLiAgVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAgICogdGhpcmQtcGFydHkgY29kZSBjaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHVwZGF0ZVNpemUoKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuXG4gICAgbGV0IHNpemUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsZW1lbnQpO1xuICAgICAgY29uc3Qgd2lkdGggPVxuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJMZWZ0V2lkdGgnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdMZWZ0J10pIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nUmlnaHQnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlclJpZ2h0V2lkdGgnXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPVxuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyVG9wV2lkdGgnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdUb3AnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdCb3R0b20nXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlckJvdHRvbVdpZHRoJ10pO1xuICAgICAgaWYgKCFpc05hTih3aWR0aCkgJiYgIWlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgc2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNBcmVhKHNpemUpICYmXG4gICAgICAgICAgISEoXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIHx8XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCB8fFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTm8gbWFwIHZpc2libGUgYmVjYXVzZSB0aGUgbWFwIGNvbnRhaW5lcidzIHdpZHRoIG9yIGhlaWdodCBhcmUgMC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgaWYgKHNpemUgJiYgKCFvbGRTaXplIHx8ICFlcXVhbHMoc2l6ZSwgb2xkU2l6ZSkpKSB7XG4gICAgICB0aGlzLnNldFNpemUoc2l6ZSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0U2l6ZV8oc2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY29tcHV0ZXMgdGhlIHZpZXdwb3J0IHNpemUgYW5kIHNhdmUgaXQgb24gdGhlIHZpZXcgb2JqZWN0IChpZiBhbnkpXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBzaXplIFRoZSBzaXplLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlVmlld3BvcnRTaXplXyhzaXplKSB7XG4gICAgY29uc3QgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3KSB7XG4gICAgICB2aWV3LnNldFZpZXdwb3J0U2l6ZShzaXplKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hcE9wdGlvbnN9IG9wdGlvbnMgTWFwIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtNYXBPcHRpb25zSW50ZXJuYWx9IEludGVybmFsIG1hcCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucykge1xuICAvKipcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fERvY3VtZW50fVxuICAgKi9cbiAgbGV0IGtleWJvYXJkRXZlbnRUYXJnZXQgPSBudWxsO1xuICBpZiAob3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBrZXlib2FyZEV2ZW50VGFyZ2V0ID1cbiAgICAgIHR5cGVvZiBvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0KVxuICAgICAgICA6IG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAqL1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcblxuICBjb25zdCBsYXllckdyb3VwID1cbiAgICBvcHRpb25zLmxheWVycyAmJlxuICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5sYXllcnMpLmdldExheWVycykgPT09ICdmdW5jdGlvbidcbiAgICAgID8gLyoqIEB0eXBlIHtMYXllckdyb3VwfSAqLyAob3B0aW9ucy5sYXllcnMpXG4gICAgICA6IG5ldyBMYXllckdyb3VwKHtcbiAgICAgICAgICBsYXllcnM6XG4gICAgICAgICAgICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKFxuICAgICAgICAgICAgICBvcHRpb25zLmxheWVyc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5MQVlFUkdST1VQXSA9IGxheWVyR3JvdXA7XG5cbiAgdmFsdWVzW01hcFByb3BlcnR5LlRBUkdFVF0gPSBvcHRpb25zLnRhcmdldDtcblxuICB2YWx1ZXNbTWFwUHJvcGVydHkuVklFV10gPVxuICAgIG9wdGlvbnMudmlldyBpbnN0YW5jZW9mIFZpZXcgPyBvcHRpb25zLnZpZXcgOiBuZXcgVmlldygpO1xuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgbGV0IGNvbnRyb2xzO1xuICBpZiAob3B0aW9ucy5jb250cm9scyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5jb250cm9scykpIHtcbiAgICAgIGNvbnRyb2xzID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5jb250cm9scy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0eXBlb2YgKC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMuY29udHJvbHMpLmdldEFycmF5KSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgJ0V4cGVjdGVkIGBjb250cm9sc2AgdG8gYmUgYW4gYXJyYXkgb3IgYW4gYG9sL0NvbGxlY3Rpb24uanNgJ1xuICAgICAgKTtcbiAgICAgIGNvbnRyb2xzID0gb3B0aW9ucy5jb250cm9scztcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvblwiKS5kZWZhdWx0Pn0gKi9cbiAgbGV0IGludGVyYWN0aW9ucztcbiAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyYWN0aW9ucykpIHtcbiAgICAgIGludGVyYWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMuaW50ZXJhY3Rpb25zLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5pbnRlcmFjdGlvbnMpLmdldEFycmF5KSA9PT1cbiAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgICAnRXhwZWN0ZWQgYGludGVyYWN0aW9uc2AgdG8gYmUgYW4gYXJyYXkgb3IgYW4gYG9sL0NvbGxlY3Rpb24uanNgJ1xuICAgICAgKTtcbiAgICAgIGludGVyYWN0aW9ucyA9IG9wdGlvbnMuaW50ZXJhY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59ICovXG4gIGxldCBvdmVybGF5cztcbiAgaWYgKG9wdGlvbnMub3ZlcmxheXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3ZlcmxheXMpKSB7XG4gICAgICBvdmVybGF5cyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMub3ZlcmxheXMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvcHRpb25zLm92ZXJsYXlzKS5nZXRBcnJheSkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBgb3ZlcmxheXNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBvbC9Db2xsZWN0aW9uLmpzYCdcbiAgICAgICk7XG4gICAgICBvdmVybGF5cyA9IG9wdGlvbnMub3ZlcmxheXM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG92ZXJsYXlzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29udHJvbHM6IGNvbnRyb2xzLFxuICAgIGludGVyYWN0aW9uczogaW50ZXJhY3Rpb25zLFxuICAgIGtleWJvYXJkRXZlbnRUYXJnZXQ6IGtleWJvYXJkRXZlbnRUYXJnZXQsXG4gICAgb3ZlcmxheXM6IG92ZXJsYXlzLFxuICAgIHZhbHVlczogdmFsdWVzLFxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9NYXBcbiAqL1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7Y29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLCBtYWtlSW52ZXJzZX0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Z2V0V2lkdGh9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge3NoYXJlZCBhcyBpY29uSW1hZ2VDYWNoZX0gZnJvbSAnLi4vc3R5bGUvSWNvbkltYWdlQ2FjaGUuanMnO1xuaW1wb3J0IHtpblZpZXd9IGZyb20gJy4uL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCB7d3JhcFh9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiBIaXRNYXRjaFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlU3EgU3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi92ZWN0b3IuanNcIikuRmVhdHVyZUNhbGxiYWNrPFQ+fSBjYWxsYmFjayBDYWxsYmFjay5cbiAqL1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBNYXBSZW5kZXJlciBleHRlbmRzIERpc3Bvc2FibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50KHR5cGUsIGZyYW1lU3RhdGUpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY2FsY3VsYXRlTWF0cmljZXMyRChmcmFtZVN0YXRlKSB7XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3QgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0gPSBmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtO1xuICAgIGNvbnN0IHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtID0gZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybTtcblxuICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSxcbiAgICAgIGZyYW1lU3RhdGUuc2l6ZVswXSAvIDIsXG4gICAgICBmcmFtZVN0YXRlLnNpemVbMV0gLyAyLFxuICAgICAgMSAvIHZpZXdTdGF0ZS5yZXNvbHV0aW9uLFxuICAgICAgLTEgLyB2aWV3U3RhdGUucmVzb2x1dGlvbixcbiAgICAgIC12aWV3U3RhdGUucm90YXRpb24sXG4gICAgICAtdmlld1N0YXRlLmNlbnRlclswXSxcbiAgICAgIC12aWV3U3RhdGUuY2VudGVyWzFdXG4gICAgKTtcblxuICAgIG1ha2VJbnZlcnNlKHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLCBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrV3JhcHBlZCBDaGVjayBmb3Igd3JhcHBlZCBnZW9tZXRyaWVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdmVjdG9yLmpzXCIpLkZlYXR1cmVDYWxsYmFjazxUPn0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtTfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcyIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFMsVCxVXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNoZWNrV3JhcHBlZCxcbiAgICBjYWxsYmFjayxcbiAgICB0aGlzQXJnLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIHRoaXNBcmcyXG4gICkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG1hbmFnZWQgTWFuYWdlZCBsYXllci5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKG1hbmFnZWQsIGZlYXR1cmUsIGxheWVyLCBnZW9tZXRyeSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZmVhdHVyZSwgbWFuYWdlZCA/IGxheWVyIDogbnVsbCwgZ2VvbWV0cnkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcblxuICAgIGNvbnN0IHRyYW5zbGF0ZWRDb29yZGluYXRlID0gd3JhcFgoY29vcmRpbmF0ZS5zbGljZSgpLCBwcm9qZWN0aW9uKTtcbiAgICBjb25zdCBvZmZzZXRzID0gW1swLCAwXV07XG4gICAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJiBjaGVja1dyYXBwZWQpIHtcbiAgICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgICAgb2Zmc2V0cy5wdXNoKFstd29ybGRXaWR0aCwgMF0sIFt3b3JsZFdpZHRoLCAwXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXJTdGF0ZXMgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgY29uc3QgbnVtTGF5ZXJzID0gbGF5ZXJTdGF0ZXMubGVuZ3RoO1xuXG4gICAgY29uc3QgbWF0Y2hlcyA9IC8qKiBAdHlwZSB7QXJyYXk8SGl0TWF0Y2g8VD4+fSAqLyAoW10pO1xuICAgIGNvbnN0IHRtcENvb3JkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gbnVtTGF5ZXJzIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGxheWVyU3RhdGVzW2pdO1xuICAgICAgICBjb25zdCBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBsYXllci5oYXNSZW5kZXJlcigpICYmXG4gICAgICAgICAgaW5WaWV3KGxheWVyU3RhdGUsIHZpZXdTdGF0ZSkgJiZcbiAgICAgICAgICBsYXllckZpbHRlci5jYWxsKHRoaXNBcmcyLCBsYXllcilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJSZW5kZXJlciA9IGxheWVyLmdldFJlbmRlcmVyKCk7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gbGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICAgICAgaWYgKGxheWVyUmVuZGVyZXIgJiYgc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IHNvdXJjZS5nZXRXcmFwWCgpXG4gICAgICAgICAgICAgID8gdHJhbnNsYXRlZENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgOiBjb29yZGluYXRlO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZS5iaW5kKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBsYXllclN0YXRlLm1hbmFnZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0bXBDb29yZFswXSA9IGNvb3JkaW5hdGVzWzBdICsgb2Zmc2V0c1tpXVswXTtcbiAgICAgICAgICAgIHRtcENvb3JkWzFdID0gY29vcmRpbmF0ZXNbMV0gKyBvZmZzZXRzW2ldWzFdO1xuICAgICAgICAgICAgcmVzdWx0ID0gbGF5ZXJSZW5kZXJlci5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgICAgICAgICAgdG1wQ29vcmQsXG4gICAgICAgICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgICAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXIgPSAxIC8gbWF0Y2hlcy5sZW5ndGg7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtLCBpKSA9PiAobS5kaXN0YW5jZVNxICs9IGkgKiBvcmRlcikpO1xuICAgIG1hdGNoZXMuc29ydCgoYSwgYikgPT4gYS5kaXN0YW5jZVNxIC0gYi5kaXN0YW5jZVNxKTtcbiAgICBtYXRjaGVzLnNvbWUoKG0pID0+IHtcbiAgICAgIHJldHVybiAocmVzdWx0ID0gbS5jYWxsYmFjayhtLmZlYXR1cmUsIG0ubGF5ZXIsIG0uZ2VvbWV0cnkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja1dyYXBwZWQgQ2hlY2sgZm9yIHdyYXBwZWQgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGF5ZXJGaWx0ZXJgLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyB0aGVyZSBhIGZlYXR1cmUgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGU/XG4gICAqIEB0ZW1wbGF0ZSBVXG4gICAqL1xuICBoYXNGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgZnJhbWVTdGF0ZSxcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgY2hlY2tXcmFwcGVkLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIHRoaXNBcmdcbiAgKSB7XG4gICAgY29uc3QgaGFzRmVhdHVyZSA9IHRoaXMuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLFxuICAgICAgZnJhbWVTdGF0ZSxcbiAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgIGNoZWNrV3JhcHBlZCxcbiAgICAgIFRSVUUsXG4gICAgICB0aGlzLFxuICAgICAgbGF5ZXJGaWx0ZXIsXG4gICAgICB0aGlzQXJnXG4gICAgKTtcblxuICAgIHJldHVybiBoYXNGZWF0dXJlICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IE1hcC5cbiAgICovXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGZsdXNoRGVjbHV0dGVySXRlbXMoZnJhbWVTdGF0ZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2NoZWR1bGVFeHBpcmVJY29uQ2FjaGUoZnJhbWVTdGF0ZSkge1xuICAgIGlmIChpY29uSW1hZ2VDYWNoZS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMucHVzaChleHBpcmVJY29uQ2FjaGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICovXG5mdW5jdGlvbiBleHBpcmVJY29uQ2FjaGUobWFwLCBmcmFtZVN0YXRlKSB7XG4gIGljb25JbWFnZUNhY2hlLmV4cGlyZSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBNYXBSZW5kZXJlcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvQ29tcG9zaXRlXG4gKi9cbmltcG9ydCBNYXBSZW5kZXJlciBmcm9tICcuL01hcC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4uL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnQgZnJvbSAnLi4vcmVuZGVyL0V2ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0NMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7Y2hlY2tlZEZvbnRzfSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCB7aW5WaWV3fSBmcm9tICcuLi9sYXllci9MYXllci5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7cmVwbGFjZUNoaWxkcmVufSBmcm9tICcuLi9kb20uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyBtYXAgcmVuZGVyZXIuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENvbXBvc2l0ZU1hcFJlbmRlcmVyIGV4dGVuZHMgTWFwUmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgIHN1cGVyKG1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLmZvbnRDaGFuZ2VMaXN0ZW5lcktleV8gPSBsaXN0ZW4oXG4gICAgICBjaGVja2VkRm9udHMsXG4gICAgICBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICBtYXAucmVkcmF3VGV4dC5iaW5kKG1hcClcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5lbGVtZW50Xy5zdHlsZTtcbiAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHN0eWxlLnpJbmRleCA9ICcwJztcblxuICAgIHRoaXMuZWxlbWVudF8uY2xhc3NOYW1lID0gQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyBvbC1sYXllcnMnO1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gbWFwLmdldFZpZXdwb3J0KCk7XG4gICAgY29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnRfLCBjb250YWluZXIuZmlyc3RDaGlsZCB8fCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PEhUTUxFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2xheWVyL0Jhc2VWZWN0b3IuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJMYXllcnNfID0gW107XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGRpc3BhdGNoUmVuZGVyRXZlbnQodHlwZSwgZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcC5oYXNMaXN0ZW5lcih0eXBlKSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUmVuZGVyRXZlbnQodHlwZSwgdW5kZWZpbmVkLCBmcmFtZVN0YXRlKTtcbiAgICAgIG1hcC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdW5saXN0ZW5CeUtleSh0aGlzLmZvbnRDaGFuZ2VMaXN0ZW5lcktleV8pO1xuICAgIHRoaXMuZWxlbWVudF8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnRfKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmVsZW1lbnRfLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FsY3VsYXRlTWF0cmljZXMyRChmcmFtZVN0YXRlKTtcbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnQoUmVuZGVyRXZlbnRUeXBlLlBSRUNPTVBPU0UsIGZyYW1lU3RhdGUpO1xuXG4gICAgY29uc3QgbGF5ZXJTdGF0ZXNBcnJheSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS56SW5kZXggLSBiLnpJbmRleDtcbiAgICB9KTtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcblxuICAgIHRoaXMuY2hpbGRyZW5fLmxlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBkZWNsdXR0ZXJMYXllcnMgPSB0aGlzLmRlY2x1dHRlckxheWVyc187XG4gICAgZGVjbHV0dGVyTGF5ZXJzLmxlbmd0aCA9IDA7XG5cbiAgICBsZXQgcHJldmlvdXNFbGVtZW50ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBsYXllclN0YXRlc0FycmF5W2ldO1xuICAgICAgZnJhbWVTdGF0ZS5sYXllckluZGV4ID0gaTtcblxuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgY29uc3Qgc291cmNlU3RhdGUgPSBsYXllci5nZXRTb3VyY2VTdGF0ZSgpO1xuICAgICAgaWYgKFxuICAgICAgICAhaW5WaWV3KGxheWVyU3RhdGUsIHZpZXdTdGF0ZSkgfHxcbiAgICAgICAgKHNvdXJjZVN0YXRlICE9ICdyZWFkeScgJiYgc291cmNlU3RhdGUgIT0gJ3VuZGVmaW5lZCcpXG4gICAgICApIHtcbiAgICAgICAgbGF5ZXIudW5yZW5kZXIoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllci5yZW5kZXIoZnJhbWVTdGF0ZSwgcHJldmlvdXNFbGVtZW50KTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50ICE9PSBwcmV2aW91c0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbl8ucHVzaChlbGVtZW50KTtcbiAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIGlmICgnZ2V0RGVjbHV0dGVyJyBpbiBsYXllcikge1xuICAgICAgICBkZWNsdXR0ZXJMYXllcnMucHVzaChcbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2xheWVyL0Jhc2VWZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZsdXNoRGVjbHV0dGVySXRlbXMoZnJhbWVTdGF0ZSk7XG5cbiAgICByZXBsYWNlQ2hpbGRyZW4odGhpcy5lbGVtZW50XywgdGhpcy5jaGlsZHJlbl8pO1xuXG4gICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50KFJlbmRlckV2ZW50VHlwZS5QT1NUQ09NUE9TRSwgZnJhbWVTdGF0ZSk7XG5cbiAgICBpZiAoIXRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVFeHBpcmVJY29uQ2FjaGUoZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGZsdXNoRGVjbHV0dGVySXRlbXMoZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZGVjbHV0dGVyTGF5ZXJzXztcbiAgICBmb3IgKGxldCBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBsYXllcnNbaV0ucmVuZGVyRGVjbHV0dGVyKGZyYW1lU3RhdGUpO1xuICAgIH1cbiAgICBsYXllcnMubGVuZ3RoID0gMDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb3NpdGVNYXBSZW5kZXJlcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvR3JvdXBcbiAqL1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuL0Jhc2UuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQge2dldEludGVyc2VjdGlvbn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYWRkbGF5ZXInfCdyZW1vdmVsYXllcid9IEV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBsYXllciBncm91cCB0cmlnZ2VycyAnYWRkbGF5ZXInIGFuZCAncmVtb3ZlbGF5ZXInIGV2ZW50cyB3aGVuIGxheWVycyBhcmUgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tXG4gKiB0aGUgZ3JvdXAgb3Igb25lIG9mIGl0cyBjaGlsZCBncm91cHMuICBXaGVuIGEgbGF5ZXIgZ3JvdXAgaXMgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tIGFub3RoZXIgbGF5ZXIgZ3JvdXAsXG4gKiBhIHNpbmdsZSBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCAoaW5zdGVhZCBvZiBvbmUgcGVyIGxheWVyIGluIHRoZSBncm91cCBhZGRlZCBvciByZW1vdmVkKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEdyb3VwRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50VHlwZX0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtCYXNlTGF5ZXJ9IGxheWVyIFRoZSBsYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGxheWVyKSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWRkZWQgb3IgcmVtb3ZlZCBsYXllci5cbiAgICAgKiBAdHlwZSB7QmFzZUxheWVyfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gIH1cbn1cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9CYXNlXCIpLkJhc2VMYXllck9iamVjdEV2ZW50VHlwZXN8XG4gKiAgICAgJ2NoYW5nZTpsYXllcnMnLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfCdjaGFuZ2U6bGF5ZXJzJywgUmV0dXJuPn0gR3JvdXBPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIFRoZSBtaW5pbXVtIHZpZXcgem9vbSBsZXZlbCAoZXhjbHVzaXZlKSBhYm92ZSB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIFRoZSBtYXhpbXVtIHZpZXcgem9vbSBsZXZlbCAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0PnxDb2xsZWN0aW9uPGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gW2xheWVyc10gQ2hpbGQgbGF5ZXJzLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCAqPn0gW3Byb3BlcnRpZXNdIEFyYml0cmFyeSBvYnNlcnZhYmxlIHByb3BlcnRpZXMuIENhbiBiZSBhY2Nlc3NlZCB3aXRoIGAjZ2V0KClgIGFuZCBgI3NldCgpYC5cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBQcm9wZXJ0eSA9IHtcbiAgTEFZRVJTOiAnbGF5ZXJzJyxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gb2YgbGF5ZXJzIHRoYXQgYXJlIGhhbmRsZWQgdG9nZXRoZXIuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBncm91cC9Db2xsZWN0aW9uIGNoYW5nZXMuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBMYXllckdyb3VwIGV4dGVuZHMgQmFzZUxheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIExheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgYmFzZU9wdGlvbnMgPSAvKiogQHR5cGUge09wdGlvbnN9ICovIChPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLmxheWVycztcblxuICAgIGxldCBsYXllcnMgPSBvcHRpb25zLmxheWVycztcblxuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7R3JvdXBPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtHcm91cE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7R3JvdXBPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pj59XG4gICAgICovXG4gICAgdGhpcy5saXN0ZW5lcktleXNfID0ge307XG5cbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKFByb3BlcnR5LkxBWUVSUywgdGhpcy5oYW5kbGVMYXllcnNDaGFuZ2VkXyk7XG5cbiAgICBpZiAobGF5ZXJzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXllcnMpKSB7XG4gICAgICAgIGxheWVycyA9IG5ldyBDb2xsZWN0aW9uKGxheWVycy5zbGljZSgpLCB7dW5pcXVlOiB0cnVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChsYXllcnMpLmdldEFycmF5KSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAnRXhwZWN0ZWQgYGxheWVyc2AgdG8gYmUgYW4gYXJyYXkgb3IgYSBgQ29sbGVjdGlvbmAnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVycyA9IG5ldyBDb2xsZWN0aW9uKHVuZGVmaW5lZCwge3VuaXF1ZTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0TGF5ZXJzKGxheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyQ2hhbmdlXygpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJzQ2hhbmdlZF8oKSB7XG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfLmxlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVycygpO1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5wdXNoKFxuICAgICAgbGlzdGVuKGxheWVycywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsIHRoaXMuaGFuZGxlTGF5ZXJzQWRkXywgdGhpcyksXG4gICAgICBsaXN0ZW4obGF5ZXJzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSwgdGhpcy5oYW5kbGVMYXllcnNSZW1vdmVfLCB0aGlzKVxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMubGlzdGVuZXJLZXlzXykge1xuICAgICAgdGhpcy5saXN0ZW5lcktleXNfW2lkXS5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIH1cbiAgICBjbGVhcih0aGlzLmxpc3RlbmVyS2V5c18pO1xuXG4gICAgY29uc3QgbGF5ZXJzQXJyYXkgPSBsYXllcnMuZ2V0QXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllcnNBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IGxheWVyc0FycmF5W2ldO1xuICAgICAgdGhpcy5yZWdpc3RlckxheWVyTGlzdGVuZXJzXyhsYXllcik7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ2FkZGxheWVyJywgbGF5ZXIpKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCYXNlTGF5ZXJ9IGxheWVyIFRoZSBsYXllci5cbiAgICovXG4gIHJlZ2lzdGVyTGF5ZXJMaXN0ZW5lcnNfKGxheWVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJLZXlzID0gW1xuICAgICAgbGlzdGVuKFxuICAgICAgICBsYXllcixcbiAgICAgICAgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZUxheWVyQ2hhbmdlXyxcbiAgICAgICAgdGhpc1xuICAgICAgKSxcbiAgICAgIGxpc3RlbihsYXllciwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sIHRoaXMpLFxuICAgIF07XG5cbiAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICBsaXN0ZW5lcktleXMucHVzaChcbiAgICAgICAgbGlzdGVuKGxheWVyLCAnYWRkbGF5ZXInLCB0aGlzLmhhbmRsZUxheWVyR3JvdXBBZGRfLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGxheWVyLCAncmVtb3ZlbGF5ZXInLCB0aGlzLmhhbmRsZUxheWVyR3JvdXBSZW1vdmVfLCB0aGlzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyS2V5c19bZ2V0VWlkKGxheWVyKV0gPSBsaXN0ZW5lcktleXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtHcm91cEV2ZW50fSBldmVudCBUaGUgbGF5ZXIgZ3JvdXAgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVMYXllckdyb3VwQWRkXyhldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBFdmVudCgnYWRkbGF5ZXInLCBldmVudC5sYXllcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R3JvdXBFdmVudH0gZXZlbnQgVGhlIGxheWVyIGdyb3VwIGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlTGF5ZXJHcm91cFJlbW92ZV8oZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ3JlbW92ZWxheWVyJywgZXZlbnQubGF5ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc0FkZF8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSBjb2xsZWN0aW9uRXZlbnQuZWxlbWVudDtcbiAgICB0aGlzLnJlZ2lzdGVyTGF5ZXJMaXN0ZW5lcnNfKGxheWVyKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ2FkZGxheWVyJywgbGF5ZXIpKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc1JlbW92ZV8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSBjb2xsZWN0aW9uRXZlbnQuZWxlbWVudDtcbiAgICBjb25zdCBrZXkgPSBnZXRVaWQobGF5ZXIpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1trZXldLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgZGVsZXRlIHRoaXMubGlzdGVuZXJLZXlzX1trZXldO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBFdmVudCgncmVtb3ZlbGF5ZXInLCBsYXllcikpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcmV0dXJuIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXllcnMoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSAqLyAoXG4gICAgICB0aGlzLmdldChQcm9wZXJ0eS5MQVlFUlMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcGFyYW0geyFDb2xsZWN0aW9uPGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllcnMobGF5ZXJzKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMYXllcnMgPSBjb2xsZWN0aW9uLmdldEFycmF5KCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjdXJyZW50TGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdyZW1vdmVsYXllcicsIGN1cnJlbnRMYXllcnNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldChQcm9wZXJ0eS5MQVlFUlMsIGxheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBbYXJyYXldIEFycmF5IG9mIGxheWVycyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBBcnJheSBvZiBsYXllcnMuXG4gICAqL1xuICBnZXRMYXllcnNBcnJheShhcnJheSkge1xuICAgIGFycmF5ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5IDogW107XG4gICAgdGhpcy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgbGF5ZXIuZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyIHN0YXRlcyBsaXN0IGFuZCB1c2UgdGhpcyBncm91cHMgei1pbmRleCBhcyB0aGUgZGVmYXVsdFxuICAgKiBmb3IgYWxsIGxheWVycyBpbiB0aGlzIGFuZCBuZXN0ZWQgZ3JvdXBzLCBpZiBpdCBpcyB1bnNldCBhdCB0aGlzIHBvaW50LlxuICAgKiBJZiBkZXN0IGlzIG5vdCBwcm92aWRlZCBhbmQgdGhpcyBncm91cCdzIHotaW5kZXggaXMgdW5kZWZpbmVkXG4gICAqIDAgaXMgdXNlZCBhIHRoZSBkZWZhdWx0IHotaW5kZXguXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IFtkZXN0XSBPcHRpb25hbCBsaXN0XG4gICAqIG9mIGxheWVyIHN0YXRlcyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gTGlzdCBvZiBsYXllciBzdGF0ZXMuXG4gICAqL1xuICBnZXRMYXllclN0YXRlc0FycmF5KGRlc3QpIHtcbiAgICBjb25zdCBzdGF0ZXMgPSBkZXN0ICE9PSB1bmRlZmluZWQgPyBkZXN0IDogW107XG4gICAgY29uc3QgcG9zID0gc3RhdGVzLmxlbmd0aDtcblxuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmdldExheWVyU3RhdGVzQXJyYXkoc3RhdGVzKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG93bkxheWVyU3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoKTtcbiAgICBsZXQgZGVmYXVsdFpJbmRleCA9IG93bkxheWVyU3RhdGUuekluZGV4O1xuICAgIGlmICghZGVzdCAmJiBvd25MYXllclN0YXRlLnpJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWZhdWx0WkluZGV4ID0gMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHBvcywgaWkgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSAqPSBvd25MYXllclN0YXRlLm9wYWNpdHk7XG4gICAgICBsYXllclN0YXRlLnZpc2libGUgPSBsYXllclN0YXRlLnZpc2libGUgJiYgb3duTGF5ZXJTdGF0ZS52aXNpYmxlO1xuICAgICAgbGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uID0gTWF0aC5taW4oXG4gICAgICAgIGxheWVyU3RhdGUubWF4UmVzb2x1dGlvbixcbiAgICAgICAgb3duTGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uXG4gICAgICApO1xuICAgICAgbGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgIGxheWVyU3RhdGUubWluUmVzb2x1dGlvbixcbiAgICAgICAgb3duTGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uXG4gICAgICApO1xuICAgICAgbGF5ZXJTdGF0ZS5taW5ab29tID0gTWF0aC5tYXgobGF5ZXJTdGF0ZS5taW5ab29tLCBvd25MYXllclN0YXRlLm1pblpvb20pO1xuICAgICAgbGF5ZXJTdGF0ZS5tYXhab29tID0gTWF0aC5taW4obGF5ZXJTdGF0ZS5tYXhab29tLCBvd25MYXllclN0YXRlLm1heFpvb20pO1xuICAgICAgaWYgKG93bkxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXllclN0YXRlLmV4dGVudCA9IGdldEludGVyc2VjdGlvbihcbiAgICAgICAgICAgIGxheWVyU3RhdGUuZXh0ZW50LFxuICAgICAgICAgICAgb3duTGF5ZXJTdGF0ZS5leHRlbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxheWVyU3RhdGUuZXh0ZW50ID0gb3duTGF5ZXJTdGF0ZS5leHRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXllclN0YXRlLnpJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxheWVyU3RhdGUuekluZGV4ID0gZGVmYXVsdFpJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuU3RhdGV9IFNvdXJjZSBzdGF0ZS5cbiAgICovXG4gIGdldFNvdXJjZVN0YXRlKCkge1xuICAgIHJldHVybiAncmVhZHknO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyR3JvdXA7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50XG4gKi9cbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYXMgbWFwIGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGZvciB3aGljaCBldmVudHMgdHJpZ2dlciBhIG1hcCBldmVudC5cbiAqL1xuY2xhc3MgTWFwRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgZnJhbWVTdGF0ZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIHN0YXRlIGF0IHRoZSB0aW1lIG9mIHRoZSBldmVudC5cbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IGZyYW1lU3RhdGUgIT09IHVuZGVmaW5lZCA/IGZyYW1lU3RhdGUgOiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEV2ZW50O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRcbiAqL1xuaW1wb3J0IE1hcEV2ZW50IGZyb20gJy4vTWFwRXZlbnQuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGFzIG1hcCBicm93c2VyIGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGZvciB3aGljaCBldmVudHMgdHJpZ2dlciBhIG1hcCBicm93c2VyIGV2ZW50LlxuICogQHRlbXBsYXRlIHtVSUV2ZW50fSBFVkVOVFxuICovXG5jbGFzcyBNYXBCcm93c2VyRXZlbnQgZXh0ZW5kcyBNYXBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7RVZFTlR9IG9yaWdpbmFsRXZlbnQgT3JpZ2luYWwgZXZlbnQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RyYWdnaW5nXSBJcyB0aGUgbWFwIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkP1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheTxQb2ludGVyRXZlbnQ+fSBbYWN0aXZlUG9pbnRlcnNdIEFjdGl2ZSBwb2ludGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgb3JpZ2luYWxFdmVudCwgZHJhZ2dpbmcsIGZyYW1lU3RhdGUsIGFjdGl2ZVBvaW50ZXJzKSB7XG4gICAgc3VwZXIodHlwZSwgbWFwLCBmcmFtZVN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtFVkVOVH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgcGl4ZWwgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yaWdpbmFsIGJyb3dzZXIgZXZlbnQuXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIGluIHRoZSB1c2VyIHByb2plY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBtYXAgaXMgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQuIE9ubHkgc2V0IGZvclxuICAgICAqIGBQT0lOVEVSRFJBR2AgYW5kIGBQT0lOVEVSTU9WRWAgZXZlbnRzLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nICE9PSB1bmRlZmluZWQgPyBkcmFnZ2luZyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFBvaW50ZXJFdmVudD58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnMgPSBhY3RpdmVQb2ludGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWFwIHBpeGVsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICogQHR5cGUge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAqIEBhcGlcbiAgICovXG4gIGdldCBwaXhlbCgpIHtcbiAgICBpZiAoIXRoaXMucGl4ZWxfKSB7XG4gICAgICB0aGlzLnBpeGVsXyA9IHRoaXMubWFwLmdldEV2ZW50UGl4ZWwodGhpcy5vcmlnaW5hbEV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGl4ZWxfO1xuICB9XG4gIHNldCBwaXhlbChwaXhlbCkge1xuICAgIHRoaXMucGl4ZWxfID0gcGl4ZWw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvb3JkaW5hdGUgY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC4gIFRoaXMgd2lsbCBiZSBpbiB0aGUgdXNlclxuICAgKiBwcm9qZWN0aW9uIGlmIG9uZSBpcyBzZXQuICBPdGhlcndpc2UgaXQgd2lsbCBiZSBpbiB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAqIEBhcGlcbiAgICovXG4gIGdldCBjb29yZGluYXRlKCkge1xuICAgIGlmICghdGhpcy5jb29yZGluYXRlXykge1xuICAgICAgdGhpcy5jb29yZGluYXRlXyA9IHRoaXMubWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwodGhpcy5waXhlbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVfO1xuICB9XG4gIHNldCBjb29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICB0aGlzLmNvb3JkaW5hdGVfID0gY29vcmRpbmF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBicm93c2VyIGFjdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5wcmV2ZW50RGVmYXVsdC5cbiAgICogQGFwaVxuICAgKi9cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgc3VwZXIucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoJ3ByZXZlbnREZWZhdWx0JyBpbiB0aGlzLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgIC8qKiBAdHlwZSB7VUlFdmVudH0gKi8gKHRoaXMub3JpZ2luYWxFdmVudCkucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5zdG9wUHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICBzdXBlci5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoJ3N0b3BQcm9wYWdhdGlvbicgaW4gdGhpcy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAvKiogQHR5cGUge1VJRXZlbnR9ICovICh0aGlzLm9yaWdpbmFsRXZlbnQpLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXBCcm93c2VyRXZlbnQ7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudEhhbmRsZXJcbiAqL1xuXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlckV2ZW50LmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCB7UEFTU0lWRV9FVkVOVF9MSVNURU5FUlN9IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5cbmNsYXNzIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIgZXh0ZW5kcyBUYXJnZXQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgVGhlIG1hcCB3aXRoIHRoZSB2aWV3cG9ydCB0byBsaXN0ZW4gdG8gZXZlbnRzIG9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vdmVUb2xlcmFuY2VdIFRoZSBtaW5pbWFsIGRpc3RhbmNlIHRoZSBwb2ludGVyIG11c3QgdHJhdmVsIHRvIHRyaWdnZXIgYSBtb3ZlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFwLCBtb3ZlVG9sZXJhbmNlKSB7XG4gICAgc3VwZXIobWFwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGxpc3RlbiB0byB0aGUgcmVhbCBldmVudHMgb24uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNsaWNrVGltZW91dElkXztcblxuICAgIC8qKlxuICAgICAqIEVtdWxhdGUgZGJsY2xpY2sgYW5kIHNpbmdsZWNsaWNrLiBXaWxsIGJlIHRydWUgd2hlbiBvbmx5IG9uZSBwb2ludGVyIGlzIGFjdGl2ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVtdWxhdGVDbGlja3NfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tb3ZlVG9sZXJhbmNlXyA9IG1vdmVUb2xlcmFuY2UgPT09IHVuZGVmaW5lZCA/IDEgOiBtb3ZlVG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IFwiZG93blwiIHR5cGUgZXZlbnQgKG9yIG51bGwgaWYgbm9uZSBoYXZlIG9jY3VycmVkKS5cbiAgICAgKiBTZXQgb24gcG9pbnRlcmRvd24uXG4gICAgICogQHR5cGUge1BvaW50ZXJFdmVudHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kb3duXyA9IG51bGw7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5tYXBfLmdldFZpZXdwb3J0KCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9pbnRlckV2ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxudW1iZXIsIEV2ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnRfID0gZWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgIGVsZW1lbnQsXG4gICAgICBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJET1dOLFxuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93bl8sXG4gICAgICB0aGlzXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQb2ludGVyRXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVsYXllZExpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgIGVsZW1lbnQsXG4gICAgICBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgdGhpcy5yZWxheU1vdmVFdmVudF8sXG4gICAgICB0aGlzXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZVRvdWNoTW92ZV8gPSB0aGlzLmhhbmRsZVRvdWNoTW92ZV8uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZWxlbWVudF8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5UT1VDSE1PVkUsXG4gICAgICB0aGlzLmJvdW5kSGFuZGxlVG91Y2hNb3ZlXyxcbiAgICAgIFBBU1NJVkVfRVZFTlRfTElTVEVORVJTID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbXVsYXRlQ2xpY2tfKHBvaW50ZXJFdmVudCkge1xuICAgIGxldCBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQoXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgdGhpcy5tYXBfLFxuICAgICAgcG9pbnRlckV2ZW50XG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIGlmICh0aGlzLmNsaWNrVGltZW91dElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkb3VibGUtY2xpY2tcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZW91dElkXyk7XG4gICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgICAgIG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSyxcbiAgICAgICAgdGhpcy5tYXBfLFxuICAgICAgICBwb2ludGVyRXZlbnRcbiAgICAgICk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjbGlja1xuICAgICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLLFxuICAgICAgICAgIHRoaXMubWFwXyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9uIGhvdyBtYW55IHBvaW50ZXJzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVBY3RpdmVQb2ludGVyc18ocG9pbnRlckV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBwb2ludGVyRXZlbnQ7XG4gICAgY29uc3QgaWQgPSBldmVudC5wb2ludGVySWQ7XG5cbiAgICBpZiAoXG4gICAgICBldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQIHx8XG4gICAgICBldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkNBTkNFTFxuICAgICkge1xuICAgICAgZGVsZXRlIHRoaXMudHJhY2tlZFRvdWNoZXNfW2lkXTtcbiAgICAgIGZvciAoY29uc3QgcG9pbnRlcklkIGluIHRoaXMudHJhY2tlZFRvdWNoZXNfKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRUb3VjaGVzX1twb2ludGVySWRdLnRhcmdldCAhPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgLy8gU29tZSBwbGF0Zm9ybXMgYXNzaWduIGEgbmV3IHBvaW50ZXJJZCB3aGVuIHRoZSB0YXJnZXQgY2hhbmdlcy5cbiAgICAgICAgICAvLyBJZiB0aGlzIGhhcHBlbnMsIGRlbGV0ZSBvbmUgdHJhY2tlZCBwb2ludGVyLiBJZiB0aGVyZSBpcyBtb3JlXG4gICAgICAgICAgLy8gdGhhbiBvbmUgdHJhY2tlZCBwb2ludGVyIGZvciB0aGUgb2xkIHRhcmdldCwgaXQgd2lsbCBiZSBjbGVhcmVkXG4gICAgICAgICAgLy8gYnkgc3Vic2VxdWVudCBQT0lOVEVSVVAgZXZlbnRzIGZyb20gb3RoZXIgcG9pbnRlcnMuXG4gICAgICAgICAgZGVsZXRlIHRoaXMudHJhY2tlZFRvdWNoZXNfW3BvaW50ZXJJZF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgZXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOIHx8XG4gICAgICBldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkVcbiAgICApIHtcbiAgICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfW2lkXSA9IGV2ZW50O1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzXyA9IE9iamVjdC52YWx1ZXModGhpcy50cmFja2VkVG91Y2hlc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVBvaW50ZXJVcF8ocG9pbnRlckV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVBY3RpdmVQb2ludGVyc18ocG9pbnRlckV2ZW50KTtcbiAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQoXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCxcbiAgICAgIHRoaXMubWFwXyxcbiAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgLy8gV2UgZW11bGF0ZSBjbGljayBldmVudHMgb24gbGVmdCBtb3VzZSBidXR0b24gY2xpY2ssIHRvdWNoIGNvbnRhY3QsIGFuZCBwZW5cbiAgICAvLyBjb250YWN0LiBpc01vdXNlQWN0aW9uQnV0dG9uIHJldHVybnMgdHJ1ZSBpbiB0aGVzZSBjYXNlcyAoZXZ0LmJ1dHRvbiBpcyBzZXRcbiAgICAvLyB0byAwKS5cbiAgICAvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jYnV0dG9uLXN0YXRlc1xuICAgIC8vIFdlIG9ubHkgZmlyZSBjbGljaywgc2luZ2xlY2xpY2ssIGFuZCBkb3VibGVjbGljayBpZiBub2JvZHkgaGFzIGNhbGxlZFxuICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbXVsYXRlQ2xpY2tzXyAmJlxuICAgICAgIW5ld0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICF0aGlzLmRyYWdnaW5nXyAmJlxuICAgICAgdGhpcy5pc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpXG4gICAgKSB7XG4gICAgICB0aGlzLmVtdWxhdGVDbGlja18odGhpcy5kb3duXyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlUG9pbnRlcnNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5kcmFnZ2luZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMuZG93bl8gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiB3YXMgcHJlc3NlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW91c2VBY3Rpb25CdXR0b25fKHBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVBvaW50ZXJEb3duXyhwb2ludGVyRXZlbnQpIHtcbiAgICB0aGlzLmVtdWxhdGVDbGlja3NfID0gdGhpcy5hY3RpdmVQb2ludGVyc18ubGVuZ3RoID09PSAwO1xuICAgIHRoaXMudXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCk7XG4gICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTixcbiAgICAgIHRoaXMubWFwXyxcbiAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgdGhpcy5kb3duXyA9IG5ldyBQb2ludGVyRXZlbnQocG9pbnRlckV2ZW50LnR5cGUsIHBvaW50ZXJFdmVudCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZG93bl8sICd0YXJnZXQnLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogcG9pbnRlckV2ZW50LnRhcmdldCxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgZG9jID0gdGhpcy5tYXBfLmdldE93bmVyRG9jdW1lbnQoKTtcbiAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ucHVzaChcbiAgICAgICAgbGlzdGVuKFxuICAgICAgICAgIGRvYyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKSxcbiAgICAgICAgbGlzdGVuKGRvYywgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVAsIHRoaXMuaGFuZGxlUG9pbnRlclVwXywgdGhpcyksXG4gICAgICAgIC8qIE5vdGUgdGhhdCB0aGUgbGlzdGVuZXIgZm9yIGBwb2ludGVyY2FuY2VsIGlzIHNldCB1cCBvblxuICAgICAgICAgKiBgcG9pbnRlckV2ZW50SGFuZGxlcl9gIGFuZCBub3QgYGRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl9gIGxpa2VcbiAgICAgICAgICogdGhlIGBwb2ludGVydXBgIGFuZCBgcG9pbnRlcm1vdmVgIGxpc3RlbmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGUgZm9sbG93aW5nOiBgVG91Y2hTb3VyY2UudmFjdXVtVG91Y2hlc18oKWBcbiAgICAgICAgICogaXNzdWVzIGBwb2ludGVyY2FuY2VsYCBldmVudHMsIHdoZW4gdGhlcmUgd2FzIG5vIGB0b3VjaGVuZGAgZm9yIGFcbiAgICAgICAgICogYHRvdWNoc3RhcnRgLiBOb3csIGxldCdzIHNheSBhIGZpcnN0IGB0b3VjaHN0YXJ0YCBpcyByZWdpc3RlcmVkIG9uXG4gICAgICAgICAqIGBwb2ludGVyRXZlbnRIYW5kbGVyX2AuIFRoZSBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgaXMgc2V0IHVwLlxuICAgICAgICAgKiBCdXQgYGRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl9gIGRvZXNuJ3Qga25vdyBhYm91dCB0aGUgZmlyc3RcbiAgICAgICAgICogYHRvdWNoc3RhcnRgLiBJZiB0aGVyZSBpcyBubyBgdG91Y2hlbmRgIGZvciB0aGUgYHRvdWNoc3RhcnRgLCB3ZSBjYW5cbiAgICAgICAgICogb25seSByZWNlaXZlIGEgYHRvdWNoY2FuY2VsYCBmcm9tIGBwb2ludGVyRXZlbnRIYW5kbGVyX2AsIGJlY2F1c2UgaXQgaXNcbiAgICAgICAgICogb25seSByZWdpc3RlcmVkIHRoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuKFxuICAgICAgICAgIHRoaXMuZWxlbWVudF8sXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSQ0FOQ0VMLFxuICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwXyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5lbGVtZW50Xy5nZXRSb290Tm9kZSAmJiB0aGlzLmVsZW1lbnRfLmdldFJvb3ROb2RlKCkgIT09IGRvYykge1xuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICAgICAgbGlzdGVuKFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Xy5nZXRSb290Tm9kZSgpLFxuICAgICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVAsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcF8sXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyTW92ZV8ocG9pbnRlckV2ZW50KSB7XG4gICAgLy8gQmV0d2VlbiBwb2ludGVyZG93biBhbmQgcG9pbnRlcnVwLCBwb2ludGVybW92ZSBldmVudHMgYXJlIHRyaWdnZXJlZC5cbiAgICAvLyBUbyBhdm9pZCBhICdmYWxzZScgdG91Y2htb3ZlIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQsIHdlIHRlc3QgaWYgdGhlIHBvaW50ZXJcbiAgICAvLyBtb3ZlZCBhIHNpZ25pZmljYW50IGRpc3RhbmNlLlxuICAgIGlmICh0aGlzLmlzTW92aW5nXyhwb2ludGVyRXZlbnQpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgICAgdGhpcy5kcmFnZ2luZ18gPSB0cnVlO1xuICAgICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHLFxuICAgICAgICB0aGlzLm1hcF8sXG4gICAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgICAgdGhpcy5kcmFnZ2luZ18sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5hY3RpdmVQb2ludGVyc19cbiAgICAgICk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwIGFuZCByZWxheSBhIHBvaW50ZXJtb3ZlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWxheU1vdmVFdmVudF8ocG9pbnRlckV2ZW50KSB7XG4gICAgdGhpcy5vcmlnaW5hbFBvaW50ZXJNb3ZlRXZlbnRfID0gcG9pbnRlckV2ZW50O1xuICAgIGNvbnN0IGRyYWdnaW5nID0gISEodGhpcy5kb3duXyAmJiB0aGlzLmlzTW92aW5nXyhwb2ludGVyRXZlbnQpKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgICB0aGlzLm1hcF8sXG4gICAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgICAgZHJhZ2dpbmdcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsZXhpYmxlIGhhbmRsaW5nIG9mIGEgYHRvdWNoLWFjdGlvbjogbm9uZWAgY3NzIGVxdWl2YWxlbnQ6IGJlY2F1c2UgY2FsbGluZ1xuICAgKiBgcHJldmVudERlZmF1bHQoKWAgb24gYSBgcG9pbnRlcm1vdmVgIGV2ZW50IGRvZXMgbm90IHN0b3AgbmF0aXZlIHBhZ2Ugc2Nyb2xsaW5nXG4gICAqIGFuZCB6b29taW5nLCB3ZSBhbHNvIGxpc3RlbiBmb3IgYHRvdWNobW92ZWAgYW5kIGNhbGwgYHByZXZlbnREZWZhdWx0KClgIG9uIGl0XG4gICAqIHdoZW4gYW4gaW50ZXJhY3Rpb24gKGN1cnJlbnRseSBgRHJhZ1BhbmAgaGFuZGxlcyB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUb3VjaE1vdmVfKGV2ZW50KSB7XG4gICAgLy8gRHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tcGl6ZW5iZXJnL2VsbS1wZXAvaXNzdWVzLzIsIGB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF9gXG4gICAgLy8gbWF5IG5vdCBiZSBpbml0aWFsaXplZCB5ZXQgd2hlbiB3ZSBnZXQgaGVyZSBvbiBhIHBsYXRmb3JtIHdpdGhvdXQgbmF0aXZlIHBvaW50ZXIgZXZlbnRzLFxuICAgIC8vIHdoZW4gZWxtLXBlcCBpcyB1c2VkIGFzIHBvaW50ZXIgZXZlbnRzIHBvbHlmaWxsLlxuICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF87XG4gICAgaWYgKFxuICAgICAgKCFvcmlnaW5hbEV2ZW50IHx8IG9yaWdpbmFsRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiZcbiAgICAgICh0eXBlb2YgZXZlbnQuY2FuY2VsYWJsZSAhPT0gJ2Jvb2xlYW4nIHx8IGV2ZW50LmNhbmNlbGFibGUgPT09IHRydWUpXG4gICAgKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIG1vdmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW92aW5nXyhwb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5kcmFnZ2luZ18gfHxcbiAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRYIC0gdGhpcy5kb3duXy5jbGllbnRYKSA+XG4gICAgICAgIHRoaXMubW92ZVRvbGVyYW5jZV8gfHxcbiAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRZIC0gdGhpcy5kb3duXy5jbGllbnRZKSA+IHRoaXMubW92ZVRvbGVyYW5jZV9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwLlxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIGlmICh0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMucmVsYXllZExpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5UT1VDSE1PVkUsXG4gICAgICB0aGlzLmJvdW5kSGFuZGxlVG91Y2hNb3ZlX1xuICAgICk7XG5cbiAgICBpZiAodGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLmVsZW1lbnRfID0gbnVsbDtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXBCcm93c2VyRXZlbnRIYW5kbGVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRUeXBlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGV2ZW50IG5hbWVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQSB0cnVlIHNpbmdsZSBjbGljayB3aXRoIG5vIGRyYWdnaW5nIGFuZCBubyBkb3VibGUgY2xpY2suIE5vdGUgdGhhdCB0aGlzXG4gICAqIGV2ZW50IGlzIGRlbGF5ZWQgYnkgMjUwIG1zIHRvIGVuc3VyZSB0aGF0IGl0IGlzIG5vdCBhIGRvdWJsZSBjbGljay5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3NpbmdsZWNsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIFNJTkdMRUNMSUNLOiAnc2luZ2xlY2xpY2snLFxuXG4gIC8qKlxuICAgKiBBIGNsaWNrIHdpdGggbm8gZHJhZ2dpbmcuIEEgZG91YmxlIGNsaWNrIHdpbGwgZmlyZSB0d28gb2YgdGhpcy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I2NsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIENMSUNLOiBFdmVudFR5cGUuQ0xJQ0ssXG5cbiAgLyoqXG4gICAqIEEgdHJ1ZSBkb3VibGUgY2xpY2ssIHdpdGggbm8gZHJhZ2dpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNkYmxjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBEQkxDTElDSzogRXZlbnRUeXBlLkRCTENMSUNLLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHBvaW50ZXIgaXMgZHJhZ2dlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3BvaW50ZXJkcmFnXG4gICAqIEBhcGlcbiAgICovXG4gIFBPSU5URVJEUkFHOiAncG9pbnRlcmRyYWcnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHBvaW50ZXIgaXMgbW92ZWQuIE5vdGUgdGhhdCBvbiB0b3VjaCBkZXZpY2VzIHRoaXMgaXNcbiAgICogdHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBpcyBwYW5uZWQsIHNvIGlzIG5vdCB0aGUgc2FtZSBhcyBtb3VzZW1vdmUuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNwb2ludGVybW92ZVxuICAgKiBAYXBpXG4gICAqL1xuICBQT0lOVEVSTU9WRTogJ3BvaW50ZXJtb3ZlJyxcblxuICBQT0lOVEVSRE9XTjogJ3BvaW50ZXJkb3duJyxcbiAgUE9JTlRFUlVQOiAncG9pbnRlcnVwJyxcbiAgUE9JTlRFUk9WRVI6ICdwb2ludGVyb3ZlcicsXG4gIFBPSU5URVJPVVQ6ICdwb2ludGVyb3V0JyxcbiAgUE9JTlRFUkVOVEVSOiAncG9pbnRlcmVudGVyJyxcbiAgUE9JTlRFUkxFQVZFOiAncG9pbnRlcmxlYXZlJyxcbiAgUE9JTlRFUkNBTkNFTDogJ3BvaW50ZXJjYW5jZWwnLFxufTtcblxuLyoqKlxuICogQHR5cGVkZWYgeydzaW5nbGVjbGljayd8J2NsaWNrJ3wnZGJsY2xpY2snfCdwb2ludGVyZHJhZyd8J3BvaW50ZXJtb3ZlJ30gVHlwZXNcbiAqL1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBldmVudCBuYW1lcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUE9JTlRFUk1PVkU6ICdwb2ludGVybW92ZScsXG4gIFBPSU5URVJET1dOOiAncG9pbnRlcmRvd24nLFxuICBQT0lOVEVSVVA6ICdwb2ludGVydXAnLFxuICBQT0lOVEVST1ZFUjogJ3BvaW50ZXJvdmVyJyxcbiAgUE9JTlRFUk9VVDogJ3BvaW50ZXJvdXQnLFxuICBQT0lOVEVSRU5URVI6ICdwb2ludGVyZW50ZXInLFxuICBQT0lOVEVSTEVBVkU6ICdwb2ludGVybGVhdmUnLFxuICBQT0lOVEVSQ0FOQ0VMOiAncG9pbnRlcmNhbmNlbCcsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9NYXBQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBMQVlFUkdST1VQOiAnbGF5ZXJncm91cCcsXG4gIFNJWkU6ICdzaXplJyxcbiAgVEFSR0VUOiAndGFyZ2V0JyxcbiAgVklFVzogJ3ZpZXcnLFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVF1ZXVlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBQcmlvcml0eVF1ZXVlLCB7RFJPUH0gZnJvbSAnLi9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0LCBzdHJpbmcsIGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlLCBudW1iZXIpOiBudW1iZXJ9IFByaW9yaXR5RnVuY3Rpb25cbiAqL1xuXG5jbGFzcyBUaWxlUXVldWUgZXh0ZW5kcyBQcmlvcml0eVF1ZXVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UHJpb3JpdHlGdW5jdGlvbn0gdGlsZVByaW9yaXR5RnVuY3Rpb24gVGlsZSBwcmlvcml0eSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiA/fSB0aWxlQ2hhbmdlQ2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIG9uIGVhY2ggdGlsZSBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlUHJpb3JpdHlGdW5jdGlvbiwgdGlsZUNoYW5nZUNhbGxiYWNrKSB7XG4gICAgc3VwZXIoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gUHJpb3JpdHkuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aWxlUHJpb3JpdHlGdW5jdGlvbi5hcHBseShudWxsLCBlbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGVsZW1lbnRbMF0pLmdldEtleSgpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmJvdW5kSGFuZGxlVGlsZUNoYW5nZV8gPSB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKCk6ID99XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfID0gdGlsZUNoYW5nZUNhbGxiYWNrO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZXNMb2FkaW5nXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZyxib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVzTG9hZGluZ0tleXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudCBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgKi9cbiAgZW5xdWV1ZShlbGVtZW50KSB7XG4gICAgY29uc3QgYWRkZWQgPSBzdXBlci5lbnF1ZXVlKGVsZW1lbnQpO1xuICAgIGlmIChhZGRlZCkge1xuICAgICAgY29uc3QgdGlsZSA9IGVsZW1lbnRbMF07XG4gICAgICB0aWxlLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5ib3VuZEhhbmRsZVRpbGVDaGFuZ2VfKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHRpbGVzIGxvYWRpbmcuXG4gICAqL1xuICBnZXRUaWxlc0xvYWRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZXNMb2FkaW5nXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVUaWxlQ2hhbmdlKGV2ZW50KSB7XG4gICAgY29uc3QgdGlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChcbiAgICAgIHN0YXRlID09PSBUaWxlU3RhdGUuTE9BREVEIHx8XG4gICAgICBzdGF0ZSA9PT0gVGlsZVN0YXRlLkVSUk9SIHx8XG4gICAgICBzdGF0ZSA9PT0gVGlsZVN0YXRlLkVNUFRZXG4gICAgKSB7XG4gICAgICBpZiAoc3RhdGUgIT09IFRpbGVTdGF0ZS5FUlJPUikge1xuICAgICAgICB0aWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5ib3VuZEhhbmRsZVRpbGVDaGFuZ2VfKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbGVLZXkgPSB0aWxlLmdldEtleSgpO1xuICAgICAgaWYgKHRpbGVLZXkgaW4gdGhpcy50aWxlc0xvYWRpbmdLZXlzXykge1xuICAgICAgICBkZWxldGUgdGhpcy50aWxlc0xvYWRpbmdLZXlzX1t0aWxlS2V5XTtcbiAgICAgICAgLS10aGlzLnRpbGVzTG9hZGluZ187XG4gICAgICB9XG4gICAgICB0aGlzLnRpbGVDaGFuZ2VDYWxsYmFja18oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFRvdGFsTG9hZGluZyBNYXhpbXVtIG51bWJlciB0aWxlcyB0byBsb2FkIHNpbXVsdGFuZW91c2x5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4TmV3TG9hZHMgTWF4aW11bSBudW1iZXIgb2YgbmV3IHRpbGVzIHRvIGxvYWQuXG4gICAqL1xuICBsb2FkTW9yZVRpbGVzKG1heFRvdGFsTG9hZGluZywgbWF4TmV3TG9hZHMpIHtcbiAgICBsZXQgbmV3TG9hZHMgPSAwO1xuICAgIGxldCBzdGF0ZSwgdGlsZSwgdGlsZUtleTtcbiAgICB3aGlsZSAoXG4gICAgICB0aGlzLnRpbGVzTG9hZGluZ18gPCBtYXhUb3RhbExvYWRpbmcgJiZcbiAgICAgIG5ld0xvYWRzIDwgbWF4TmV3TG9hZHMgJiZcbiAgICAgIHRoaXMuZ2V0Q291bnQoKSA+IDBcbiAgICApIHtcbiAgICAgIHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5kZXF1ZXVlKClbMF0pO1xuICAgICAgdGlsZUtleSA9IHRpbGUuZ2V0S2V5KCk7XG4gICAgICBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gVGlsZVN0YXRlLklETEUgJiYgISh0aWxlS2V5IGluIHRoaXMudGlsZXNMb2FkaW5nS2V5c18pKSB7XG4gICAgICAgIHRoaXMudGlsZXNMb2FkaW5nS2V5c19bdGlsZUtleV0gPSB0cnVlO1xuICAgICAgICArK3RoaXMudGlsZXNMb2FkaW5nXztcbiAgICAgICAgKytuZXdMb2FkcztcbiAgICAgICAgdGlsZS5sb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVRdWV1ZTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9NYXAuanMnKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbGVTb3VyY2VLZXkgVGlsZSBzb3VyY2Uga2V5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdGlsZUNlbnRlciBUaWxlIGNlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlUmVzb2x1dGlvbiBUaWxlIHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcHJpb3JpdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWxlUHJpb3JpdHkoXG4gIGZyYW1lU3RhdGUsXG4gIHRpbGUsXG4gIHRpbGVTb3VyY2VLZXksXG4gIHRpbGVDZW50ZXIsXG4gIHRpbGVSZXNvbHV0aW9uXG4pIHtcbiAgLy8gRmlsdGVyIG91dCB0aWxlcyBhdCBoaWdoZXIgem9vbSBsZXZlbHMgdGhhbiB0aGUgY3VycmVudCB6b29tIGxldmVsLCBvciB0aGF0XG4gIC8vIGFyZSBvdXRzaWRlIHRoZSB2aXNpYmxlIGV4dGVudC5cbiAgaWYgKCFmcmFtZVN0YXRlIHx8ICEodGlsZVNvdXJjZUtleSBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzKSkge1xuICAgIHJldHVybiBEUk9QO1xuICB9XG4gIGlmICghZnJhbWVTdGF0ZS53YW50ZWRUaWxlc1t0aWxlU291cmNlS2V5XVt0aWxlLmdldEtleSgpXSkge1xuICAgIHJldHVybiBEUk9QO1xuICB9XG4gIC8vIFByaW9yaXRpemUgdGhlIGhpZ2hlc3Qgem9vbSBsZXZlbCB0aWxlcyBjbG9zZXN0IHRvIHRoZSBmb2N1cy5cbiAgLy8gVGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIGFyZSBwcmlvcml0aXplZCB1c2luZyBNYXRoLmxvZyh0aWxlUmVzb2x1dGlvbikuXG4gIC8vIFdpdGhpbiBhIHpvb20gbGV2ZWwsIHRpbGVzIGFyZSBwcmlvcml0aXplZCBieSB0aGUgZGlzdGFuY2UgaW4gcGl4ZWxzIGJldHdlZW5cbiAgLy8gdGhlIGNlbnRlciBvZiB0aGUgdGlsZSBhbmQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQuICBUaGUgZmFjdG9yIG9mIDY1NTM2XG4gIC8vIG1lYW5zIHRoYXQgdGhlIHByaW9yaXRpemF0aW9uIHNob3VsZCBiZWhhdmUgYXMgZGVzaXJlZCBmb3IgdGlsZXMgdXAgdG9cbiAgLy8gNjU1MzYgKiBNYXRoLmxvZygyKSA9IDQ1NDI2IHBpeGVscyBmcm9tIHRoZSBmb2N1cy5cbiAgY29uc3QgY2VudGVyID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUuY2VudGVyO1xuICBjb25zdCBkZWx0YVggPSB0aWxlQ2VudGVyWzBdIC0gY2VudGVyWzBdO1xuICBjb25zdCBkZWx0YVkgPSB0aWxlQ2VudGVyWzFdIC0gY2VudGVyWzFdO1xuICByZXR1cm4gKFxuICAgIDY1NTM2ICogTWF0aC5sb2codGlsZVJlc29sdXRpb24pICtcbiAgICBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSAvIHRpbGVSZXNvbHV0aW9uXG4gICk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBEUk9QID0gSW5maW5pdHk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJpb3JpdHkgcXVldWUuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGZyb20gdGhlIENsb3N1cmUgTGlicmFyeSdzIEhlYXAgY2xhc3MgYW5kXG4gKiBQeXRob24ncyBoZWFwcSBtb2R1bGUuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9zdHJ1Y3RzL2hlYXAuanNcbiAqIGFuZCBodHRwczovL2hnLnB5dGhvbi5vcmcvY3B5dGhvbi9maWxlLzIuNy9MaWIvaGVhcHEucHkuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiBudW1iZXJ9IHByaW9yaXR5RnVuY3Rpb24gUHJpb3JpdHkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6IHN0cmluZ30ga2V5RnVuY3Rpb24gS2V5IGZ1bmN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpb3JpdHlGdW5jdGlvbiwga2V5RnVuY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVCk6IG51bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucHJpb3JpdHlGdW5jdGlvbl8gPSBwcmlvcml0eUZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFQpOiBzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmtleUZ1bmN0aW9uXyA9IGtleUZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wcmlvcml0aWVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucXVldWVkRWxlbWVudHNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzXy5sZW5ndGggPSAwO1xuICAgIHRoaXMucHJpb3JpdGllc18ubGVuZ3RoID0gMDtcbiAgICBjbGVhcih0aGlzLnF1ZXVlZEVsZW1lbnRzXyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGhpZ2hlc3QtcHJpb3JpdHkgZWxlbWVudC4gTyhsb2cgTikuXG4gICAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgIHByaW9yaXRpZXMubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHNbMF0gPSAvKiogQHR5cGUge1R9ICovIChlbGVtZW50cy5wb3AoKSk7XG4gICAgICBwcmlvcml0aWVzWzBdID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwcmlvcml0aWVzLnBvcCgpKTtcbiAgICAgIHRoaXMuc2lmdFVwXygwKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudEtleSA9IHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZEVsZW1lbnRzX1tlbGVtZW50S2V5XTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGFuIGVsZW1lbnQuIE8obG9nIE4pLlxuICAgKiBAcGFyYW0ge1R9IGVsZW1lbnQgRWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICovXG4gIGVucXVldWUoZWxlbWVudCkge1xuICAgIGFzc2VydChcbiAgICAgICEodGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCkgaW4gdGhpcy5xdWV1ZWRFbGVtZW50c18pLFxuICAgICAgJ1RyaWVkIHRvIGVucXVldWUgYW4gYGVsZW1lbnRgIHRoYXQgd2FzIGFscmVhZHkgYWRkZWQgdG8gdGhlIHF1ZXVlJ1xuICAgICk7XG4gICAgY29uc3QgcHJpb3JpdHkgPSB0aGlzLnByaW9yaXR5RnVuY3Rpb25fKGVsZW1lbnQpO1xuICAgIGlmIChwcmlvcml0eSAhPSBEUk9QKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzXy5wdXNoKGVsZW1lbnQpO1xuICAgICAgdGhpcy5wcmlvcml0aWVzXy5wdXNoKHByaW9yaXR5KTtcbiAgICAgIHRoaXMucXVldWVkRWxlbWVudHNfW3RoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpXSA9IHRydWU7XG4gICAgICB0aGlzLnNpZnREb3duXygwLCB0aGlzLmVsZW1lbnRzXy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBDb3VudC5cbiAgICovXG4gIGdldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzXy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgbGVmdCBjaGlsZCBmb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBsZWZ0IGNoaWxkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGVmdENoaWxkSW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICogMiArIDE7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHJpZ2h0IGNoaWxkIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXQgdGhlIHJpZ2h0IGNoaWxkIGZvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHJpZ2h0IGNoaWxkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UmlnaHRDaGlsZEluZGV4XyhpbmRleCkge1xuICAgIHJldHVybiBpbmRleCAqIDIgKyAyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwYXJlbnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgcGFyZW50IGZvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHBhcmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBhcmVudEluZGV4XyhpbmRleCkge1xuICAgIHJldHVybiAoaW5kZXggLSAxKSA+PiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBhIGhlYXAuIE8oTikuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoZWFwaWZ5XygpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAodGhpcy5lbGVtZW50c18ubGVuZ3RoID4+IDEpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMuc2lmdFVwXyhpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzXy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGtleSBxdWV1ZWQuXG4gICAqL1xuICBpc0tleVF1ZXVlZChrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMucXVldWVkRWxlbWVudHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBxdWV1ZWQuXG4gICAqL1xuICBpc1F1ZXVlZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNLZXlRdWV1ZWQodGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gbW92ZSBkb3duLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2lmdFVwXyhpbmRleCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gICAgY29uc3QgY291bnQgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XTtcbiAgICBjb25zdCBwcmlvcml0eSA9IHByaW9yaXRpZXNbaW5kZXhdO1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcblxuICAgIHdoaWxlIChpbmRleCA8IGNvdW50ID4+IDEpIHtcbiAgICAgIGNvbnN0IGxJbmRleCA9IHRoaXMuZ2V0TGVmdENoaWxkSW5kZXhfKGluZGV4KTtcbiAgICAgIGNvbnN0IHJJbmRleCA9IHRoaXMuZ2V0UmlnaHRDaGlsZEluZGV4XyhpbmRleCk7XG5cbiAgICAgIGNvbnN0IHNtYWxsZXJDaGlsZEluZGV4ID1cbiAgICAgICAgckluZGV4IDwgY291bnQgJiYgcHJpb3JpdGllc1tySW5kZXhdIDwgcHJpb3JpdGllc1tsSW5kZXhdXG4gICAgICAgICAgPyBySW5kZXhcbiAgICAgICAgICA6IGxJbmRleDtcblxuICAgICAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudHNbc21hbGxlckNoaWxkSW5kZXhdO1xuICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0aWVzW3NtYWxsZXJDaGlsZEluZGV4XTtcbiAgICAgIGluZGV4ID0gc21hbGxlckNoaWxkSW5kZXg7XG4gICAgfVxuXG4gICAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudDtcbiAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICAgIHRoaXMuc2lmdERvd25fKHN0YXJ0SW5kZXgsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBUaGUgaW5kZXggb2YgdGhlIHJvb3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gbW92ZSB1cC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNpZnREb3duXyhzdGFydEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XTtcbiAgICBjb25zdCBwcmlvcml0eSA9IHByaW9yaXRpZXNbaW5kZXhdO1xuXG4gICAgd2hpbGUgKGluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgICAgY29uc3QgcGFyZW50SW5kZXggPSB0aGlzLmdldFBhcmVudEluZGV4XyhpbmRleCk7XG4gICAgICBpZiAocHJpb3JpdGllc1twYXJlbnRJbmRleF0gPiBwcmlvcml0eSkge1xuICAgICAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50c1twYXJlbnRJbmRleF07XG4gICAgICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdGllc1twYXJlbnRJbmRleF07XG4gICAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudDtcbiAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgcmVwcmlvcml0aXplKCkge1xuICAgIGNvbnN0IHByaW9yaXR5RnVuY3Rpb24gPSB0aGlzLnByaW9yaXR5RnVuY3Rpb25fO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBuID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGxldCBlbGVtZW50LCBpLCBwcmlvcml0eTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBwcmlvcml0eSA9IHByaW9yaXR5RnVuY3Rpb24oZWxlbWVudCk7XG4gICAgICBpZiAocHJpb3JpdHkgPT0gRFJPUCkge1xuICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgICAgICAgZWxlbWVudHNbaW5kZXgrK10gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50cy5sZW5ndGggPSBpbmRleDtcbiAgICBwcmlvcml0aWVzLmxlbmd0aCA9IGluZGV4O1xuICAgIHRoaXMuaGVhcGlmeV8oKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcmlvcml0eVF1ZXVlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSURMRTogMCxcbiAgTE9BRElORzogMSxcbiAgTE9BREVEOiAyLFxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGlsZSBsb2FkaW5nIGZhaWxlZFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgRVJST1I6IDMsXG4gIEVNUFRZOiA0LFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9BdHRyaWJ1dGlvblxuICovXG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09MTEFQU0VELCBDTEFTU19DT05UUk9MLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtyZW1vdmVDaGlsZHJlbiwgcmVwbGFjZU5vZGV9IGZyb20gJy4uL2RvbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWF0dHJpYnV0aW9uJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gU3BlY2lmeSBhIHRhcmdldCBpZiB5b3VcbiAqIHdhbnQgdGhlIGNvbnRyb2wgdG8gYmUgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgbWFwJ3NcbiAqIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29sbGFwc2libGVdIFNwZWNpZnkgaWYgYXR0cmlidXRpb25zIGNhblxuICogYmUgY29sbGFwc2VkLiBJZiBub3Qgc3BlY2lmaWVkLCBzb3VyY2VzIGNvbnRyb2wgdGhpcyBiZWhhdmlvciB3aXRoIHRoZWlyXG4gKiBgYXR0cmlidXRpb25zQ29sbGFwc2libGVgIHNldHRpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb2xsYXBzZWQ9dHJ1ZV0gU3BlY2lmeSBpZiBhdHRyaWJ1dGlvbnMgc2hvdWxkXG4gKiBiZSBjb2xsYXBzZWQgYXQgc3RhcnR1cC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGlwTGFiZWw9J0F0dHJpYnV0aW9ucyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbbGFiZWw9J2knXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlXG4gKiBjb2xsYXBzZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtleHBhbmRDbGFzc05hbWU9Y2xhc3NOYW1lICsgJy1leHBhbmQnXSBDU1MgY2xhc3MgbmFtZSBmb3IgdGhlXG4gKiBjb2xsYXBzZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbY29sbGFwc2VMYWJlbD0nXHUyMDNBJ10gVGV4dCBsYWJlbCB0byB1c2VcbiAqIGZvciB0aGUgZXhwYW5kZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xsYXBzZUNsYXNzTmFtZT1jbGFzc05hbWUgKyAnLWNvbGxhcHNlJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZVxuICogZXhwYW5kZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW3JlbmRlcl0gRnVuY3Rpb24gY2FsbGVkIHdoZW5cbiAqIHRoZSBjb250cm9sIHNob3VsZCBiZSByZS1yZW5kZXJlZC4gVGhpcyBpcyBjYWxsZWQgaW4gYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICogY2FsbGJhY2suXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250cm9sIHRvIHNob3cgYWxsIHRoZSBhdHRyaWJ1dGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXllciBzb3VyY2VzXG4gKiBpbiB0aGUgbWFwLiBUaGlzIGNvbnRyb2wgaXMgb25lIG9mIHRoZSBkZWZhdWx0IGNvbnRyb2xzIGluY2x1ZGVkIGluIG1hcHMuXG4gKiBCeSBkZWZhdWx0IGl0IHdpbGwgc2hvdyBpbiB0aGUgYm90dG9tIHJpZ2h0IHBvcnRpb24gb2YgdGhlIG1hcCwgYnV0IHRoaXMgY2FuXG4gKiBiZSBjaGFuZ2VkIGJ5IHVzaW5nIGEgY3NzIHNlbGVjdG9yIGZvciBgLm9sLWF0dHJpYnV0aW9uYC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEF0dHJpYnV0aW9uIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBBdHRyaWJ1dGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgc3VwZXIoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICByZW5kZXI6IG9wdGlvbnMucmVuZGVyLFxuICAgICAgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudWxFbGVtZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2VkXyA9XG4gICAgICBvcHRpb25zLmNvbGxhcHNlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzZWQgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJDb2xsYXBzZWRfID0gdGhpcy5jb2xsYXBzZWRfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJyaWRlQ29sbGFwc2libGVfID0gb3B0aW9ucy5jb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNpYmxlXyA9XG4gICAgICBvcHRpb25zLmNvbGxhcHNpYmxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxhcHNpYmxlIDogdHJ1ZTtcblxuICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZV8pIHtcbiAgICAgIHRoaXMuY29sbGFwc2VkXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbGFzc05hbWUgOiAnb2wtYXR0cmlidXRpb24nO1xuXG4gICAgY29uc3QgdGlwTGFiZWwgPVxuICAgICAgb3B0aW9ucy50aXBMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aXBMYWJlbCA6ICdBdHRyaWJ1dGlvbnMnO1xuXG4gICAgY29uc3QgZXhwYW5kQ2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuZXhwYW5kQ2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmV4cGFuZENsYXNzTmFtZVxuICAgICAgICA6IGNsYXNzTmFtZSArICctZXhwYW5kJztcblxuICAgIGNvbnN0IGNvbGxhcHNlTGFiZWwgPVxuICAgICAgb3B0aW9ucy5jb2xsYXBzZUxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxhcHNlTGFiZWwgOiAnXFx1MjAzQSc7XG5cbiAgICBjb25zdCBjb2xsYXBzZUNsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNvbGxhcHNlQ2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmNvbGxhcHNlQ2xhc3NOYW1lXG4gICAgICAgIDogY2xhc3NOYW1lICsgJy1jb2xsYXBzZSc7XG5cbiAgICBpZiAodHlwZW9mIGNvbGxhcHNlTGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfLnRleHRDb250ZW50ID0gY29sbGFwc2VMYWJlbDtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8uY2xhc3NOYW1lID0gY29sbGFwc2VDbGFzc05hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gPSBjb2xsYXBzZUxhYmVsO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsID0gb3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYWJlbCA6ICdpJztcblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMubGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5sYWJlbF8udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICAgIHRoaXMubGFiZWxfLmNsYXNzTmFtZSA9IGV4cGFuZENsYXNzTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbF8gPSBsYWJlbDtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVMYWJlbCA9XG4gICAgICB0aGlzLmNvbGxhcHNpYmxlXyAmJiAhdGhpcy5jb2xsYXBzZWRfID8gdGhpcy5jb2xsYXBzZUxhYmVsXyA6IHRoaXMubGFiZWxfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy50b2dnbGVCdXR0b25fID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgdGhpcy50b2dnbGVCdXR0b25fLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgU3RyaW5nKCF0aGlzLmNvbGxhcHNlZF8pKTtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8udGl0bGUgPSB0aXBMYWJlbDtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8uYXBwZW5kQ2hpbGQoYWN0aXZlTGFiZWwpO1xuXG4gICAgdGhpcy50b2dnbGVCdXR0b25fLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICB0aGlzLmhhbmRsZUNsaWNrXy5iaW5kKHRoaXMpLFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3QgY3NzQ2xhc3NlcyA9XG4gICAgICBjbGFzc05hbWUgK1xuICAgICAgJyAnICtcbiAgICAgIENMQVNTX1VOU0VMRUNUQUJMRSArXG4gICAgICAnICcgK1xuICAgICAgQ0xBU1NfQ09OVFJPTCArXG4gICAgICAodGhpcy5jb2xsYXBzZWRfICYmIHRoaXMuY29sbGFwc2libGVfID8gJyAnICsgQ0xBU1NfQ09MTEFQU0VEIDogJycpICtcbiAgICAgICh0aGlzLmNvbGxhcHNpYmxlXyA/ICcnIDogJyBvbC11bmNvbGxhcHNpYmxlJyk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXM7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRvZ2dsZUJ1dHRvbl8pO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy51bEVsZW1lbnRfKTtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBjdXJyZW50bHkgcmVuZGVyZWQgcmVzb2x1dGlvbnMuXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3QgYSBsaXN0IG9mIHZpc2libGUgYXR0cmlidXRpb25zIGFuZCBzZXQgdGhlIGNvbGxhcHNpYmxlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBdHRyaWJ1dGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb2xsZWN0U291cmNlQXR0cmlidXRpb25zXyhmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgdmlzaWJsZUF0dHJpYnV0aW9ucyA9IEFycmF5LmZyb20oXG4gICAgICBuZXcgU2V0KFxuICAgICAgICB0aGlzLmdldE1hcCgpXG4gICAgICAgICAgLmdldEFsbExheWVycygpXG4gICAgICAgICAgLmZsYXRNYXAoKGxheWVyKSA9PiBsYXllci5nZXRBdHRyaWJ1dGlvbnMoZnJhbWVTdGF0ZSkpXG4gICAgICApXG4gICAgKTtcblxuICAgIGNvbnN0IGNvbGxhcHNpYmxlID0gIXRoaXMuZ2V0TWFwKClcbiAgICAgIC5nZXRBbGxMYXllcnMoKVxuICAgICAgLnNvbWUoXG4gICAgICAgIChsYXllcikgPT5cbiAgICAgICAgICBsYXllci5nZXRTb3VyY2UoKSAmJlxuICAgICAgICAgIGxheWVyLmdldFNvdXJjZSgpLmdldEF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlKCkgPT09IGZhbHNlXG4gICAgICApO1xuICAgIGlmICghdGhpcy5vdmVycmlkZUNvbGxhcHNpYmxlXykge1xuICAgICAgdGhpcy5zZXRDb2xsYXBzaWJsZShjb2xsYXBzaWJsZSk7XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlQXR0cmlidXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgdXBkYXRlRWxlbWVudF8oZnJhbWVTdGF0ZSkge1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRpb25zID0gdGhpcy5jb2xsZWN0U291cmNlQXR0cmlidXRpb25zXyhmcmFtZVN0YXRlKTtcblxuICAgIGNvbnN0IHZpc2libGUgPSBhdHRyaWJ1dGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAodGhpcy5yZW5kZXJlZFZpc2libGVfICE9IHZpc2libGUpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICcnIDogJ25vbmUnO1xuICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdmlzaWJsZTtcbiAgICB9XG5cbiAgICBpZiAoZXF1YWxzKGF0dHJpYnV0aW9ucywgdGhpcy5yZW5kZXJlZEF0dHJpYnV0aW9uc18pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy51bEVsZW1lbnRfKTtcblxuICAgIC8vIGFwcGVuZCB0aGUgYXR0cmlidXRpb25zXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXR0cmlidXRpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBhdHRyaWJ1dGlvbnNbaV07XG4gICAgICB0aGlzLnVsRWxlbWVudF8uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZEF0dHJpYnV0aW9uc18gPSBhdHRyaWJ1dGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGlja18oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuaGFuZGxlVG9nZ2xlXygpO1xuICAgIHRoaXMudXNlckNvbGxhcHNlZF8gPSB0aGlzLmNvbGxhcHNlZF87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRvZ2dsZV8oKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfQ09MTEFQU0VEKTtcbiAgICBpZiAodGhpcy5jb2xsYXBzZWRfKSB7XG4gICAgICByZXBsYWNlTm9kZSh0aGlzLmNvbGxhcHNlTGFiZWxfLCB0aGlzLmxhYmVsXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VOb2RlKHRoaXMubGFiZWxfLCB0aGlzLmNvbGxhcHNlTGFiZWxfKTtcbiAgICB9XG4gICAgdGhpcy5jb2xsYXBzZWRfID0gIXRoaXMuY29sbGFwc2VkXztcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgU3RyaW5nKCF0aGlzLmNvbGxhcHNlZF8pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGlvbiBpcyBjb2xsYXBzaWJsZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29sbGFwc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGFwc2libGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSBhdHRyaWJ1dGlvbiBzaG91bGQgYmUgY29sbGFwc2libGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sbGFwc2libGUgVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNpYmxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb2xsYXBzaWJsZShjb2xsYXBzaWJsZSkge1xuICAgIGlmICh0aGlzLmNvbGxhcHNpYmxlXyA9PT0gY29sbGFwc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb2xsYXBzaWJsZV8gPSBjb2xsYXBzaWJsZTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgnb2wtdW5jb2xsYXBzaWJsZScpO1xuICAgIGlmICh0aGlzLnVzZXJDb2xsYXBzZWRfKSB7XG4gICAgICB0aGlzLmhhbmRsZVRvZ2dsZV8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGFwc2Ugb3IgZXhwYW5kIHRoZSBhdHRyaWJ1dGlvbiBhY2NvcmRpbmcgdG8gdGhlIHBhc3NlZCBwYXJhbWV0ZXIuIFdpbGxcbiAgICogbm90IGRvIGFueXRoaW5nIGlmIHRoZSBhdHRyaWJ1dGlvbiBpc24ndCBjb2xsYXBzaWJsZSBvciBpZiB0aGUgY3VycmVudFxuICAgKiBjb2xsYXBzZWQgc3RhdGUgaXMgYWxyZWFkeSB0aGUgb25lIHJlcXVlc3RlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzZWQgVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sbGFwc2VkKGNvbGxhcHNlZCkge1xuICAgIHRoaXMudXNlckNvbGxhcHNlZF8gPSBjb2xsYXBzZWQ7XG4gICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlXyB8fCB0aGlzLmNvbGxhcHNlZF8gPT09IGNvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVRvZ2dsZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIHdoZW4gdGhlIGF0dHJpYnV0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQgb3IgYGZhbHNlYFxuICAgKiBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsYXBzZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRpb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBFdmVudCBNYXAgZXZlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyKG1hcEV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50XyhtYXBFdmVudC5mcmFtZVN0YXRlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGlvbjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9kZWZhdWx0c1xuICovXG5pbXBvcnQgQXR0cmlidXRpb24gZnJvbSAnLi9BdHRyaWJ1dGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBSb3RhdGUgZnJvbSAnLi9Sb3RhdGUuanMnO1xuaW1wb3J0IFpvb20gZnJvbSAnLi9ab29tLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uPXRydWVdIEluY2x1ZGVcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9BdHRyaWJ1dGlvbn5BdHRyaWJ1dGlvbn0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vQXR0cmlidXRpb24uanNcIikuT3B0aW9uc30gW2F0dHJpYnV0aW9uT3B0aW9uc11cbiAqIE9wdGlvbnMgZm9yIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9BdHRyaWJ1dGlvbn5BdHRyaWJ1dGlvbn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGU9dHJ1ZV0gSW5jbHVkZVxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX5Sb3RhdGV9LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1JvdGF0ZS5qc1wiKS5PcHRpb25zfSBbcm90YXRlT3B0aW9uc10gT3B0aW9uc1xuICogZm9yIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Sb3RhdGV+Um90YXRlfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3pvb21dIEluY2x1ZGUge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vWm9vbS5qc1wiKS5PcHRpb25zfSBbem9vbU9wdGlvbnNdIE9wdGlvbnMgZm9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfS5cbiAqL1xuXG4vKipcbiAqIFNldCBvZiBjb250cm9scyBpbmNsdWRlZCBpbiBtYXBzIGJ5IGRlZmF1bHQuIFVubGVzcyBjb25maWd1cmVkIG90aGVyd2lzZSxcbiAqIHRoaXMgcmV0dXJucyBhIGNvbGxlY3Rpb24gY29udGFpbmluZyBhbiBpbnN0YW5jZSBvZiBlYWNoIG9mIHRoZSBmb2xsb3dpbmdcbiAqIGNvbnRyb2xzOlxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufVxuICpcbiAqIEBwYXJhbSB7RGVmYXVsdHNPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGRlZmF1bHQgY29udHJvbHMuXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gQSBjb2xsZWN0aW9uIG9mIGNvbnRyb2xzXG4gKiB0byBiZSB1c2VkIHdpdGggdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gY29uc3RydWN0b3IncyBgY29udHJvbHNgIG9wdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgY29uc3QgY29udHJvbHMgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIGNvbnN0IHpvb21Db250cm9sID0gb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb20gOiB0cnVlO1xuICBpZiAoem9vbUNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBab29tKG9wdGlvbnMuem9vbU9wdGlvbnMpKTtcbiAgfVxuXG4gIGNvbnN0IHJvdGF0ZUNvbnRyb2wgPSBvcHRpb25zLnJvdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGUgOiB0cnVlO1xuICBpZiAocm90YXRlQ29udHJvbCkge1xuICAgIGNvbnRyb2xzLnB1c2gobmV3IFJvdGF0ZShvcHRpb25zLnJvdGF0ZU9wdGlvbnMpKTtcbiAgfVxuXG4gIGNvbnN0IGF0dHJpYnV0aW9uQ29udHJvbCA9XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hdHRyaWJ1dGlvbiA6IHRydWU7XG4gIGlmIChhdHRyaWJ1dGlvbkNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zLmF0dHJpYnV0aW9uT3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xzO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL1JvdGF0ZVxuICovXG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfSElEREVOLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLXJvdGF0ZSddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtsYWJlbD0nXHUyMUU3J10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSByb3RhdGUgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpcExhYmVsPSdSZXNldCByb3RhdGlvbiddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgcm90YXRlIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29tcGFzc0NsYXNzTmFtZT0nb2wtY29tcGFzcyddIENTUyBjbGFzcyBuYW1lIGZvciB0aGUgY29tcGFzcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b0hpZGU9dHJ1ZV0gSGlkZSB0aGUgY29udHJvbCB3aGVuIHJvdGF0aW9uIGlzIDAuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIHNob3VsZFxuICogYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6dm9pZH0gW3Jlc2V0Tm9ydGhdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIGlzIGNsaWNrZWQuXG4gKiBUaGlzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYHJlc2V0Tm9ydGhgLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBidXR0b24gY29udHJvbCB0byByZXNldCByb3RhdGlvbiB0byAwLlxuICogVG8gc3R5bGUgdGhpcyBjb250cm9sIHVzZSBjc3Mgc2VsZWN0b3IgYC5vbC1yb3RhdGVgLiBBIGAub2wtaGlkZGVuYCBjc3NcbiAqIHNlbGVjdG9yIGlzIGFkZGVkIHRvIHRoZSBidXR0b24gd2hlbiB0aGUgcm90YXRpb24gaXMgMC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFJvdGF0ZSBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gUm90YXRlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHJlbmRlcjogb3B0aW9ucy5yZW5kZXIsXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1yb3RhdGUnO1xuXG4gICAgY29uc3QgbGFiZWwgPSBvcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxhYmVsIDogJ1xcdTIxRTcnO1xuXG4gICAgY29uc3QgY29tcGFzc0NsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNvbXBhc3NDbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuY29tcGFzc0NsYXNzTmFtZVxuICAgICAgICA6ICdvbC1jb21wYXNzJztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxfID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMubGFiZWxfLmNsYXNzTmFtZSA9IGNvbXBhc3NDbGFzc05hbWU7XG4gICAgICB0aGlzLmxhYmVsXy50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGxhYmVsO1xuICAgICAgdGhpcy5sYWJlbF8uY2xhc3NMaXN0LmFkZChjb21wYXNzQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aXBMYWJlbCA9IG9wdGlvbnMudGlwTGFiZWwgPyBvcHRpb25zLnRpcExhYmVsIDogJ1Jlc2V0IHJvdGF0aW9uJztcblxuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLXJlc2V0JztcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi50aXRsZSA9IHRpcExhYmVsO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsXyk7XG5cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcyksXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICBjb25zdCBjc3NDbGFzc2VzID1cbiAgICAgIGNsYXNzTmFtZSArICcgJyArIENMQVNTX1VOU0VMRUNUQUJMRSArICcgJyArIENMQVNTX0NPTlRST0w7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXM7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgdGhpcy5jYWxsUmVzZXROb3J0aF8gPSBvcHRpb25zLnJlc2V0Tm9ydGggPyBvcHRpb25zLnJlc2V0Tm9ydGggOiB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmF1dG9IaWRlXyA9IG9wdGlvbnMuYXV0b0hpZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0b0hpZGUgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmF1dG9IaWRlXykge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfSElEREVOKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGlja18oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLmNhbGxSZXNldE5vcnRoXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGxSZXNldE5vcnRoXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0Tm9ydGhfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldE5vcnRoXygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICghdmlldykge1xuICAgICAgLy8gdGhlIG1hcCBkb2VzIG5vdCBoYXZlIGEgdmlldywgc28gd2UgY2FuJ3QgYWN0XG4gICAgICAvLyB1cG9uIGl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwICYmIHJvdGF0aW9uICUgKDIgKiBNYXRoLlBJKSAhPT0gMCkge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRSb3RhdGlvbigwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSByb3RhdGUgY29udHJvbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXIobWFwRXZlbnQpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gbWFwRXZlbnQuZnJhbWVTdGF0ZTtcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT0gdGhpcy5yb3RhdGlvbl8pIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ3JhZCknO1xuICAgICAgaWYgKHRoaXMuYXV0b0hpZGVfKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19ISURERU4pO1xuICAgICAgICBpZiAoIWNvbnRhaW5zICYmIHJvdGF0aW9uID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfSElEREVOKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWlucyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX0hJRERFTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSb3RhdGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvWm9vbVxuICovXG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLXpvb20nXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbUluQ2xhc3NOYW1lPWNsYXNzTmFtZSArICctaW4nXSBDU1MgY2xhc3MgbmFtZSBmb3IgdGhlIHpvb20taW4gYnV0dG9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tT3V0Q2xhc3NOYW1lPWNsYXNzTmFtZSArICctb3V0J10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZSB6b29tLW91dCBidXR0b24uXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW3pvb21JbkxhYmVsPScrJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSB6b29tLWluXG4gKiBidXR0b24uIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFt6b29tT3V0TGFiZWw9J1x1MjAxMyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgem9vbS1vdXQgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb21JblRpcExhYmVsPSdab29tIGluJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSBidXR0b24gdGlwLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tT3V0VGlwTGFiZWw9J1pvb20gb3V0J10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSBidXR0b24gdGlwLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBkZWx0YSBhcHBsaWVkIG9uIGVhY2ggY2xpY2suXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gU3BlY2lmeSBhIHRhcmdldCBpZiB5b3Ugd2FudCB0aGUgY29udHJvbCB0byBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgbWFwJ3Mgdmlld3BvcnQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNvbnRyb2wgd2l0aCAyIGJ1dHRvbnMsIG9uZSBmb3Igem9vbSBpbiBhbmQgb25lIGZvciB6b29tIG91dC5cbiAqIFRoaXMgY29udHJvbCBpcyBvbmUgb2YgdGhlIGRlZmF1bHQgY29udHJvbHMgb2YgYSBtYXAuIFRvIHN0eWxlIHRoaXMgY29udHJvbFxuICogdXNlIGNzcyBzZWxlY3RvcnMgYC5vbC16b29tLWluYCBhbmQgYC5vbC16b29tLW91dGAuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBab29tIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBab29tIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLXpvb20nO1xuXG4gICAgY29uc3QgZGVsdGEgPSBvcHRpb25zLmRlbHRhICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbHRhIDogMTtcblxuICAgIGNvbnN0IHpvb21JbkNsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLnpvb21JbkNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy56b29tSW5DbGFzc05hbWVcbiAgICAgICAgOiBjbGFzc05hbWUgKyAnLWluJztcblxuICAgIGNvbnN0IHpvb21PdXRDbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy56b29tT3V0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnpvb21PdXRDbGFzc05hbWVcbiAgICAgICAgOiBjbGFzc05hbWUgKyAnLW91dCc7XG5cbiAgICBjb25zdCB6b29tSW5MYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21JbkxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21JbkxhYmVsIDogJysnO1xuICAgIGNvbnN0IHpvb21PdXRMYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21PdXRMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tT3V0TGFiZWwgOiAnXFx1MjAxMyc7XG5cbiAgICBjb25zdCB6b29tSW5UaXBMYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21JblRpcExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21JblRpcExhYmVsIDogJ1pvb20gaW4nO1xuICAgIGNvbnN0IHpvb21PdXRUaXBMYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21PdXRUaXBMYWJlbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy56b29tT3V0VGlwTGFiZWxcbiAgICAgICAgOiAnWm9vbSBvdXQnO1xuXG4gICAgY29uc3QgaW5FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgaW5FbGVtZW50LmNsYXNzTmFtZSA9IHpvb21JbkNsYXNzTmFtZTtcbiAgICBpbkVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGluRWxlbWVudC50aXRsZSA9IHpvb21JblRpcExhYmVsO1xuICAgIGluRWxlbWVudC5hcHBlbmRDaGlsZChcbiAgICAgIHR5cGVvZiB6b29tSW5MYWJlbCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh6b29tSW5MYWJlbClcbiAgICAgICAgOiB6b29tSW5MYWJlbFxuICAgICk7XG5cbiAgICBpbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcywgZGVsdGEpLFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3Qgb3V0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIG91dEVsZW1lbnQuY2xhc3NOYW1lID0gem9vbU91dENsYXNzTmFtZTtcbiAgICBvdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBvdXRFbGVtZW50LnRpdGxlID0gem9vbU91dFRpcExhYmVsO1xuICAgIG91dEVsZW1lbnQuYXBwZW5kQ2hpbGQoXG4gICAgICB0eXBlb2Ygem9vbU91dExhYmVsID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHpvb21PdXRMYWJlbClcbiAgICAgICAgOiB6b29tT3V0TGFiZWxcbiAgICApO1xuXG4gICAgb3V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzLCAtZGVsdGEpLFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3QgY3NzQ2xhc3NlcyA9XG4gICAgICBjbGFzc05hbWUgKyAnICcgKyBDTEFTU19VTlNFTEVDVEFCTEUgKyAnICcgKyBDTEFTU19DT05UUk9MO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5FbGVtZW50KTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKG91dEVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgWm9vbSBkZWx0YS5cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGlja18oZGVsdGEsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnpvb21CeURlbHRhXyhkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFpvb20gZGVsdGEuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB6b29tQnlEZWx0YV8oZGVsdGEpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICghdmlldykge1xuICAgICAgLy8gdGhlIG1hcCBkb2VzIG5vdCBoYXZlIGEgdmlldywgc28gd2UgY2FuJ3QgYWN0XG4gICAgICAvLyB1cG9uIGl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRab29tID0gdmlldy5nZXRab29tKCk7XG4gICAgaWYgKGN1cnJlbnRab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5ld1pvb20gPSB2aWV3LmdldENvbnN0cmFpbmVkWm9vbShjdXJyZW50Wm9vbSArIGRlbHRhKTtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uXyA+IDApIHtcbiAgICAgICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHpvb206IG5ld1pvb20sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3LnNldFpvb20obmV3Wm9vbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpvb207XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL2RlZmF1bHRzXG4gKi9cbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IERvdWJsZUNsaWNrWm9vbSBmcm9tICcuL0RvdWJsZUNsaWNrWm9vbS5qcyc7XG5pbXBvcnQgRHJhZ1BhbiBmcm9tICcuL0RyYWdQYW4uanMnO1xuaW1wb3J0IERyYWdSb3RhdGUgZnJvbSAnLi9EcmFnUm90YXRlLmpzJztcbmltcG9ydCBEcmFnWm9vbSBmcm9tICcuL0RyYWdab29tLmpzJztcbmltcG9ydCBLZXlib2FyZFBhbiBmcm9tICcuL0tleWJvYXJkUGFuLmpzJztcbmltcG9ydCBLZXlib2FyZFpvb20gZnJvbSAnLi9LZXlib2FyZFpvb20uanMnO1xuaW1wb3J0IEtpbmV0aWMgZnJvbSAnLi4vS2luZXRpYy5qcyc7XG5pbXBvcnQgTW91c2VXaGVlbFpvb20gZnJvbSAnLi9Nb3VzZVdoZWVsWm9vbS5qcyc7XG5pbXBvcnQgUGluY2hSb3RhdGUgZnJvbSAnLi9QaW5jaFJvdGF0ZS5qcyc7XG5pbXBvcnQgUGluY2hab29tIGZyb20gJy4vUGluY2hab29tLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsdFNoaWZ0RHJhZ1JvdGF0ZT10cnVlXSBXaGV0aGVyIEFsdC1TaGlmdC1kcmFnIHJvdGF0ZSBpc1xuICogZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29uRm9jdXNPbmx5PWZhbHNlXSBJbnRlcmFjdCBvbmx5IHdoZW4gdGhlIG1hcCBoYXMgdGhlXG4gKiBmb2N1cy4gVGhpcyBhZmZlY3RzIHRoZSBgTW91c2VXaGVlbFpvb21gIGFuZCBgRHJhZ1BhbmAgaW50ZXJhY3Rpb25zIGFuZCBpc1xuICogdXNlZnVsIHdoZW4gcGFnZSBzY3JvbGwgaXMgZGVzaXJlZCBmb3IgbWFwcyB0aGF0IGRvIG5vdCBoYXZlIHRoZSBicm93c2VyJ3NcbiAqIGZvY3VzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZG91YmxlQ2xpY2tab29tPXRydWVdIFdoZXRoZXIgZG91YmxlIGNsaWNrIHpvb20gaXNcbiAqIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZXlib2FyZD10cnVlXSBXaGV0aGVyIGtleWJvYXJkIGludGVyYWN0aW9uIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttb3VzZVdoZWVsWm9vbT10cnVlXSBXaGV0aGVyIG1vdXNld2hlZWwgem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2hpZnREcmFnWm9vbT10cnVlXSBXaGV0aGVyIFNoaWZ0LWRyYWcgem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZHJhZ1Bhbj10cnVlXSBXaGV0aGVyIGRyYWcgcGFuIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwaW5jaFJvdGF0ZT10cnVlXSBXaGV0aGVyIHBpbmNoIHJvdGF0ZSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGluY2hab29tPXRydWVdIFdoZXRoZXIgcGluY2ggem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tRGVsdGFdIFpvb20gbGV2ZWwgZGVsdGEgd2hlbiB1c2luZyBrZXlib2FyZCBvciBkb3VibGUgY2xpY2sgem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbUR1cmF0aW9uXSBEdXJhdGlvbiBvZiB0aGUgem9vbSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG4vKipcbiAqIFNldCBvZiBpbnRlcmFjdGlvbnMgaW5jbHVkZWQgaW4gbWFwcyBieSBkZWZhdWx0LiBTcGVjaWZpYyBpbnRlcmFjdGlvbnMgY2FuIGJlXG4gKiBleGNsdWRlZCBieSBzZXR0aW5nIHRoZSBhcHByb3ByaWF0ZSBvcHRpb24gdG8gZmFsc2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKiBvcHRpb25zLCBidXQgdGhlIG9yZGVyIG9mIHRoZSBpbnRlcmFjdGlvbnMgaXMgZml4ZWQuICBJZiB5b3Ugd2FudCB0byBzcGVjaWZ5XG4gKiBhIGRpZmZlcmVudCBvcmRlciBmb3IgaW50ZXJhY3Rpb25zLCB5b3Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSB5b3VyIG93blxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbn5JbnRlcmFjdGlvbn0gaW5zdGFuY2VzIGFuZCBpbnNlcnRcbiAqIHRoZW0gaW50byBhIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBpbiB0aGUgb3JkZXIgeW91IHdhbnRcbiAqIGJlZm9yZSBjcmVhdGluZyB5b3VyIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gaW5zdGFuY2UuIENoYW5naW5nIHRoZSBvcmRlciBjYW5cbiAqIGJlIG9mIGludGVyZXN0IGlmIHRoZSBldmVudCBwcm9wYWdhdGlvbiBuZWVkcyB0byBiZSBzdG9wcGVkIGF0IGEgcG9pbnQuXG4gKiBUaGUgZGVmYXVsdCBzZXQgb2YgaW50ZXJhY3Rpb25zLCBpbiBzZXF1ZW5jZSwgaXM6XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZX5EcmFnUm90YXRlfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbX5Eb3VibGVDbGlja1pvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbn5EcmFnUGFufVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlflBpbmNoUm90YXRlfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1BpbmNoWm9vbX5QaW5jaFpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW5+S2V5Ym9hcmRQYW59XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbX5Nb3VzZVdoZWVsWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbX5EcmFnWm9vbX1cbiAqXG4gKiBAcGFyYW0ge0RlZmF1bHRzT3B0aW9uc30gW29wdGlvbnNdIERlZmF1bHRzIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKiBBIGNvbGxlY3Rpb24gb2YgaW50ZXJhY3Rpb25zIHRvIGJlIHVzZWQgd2l0aCB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfVxuICogY29uc3RydWN0b3IncyBgaW50ZXJhY3Rpb25zYCBvcHRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0cyhvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICBjb25zdCBpbnRlcmFjdGlvbnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIGNvbnN0IGtpbmV0aWMgPSBuZXcgS2luZXRpYygtMC4wMDUsIDAuMDUsIDEwMCk7XG5cbiAgY29uc3QgYWx0U2hpZnREcmFnUm90YXRlID1cbiAgICBvcHRpb25zLmFsdFNoaWZ0RHJhZ1JvdGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IG9wdGlvbnMuYWx0U2hpZnREcmFnUm90YXRlXG4gICAgICA6IHRydWU7XG4gIGlmIChhbHRTaGlmdERyYWdSb3RhdGUpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgRHJhZ1JvdGF0ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IGRvdWJsZUNsaWNrWm9vbSA9XG4gICAgb3B0aW9ucy5kb3VibGVDbGlja1pvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZG91YmxlQ2xpY2tab29tIDogdHJ1ZTtcbiAgaWYgKGRvdWJsZUNsaWNrWm9vbSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKFxuICAgICAgbmV3IERvdWJsZUNsaWNrWm9vbSh7XG4gICAgICAgIGRlbHRhOiBvcHRpb25zLnpvb21EZWx0YSxcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uLFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgY29uc3QgZHJhZ1BhbiA9IG9wdGlvbnMuZHJhZ1BhbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kcmFnUGFuIDogdHJ1ZTtcbiAgaWYgKGRyYWdQYW4pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBEcmFnUGFuKHtcbiAgICAgICAgb25Gb2N1c09ubHk6IG9wdGlvbnMub25Gb2N1c09ubHksXG4gICAgICAgIGtpbmV0aWM6IGtpbmV0aWMsXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb25zdCBwaW5jaFJvdGF0ZSA9XG4gICAgb3B0aW9ucy5waW5jaFJvdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waW5jaFJvdGF0ZSA6IHRydWU7XG4gIGlmIChwaW5jaFJvdGF0ZSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBQaW5jaFJvdGF0ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IHBpbmNoWm9vbSA9IG9wdGlvbnMucGluY2hab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBpbmNoWm9vbSA6IHRydWU7XG4gIGlmIChwaW5jaFpvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBQaW5jaFpvb20oe1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb24sXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb25zdCBrZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5Ym9hcmQgOiB0cnVlO1xuICBpZiAoa2V5Ym9hcmQpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgS2V5Ym9hcmRQYW4oKSk7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2goXG4gICAgICBuZXcgS2V5Ym9hcmRab29tKHtcbiAgICAgICAgZGVsdGE6IG9wdGlvbnMuem9vbURlbHRhLFxuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb24sXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb25zdCBtb3VzZVdoZWVsWm9vbSA9XG4gICAgb3B0aW9ucy5tb3VzZVdoZWVsWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3VzZVdoZWVsWm9vbSA6IHRydWU7XG4gIGlmIChtb3VzZVdoZWVsWm9vbSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKFxuICAgICAgbmV3IE1vdXNlV2hlZWxab29tKHtcbiAgICAgICAgb25Gb2N1c09ubHk6IG9wdGlvbnMub25Gb2N1c09ubHksXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHNoaWZ0RHJhZ1pvb20gPVxuICAgIG9wdGlvbnMuc2hpZnREcmFnWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaGlmdERyYWdab29tIDogdHJ1ZTtcbiAgaWYgKHNoaWZ0RHJhZ1pvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBEcmFnWm9vbSh7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBpbnRlcmFjdGlvbnM7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25Qcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCB7ZWFzZU91dCwgbGluZWFyfSBmcm9tICcuLi9lYXNpbmcuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZScsIFJldHVybj59IEludGVyYWN0aW9uT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIE9iamVjdCBsaXRlcmFsIHdpdGggY29uZmlnIG9wdGlvbnMgZm9yIGludGVyYWN0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gaGFuZGxlRXZlbnRcbiAqIE1ldGhvZCBjYWxsZWQgYnkgdGhlIG1hcCB0byBub3RpZnkgdGhlIGludGVyYWN0aW9uIHRoYXQgYSBicm93c2VyIGV2ZW50IHdhc1xuICogZGlzcGF0Y2hlZCB0byB0aGUgbWFwLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBwcm9wYWdhdGlvbiBvZlxuICogdGhlIGV2ZW50IHRvIG90aGVyIGludGVyYWN0aW9ucyBpbiB0aGUgbWFwJ3MgaW50ZXJhY3Rpb25zIGNoYWluIHdpbGwgYmVcbiAqIHByZXZlbnRlZCAodGhpcyBpbmNsdWRlcyBmdW5jdGlvbnMgd2l0aCBubyBleHBsaWNpdCByZXR1cm4pLiBUaGUgaW50ZXJhY3Rpb25zXG4gKiBhcmUgdHJhdmVyc2VkIGluIHJldmVyc2Ugb3JkZXIgb2YgdGhlIGludGVyYWN0aW9ucyBjb2xsZWN0aW9uIG9mIHRoZSBtYXAuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBVc2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBtYXAuIFNvbWUgYXJlIHNpbWlsYXIgdG8gY29udHJvbHMsXG4gKiBidXQgYXJlIG5vdCBhc3NvY2lhdGVkIHdpdGggYSBET00gZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbX5LZXlib2FyZFpvb219IGlzXG4gKiBmdW5jdGlvbmFsbHkgdGhlIHNhbWUgYXMge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0sIGJ1dCB0cmlnZ2VyZWRcbiAqIGJ5IGEga2V5Ym9hcmQgZXZlbnQgbm90IGEgYnV0dG9uIGVsZW1lbnQgZXZlbnQuXG4gKiBBbHRob3VnaCBpbnRlcmFjdGlvbnMgZG8gbm90IGhhdmUgYSBET00gZWxlbWVudCwgc29tZSBvZiB0aGVtIGRvIHJlbmRlclxuICogdmVjdG9ycyBhbmQgc28gYXJlIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgSW50ZXJhY3Rpb24gZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtJbnRlcmFjdGlvbk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0ludGVyYWN0aW9uT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtJbnRlcmFjdGlvbk9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZUV2ZW50ID0gb3B0aW9ucy5oYW5kbGVFdmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG51bGw7XG5cbiAgICB0aGlzLnNldEFjdGl2ZSh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgaW50ZXJhY3Rpb24gaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHRoaXMuZ2V0KEludGVyYWN0aW9uUHJvcGVydHkuQUNUSVZFKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW50ZXJhY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBBY3RpdmUuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICB0aGlzLnNldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSwgYWN0aXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRlbHRhIERlbHRhLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYW4odmlldywgZGVsdGEsIGR1cmF0aW9uKSB7XG4gIGNvbnN0IGN1cnJlbnRDZW50ZXIgPSB2aWV3LmdldENlbnRlckludGVybmFsKCk7XG4gIGlmIChjdXJyZW50Q2VudGVyKSB7XG4gICAgY29uc3QgY2VudGVyID0gW2N1cnJlbnRDZW50ZXJbMF0gKyBkZWx0YVswXSwgY3VycmVudENlbnRlclsxXSArIGRlbHRhWzFdXTtcbiAgICB2aWV3LmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGR1cmF0aW9uIDogMjUwLFxuICAgICAgZWFzaW5nOiBsaW5lYXIsXG4gICAgICBjZW50ZXI6IHZpZXcuZ2V0Q29uc3RyYWluZWRDZW50ZXIoY2VudGVyKSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEgZnJvbSBwcmV2aW91cyB6b29tIGxldmVsLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIEFuY2hvciBjb29yZGluYXRlIGluIHRoZSB1c2VyIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCBhbmNob3IsIGR1cmF0aW9uKSB7XG4gIGNvbnN0IGN1cnJlbnRab29tID0gdmlldy5nZXRab29tKCk7XG5cbiAgaWYgKGN1cnJlbnRab29tID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBuZXdab29tID0gdmlldy5nZXRDb25zdHJhaW5lZFpvb20oY3VycmVudFpvb20gKyBkZWx0YSk7XG4gIGNvbnN0IG5ld1Jlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb25Gb3Jab29tKG5ld1pvb20pO1xuXG4gIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gIH1cbiAgdmlldy5hbmltYXRlKHtcbiAgICByZXNvbHV0aW9uOiBuZXdSZXNvbHV0aW9uLFxuICAgIGFuY2hvcjogYW5jaG9yLFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiAyNTAsXG4gICAgZWFzaW5nOiBlYXNlT3V0LFxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJhY3Rpb247XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFDVElWRTogJ2FjdGl2ZScsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb21cbiAqL1xuaW1wb3J0IEludGVyYWN0aW9uLCB7em9vbUJ5RGVsdGF9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gZWFjaCBkb3VibGUgY2xpY2suXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSBieSBkb3VibGUtY2xpY2tpbmcgb24gdGhlIG1hcC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRG91YmxlQ2xpY2tab29tIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YV8gPSBvcHRpb25zLmRlbHRhID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhXG4gICAqIGRvdWJsZWNsaWNrKSBhbmQgZXZlbnR1YWxseSB6b29tcyB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICovXG4gIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGxldCBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSykge1xuICAgICAgY29uc3QgYnJvd3NlckV2ZW50ID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAoXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICApO1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIGNvbnN0IGFuY2hvciA9IG1hcEJyb3dzZXJFdmVudC5jb29yZGluYXRlO1xuICAgICAgY29uc3QgZGVsdGEgPSBicm93c2VyRXZlbnQuc2hpZnRLZXkgPyAtdGhpcy5kZWx0YV8gOiB0aGlzLmRlbHRhXztcbiAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIGFuY2hvciwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgYnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEb3VibGVDbGlja1pvb207XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BvaW50ZXJcbiAqL1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZURvd25FdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZG93blwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIHRoZW4gYSBkcmFnXG4gKiBzZXF1ZW5jZSBpcyBzdGFydGVkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW2hhbmRsZURyYWdFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZHJhZ1wiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzXG4gKiBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZUV2ZW50XVxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIFRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCB0aGVcbiAqIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9uc1xuICogY2hhaW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbaGFuZGxlTW92ZUV2ZW50XVxuICogRnVuY3Rpb24gaGFuZGxpbmcgXCJtb3ZlXCIgZXZlbnRzLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBcIm1vdmVcIiBldmVudHMuXG4gKiBUaGlzIGZ1bmN0aW9ucyBpcyBhbHNvIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLCBzbyBkdXJpbmcgYSBkcmFnXG4gKiBzZXF1ZW5jZSBib3RoIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCBmdW5jdGlvbiBhbmQgdGhpcyBmdW5jdGlvbiBhcmUgY2FsbGVkLlxuICogSWYgYGhhbmRsZURvd25FdmVudGAgaXMgZGVmaW5lZCBhbmQgaXQgcmV0dXJucyB0cnVlIHRoaXMgZnVuY3Rpb24gd2lsbCBub3RcbiAqIGJlIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZVVwRXZlbnRdXG4gKiAgRnVuY3Rpb24gaGFuZGxpbmcgXCJ1cFwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGVuIHRoZVxuICogY3VycmVudCBkcmFnIHNlcXVlbmNlIGlzIHN0b3BwZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOmJvb2xlYW59IFtzdG9wRG93bl1cbiAqIFNob3VsZCB0aGUgZG93biBldmVudCBiZSBwcm9wYWdhdGVkIHRvIG90aGVyIGludGVyYWN0aW9ucywgb3Igc2hvdWxkIGJlXG4gKiBzdG9wcGVkP1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyB0aGF0IGNhbGxzIHVzZXItZGVmaW5lZCBmdW5jdGlvbnMgb24gYGRvd25gLCBgbW92ZWAgYW5kIGB1cGBcbiAqIGV2ZW50cy4gVGhpcyBjbGFzcyBhbHNvIG1hbmFnZXMgXCJkcmFnIHNlcXVlbmNlc1wiLlxuICpcbiAqIFdoZW4gdGhlIGBoYW5kbGVEb3duRXZlbnRgIHVzZXIgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgYSBkcmFnIHNlcXVlbmNlIGlzXG4gKiBzdGFydGVkLiBEdXJpbmcgYSBkcmFnIHNlcXVlbmNlIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCB1c2VyIGZ1bmN0aW9uIGlzXG4gKiBjYWxsZWQgb24gYG1vdmVgIGV2ZW50cy4gVGhlIGRyYWcgc2VxdWVuY2UgZW5kcyB3aGVuIHRoZSBgaGFuZGxlVXBFdmVudGBcbiAqIHVzZXIgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBvaW50ZXJJbnRlcmFjdGlvbiBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIChvcHRpb25zKVxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVEb3duRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlRG93bkV2ZW50ID0gb3B0aW9ucy5oYW5kbGVEb3duRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRHJhZ0V2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZURyYWdFdmVudCA9IG9wdGlvbnMuaGFuZGxlRHJhZ0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZU1vdmVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlRXZlbnQgPSBvcHRpb25zLmhhbmRsZU1vdmVFdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVVcEV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZVVwRXZlbnQgPSBvcHRpb25zLmhhbmRsZVVwRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHRoaXMuc3RvcERvd24gPSBvcHRpb25zLnN0b3BEb3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxQb2ludGVyRXZlbnQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2YgcG9pbnRlcnMgaW52b2x2ZWQgaW4gdGhlIGludGVyYWN0aW9uLFxuICAgKiBlLmcuIGAyYCB3aGVuIHR3byBmaW5nZXJzIGFyZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcG9pbnRlcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvaW50ZXJDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7fVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgY2FsbCBpbnRvXG4gICAqIG90aGVyIGZ1bmN0aW9ucywgaWYgZXZlbnQgc2VxdWVuY2VzIGxpa2UgZS5nLiAnZHJhZycgb3IgJ2Rvd24tdXAnIGV0Yy4gYXJlXG4gICAqIGRldGVjdGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlVHJhY2tlZFBvaW50ZXJzXyhtYXBCcm93c2VyRXZlbnQpO1xuICAgIGlmICh0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIC8vIHByZXZlbnQgcGFnZSBzY3JvbGxpbmcgZHVyaW5nIGRyYWdnaW5nXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZWRVcCA9IHRoaXMuaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPVxuICAgICAgICAgIGhhbmRsZWRVcCAmJiB0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZWQgPSB0aGlzLmhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBoYW5kbGVkO1xuICAgICAgICBzdG9wRXZlbnQgPSB0aGlzLnN0b3BEb3duKGhhbmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhc3RvcEV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIG1vdmUgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU1vdmVFdmVudChtYXBCcm93c2VyRXZlbnQpIHt9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIFwiZG93blwiIGV2ZW50cyBzaG91bGQgYmUgcHJvcGFnYXRlZFxuICAgKiB0byBvdGhlciBpbnRlcmFjdGlvbnMgb3Igc2hvdWxkIGJlIHN0b3BwZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFuZGxlZCBXYXMgdGhlIGV2ZW50IGhhbmRsZWQgYnkgdGhlIGludGVyYWN0aW9uP1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBTaG91bGQgdGhlIGBkb3duYCBldmVudCBiZSBzdG9wcGVkP1xuICAgKi9cbiAgc3RvcERvd24oaGFuZGxlZCkge1xuICAgIHJldHVybiBoYW5kbGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVRyYWNrZWRQb2ludGVyc18obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC5hY3RpdmVQb2ludGVycykge1xuICAgICAgdGhpcy50YXJnZXRQb2ludGVycyA9IG1hcEJyb3dzZXJFdmVudC5hY3RpdmVQb2ludGVycztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50ZXJFdmVudD59IHBvaW50ZXJFdmVudHMgTGlzdCBvZiBldmVudHMuXG4gKiBAcmV0dXJuIHt7Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9fSBDZW50cm9pZCBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKHBvaW50ZXJFdmVudHMpIHtcbiAgY29uc3QgbGVuZ3RoID0gcG9pbnRlckV2ZW50cy5sZW5ndGg7XG4gIGxldCBjbGllbnRYID0gMDtcbiAgbGV0IGNsaWVudFkgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2xpZW50WCArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFg7XG4gICAgY2xpZW50WSArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFk7XG4gIH1cbiAgcmV0dXJuIHtjbGllbnRYOiBjbGllbnRYIC8gbGVuZ3RoLCBjbGllbnRZOiBjbGllbnRZIC8gbGVuZ3RofTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckludGVyYWN0aW9uO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnUGFuXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtcbiAgY2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnMsXG59IGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYWxsLFxuICBmb2N1c1dpdGhUYWJpbmRleCxcbiAgbm9Nb2RpZmllcktleXMsXG4gIHByaW1hcnlBY3Rpb24sXG59IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtcbiAgcm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGUsXG4gIHNjYWxlIGFzIHNjYWxlQ29vcmRpbmF0ZSxcbn0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5ub01vZGlmaWVyS2V5c30gYW5kIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5wcmltYXJ5QWN0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29uRm9jdXNPbmx5PWZhbHNlXSBXaGVuIHRoZSBtYXAncyB0YXJnZXQgaGFzIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUgc2V0LFxuICogdGhlIGludGVyYWN0aW9uIHdpbGwgb25seSBoYW5kbGUgZXZlbnRzIHdoZW4gdGhlIG1hcCBoYXMgdGhlIGZvY3VzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9LaW5ldGljLmpzXCIpLmRlZmF1bHR9IFtraW5ldGljXSBLaW5ldGljIGluZXJ0aWEgdG8gYXBwbHkgdG8gdGhlIHBhbi5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBwYW4gdGhlIG1hcCBieSBkcmFnZ2luZyB0aGUgbWFwLlxuICogQGFwaVxuICovXG5jbGFzcyBEcmFnUGFuIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgc3RvcERvd246IEZBTFNFLFxuICAgIH0pO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9LaW5ldGljLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMua2luZXRpY18gPSBvcHRpb25zLmtpbmV0aWM7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5sYXN0Q2VudHJvaWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQb2ludGVyc0NvdW50XztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucGFubmluZ18gPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbmRpdGlvbiA9IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICA/IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICA6IGFsbChub01vZGlmaWVyS2V5cywgcHJpbWFyeUFjdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLm9uRm9jdXNPbmx5XG4gICAgICA/IGFsbChmb2N1c1dpdGhUYWJpbmRleCwgY29uZGl0aW9uKVxuICAgICAgOiBjb25kaXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubm9LaW5ldGljXyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBpZiAoIXRoaXMucGFubmluZ18pIHtcbiAgICAgIHRoaXMucGFubmluZ18gPSB0cnVlO1xuICAgICAgbWFwLmdldFZpZXcoKS5iZWdpbkludGVyYWN0aW9uKCk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFBvaW50ZXJzID0gdGhpcy50YXJnZXRQb2ludGVycztcbiAgICBjb25zdCBjZW50cm9pZCA9IG1hcC5nZXRFdmVudFBpeGVsKGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRhcmdldFBvaW50ZXJzKSk7XG4gICAgaWYgKHRhcmdldFBvaW50ZXJzLmxlbmd0aCA9PSB0aGlzLmxhc3RQb2ludGVyc0NvdW50Xykge1xuICAgICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgICAgdGhpcy5raW5ldGljXy51cGRhdGUoY2VudHJvaWRbMF0sIGNlbnRyb2lkWzFdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxhc3RDZW50cm9pZCkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IFtcbiAgICAgICAgICB0aGlzLmxhc3RDZW50cm9pZFswXSAtIGNlbnRyb2lkWzBdLFxuICAgICAgICAgIGNlbnRyb2lkWzFdIC0gdGhpcy5sYXN0Q2VudHJvaWRbMV0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgICBzY2FsZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICAgICAgcm90YXRlQ29vcmRpbmF0ZShkZWx0YSwgdmlldy5nZXRSb3RhdGlvbigpKTtcbiAgICAgICAgdmlldy5hZGp1c3RDZW50ZXJJbnRlcm5hbChkZWx0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAvLyByZXNldCBzbyB3ZSBkb24ndCBvdmVyZXN0aW1hdGUgdGhlIGtpbmV0aWMgZW5lcmd5IGFmdGVyXG4gICAgICAvLyBhZnRlciBvbmUgZmluZ2VyIGRvd24sIHRpbnkgZHJhZywgc2Vjb25kIGZpbmdlciBkb3duXG4gICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENlbnRyb2lkID0gY2VudHJvaWQ7XG4gICAgdGhpcy5sYXN0UG9pbnRlcnNDb3VudF8gPSB0YXJnZXRQb2ludGVycy5sZW5ndGg7XG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICghdGhpcy5ub0tpbmV0aWNfICYmIHRoaXMua2luZXRpY18gJiYgdGhpcy5raW5ldGljXy5lbmQoKSkge1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMua2luZXRpY18uZ2V0RGlzdGFuY2UoKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLmtpbmV0aWNfLmdldEFuZ2xlKCk7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHZpZXcuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICAgICAgY29uc3QgY2VudGVycHggPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZUludGVybmFsKGNlbnRlcik7XG4gICAgICAgIGNvbnN0IGRlc3QgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKFtcbiAgICAgICAgICBjZW50ZXJweFswXSAtIGRpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIGNlbnRlcnB4WzFdIC0gZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIF0pO1xuICAgICAgICB2aWV3LmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICAgICAgY2VudGVyOiB2aWV3LmdldENvbnN0cmFpbmVkQ2VudGVyKGRlc3QpLFxuICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhbm5pbmdfKSB7XG4gICAgICAgIHRoaXMucGFubmluZ18gPSBmYWxzZTtcbiAgICAgICAgdmlldy5lbmRJbnRlcmFjdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgLy8gcmVzZXQgc28gd2UgZG9uJ3Qgb3ZlcmVzdGltYXRlIHRoZSBraW5ldGljIGVuZXJneSBhZnRlclxuICAgICAgLy8gYWZ0ZXIgb25lIGZpbmdlciB1cCwgdGlueSBkcmFnLCBzZWNvbmQgZmluZ2VyIHVwXG4gICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICAgIC8vIHN0b3AgYW55IGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vIGtpbmV0aWMgYXMgc29vbiBhcyBtb3JlIHRoYW4gb25lIHBvaW50ZXIgb24gdGhlIHNjcmVlbiBpc1xuICAgICAgLy8gZGV0ZWN0ZWQuIFRoaXMgaXMgdG8gcHJldmVudCBuYXN0eSBwYW5zIGFmdGVyIHBpbmNoLlxuICAgICAgdGhpcy5ub0tpbmV0aWNfID0gdGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnUGFuO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvY29uZGl0aW9uXG4gKi9cbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtGQUxTRSwgVFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7TUFDLCBXRUJLSVR9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYHtib29sZWFufWAuIElmIHRoZSBjb25kaXRpb24gaXMgbWV0LCB0cnVlIHNob3VsZCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczogPywgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBDb25kaXRpb25cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBwYXNzZXMgd2hlbiBhbGwgcHJvdmlkZWQgY29uZGl0aW9ucyBwYXNzLlxuICogQHBhcmFtIHsuLi5Db25kaXRpb259IHZhcl9hcmdzIENvbmRpdGlvbnMgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtDb25kaXRpb259IENvbmRpdGlvbiBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsbCh2YXJfYXJncykge1xuICBjb25zdCBjb25kaXRpb25zID0gYXJndW1lbnRzO1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEFsbCBjb25kaXRpb25zIHBhc3NlZC5cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBsZXQgcGFzcyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29uZGl0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBwYXNzID0gcGFzcyAmJiBjb25kaXRpb25zW2ldKGV2ZW50KTtcbiAgICAgIGlmICghcGFzcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhc3M7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBhbHQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW5cbiAqIGFkZGl0aW9uYWxseSB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgYWx0IGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgYWx0S2V5T25seSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gKFxuICAgIG9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5XG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgYWx0LWtleSBhbmQgc2hpZnQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiAoZS5nLiB3aGVuIGFkZGl0aW9uYWxseSB0aGUgcGxhdGZvcm0tbW9kaWZpZXIta2V5IGlzIHByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgYWx0IGFuZCBzaGlmdCBrZXlzIGFyZSBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgYWx0U2hpZnRLZXlzT25seSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gKFxuICAgIG9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgIG9yaWdpbmFsRXZlbnQuc2hpZnRLZXlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgbWFwIGhhcyB0aGUgZm9jdXMuIFRoaXMgY29uZGl0aW9uIHJlcXVpcmVzIGEgbWFwIHRhcmdldFxuICogZWxlbWVudCB3aXRoIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUsIGUuZy4gYDxkaXYgaWQ9XCJtYXBcIiB0YWJpbmRleD1cIjFcIj5gLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG1hcCBoYXMgdGhlIGZvY3VzLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgZm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGV2ZW50Lm1hcC5nZXRUYXJnZXRFbGVtZW50KCk7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBldmVudC5tYXAuZ2V0T3duZXJEb2N1bWVudCgpLmFjdGl2ZUVsZW1lbnQ7XG4gIHJldHVybiB0YXJnZXRFbGVtZW50LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBtYXAgaGFzIHRoZSBmb2N1cyBvciBubyAndGFiaW5kZXgnIGF0dHJpYnV0ZSBzZXQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbWFwIGNvbnRhaW5lciBoYXMgdGhlIGZvY3VzIG9yIG5vICd0YWJpbmRleCcgYXR0cmlidXRlLlxuICovXG5leHBvcnQgY29uc3QgZm9jdXNXaXRoVGFiaW5kZXggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50Lm1hcC5nZXRUYXJnZXRFbGVtZW50KCkuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpXG4gICAgPyBmb2N1cyhldmVudClcbiAgICA6IHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbHdheXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgYWx3YXlzID0gVFJVRTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIGBjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBjbGljayA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuQ0xJQ0s7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhcyBhbiBcImFjdGlvblwiLXByb2R1Y2luZyBtb3VzZSBidXR0b24uXG4gKlxuICogQnkgZGVmaW5pdGlvbiwgdGhpcyBpbmNsdWRlcyBsZWZ0LWNsaWNrIG9uIHdpbmRvd3MvbGludXgsIGFuZCBsZWZ0LWNsaWNrXG4gKiB3aXRob3V0IHRoZSBjdHJsIGtleSBvbiBNYWNzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZXN1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCBtb3VzZUFjdGlvbkJ1dHRvbiA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiBvcmlnaW5hbEV2ZW50LmJ1dHRvbiA9PSAwICYmICEoV0VCS0lUICYmIE1BQyAmJiBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYWx3YXlzIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEZhbHNlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgbmV2ZXIgPSBGQUxTRTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBicm93c2VyIGV2ZW50IGlzIGEgYHBvaW50ZXJtb3ZlYCBldmVudCwgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJyb3dzZXIgZXZlbnQgaXMgYSBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgcG9pbnRlck1vdmUgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSAncG9pbnRlcm1vdmUnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgc2luZ2xlY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgc2luZ2xlY2xpY2tgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgc2luZ2xlQ2xpY2sgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgZGJsY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgZGJsY2xpY2tgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgZG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG5vIG1vZGlmaWVyIGtleSAoYWx0LSwgc2hpZnQtIG9yIHBsYXRmb3JtLW1vZGlmaWVyLWtleSkgaXNcbiAqIHByZXNzZWQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvbmx5IGlmIHRoZXJlIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBub01vZGlmaWVyS2V5cyA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gKFxuICAgICFvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSAodGhlIG1ldGEta2V5IG9uIE1hYyxcbiAqIGN0cmwta2V5IG90aGVyd2lzZSkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlbiBhZGRpdGlvbmFsbHlcbiAqIHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXRmb3JtTW9kaWZpZXJLZXlPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgKE1BQyA/IG9yaWdpbmFsRXZlbnQubWV0YUtleSA6IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgKHRoZSBtZXRhLWtleSBvbiBNYWMsXG4gKiBjdHJsLWtleSBvdGhlcndpc2UpIGlzIHByZXNzZWQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxhdGZvcm0gbW9kaWZpZXIga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBwbGF0Zm9ybU1vZGlmaWVyS2V5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiBNQUMgPyBvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgOiBvcmlnaW5hbEV2ZW50LmN0cmxLZXk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW5cbiAqIGFkZGl0aW9uYWxseSB0aGUgYWx0LWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgc2hpZnRLZXlPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgIG9yaWdpbmFsRXZlbnQuc2hpZnRLZXlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGVkaXRhYmxlLCBpLmUuIG5vdCBhbiBgaW5wdXRgLFxuICogYHNlbGVjdGAsIG9yIGB0ZXh0YXJlYWAgZWxlbWVudCBhbmQgbm8gYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIGlzXG4gKiBzZXQgb3IgaW5oZXJpdGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9ubHkgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBlZGl0YWJsZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHRhcmdldE5vdEVkaXRhYmxlID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIGNvbnN0IHRhZ05hbWUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChvcmlnaW5hbEV2ZW50LnRhcmdldCkudGFnTmFtZTtcbiAgcmV0dXJuIChcbiAgICB0YWdOYW1lICE9PSAnSU5QVVQnICYmXG4gICAgdGFnTmFtZSAhPT0gJ1NFTEVDVCcgJiZcbiAgICB0YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmXG4gICAgLy8gYGlzQ29udGVudEVkaXRhYmxlYCBpcyBvbmx5IGF2YWlsYWJsZSBvbiBgSFRNTEVsZW1lbnRgLCBidXQgaXQgbWF5IGFsc28gYmUgYVxuICAgIC8vIGRpZmZlcmVudCB0eXBlIGxpa2UgYFNWR0VsZW1lbnRgLlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAhb3JpZ2luYWxFdmVudC50YXJnZXQuaXNDb250ZW50RWRpdGFibGVcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgbW91c2UgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIG1vdXNlIGRldmljZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IG1vdXNlT25seSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3QgcG9pbnRlckV2ZW50ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnRcIikuZGVmYXVsdH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudFxuICApLm9yaWdpbmFsRXZlbnQ7XG4gIGFzc2VydChcbiAgICBwb2ludGVyRXZlbnQgIT09IHVuZGVmaW5lZCxcbiAgICAnbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50J1xuICApO1xuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI3dpZGwtUG9pbnRlckV2ZW50LXBvaW50ZXJUeXBlXG4gIHJldHVybiBwb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT0gJ21vdXNlJztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgdG91Y2hhYmxlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSB0b3VjaGFibGUgZGV2aWNlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgdG91Y2hPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBwb2ludGVyRXZ0ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnRcIikuZGVmYXVsdH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudFxuICApLm9yaWdpbmFsRXZlbnQ7XG4gIGFzc2VydChcbiAgICBwb2ludGVyRXZ0ICE9PSB1bmRlZmluZWQsXG4gICAgJ21hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudCdcbiAgKTtcbiAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN3aWRsLVBvaW50ZXJFdmVudC1wb2ludGVyVHlwZVxuICByZXR1cm4gcG9pbnRlckV2dC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgZGlnaXRhbCBwZW4uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgZGlnaXRhbCBwZW4uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBwZW5Pbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBwb2ludGVyRXZ0ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnRcIikuZGVmYXVsdH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudFxuICApLm9yaWdpbmFsRXZlbnQ7XG4gIGFzc2VydChcbiAgICBwb2ludGVyRXZ0ICE9PSB1bmRlZmluZWQsXG4gICAgJ21hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudCdcbiAgKTtcbiAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN3aWRsLVBvaW50ZXJFdmVudC1wb2ludGVyVHlwZVxuICByZXR1cm4gcG9pbnRlckV2dC5wb2ludGVyVHlwZSA9PT0gJ3Blbic7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHByaW1hcnkgcG9pbnRlciBpblxuICogY29udGFjdCB3aXRoIHRoZSBzdXJmYWNlIG9yIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHByaW1hcnkgcG9pbnRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW1hcnlBY3Rpb24gPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdmVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50XCIpLmRlZmF1bHR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnRcbiAgKS5vcmlnaW5hbEV2ZW50O1xuICBhc3NlcnQoXG4gICAgcG9pbnRlckV2ZW50ICE9PSB1bmRlZmluZWQsXG4gICAgJ21hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudCdcbiAgKTtcbiAgcmV0dXJuIHBvaW50ZXJFdmVudC5pc1ByaW1hcnkgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbiA9PT0gMDtcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVcbiAqL1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGFsdFNoaWZ0S2V5c09ubHksXG4gIG1vdXNlQWN0aW9uQnV0dG9uLFxuICBtb3VzZU9ubHksXG59IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtkaXNhYmxlfSBmcm9tICcuLi9yb3RhdGlvbmNvbnN0cmFpbnQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLmFsdFNoaWZ0S2V5c09ubHl9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcm90YXRlIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAsXG4gKiBub3JtYWxseSBjb21iaW5lZCB3aXRoIGFuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn0gdGhhdCBsaW1pdHNcbiAqIGl0IHRvIHdoZW4gdGhlIGFsdCBhbmQgc2hpZnQga2V5cyBhcmUgaGVsZCBkb3duLlxuICpcbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIERyYWdSb3RhdGUgZXh0ZW5kcyBQb2ludGVySW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIHN0b3BEb3duOiBGQUxTRSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBhbHRTaGlmdEtleXNPbmx5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0Q29uc3RyYWludHMoKS5yb3RhdGlvbiA9PT0gZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gbWFwLmdldFNpemUoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgY29uc3QgdGhldGEgPSBNYXRoLmF0YW4yKHNpemVbMV0gLyAyIC0gb2Zmc2V0WzFdLCBvZmZzZXRbMF0gLSBzaXplWzBdIC8gMik7XG4gICAgaWYgKHRoaXMubGFzdEFuZ2xlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHRoZXRhIC0gdGhpcy5sYXN0QW5nbGVfO1xuICAgICAgdmlldy5hZGp1c3RSb3RhdGlvbkludGVybmFsKC1kZWx0YSk7XG4gICAgfVxuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHRoZXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24odGhpcy5kdXJhdGlvbl8pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBtb3VzZUFjdGlvbkJ1dHRvbihtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICB0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KVxuICAgICkge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnUm90YXRlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnQm94XG4gKi9cbi8vIEZJWE1FIGRyYXcgZHJhZyBib3hcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IFJlbmRlckJveCBmcm9tICcuLi9yZW5kZXIvQm94LmpzJztcbmltcG9ydCB7bW91c2VBY3Rpb25CdXR0b259IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHR3b1xuICoge0BsaW5rIG1vZHVsZTpvbC9waXhlbH5QaXhlbH1zIGFuZCByZXR1cm5zIGEgYHtib29sZWFufWAuIElmIHRoZSBjb25kaXRpb24gaXMgbWV0LFxuICogdHJ1ZSBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczogPywgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsLCBpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbCk6Ym9vbGVhbn0gRW5kQ29uZGl0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtZHJhZ2JveCddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZSBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG9sL2V2ZW50cy9jb25kaXRpb25+bW91c2VBY3Rpb25CdXR0b259LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5BcmVhPTY0XSBUaGUgbWluaW11bSBhcmVhIG9mIHRoZSBib3ggaW4gcGl4ZWwsIHRoaXMgdmFsdWUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICogYGJveEVuZENvbmRpdGlvbmAgZnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge0VuZENvbmRpdGlvbn0gW2JveEVuZENvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgdHdvXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3BpeGVsflBpeGVsfXMgdG8gaW5kaWNhdGUgd2hldGhlciBhIGBib3hlbmRgIGV2ZW50IHNob3VsZCBiZSBmaXJlZC5cbiAqIERlZmF1bHQgaXMgYHRydWVgIGlmIHRoZSBhcmVhIG9mIHRoZSBib3ggaXMgYmlnZ2VyIHRoYW4gdGhlIGBtaW5BcmVhYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHRoaXM6RHJhZ0JveCwgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtvbkJveEVuZF0gQ29kZSB0byBleGVjdXRlIGp1c3RcbiAqIGJlZm9yZSBgYm94ZW5kYCBpcyBmaXJlZC5cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IERyYWdCb3hFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBkcmFnIGJveCBzdGFydC5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBCT1hTVEFSVDogJ2JveHN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIG9uIGRyYWcgd2hlbiBib3ggaXMgYWN0aXZlLlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveGRyYWdcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YRFJBRzogJ2JveGRyYWcnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBkcmFnIGJveCBlbmQuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94ZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIEJPWEVORDogJ2JveGVuZCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IGNhbmNlbGVkLlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveGNhbmNlbFxuICAgKiBAYXBpXG4gICAqL1xuICBCT1hDQU5DRUw6ICdib3hjYW5jZWwnLFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdCb3h+RHJhZ0JveH0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2ZcbiAqIHRoaXMgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERyYWdCb3hFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgZXZlbnQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE9yaWdpbmF0aW5nIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgZHJhZyBldmVudC5cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudDtcbiAgfVxufVxuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPCdib3hjYW5jZWwnfCdib3hkcmFnJ3wnYm94ZW5kJ3wnYm94c3RhcnQnLCBEcmFnQm94RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZSd8J2JveGNhbmNlbCd8J2JveGRyYWcnfCdib3hlbmQnLCBSZXR1cm4+fSBEcmFnQm94T25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBkcmF3IGEgdmVjdG9yIGJveCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiB0aGUgc2hpZnQgb3Igb3RoZXIga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyB1c2VkLCBmb3IgZXhhbXBsZSxcbiAqIGZvciB6b29taW5nIHRvIGEgc3BlY2lmaWMgYXJlYSBvZiB0aGUgbWFwXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21+RHJhZ1pvb219IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbX5EcmFnUm90YXRlQW5kWm9vbX0pLlxuICpcbiAqIEBmaXJlcyBEcmFnQm94RXZlbnRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ0JveCBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0RyYWdCb3hPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQm94T25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQm94T25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9Cb3guanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm94XyA9IG5ldyBSZW5kZXJCb3gob3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWdib3gnKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1pbkFyZWFfID0gb3B0aW9ucy5taW5BcmVhICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkFyZWEgOiA2NDtcblxuICAgIGlmIChvcHRpb25zLm9uQm94RW5kKSB7XG4gICAgICB0aGlzLm9uQm94RW5kID0gb3B0aW9ucy5vbkJveEVuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBtb3VzZUFjdGlvbkJ1dHRvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0VuZENvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmJveEVuZENvbmRpdGlvbl8gPSBvcHRpb25zLmJveEVuZENvbmRpdGlvblxuICAgICAgPyBvcHRpb25zLmJveEVuZENvbmRpdGlvblxuICAgICAgOiB0aGlzLmRlZmF1bHRCb3hFbmRDb25kaXRpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29uZGl0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBib3hlbmQgZXZlbnRcbiAgICogc2hvdWxkIGZpcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBUaGUgb3JpZ2luYXRpbmcgTWFwQnJvd3NlckV2ZW50XG4gICAqICAgICBsZWFkaW5nIHRvIHRoZSBib3ggZW5kLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFRoZSBzdGFydGluZyBwaXhlbCBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBUaGUgZW5kIHBpeGVsIG9mIHRoZSBib3guXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBib3hlbmQgY29uZGl0aW9uIHNob3VsZCBiZSBmaXJlZC5cbiAgICovXG4gIGRlZmF1bHRCb3hFbmRDb25kaXRpb24obWFwQnJvd3NlckV2ZW50LCBzdGFydFBpeGVsLCBlbmRQaXhlbCkge1xuICAgIGNvbnN0IHdpZHRoID0gZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGVuZFBpeGVsWzFdIC0gc3RhcnRQaXhlbFsxXTtcbiAgICByZXR1cm4gd2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCA+PSB0aGlzLm1pbkFyZWFfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZ2VvbWV0cnkgb2YgbGFzdCBkcmF3biBib3guXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94Xy5nZXRHZW9tZXRyeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdGhpcy5ib3hfLnNldFBpeGVscyh0aGlzLnN0YXJ0UGl4ZWxfLCBtYXBCcm93c2VyRXZlbnQucGl4ZWwpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IERyYWdCb3hFdmVudChcbiAgICAgICAgRHJhZ0JveEV2ZW50VHlwZS5CT1hEUkFHLFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50XG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdGhpcy5ib3hfLnNldE1hcChudWxsKTtcblxuICAgIGNvbnN0IGNvbXBsZXRlQm94ID0gdGhpcy5ib3hFbmRDb25kaXRpb25fKFxuICAgICAgbWFwQnJvd3NlckV2ZW50LFxuICAgICAgdGhpcy5zdGFydFBpeGVsXyxcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5waXhlbFxuICAgICk7XG4gICAgaWYgKGNvbXBsZXRlQm94KSB7XG4gICAgICB0aGlzLm9uQm94RW5kKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBEcmFnQm94RXZlbnQoXG4gICAgICAgIGNvbXBsZXRlQm94ID8gRHJhZ0JveEV2ZW50VHlwZS5CT1hFTkQgOiBEcmFnQm94RXZlbnRUeXBlLkJPWENBTkNFTCxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudFxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgICAgdGhpcy5ib3hfLnNldE1hcChtYXBCcm93c2VyRXZlbnQubWFwKTtcbiAgICAgIHRoaXMuYm94Xy5zZXRQaXhlbHModGhpcy5zdGFydFBpeGVsXywgdGhpcy5zdGFydFBpeGVsXyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBEcmFnQm94RXZlbnQoXG4gICAgICAgICAgRHJhZ0JveEV2ZW50VHlwZS5CT1hTVEFSVCxcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gZXhlY3V0ZSBqdXN0IGJlZm9yZSBgb25ib3hlbmRgIGlzIGZpcmVkXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgb25Cb3hFbmQoZXZlbnQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdCb3g7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9Cb3hcbiAqL1xuXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5cbmNsYXNzIFJlbmRlckJveCBleHRlbmRzIERpc3Bvc2FibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBDU1MgY2xhc3MgbmFtZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgIHRoaXMuZWxlbWVudF8uY2xhc3NOYW1lID0gJ29sLWJveCAnICsgY2xhc3NOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmVuZFBpeGVsXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy5zZXRNYXAobnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbmRlcl8oKSB7XG4gICAgY29uc3Qgc3RhcnRQaXhlbCA9IHRoaXMuc3RhcnRQaXhlbF87XG4gICAgY29uc3QgZW5kUGl4ZWwgPSB0aGlzLmVuZFBpeGVsXztcbiAgICBjb25zdCBweCA9ICdweCc7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsZW1lbnRfLnN0eWxlO1xuICAgIHN0eWxlLmxlZnQgPSBNYXRoLm1pbihzdGFydFBpeGVsWzBdLCBlbmRQaXhlbFswXSkgKyBweDtcbiAgICBzdHlsZS50b3AgPSBNYXRoLm1pbihzdGFydFBpeGVsWzFdLCBlbmRQaXhlbFsxXSkgKyBweDtcbiAgICBzdHlsZS53aWR0aCA9IE1hdGguYWJzKGVuZFBpeGVsWzBdIC0gc3RhcnRQaXhlbFswXSkgKyBweDtcbiAgICBzdHlsZS5oZWlnaHQgPSBNYXRoLmFicyhlbmRQaXhlbFsxXSAtIHN0YXJ0UGl4ZWxbMV0pICsgcHg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBtYXAgTWFwLlxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHRoaXMubWFwXy5nZXRPdmVybGF5Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuZWxlbWVudF8uc3R5bGU7XG4gICAgICBzdHlsZS5sZWZ0ID0gJ2luaGVyaXQnO1xuICAgICAgc3R5bGUudG9wID0gJ2luaGVyaXQnO1xuICAgICAgc3R5bGUud2lkdGggPSAnaW5oZXJpdCc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnaW5oZXJpdCc7XG4gICAgfVxuICAgIHRoaXMubWFwXyA9IG1hcDtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICB0aGlzLm1hcF8uZ2V0T3ZlcmxheUNvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudF8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFN0YXJ0IHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBFbmQgcGl4ZWwuXG4gICAqL1xuICBzZXRQaXhlbHMoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpIHtcbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLmVuZFBpeGVsXyA9IGVuZFBpeGVsO1xuICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSgpO1xuICAgIHRoaXMucmVuZGVyXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgdXBkYXRlcyB0aGUgY2FjaGVkIGdlb21ldHJ5LlxuICAgKi9cbiAgY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSgpIHtcbiAgICBjb25zdCBzdGFydFBpeGVsID0gdGhpcy5zdGFydFBpeGVsXztcbiAgICBjb25zdCBlbmRQaXhlbCA9IHRoaXMuZW5kUGl4ZWxfO1xuICAgIGNvbnN0IHBpeGVscyA9IFtcbiAgICAgIHN0YXJ0UGl4ZWwsXG4gICAgICBbc3RhcnRQaXhlbFswXSwgZW5kUGl4ZWxbMV1dLFxuICAgICAgZW5kUGl4ZWwsXG4gICAgICBbZW5kUGl4ZWxbMF0sIHN0YXJ0UGl4ZWxbMV1dLFxuICAgIF07XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBwaXhlbHMubWFwKFxuICAgICAgdGhpcy5tYXBfLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbCxcbiAgICAgIHRoaXMubWFwX1xuICAgICk7XG4gICAgLy8gY2xvc2UgdGhlIHBvbHlnb25cbiAgICBjb29yZGluYXRlc1s0XSA9IGNvb3JkaW5hdGVzWzBdLnNsaWNlKCk7XG4gICAgaWYgKCF0aGlzLmdlb21ldHJ5Xykge1xuICAgICAgdGhpcy5nZW9tZXRyeV8gPSBuZXcgUG9seWdvbihbY29vcmRpbmF0ZXNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZW9tZXRyeV8uc2V0Q29vcmRpbmF0ZXMoW2Nvb3JkaW5hdGVzXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5XztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJCb3g7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdab29tXG4gKi9cbmltcG9ydCBEcmFnQm94IGZyb20gJy4vRHJhZ0JveC5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge3NoaWZ0S2V5T25seX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWRyYWd6b29tJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHN0eWxpbmcgdGhlXG4gKiBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5zaGlmdEtleU9ubHl9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdXQ9ZmFsc2VdIFVzZSBpbnRlcmFjdGlvbiBmb3Igem9vbWluZyBvdXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbkFyZWE9NjRdIFRoZSBtaW5pbXVtIGFyZWEgb2YgdGhlIGJveCBpbiBwaXhlbCwgdGhpcyB2YWx1ZSBpcyB1c2VkIGJ5IHRoZSBwYXJlbnQgZGVmYXVsdFxuICogYGJveEVuZENvbmRpdGlvbmAgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLFxuICogbm9ybWFsbHkgY29tYmluZWQgd2l0aCBhbiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb259IHRoYXQgbGltaXRzXG4gKiBpdCB0byB3aGVuIGEga2V5LCBzaGlmdCBieSBkZWZhdWx0LCBpcyBoZWxkIGRvd24uXG4gKlxuICogVG8gY2hhbmdlIHRoZSBzdHlsZSBvZiB0aGUgYm94LCB1c2UgQ1NTIGFuZCB0aGUgYC5vbC1kcmFnem9vbWAgc2VsZWN0b3IsIG9yXG4gKiB5b3VyIGN1c3RvbSBvbmUgY29uZmlndXJlZCB3aXRoIGBjbGFzc05hbWVgLlxuICogQGFwaVxuICovXG5jbGFzcyBEcmFnWm9vbSBleHRlbmRzIERyYWdCb3gge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIGNvbnN0IGNvbmRpdGlvbiA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBzaGlmdEtleU9ubHk7XG5cbiAgICBzdXBlcih7XG4gICAgICBjb25kaXRpb246IGNvbmRpdGlvbixcbiAgICAgIGNsYXNzTmFtZTogb3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWd6b29tJyxcbiAgICAgIG1pbkFyZWE6IG9wdGlvbnMubWluQXJlYSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyMDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3V0XyA9IG9wdGlvbnMub3V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm91dCA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGUganVzdCBiZWZvcmUgYG9uYm94ZW5kYCBpcyBmaXJlZFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICovXG4gIG9uQm94RW5kKGV2ZW50KSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBjb25zdCB2aWV3ID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSAqLyAobWFwLmdldFZpZXcoKSk7XG4gICAgbGV0IGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuXG4gICAgaWYgKHRoaXMub3V0Xykge1xuICAgICAgY29uc3Qgcm90YXRlZEV4dGVudCA9IHZpZXcucm90YXRlZEV4dGVudEZvckdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb25Gb3JFeHRlbnRJbnRlcm5hbChyb3RhdGVkRXh0ZW50KTtcbiAgICAgIGNvbnN0IGZhY3RvciA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpIC8gcmVzb2x1dGlvbjtcbiAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICAgIGdlb21ldHJ5LnNjYWxlKGZhY3RvciAqIGZhY3Rvcik7XG4gICAgfVxuXG4gICAgdmlldy5maXRJbnRlcm5hbChnZW9tZXRyeSwge1xuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fLFxuICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdab29tO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFBhblxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uLCB7cGFufSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBLZXkgZnJvbSAnLi4vZXZlbnRzL0tleS5qcyc7XG5pbXBvcnQge25vTW9kaWZpZXJLZXlzLCB0YXJnZXROb3RFZGl0YWJsZX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge3JvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlfSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5ub01vZGlmaWVyS2V5c30gYW5kXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24udGFyZ2V0Tm90RWRpdGFibGV9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0xMDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsRGVsdGE9MTI4XSBUaGUgYW1vdW50IG9mIHBpeGVscyB0byBwYW4gb24gZWFjaCBrZXlcbiAqIHByZXNzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHBhbiB0aGUgbWFwIHVzaW5nIGtleWJvYXJkIGFycm93cy5cbiAqIE5vdGUgdGhhdCwgYWx0aG91Z2ggdGhpcyBpbnRlcmFjdGlvbiBpcyBieSBkZWZhdWx0IGluY2x1ZGVkIGluIG1hcHMsXG4gKiB0aGUga2V5cyBjYW4gb25seSBiZSB1c2VkIHdoZW4gYnJvd3NlciBmb2N1cyBpcyBvbiB0aGUgZWxlbWVudCB0byB3aGljaFxuICogdGhlIGtleWJvYXJkIGV2ZW50cyBhcmUgYXR0YWNoZWQuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIG1hcCBkaXYsXG4gKiB0aG91Z2ggeW91IGNhbiBjaGFuZ2UgdGhpcyB3aXRoIHRoZSBga2V5Ym9hcmRFdmVudFRhcmdldGAgaW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0uIGBkb2N1bWVudGAgbmV2ZXIgbG9zZXMgZm9jdXMgYnV0LCBmb3IgYW55IG90aGVyXG4gKiBlbGVtZW50LCBmb2N1cyB3aWxsIGhhdmUgdG8gYmUgb24sIGFuZCByZXR1cm5lZCB0bywgdGhpcyBlbGVtZW50IGlmIHRoZSBrZXlzXG4gKiBhcmUgdG8gZnVuY3Rpb24uXG4gKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbX5LZXlib2FyZFpvb219LlxuICogQGFwaVxuICovXG5jbGFzcyBLZXlib2FyZFBhbiBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgQnJvd3NlciBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb21iaW5lZCBjb25kaXRpb24gcmVzdWx0LlxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdENvbmRpdGlvbl8gPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBub01vZGlmaWVyS2V5cyhtYXBCcm93c2VyRXZlbnQpICYmIHRhcmdldE5vdEVkaXRhYmxlKG1hcEJyb3dzZXJFdmVudClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9XG4gICAgICBvcHRpb25zLmNvbmRpdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5jb25kaXRpb25cbiAgICAgICAgOiB0aGlzLmRlZmF1bHRDb25kaXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsRGVsdGFfID1cbiAgICAgIG9wdGlvbnMucGl4ZWxEZWx0YSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waXhlbERlbHRhIDogMTI4O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gaWYgaXQgd2FzIGFcbiAgICogYEtleUV2ZW50YCwgYW5kIGRlY2lkZXMgdGhlIGRpcmVjdGlvbiB0byBwYW4gdG8gKGlmIGFuIGFycm93IGtleSB3YXNcbiAgICogcHJlc3NlZCkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZRE9XTikge1xuICAgICAgY29uc3Qga2V5RXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR9ICovIChcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCBrZXkgPSBrZXlFdmVudC5rZXk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICAgIChrZXkgPT0gS2V5LkRPV04gfHxcbiAgICAgICAgICBrZXkgPT0gS2V5LkxFRlQgfHxcbiAgICAgICAgICBrZXkgPT0gS2V5LlJJR0hUIHx8XG4gICAgICAgICAga2V5ID09IEtleS5VUClcbiAgICAgICkge1xuICAgICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgY29uc3QgbWFwVW5pdHNEZWx0YSA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpICogdGhpcy5waXhlbERlbHRhXztcbiAgICAgICAgbGV0IGRlbHRhWCA9IDAsXG4gICAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgaWYgKGtleSA9PSBLZXkuRE9XTikge1xuICAgICAgICAgIGRlbHRhWSA9IC1tYXBVbml0c0RlbHRhO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSBLZXkuTEVGVCkge1xuICAgICAgICAgIGRlbHRhWCA9IC1tYXBVbml0c0RlbHRhO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSBLZXkuUklHSFQpIHtcbiAgICAgICAgICBkZWx0YVggPSBtYXBVbml0c0RlbHRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWSA9IG1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSBbZGVsdGFYLCBkZWx0YVldO1xuICAgICAgICByb3RhdGVDb29yZGluYXRlKGRlbHRhLCB2aWV3LmdldFJvdGF0aW9uKCkpO1xuICAgICAgICBwYW4odmlldywgZGVsdGEsIHRoaXMuZHVyYXRpb25fKTtcbiAgICAgICAga2V5RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc3RvcEV2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgS2V5Ym9hcmRQYW47XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9LZXlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBMRUZUOiAnQXJyb3dMZWZ0JyxcbiAgVVA6ICdBcnJvd1VwJyxcbiAgUklHSFQ6ICdBcnJvd1JpZ2h0JyxcbiAgRE9XTjogJ0Fycm93RG93bicsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7cGxhdGZvcm1Nb2RpZmllcktleSwgdGFyZ2V0Tm90RWRpdGFibGV9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGUgZGVmYXVsdCBjb25kaXRpb24gaXNcbiAqIHRoYXQge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLnRhcmdldE5vdEVkaXRhYmxlfSBpcyBmdWxmaWxsZWQgYW5kIHRoYXRcbiAqIHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXNuJ3QgcHJlc3NlZFxuICogKCF7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ucGxhdGZvcm1Nb2RpZmllcktleX0pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBsZXZlbCBkZWx0YSBvbiBlYWNoIGtleSBwcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgKyBhbmQgLS5cbiAqIE5vdGUgdGhhdCwgYWx0aG91Z2ggdGhpcyBpbnRlcmFjdGlvbiBpcyBieSBkZWZhdWx0IGluY2x1ZGVkIGluIG1hcHMsXG4gKiB0aGUga2V5cyBjYW4gb25seSBiZSB1c2VkIHdoZW4gYnJvd3NlciBmb2N1cyBpcyBvbiB0aGUgZWxlbWVudCB0byB3aGljaFxuICogdGhlIGtleWJvYXJkIGV2ZW50cyBhcmUgYXR0YWNoZWQuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIG1hcCBkaXYsXG4gKiB0aG91Z2ggeW91IGNhbiBjaGFuZ2UgdGhpcyB3aXRoIHRoZSBga2V5Ym9hcmRFdmVudFRhcmdldGAgaW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0uIGBkb2N1bWVudGAgbmV2ZXIgbG9zZXMgZm9jdXMgYnV0LCBmb3IgYW55IG90aGVyXG4gKiBlbGVtZW50LCBmb2N1cyB3aWxsIGhhdmUgdG8gYmUgb24sIGFuZCByZXR1cm5lZCB0bywgdGhpcyBlbGVtZW50IGlmIHRoZSBrZXlzXG4gKiBhcmUgdG8gZnVuY3Rpb24uXG4gKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFufktleWJvYXJkUGFufS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgS2V5Ym9hcmRab29tIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgPyBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgOiBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICFwbGF0Zm9ybU1vZGlmaWVyS2V5KG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIHRhcmdldE5vdEVkaXRhYmxlKG1hcEJyb3dzZXJFdmVudClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gb3B0aW9ucy5kZWx0YSA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGlmIGl0IHdhcyBhXG4gICAqIGBLZXlFdmVudGAsIGFuZCBkZWNpZGVzIHdoZXRoZXIgdG8gem9vbSBpbiBvciBvdXQgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICAgKiBrZXkgcHJlc3NlZCB3YXMgJysnIG9yICctJykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOIHx8XG4gICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZUFJFU1NcbiAgICApIHtcbiAgICAgIGNvbnN0IGtleUV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fSAqLyAoXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICApO1xuICAgICAgY29uc3Qga2V5ID0ga2V5RXZlbnQua2V5O1xuICAgICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmIChrZXkgPT09ICcrJyB8fCBrZXkgPT09ICctJykpIHtcbiAgICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBrZXkgPT09ICcrJyA/IHRoaXMuZGVsdGFfIDogLXRoaXMuZGVsdGFfO1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIHVuZGVmaW5lZCwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgICBrZXlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFpvb207XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0tpbmV0aWNcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEltcGxlbWVudGF0aW9uIG9mIGluZXJ0aWFsIGRlY2VsZXJhdGlvbiBmb3IgbWFwIG1vdmVtZW50LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgS2luZXRpYyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVjYXkgUmF0ZSBvZiBkZWNheSAobXVzdCBiZSBuZWdhdGl2ZSkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5WZWxvY2l0eSBNaW5pbXVtIHZlbG9jaXR5IChwaXhlbHMvbWlsbGlzZWNvbmQpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgRGVsYXkgdG8gY29uc2lkZXIgdG8gY2FsY3VsYXRlIHRoZSBraW5ldGljXG4gICAqICAgICBpbml0aWFsIHZhbHVlcyAobWlsbGlzZWNvbmRzKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRlY2F5LCBtaW5WZWxvY2l0eSwgZGVsYXkpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWNheV8gPSBkZWNheTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblZlbG9jaXR5XyA9IG1pblZlbG9jaXR5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsYXlfID0gZGVsYXk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGVfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgYmVnaW4oKSB7XG4gICAgdGhpcy5wb2ludHNfLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5hbmdsZV8gPSAwO1xuICAgIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICovXG4gIHVwZGF0ZSh4LCB5KSB7XG4gICAgdGhpcy5wb2ludHNfLnB1c2goeCwgeSwgRGF0ZS5ub3coKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB3ZSBzaG91bGQgZG8ga2luZXRpYyBhbmltYXRpb24uXG4gICAqL1xuICBlbmQoKSB7XG4gICAgaWYgKHRoaXMucG9pbnRzXy5sZW5ndGggPCA2KSB7XG4gICAgICAvLyBhdCBsZWFzdCAyIHBvaW50cyBhcmUgcmVxdWlyZWQgKGkuZS4gdGhlcmUgbXVzdCBiZSBhdCBsZWFzdCA2IGVsZW1lbnRzXG4gICAgICAvLyBpbiB0aGUgYXJyYXkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gRGF0ZS5ub3coKSAtIHRoaXMuZGVsYXlfO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMucG9pbnRzXy5sZW5ndGggLSAzO1xuICAgIGlmICh0aGlzLnBvaW50c19bbGFzdEluZGV4ICsgMl0gPCBkZWxheSkge1xuICAgICAgLy8gdGhlIGxhc3QgdHJhY2tlZCBwb2ludCBpcyB0b28gb2xkLCB3aGljaCBtZWFucyB0aGF0IHRoZSB1c2VyIHN0b3BwZWRcbiAgICAgIC8vIHBhbm5pbmcgYmVmb3JlIHJlbGVhc2luZyB0aGUgbWFwXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBmaXJzdCBwb2ludCB3aGljaCBzdGlsbCBmYWxscyBpbnRvIHRoZSBkZWxheSB0aW1lXG4gICAgbGV0IGZpcnN0SW5kZXggPSBsYXN0SW5kZXggLSAzO1xuICAgIHdoaWxlIChmaXJzdEluZGV4ID4gMCAmJiB0aGlzLnBvaW50c19bZmlyc3RJbmRleCArIDJdID4gZGVsYXkpIHtcbiAgICAgIGZpcnN0SW5kZXggLT0gMztcbiAgICB9XG5cbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMucG9pbnRzX1tsYXN0SW5kZXggKyAyXSAtIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4ICsgMl07XG4gICAgLy8gd2UgZG9uJ3Qgd2FudCBhIGR1cmF0aW9uIG9mIDAgKGRpdmlkZSBieSB6ZXJvKVxuICAgIC8vIHdlIGFsc28gbWFrZSBzdXJlIHRoZSB1c2VyIHBhbm5lZCBmb3IgYSBkdXJhdGlvbiBvZiBhdCBsZWFzdCBvbmUgZnJhbWVcbiAgICAvLyAoMS82MHMpIHRvIGNvbXB1dGUgc2FuZSBkaXNwbGFjZW1lbnQgdmFsdWVzXG4gICAgaWYgKGR1cmF0aW9uIDwgMTAwMCAvIDYwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZHggPSB0aGlzLnBvaW50c19bbGFzdEluZGV4XSAtIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4XTtcbiAgICBjb25zdCBkeSA9IHRoaXMucG9pbnRzX1tsYXN0SW5kZXggKyAxXSAtIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4ICsgMV07XG4gICAgdGhpcy5hbmdsZV8gPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgdGhpcy5pbml0aWFsVmVsb2NpdHlfID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAvIGR1cmF0aW9uO1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPiB0aGlzLm1pblZlbG9jaXR5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRvdGFsIGRpc3RhbmNlIHRyYXZlbGxlZCAocGl4ZWxzKS5cbiAgICovXG4gIGdldERpc3RhbmNlKCkge1xuICAgIHJldHVybiAodGhpcy5taW5WZWxvY2l0eV8gLSB0aGlzLmluaXRpYWxWZWxvY2l0eV8pIC8gdGhpcy5kZWNheV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBvZiB0aGUga2luZXRpYyBwYW5uaW5nIGFuaW1hdGlvbiAocmFkaWFucykuXG4gICAqL1xuICBnZXRBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZV87XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgS2luZXRpYztcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb21cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPLCBGSVJFRk9YfSBmcm9tICcuLi9oYXMuanMnO1xuaW1wb3J0IHthbGwsIGFsd2F5cywgZm9jdXNXaXRoVGFiaW5kZXh9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyd0cmFja3BhZCcgfCAnd2hlZWwnfSBNb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5hbHdheXN9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25Gb2N1c09ubHk9ZmFsc2VdIFdoZW4gdGhlIG1hcCdzIHRhcmdldCBoYXMgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBzZXQsXG4gKiB0aGUgaW50ZXJhY3Rpb24gd2lsbCBvbmx5IGhhbmRsZSBldmVudHMgd2hlbiB0aGUgbWFwIGhhcyB0aGUgZm9jdXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heERlbHRhPTFdIE1heGltdW0gbW91c2Ugd2hlZWwgZGVsdGEuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZW91dD04MF0gTW91c2Ugd2hlZWwgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VBbmNob3I9dHJ1ZV0gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlJ3NcbiAqIGxvY2F0aW9uIGFzIHRoZSBhbmNob3IuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHpvb21pbmcgaW4gYW5kIG91dCB3aWxsIHpvb20gdG9cbiAqIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbiBpbnN0ZWFkIG9mIHpvb21pbmcgb24gdGhlIG1vdXNlJ3MgbG9jYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgbW91c2Ugd2hlZWwgem9vbVxuICogZXZlbnQgd2lsbCBhbHdheXMgYW5pbWF0ZSB0byB0aGUgY2xvc2VzdCB6b29tIGxldmVsIGFmdGVyIGFuIGludGVyYWN0aW9uO1xuICogZmFsc2UgbWVhbnMgaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbGxvd2VkLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBzY3JvbGxpbmcgdGhlIG1vdXNlIHdoZWVsLlxuICogQGFwaVxuICovXG5jbGFzcyBNb3VzZVdoZWVsWm9vbSBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIChvcHRpb25zKVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b3RhbERlbHRhXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0RGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IG9wdGlvbnMubWF4RGVsdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4RGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRfID0gb3B0aW9ucy50aW1lb3V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbWVvdXQgOiA4MDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51c2VBbmNob3JfID1cbiAgICAgIG9wdGlvbnMudXNlQW5jaG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVzZUFuY2hvciA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8gPVxuICAgICAgb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb25cbiAgICAgICAgOiBmYWxzZTtcblxuICAgIGNvbnN0IGNvbmRpdGlvbiA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBhbHdheXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLm9uRm9jdXNPbmx5XG4gICAgICA/IGFsbChmb2N1c1dpdGhUYWJpbmRleCwgY29uZGl0aW9uKVxuICAgICAgOiBjb25kaXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNb2RlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2twYWQgZXZlbnRzIHNlcGFyYXRlZCBieSB0aGlzIGRlbGF5IHdpbGwgYmUgY29uc2lkZXJlZCBzZXBhcmF0ZVxuICAgICAqIGludGVyYWN0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50cmFja3BhZEV2ZW50R2FwXyA9IDQwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+fVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkZWx0YSB2YWx1ZXMgcGVyIHpvb20gbGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YVBlclpvb21fID0gMzAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbmRJbnRlcmFjdGlvbl8oKSB7XG4gICAgdGhpcy50cmFja3BhZFRpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB2aWV3LmVuZEludGVyYWN0aW9uKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5sYXN0RGVsdGFfID8gKHRoaXMubGFzdERlbHRhXyA+IDAgPyAxIDogLTEpIDogMCxcbiAgICAgIHRoaXMubGFzdEFuY2hvcl9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhIG1vdXNld2hlZWwtZXZlbnQpIGFuZCBldmVudHVhbGx5XG4gICAqIHpvb21zIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBtYXBCcm93c2VyRXZlbnQudHlwZTtcbiAgICBpZiAodHlwZSAhPT0gRXZlbnRUeXBlLldIRUVMKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSAvKiogQHR5cGUge1doZWVsRXZlbnR9ICovIChcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgKTtcbiAgICB3aGVlbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodGhpcy51c2VBbmNob3JfKSB7XG4gICAgICB0aGlzLmxhc3RBbmNob3JfID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgfVxuXG4gICAgLy8gRGVsdGEgbm9ybWFsaXNhdGlvbiBpbnNwaXJlZCBieVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2Jsb2IvMDAxYzdiOS9qcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzXG4gICAgbGV0IGRlbHRhO1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuV0hFRUwpIHtcbiAgICAgIGRlbHRhID0gd2hlZWxFdmVudC5kZWx0YVk7XG4gICAgICBpZiAoRklSRUZPWCAmJiB3aGVlbEV2ZW50LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgICAgZGVsdGEgLz0gREVWSUNFX1BJWEVMX1JBVElPO1xuICAgICAgfVxuICAgICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICAgIGRlbHRhICo9IDQwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3REZWx0YV8gPSBkZWx0YTtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAodGhpcy5zdGFydFRpbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubW9kZV8gfHwgbm93IC0gdGhpcy5zdGFydFRpbWVfID4gdGhpcy50cmFja3BhZEV2ZW50R2FwXykge1xuICAgICAgdGhpcy5tb2RlXyA9IE1hdGguYWJzKGRlbHRhKSA8IDQgPyAndHJhY2twYWQnIDogJ3doZWVsJztcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoXG4gICAgICB0aGlzLm1vZGVfID09PSAndHJhY2twYWQnICYmXG4gICAgICAhKHZpZXcuZ2V0Q29uc3RyYWluUmVzb2x1dGlvbigpIHx8IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8pXG4gICAgKSB7XG4gICAgICBpZiAodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhY2twYWRUaW1lb3V0SWRfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5iZWdpbkludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHNldFRpbWVvdXQoXG4gICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb25fLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMudGltZW91dF9cbiAgICAgICk7XG4gICAgICB2aWV3LmFkanVzdFpvb20oLWRlbHRhIC8gdGhpcy5kZWx0YVBlclpvb21fLCB0aGlzLmxhc3RBbmNob3JfKTtcbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnRvdGFsRGVsdGFfICs9IGRlbHRhO1xuXG4gICAgY29uc3QgdGltZUxlZnQgPSBNYXRoLm1heCh0aGlzLnRpbWVvdXRfIC0gKG5vdyAtIHRoaXMuc3RhcnRUaW1lXyksIDApO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgdGhpcy50aW1lb3V0SWRfID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuaGFuZGxlV2hlZWxab29tXy5iaW5kKHRoaXMsIG1hcCksXG4gICAgICB0aW1lTGVmdFxuICAgICk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGhhbmRsZVdoZWVsWm9vbV8obWFwKSB7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBsZXQgZGVsdGEgPVxuICAgICAgLWNsYW1wKFxuICAgICAgICB0aGlzLnRvdGFsRGVsdGFfLFxuICAgICAgICAtdGhpcy5tYXhEZWx0YV8gKiB0aGlzLmRlbHRhUGVyWm9vbV8sXG4gICAgICAgIHRoaXMubWF4RGVsdGFfICogdGhpcy5kZWx0YVBlclpvb21fXG4gICAgICApIC8gdGhpcy5kZWx0YVBlclpvb21fO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpblJlc29sdXRpb24oKSB8fCB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fKSB7XG4gICAgICAvLyB2aWV3IGhhcyBhIHpvb20gY29uc3RyYWludCwgem9vbSBieSAxXG4gICAgICBkZWx0YSA9IGRlbHRhID8gKGRlbHRhID4gMCA/IDEgOiAtMSkgOiAwO1xuICAgIH1cbiAgICB6b29tQnlEZWx0YSh2aWV3LCBkZWx0YSwgdGhpcy5sYXN0QW5jaG9yXywgdGhpcy5kdXJhdGlvbl8pO1xuXG4gICAgdGhpcy5tb2RlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvdGFsRGVsdGFfID0gMDtcbiAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIHVzaW5nIHRoZSBtb3VzZSdzIGxvY2F0aW9uIGFzIGFuIGFuY2hvciB3aGVuIHpvb21pbmdcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBbmNob3IgdHJ1ZSB0byB6b29tIHRvIHRoZSBtb3VzZSdzIGxvY2F0aW9uLCBmYWxzZVxuICAgKiB0byB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIG1hcFxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNb3VzZUFuY2hvcih1c2VBbmNob3IpIHtcbiAgICB0aGlzLnVzZUFuY2hvcl8gPSB1c2VBbmNob3I7XG4gICAgaWYgKCF1c2VBbmNob3IpIHtcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVdoZWVsWm9vbTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUGluY2hSb3RhdGVcbiAqL1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiwge1xuICBjZW50cm9pZCBhcyBjZW50cm9pZEZyb21Qb2ludGVycyxcbn0gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2Rpc2FibGV9IGZyb20gJy4uL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluXG4gKiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RocmVzaG9sZD0wLjNdIE1pbmltYWwgYW5nbGUgaW4gcmFkaWFucyB0byBzdGFydCBhIHJvdGF0aW9uLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHJvdGF0ZSB0aGUgbWFwIGJ5IHR3aXN0aW5nIHdpdGggdHdvIGZpbmdlcnNcbiAqIG9uIGEgdG91Y2ggc2NyZWVuLlxuICogQGFwaVxuICovXG5jbGFzcyBQaW5jaFJvdGF0ZSBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgcG9pbnRlck9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAoXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGlmICghcG9pbnRlck9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHBvaW50ZXJPcHRpb25zLnN0b3BEb3duID0gRkFMU0U7XG4gICAgfVxuXG4gICAgc3VwZXIocG9pbnRlck9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGluZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uRGVsdGFfID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGhyZXNob2xkXyA9IG9wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRocmVzaG9sZCA6IDAuMztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgcm90YXRpb25EZWx0YSA9IDAuMDtcblxuICAgIGNvbnN0IHRvdWNoMCA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMF07XG4gICAgY29uc3QgdG91Y2gxID0gdGhpcy50YXJnZXRQb2ludGVyc1sxXTtcblxuICAgIC8vIGFuZ2xlIGJldHdlZW4gdG91Y2hlc1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihcbiAgICAgIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gwLmNsaWVudFksXG4gICAgICB0b3VjaDEuY2xpZW50WCAtIHRvdWNoMC5jbGllbnRYXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVsdGEgPSBhbmdsZSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICAgIHRoaXMucm90YXRpb25EZWx0YV8gKz0gZGVsdGE7XG4gICAgICBpZiAoIXRoaXMucm90YXRpbmdfICYmIE1hdGguYWJzKHRoaXMucm90YXRpb25EZWx0YV8pID4gdGhpcy50aHJlc2hvbGRfKSB7XG4gICAgICAgIHRoaXMucm90YXRpbmdfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJvdGF0aW9uRGVsdGEgPSBkZWx0YTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QW5nbGVfID0gYW5nbGU7XG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpbnRzKCkucm90YXRpb24gPT09IGRpc2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByb3RhdGUgYW5jaG9yIHBvaW50LlxuICAgIC8vIEZJWE1FOiBzaG91bGQgYmUgdGhlIGludGVyc2VjdGlvbiBwb2ludCBiZXR3ZWVuIHRoZSBsaW5lczpcbiAgICAvLyAgICAgdG91Y2gwLHRvdWNoMSBhbmQgcHJldmlvdXNUb3VjaDAscHJldmlvdXNUb3VjaDFcbiAgICB0aGlzLmFuY2hvcl8gPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKFxuICAgICAgbWFwLmdldEV2ZW50UGl4ZWwoY2VudHJvaWRGcm9tUG9pbnRlcnModGhpcy50YXJnZXRQb2ludGVycykpXG4gICAgKTtcblxuICAgIC8vIHJvdGF0ZVxuICAgIGlmICh0aGlzLnJvdGF0aW5nXykge1xuICAgICAgbWFwLnJlbmRlcigpO1xuICAgICAgdmlldy5hZGp1c3RSb3RhdGlvbkludGVybmFsKHJvdGF0aW9uRGVsdGEsIHRoaXMuYW5jaG9yXyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB2aWV3LmVuZEludGVyYWN0aW9uKHRoaXMuZHVyYXRpb25fKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJvdGF0aW5nXyA9IGZhbHNlO1xuICAgICAgdGhpcy5yb3RhdGlvbkRlbHRhXyA9IDAuMDtcbiAgICAgIGlmICghdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaW5jaFJvdGF0ZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUGluY2hab29tXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtcbiAgY2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnMsXG59IGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249NDAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBwaW5jaGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgUGluY2hab29tIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBzdXBlcihwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiA0MDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgc2NhbGVEZWx0YSA9IDEuMDtcblxuICAgIGNvbnN0IHRvdWNoMCA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMF07XG4gICAgY29uc3QgdG91Y2gxID0gdGhpcy50YXJnZXRQb2ludGVyc1sxXTtcbiAgICBjb25zdCBkeCA9IHRvdWNoMC5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFg7XG4gICAgY29uc3QgZHkgPSB0b3VjaDAuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgLy8gZGlzdGFuY2UgYmV0d2VlbiB0b3VjaGVzXG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgaWYgKHRoaXMubGFzdERpc3RhbmNlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2FsZURlbHRhID0gdGhpcy5sYXN0RGlzdGFuY2VfIC8gZGlzdGFuY2U7XG4gICAgfVxuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IGRpc3RhbmNlO1xuXG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcblxuICAgIGlmIChzY2FsZURlbHRhICE9IDEuMCkge1xuICAgICAgdGhpcy5sYXN0U2NhbGVEZWx0YV8gPSBzY2FsZURlbHRhO1xuICAgIH1cblxuICAgIC8vIHNjYWxlIGFuY2hvciBwb2ludC5cbiAgICB0aGlzLmFuY2hvcl8gPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKFxuICAgICAgbWFwLmdldEV2ZW50UGl4ZWwoY2VudHJvaWRGcm9tUG9pbnRlcnModGhpcy50YXJnZXRQb2ludGVycykpXG4gICAgKTtcblxuICAgIC8vIHNjYWxlLCBieXBhc3MgdGhlIHJlc29sdXRpb24gY29uc3RyYWludFxuICAgIG1hcC5yZW5kZXIoKTtcbiAgICB2aWV3LmFkanVzdFJlc29sdXRpb25JbnRlcm5hbChzY2FsZURlbHRhLCB0aGlzLmFuY2hvcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxhc3RTY2FsZURlbHRhXyA+IDEgPyAxIDogLTE7XG4gICAgICB2aWV3LmVuZEludGVyYWN0aW9uKHRoaXMuZHVyYXRpb25fLCBkaXJlY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdGhpcy5hbmNob3JfID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gMTtcbiAgICAgIGlmICghdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaW5jaFpvb207XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvTW91c2VQb3NpdGlvblxuICovXG5cbmltcG9ydCBDb250cm9sIGZyb20gJy4vQ29udHJvbC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7XG4gIGdldCBhcyBnZXRQcm9qZWN0aW9uLFxuICBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMsXG4gIGdldFVzZXJQcm9qZWN0aW9uLFxuICBpZGVudGl0eVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7d3JhcFh9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFBST0pFQ1RJT04gPSAncHJvamVjdGlvbic7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgQ09PUkRJTkFURV9GT1JNQVQgPSAnY29vcmRpbmF0ZUZvcm1hdCc7XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmNvb3JkaW5hdGVGb3JtYXQnfCdjaGFuZ2U6cHJvamVjdGlvbicsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6Y29vcmRpbmF0ZUZvcm1hdCd8J2NoYW5nZTpwcm9qZWN0aW9uJywgUmV0dXJuPn0gTW91c2VQb3NpdGlvbk9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbW91c2UtcG9zaXRpb24nXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlRm9ybWF0fSBbY29vcmRpbmF0ZUZvcm1hdF0gQ29vcmRpbmF0ZSBmb3JtYXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLiBEZWZhdWx0IGlzIHRoZSB2aWV3IHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZVxuICogY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlXG4gKiBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl0gTWFya3VwIHRvIHNob3cgd2hlbiB0aGUgbW91c2UgcG9zaXRpb24gaXMgbm90XG4gKiBhdmFpbGFibGUgKGUuZy4gd2hlbiB0aGUgcG9pbnRlciBsZWF2ZXMgdGhlIG1hcCB2aWV3cG9ydCkuICBCeSBkZWZhdWx0LCBhIG5vbi1icmVha2luZyBzcGFjZSBpcyByZW5kZXJlZFxuICogaW5pdGlhbGx5IGFuZCB0aGUgbGFzdCBwb3NpdGlvbiBpcyByZXRhaW5lZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIHZpZXdwb3J0LlxuICogV2hlbiBhIHN0cmluZyBpcyBwcm92aWRlZCAoZS5nLiBgJ25vIHBvc2l0aW9uJ2Agb3IgYCcnYCBmb3IgYW4gZW1wdHkgc3RyaW5nKSBpdCBpcyB1c2VkIGFzIGFcbiAqIHBsYWNlaG9sZGVyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5IG9uIHRoZSBwcm9qZWN0aW9uJ3MgYW50aW1lcmlkaWFuLCBpZiBpdFxuICogaXMgYSBnbG9iYWwgcHJvamVjdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29udHJvbCB0byBzaG93IHRoZSAyRCBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UgY3Vyc29yLiBCeSBkZWZhdWx0LCB0aGVzZVxuICogYXJlIGluIHRoZSB2aWV3IHByb2plY3Rpb24sIGJ1dCBjYW4gYmUgaW4gYW55IHN1cHBvcnRlZCBwcm9qZWN0aW9uLlxuICogQnkgZGVmYXVsdCB0aGUgY29udHJvbCBpcyBzaG93biBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwLCBidXQgdGhpc1xuICogY2FuIGJlIGNoYW5nZWQgYnkgdXNpbmcgdGhlIGNzcyBzZWxlY3RvciBgLm9sLW1vdXNlLXBvc2l0aW9uYC5cbiAqXG4gKiBPbiB0b3VjaCBkZXZpY2VzLCB3aGljaCB1c3VhbGx5IGRvIG5vdCBoYXZlIGEgbW91c2UgY3Vyc29yLCB0aGUgY29vcmRpbmF0ZXNcbiAqIG9mIHRoZSBjdXJyZW50bHkgdG91Y2hlZCBwb3NpdGlvbiBhcmUgc2hvd24uXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBNb3VzZVBvc2l0aW9uIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBNb3VzZSBwb3NpdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1tb3VzZS1wb3NpdGlvbic7XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgcmVuZGVyOiBvcHRpb25zLnJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgfSk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge01vdXNlUG9zaXRpb25PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNb3VzZVBvc2l0aW9uT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNb3VzZVBvc2l0aW9uT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoUFJPSkVDVElPTiwgdGhpcy5oYW5kbGVQcm9qZWN0aW9uQ2hhbmdlZF8pO1xuXG4gICAgaWYgKG9wdGlvbnMuY29vcmRpbmF0ZUZvcm1hdCkge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlRm9ybWF0KG9wdGlvbnMuY29vcmRpbmF0ZUZvcm1hdCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMuc2V0UHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJPbk1vdXNlT3V0XyA9IG9wdGlvbnMucGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnBsYWNlaG9sZGVyXyA9IHRoaXMucmVuZGVyT25Nb3VzZU91dF8gPyBvcHRpb25zLnBsYWNlaG9sZGVyIDogJyYjMTYwOyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEhUTUxfID0gZWxlbWVudC5pbm5lckhUTUw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tYXBQcm9qZWN0aW9uXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBYXyA9IG9wdGlvbnMud3JhcFggPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQcm9qZWN0aW9uQ2hhbmdlZF8oKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1fID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGUgZm9ybWF0IHR5cGUgdXNlZCB0byByZW5kZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24gb3JcbiAgICogdW5kZWZpbmVkLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGVGb3JtYXR8dW5kZWZpbmVkfSBUaGUgZm9ybWF0IHRvIHJlbmRlciB0aGUgY3VycmVudFxuICAgKiAgICAgcG9zaXRpb24gaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVGb3JtYXQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlRm9ybWF0fHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoQ09PUkRJTkFURV9GT1JNQVQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHByb2plY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHJlcG9ydCB0aGUgbW91c2UgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHByb2plY3Rpb24gdG8gcmVwb3J0IG1vdXNlXG4gICAqICAgICBwb3NpdGlvbiBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHx1bmRlZmluZWR9ICovIChcbiAgICAgIHRoaXMuZ2V0KFBST0pFQ1RJT04pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgdGhpcy51cGRhdGVIVE1MXyhtYXAuZ2V0RXZlbnRQaXhlbChldmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU1vdXNlT3V0KGV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVIVE1MXyhudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogUGFzcyBgbnVsbGAgdG8ganVzdCByZW1vdmUgdGhlIGNvbnRyb2wgZnJvbSB0aGUgY3VycmVudCBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIHN1cGVyLnNldE1hcChtYXApO1xuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gbWFwLmdldFZpZXdwb3J0KCk7XG4gICAgICB0aGlzLmxpc3RlbmVyS2V5cy5wdXNoKFxuICAgICAgICBsaXN0ZW4odmlld3BvcnQsIEV2ZW50VHlwZS5QT0lOVEVSTU9WRSwgdGhpcy5oYW5kbGVNb3VzZU1vdmUsIHRoaXMpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMucmVuZGVyT25Nb3VzZU91dF8pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcktleXMucHVzaChcbiAgICAgICAgICBsaXN0ZW4odmlld3BvcnQsIEV2ZW50VHlwZS5QT0lOVEVST1VULCB0aGlzLmhhbmRsZU1vdXNlT3V0LCB0aGlzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVIVE1MXyhudWxsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlIGZvcm1hdCB0eXBlIHVzZWQgdG8gcmVuZGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZUZvcm1hdH0gZm9ybWF0IFRoZSBmb3JtYXQgdG8gcmVuZGVyIHRoZSBjdXJyZW50XG4gICAqICAgICBwb3NpdGlvbiBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICB0aGlzLnNldChDT09SRElOQVRFX0ZPUk1BVCwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByb2plY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHJlcG9ydCB0aGUgbW91c2UgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbiB0byByZXBvcnQgbW91c2VcbiAgICogICAgIHBvc2l0aW9uIGluLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICB0aGlzLnNldChQUk9KRUNUSU9OLCBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVIVE1MXyhwaXhlbCkge1xuICAgIGxldCBodG1sID0gdGhpcy5wbGFjZWhvbGRlcl87XG4gICAgaWYgKHBpeGVsICYmIHRoaXMubWFwUHJvamVjdGlvbl8pIHtcbiAgICAgIGlmICghdGhpcy50cmFuc2Zvcm1fKSB7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybV8gPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gICAgICAgICAgICB0aGlzLm1hcFByb2plY3Rpb25fLFxuICAgICAgICAgICAgcHJvamVjdGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1fID0gaWRlbnRpdHlUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICBjb25zdCBjb29yZGluYXRlID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChwaXhlbCk7XG4gICAgICBpZiAoY29vcmRpbmF0ZSkge1xuICAgICAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG4gICAgICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtXyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgICAgICAgICAgIHRoaXMubWFwUHJvamVjdGlvbl8sXG4gICAgICAgICAgICB1c2VyUHJvamVjdGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2Zvcm1fKGNvb3JkaW5hdGUsIGNvb3JkaW5hdGUpO1xuICAgICAgICBpZiAodGhpcy53cmFwWF8pIHtcbiAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID1cbiAgICAgICAgICAgIHVzZXJQcm9qZWN0aW9uIHx8IHRoaXMuZ2V0UHJvamVjdGlvbigpIHx8IHRoaXMubWFwUHJvamVjdGlvbl87XG4gICAgICAgICAgd3JhcFgoY29vcmRpbmF0ZSwgcHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZUZvcm1hdCA9IHRoaXMuZ2V0Q29vcmRpbmF0ZUZvcm1hdCgpO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZUZvcm1hdCkge1xuICAgICAgICAgIGh0bWwgPSBjb29yZGluYXRlRm9ybWF0KGNvb3JkaW5hdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGh0bWwgPSBjb29yZGluYXRlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVkSFRNTF8gfHwgaHRtbCAhPT0gdGhpcy5yZW5kZXJlZEhUTUxfKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHRoaXMucmVuZGVyZWRIVE1MXyA9IGh0bWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcHJvamVjdGlvbi4gUmVuZGVyaW5nIG9mIHRoZSBjb29yZGluYXRlcyBpcyBkb25lIGluXG4gICAqIGBoYW5kbGVNb3VzZU1vdmVgIGFuZCBgaGFuZGxlTW91c2VVcGAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcihtYXBFdmVudCkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSBtYXBFdmVudC5mcmFtZVN0YXRlO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgdGhpcy5tYXBQcm9qZWN0aW9uXyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm1hcFByb2plY3Rpb25fICE9IGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24pIHtcbiAgICAgICAgdGhpcy5tYXBQcm9qZWN0aW9uXyA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgICAgIHRoaXMudHJhbnNmb3JtXyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vdXNlUG9zaXRpb247XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlSW1hZ2VcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVRpbGUgZnJvbSAnLi4vSW1hZ2VUaWxlLmpzJztcbmltcG9ydCBSZXByb2pUaWxlIGZyb20gJy4uL3JlcHJvai9UaWxlLmpzJztcbmltcG9ydCBUaWxlQ2FjaGUgZnJvbSAnLi4vVGlsZUNhY2hlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCBVcmxUaWxlIGZyb20gJy4vVXJsVGlsZS5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnQsIGdldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7Z2V0S2V5LCBnZXRLZXlaWFl9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge2dldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gSW5pdGlhbCB0aWxlIGNhY2hlIHNpemUuIFdpbGwgYXV0by1ncm93IHRvIGhvbGQgYXQgbGVhc3QgdGhlIG51bWJlciBvZiB0aWxlcyBpbiB0aGUgdmlld3BvcnQuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPXRydWVdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy4gIFNldCB0byBmYWxzZSB0byB1c2UgdGhlIG5lYXJlc3QgbmVpZ2hib3IgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZT1mYWxzZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi4gRGVmYXVsdCBpcyB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGVdIFNvdXJjZSBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGltcG9ydChcIi4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSBbdGlsZUNsYXNzXSBDbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIGltYWdlIHRpbGVzLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL0ltYWdlVGlsZX5JbWFnZVRpbGV9LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuIEZvciBleGFtcGxlLCBpZiB0aGUgdGlsZVxuICogc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGdldCB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gVVJMIHRlbXBsYXRlLiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy5cbiAqIEEgYHs/LT99YCB0ZW1wbGF0ZSBwYXR0ZXJuLCBmb3IgZXhhbXBsZSBgc3ViZG9tYWlue2EtZn0uZG9tYWluLmNvbWAsIG1heSBiZVxuICogdXNlZCBpbnN0ZWFkIG9mIGRlZmluaW5nIGVhY2ggb25lIHNlcGFyYXRlbHkgaW4gdGhlIGB1cmxzYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFt1cmxzXSBBbiBhcnJheSBvZiBVUkwgdGVtcGxhdGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFhdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LiBUaGUgZGVmYXVsdCwgaXMgdG9cbiAqIHJlcXVlc3Qgb3V0LW9mLWJvdW5kcyB0aWxlcyBmcm9tIHRoZSBzZXJ2ZXIuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9ubHkgb25lXG4gKiB3b3JsZCB3aWxsIGJlIHJlbmRlcmVkLiBXaGVuIHNldCB0byBgdHJ1ZWAsIHRpbGVzIHdpbGwgYmUgcmVxdWVzdGVkIGZvciBvbmVcbiAqIHdvcmxkIG9ubHksIGJ1dCB0aGV5IHdpbGwgYmUgd3JhcHBlZCBob3Jpem9udGFsbHkgdG8gcmVuZGVyIG11bHRpcGxlIHdvcmxkcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XSBPcHRpb25hbCB0aWxlIGtleSBmb3IgcHJvcGVyIGNhY2hlIGZldGNoaW5nXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFt6RGlyZWN0aW9uPTBdXG4gKiBDaG9vc2Ugd2hldGhlciB0byB1c2UgdGlsZXMgd2l0aCBhIGhpZ2hlciBvciBsb3dlciB6b29tIGxldmVsIHdoZW4gYmV0d2VlbiBpbnRlZ2VyXG4gKiB6b29tIGxldmVscy4gU2VlIHtAbGluayBtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR+VGlsZUdyaWQjZ2V0WkZvclJlc29sdXRpb259LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgaW1hZ2VzIGRpdmlkZWQgaW50byBhIHRpbGUgZ3JpZC5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9UaWxlLmpzXCIpLlRpbGVTb3VyY2VFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBUaWxlSW1hZ2UgZXh0ZW5kcyBVcmxUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9wdGlvbnN9IG9wdGlvbnMgSW1hZ2UgdGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgdGlsZUdyaWQ6IG9wdGlvbnMudGlsZUdyaWQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb25cbiAgICAgICAgPyBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb25cbiAgICAgICAgOiBkZWZhdWx0VGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHRpbGVQaXhlbFJhdGlvOiBvcHRpb25zLnRpbGVQaXhlbFJhdGlvLFxuICAgICAgdGlsZVVybEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbixcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICB1cmxzOiBvcHRpb25zLnVybHMsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGludGVycG9sYXRlOlxuICAgICAgICBvcHRpb25zLmludGVycG9sYXRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmludGVycG9sYXRlIDogdHJ1ZSxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSxcbiAgICAgIHpEaXJlY3Rpb246IG9wdGlvbnMuekRpcmVjdGlvbixcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luID1cbiAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHt0eXBlb2YgSW1hZ2VUaWxlfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNsYXNzID1cbiAgICAgIG9wdGlvbnMudGlsZUNsYXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbGVDbGFzcyA6IEltYWdlVGlsZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIFRpbGVDYWNoZT59XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkXyA9IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIGlmICh0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2tleV0uY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gdXNlZFRpbGVzIFVzZWQgdGlsZXMuXG4gICAqL1xuICBleHBpcmVDYWNoZShwcm9qZWN0aW9uLCB1c2VkVGlsZXMpIHtcbiAgICBjb25zdCB1c2VkVGlsZUNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuXG4gICAgdGhpcy50aWxlQ2FjaGUuZXhwaXJlQ2FjaGUoXG4gICAgICB0aGlzLnRpbGVDYWNoZSA9PSB1c2VkVGlsZUNhY2hlID8gdXNlZFRpbGVzIDoge31cbiAgICApO1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICBjb25zdCB0aWxlQ2FjaGUgPSB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25baWRdO1xuICAgICAgdGlsZUNhY2hlLmV4cGlyZUNhY2hlKHRpbGVDYWNoZSA9PSB1c2VkVGlsZUNhY2hlID8gdXNlZFRpbGVzIDoge30pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgZ2V0R3V0dGVyRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiZcbiAgICAgIHByb2plY3Rpb24gJiZcbiAgICAgICFlcXVpdmFsZW50KHRoaXMuZ2V0UHJvamVjdGlvbigpLCBwcm9qZWN0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEd1dHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgZ2V0R3V0dGVyKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUga2V5IHRvIGJlIHVzZWQgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBrZXkgZm9yIGFsbCB0aWxlcy5cbiAgICovXG4gIGdldEtleSgpIHtcbiAgICBsZXQga2V5ID0gc3VwZXIuZ2V0S2V5KCk7XG4gICAgaWYgKCF0aGlzLmdldEludGVycG9sYXRlKCkpIHtcbiAgICAgIGtleSArPSAnOmRpc2FibGUtaW50ZXJwb2xhdGlvbic7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBPcGFxdWUuXG4gICAqL1xuICBnZXRPcGFxdWUocHJvamVjdGlvbikge1xuICAgIGlmIChcbiAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpICYmXG4gICAgICBwcm9qZWN0aW9uICYmXG4gICAgICAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldE9wYXF1ZShwcm9qZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBUaWxlIGdyaWQuXG4gICAqL1xuICBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHRoaXMudGlsZUdyaWQgJiYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICAgIH1cbiAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pO1xuICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24pKSB7XG4gICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9XG4gICAgICAgIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uW3Byb2pLZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZUNhY2hlLmpzXCIpLmRlZmF1bHR9IFRpbGUgY2FjaGUuXG4gICAqL1xuICBnZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICBjb25zdCB0aGlzUHJvaiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGlmICghdGhpc1Byb2ogfHwgZXF1aXZhbGVudCh0aGlzUHJvaiwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcHJvaktleSA9IGdldFVpZChwcm9qZWN0aW9uKTtcbiAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikpIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IG5ldyBUaWxlQ2FjaGUoXG4gICAgICAgIHRoaXMudGlsZUNhY2hlLmhpZ2hXYXRlck1hcmtcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25bcHJvaktleV07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHNldCBvbiB0aGUgdGlsZS5cbiAgICogQHJldHVybiB7IUltYWdlVGlsZX0gVGlsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSkge1xuICAgIGNvbnN0IHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICBjb25zdCB1cmxUaWxlQ29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbihcbiAgICAgIHRpbGVDb29yZCxcbiAgICAgIHByb2plY3Rpb25cbiAgICApO1xuICAgIGNvbnN0IHRpbGVVcmwgPSB1cmxUaWxlQ29vcmRcbiAgICAgID8gdGhpcy50aWxlVXJsRnVuY3Rpb24odXJsVGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdGlsZSA9IG5ldyB0aGlzLnRpbGVDbGFzcyhcbiAgICAgIHRpbGVDb29yZCxcbiAgICAgIHRpbGVVcmwgIT09IHVuZGVmaW5lZCA/IFRpbGVTdGF0ZS5JRExFIDogVGlsZVN0YXRlLkVNUFRZLFxuICAgICAgdGlsZVVybCAhPT0gdW5kZWZpbmVkID8gdGlsZVVybCA6ICcnLFxuICAgICAgdGhpcy5jcm9zc09yaWdpbixcbiAgICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHRoaXMudGlsZU9wdGlvbnNcbiAgICApO1xuICAgIHRpbGUua2V5ID0ga2V5O1xuICAgIHRpbGUuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IShJbWFnZVRpbGV8UmVwcm9qVGlsZSl9IFRpbGUuXG4gICAqL1xuICBnZXRUaWxlKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICBjb25zdCBzb3VyY2VQcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKFxuICAgICAgIXNvdXJjZVByb2plY3Rpb24gfHxcbiAgICAgICFwcm9qZWN0aW9uIHx8XG4gICAgICBlcXVpdmFsZW50KHNvdXJjZVByb2plY3Rpb24sIHByb2plY3Rpb24pXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlSW50ZXJuYWwoXG4gICAgICAgIHosXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBpeGVsUmF0aW8sXG4gICAgICAgIHNvdXJjZVByb2plY3Rpb24gfHwgcHJvamVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgY29uc3QgdGlsZUNvb3JkID0gW3osIHgsIHldO1xuICAgIGxldCB0aWxlO1xuICAgIGNvbnN0IHRpbGVDb29yZEtleSA9IGdldEtleSh0aWxlQ29vcmQpO1xuICAgIGlmIChjYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgICB0aWxlID0gY2FjaGUuZ2V0KHRpbGVDb29yZEtleSk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XG4gICAgaWYgKHRpbGUgJiYgdGlsZS5rZXkgPT0ga2V5KSB7XG4gICAgICByZXR1cm4gdGlsZTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlVGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihzb3VyY2VQcm9qZWN0aW9uKTtcbiAgICBjb25zdCB0YXJnZXRUaWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHdyYXBwZWRUaWxlQ29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbihcbiAgICAgIHRpbGVDb29yZCxcbiAgICAgIHByb2plY3Rpb25cbiAgICApO1xuICAgIGNvbnN0IG5ld1RpbGUgPSBuZXcgUmVwcm9qVGlsZShcbiAgICAgIHNvdXJjZVByb2plY3Rpb24sXG4gICAgICBzb3VyY2VUaWxlR3JpZCxcbiAgICAgIHByb2plY3Rpb24sXG4gICAgICB0YXJnZXRUaWxlR3JpZCxcbiAgICAgIHRpbGVDb29yZCxcbiAgICAgIHdyYXBwZWRUaWxlQ29vcmQsXG4gICAgICB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pLFxuICAgICAgdGhpcy5nZXRHdXR0ZXIoKSxcbiAgICAgICh6LCB4LCB5LCBwaXhlbFJhdGlvKSA9PlxuICAgICAgICB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uKSxcbiAgICAgIHRoaXMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfLFxuICAgICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18sXG4gICAgICB0aGlzLnRpbGVPcHRpb25zXG4gICAgKTtcbiAgICBuZXdUaWxlLmtleSA9IGtleTtcblxuICAgIGlmICh0aWxlKSB7XG4gICAgICBuZXdUaWxlLmludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgIG5ld1RpbGUucmVmcmVzaEludGVyaW1DaGFpbigpO1xuICAgICAgY2FjaGUucmVwbGFjZSh0aWxlQ29vcmRLZXksIG5ld1RpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5zZXQodGlsZUNvb3JkS2V5LCBuZXdUaWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1RpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFJbWFnZVRpbGV9IFRpbGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgbGV0IHRpbGUgPSBudWxsO1xuICAgIGNvbnN0IHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgIGlmICghdGhpcy50aWxlQ2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZV8oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KTtcbiAgICAgIHRoaXMudGlsZUNhY2hlLnNldCh0aWxlQ29vcmRLZXksIHRpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlID0gdGhpcy50aWxlQ2FjaGUuZ2V0KHRpbGVDb29yZEtleSk7XG4gICAgICBpZiAodGlsZS5rZXkgIT0ga2V5KSB7XG4gICAgICAgIC8vIFRoZSBzb3VyY2UncyBwYXJhbXMgY2hhbmdlZC4gSWYgdGhlIHRpbGUgaGFzIGFuIGludGVyaW0gdGlsZSBhbmQgaWYgd2VcbiAgICAgICAgLy8gY2FuIHVzZSBpdCB0aGVuIHdlIHVzZSBpdC4gT3RoZXJ3aXNlIHdlIGNyZWF0ZSBhIG5ldyB0aWxlLiAgSW4gYm90aFxuICAgICAgICAvLyBjYXNlcyB3ZSBhdHRlbXB0IHRvIGFzc2lnbiBhbiBpbnRlcmltIHRpbGUgdG8gdGhlIG5ldyB0aWxlLlxuICAgICAgICBjb25zdCBpbnRlcmltVGlsZSA9IHRpbGU7XG4gICAgICAgIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSk7XG5cbiAgICAgICAgLy9tYWtlIHRoZSBuZXcgdGlsZSB0aGUgaGVhZCBvZiB0aGUgbGlzdCxcbiAgICAgICAgaWYgKGludGVyaW1UaWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAvL3RoZSBvbGQgdGlsZSBoYXNuJ3QgYmVndW4gbG9hZGluZyB5ZXQsIGFuZCBpcyBub3cgb3V0ZGF0ZWQsIHNvIHdlIGNhbiBzaW1wbHkgZGlzY2FyZCBpdFxuICAgICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBpbnRlcmltVGlsZS5pbnRlcmltVGlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gaW50ZXJpbVRpbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZS5yZWZyZXNoSW50ZXJpbUNoYWluKCk7XG4gICAgICAgIHRoaXMudGlsZUNhY2hlLnJlcGxhY2UodGlsZUNvb3JkS2V5LCB0aWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIHJlbmRlciByZXByb2plY3Rpb24gZWRnZXMgb3Igbm90ICh1c3VhbGx5IGZvciBkZWJ1Z2dpbmcpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlciBSZW5kZXIgdGhlIGVkZ2VzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSZW5kZXJSZXByb2plY3Rpb25FZGdlcyhyZW5kZXIpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPT0gcmVuZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID0gcmVuZGVyO1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25baWRdLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpbGUgZ3JpZCB0byB1c2Ugd2hlbiByZXByb2plY3RpbmcgdGhlIHRpbGVzIHRvIHRoZSBnaXZlblxuICAgKiBwcm9qZWN0aW9uIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgdGlsZSBncmlkIGZvciB0aGUgcHJvamVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlIGRlZmF1bHQgdGlsZSBncmlkIGNhbm5vdCBiZSBjcmVhdGVkXG4gICAqIChlLmcuIHByb2plY3Rpb24gaGFzIG5vIGV4dGVudCBkZWZpbmVkKSBvclxuICAgKiBmb3Igb3B0aW1pemF0aW9uIHJlYXNvbnMgKGN1c3RvbSB0aWxlIHNpemUsIHJlc29sdXRpb25zLCAuLi4pLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlZ3JpZCBUaWxlIGdyaWQgdG8gdXNlIGZvciB0aGUgcHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24sIHRpbGVncmlkKSB7XG4gICAgY29uc3QgcHJvaiA9IGdldFByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKHByb2opIHtcbiAgICAgIGNvbnN0IHByb2pLZXkgPSBnZXRVaWQocHJvaik7XG4gICAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IHRpbGVncmlkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHN1cGVyLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltpZF0uY2xlYXIoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlVGlsZX0gaW1hZ2VUaWxlIEltYWdlIHRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChpbWFnZVRpbGUuZ2V0SW1hZ2UoKSkuc3JjID1cbiAgICBzcmM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVJbWFnZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVxuICovXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCB7ZWFzZUlufSBmcm9tICcuL2Vhc2luZy5qcyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvVGlsZX5UaWxlfSBmb3IgdGhlIHRpbGUgYW5kIGFcbiAqIGB7c3RyaW5nfWAgZm9yIHRoZSB1cmwgYXMgYXJndW1lbnRzLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIHNvdXJjZS5zZXRUaWxlTG9hZEZ1bmN0aW9uKGZ1bmN0aW9uKHRpbGUsIHNyYykge1xuICogICB0aWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfSk7XG4gKiBgYGBcbiAqIEZvciBtb3JlIGZpbmUgZ3JhaW5lZCBjb250cm9sLCB0aGUgbG9hZCBmdW5jdGlvbiBjYW4gdXNlIGZldGNoIG9yIFhNTEh0dHBSZXF1ZXN0IGFuZCBpbnZvbHZlXG4gKiBlcnJvciBoYW5kbGluZzpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICdvbC9UaWxlU3RhdGUuanMnO1xuICpcbiAqIHNvdXJjZS5zZXRUaWxlTG9hZEZ1bmN0aW9uKGZ1bmN0aW9uKHRpbGUsIHNyYykge1xuICogICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAqICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAqICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gKiAgICAgY29uc3QgZGF0YSA9IHRoaXMucmVzcG9uc2U7XG4gKiAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICogICAgICAgdGlsZS5nZXRJbWFnZSgpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YSk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIHRpbGUuc2V0U3RhdGUoVGlsZVN0YXRlLkVSUk9SKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICogICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGlsZS5zZXRTdGF0ZShUaWxlU3RhdGUuRVJST1IpO1xuICogICB9KTtcbiAqICAgeGhyLm9wZW4oJ0dFVCcsIHNyYyk7XG4gKiAgIHhoci5zZW5kKCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihUaWxlLCBzdHJpbmcpOiB2b2lkfSBMb2FkRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZX0gc291cmNlcyB1c2UgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgdG8gZ2V0XG4gKiB0aGUgdXJsIHRoYXQgcHJvdmlkZXMgYSB0aWxlIGZvciBhIGdpdmVuIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gZm9yIHRoZSB0aWxlXG4gKiBjb29yZGluYXRlLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSBwaXhlbCByYXRpbyBhbmQgYVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhcyBhcmd1bWVudHNcbiAqIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIHRpbGUgVVJMLCBvciB1bmRlZmluZWQgaWYgbm8gdGlsZVxuICogc2hvdWxkIGJlIHJlcXVlc3RlZCBmb3IgdGhlIHBhc3NlZCB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCwgbnVtYmVyLFxuICogICAgICAgICAgIGltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQpOiAoc3RyaW5nfHVuZGVmaW5lZCl9IFVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBBIGR1cmF0aW9uIGZvciB0aWxlIG9wYWNpdHlcbiAqIHRyYW5zaXRpb25zIGluIG1pbGxpc2Vjb25kcy4gQSBkdXJhdGlvbiBvZiAwIGRpc2FibGVzIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICogQGFwaVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3IgdGlsZXMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFRpbGUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gVGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZUNvb3JkLCBzdGF0ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ29vcmQgPSB0aWxlQ29vcmQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQW4gXCJpbnRlcmltXCIgdGlsZSBmb3IgdGhpcyB0aWxlLiBUaGUgaW50ZXJpbSB0aWxlIG1heSBiZSB1c2VkIHdoaWxlIHRoaXNcbiAgICAgKiBvbmUgaXMgbG9hZGluZywgZm9yIFwic21vb3RoXCIgdHJhbnNpdGlvbnMgd2hlbiBjaGFuZ2luZyBwYXJhbXMvZGltZW5zaW9uc1xuICAgICAqIG9uIHRoZSBzb3VyY2UuXG4gICAgICogQHR5cGUge1RpbGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmludGVyaW1UaWxlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEga2V5IGFzc2lnbmVkIHRvIHRoZSB0aWxlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIHRpbGUgc291cmNlIHRvIGRldGVybWluZVxuICAgICAqIGlmIHRoaXMgdGlsZSBjYW4gZWZmZWN0aXZlbHkgYmUgdXNlZCwgb3IgaWYgYSBuZXcgdGlsZSBzaG91bGQgYmUgY3JlYXRlZFxuICAgICAqIGFuZCB0aGlzIG9uZSBiZSB1c2VkIGFzIGFuIGludGVyaW0gdGlsZSBmb3IgdGhpcyBuZXcgdGlsZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25fID1cbiAgICAgIG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkID8gMjUwIDogb3B0aW9ucy50cmFuc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIG9mIHN0YXJ0IHRpbWVzIGZvciByZW5kZXJpbmcgdHJhbnNpdGlvbnMuICBJZiB0aGUgc3RhcnQgdGltZSBpc1xuICAgICAqIGVxdWFsIHRvIC0xLCB0aGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlID0gISFvcHRpb25zLmludGVycG9sYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNoYW5nZWQoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50VHlwZS5DSEFOR0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSB0aGUgdGlsZSBjYWNoZSB3aGVuIHRoZSB0aWxlIGlzIHJlbW92ZWQgZnJvbSB0aGUgY2FjaGUgZHVlIHRvIGV4cGlyeVxuICAgKi9cbiAgcmVsZWFzZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgICAvLyB0byByZW1vdmUgdGhlIGBjaGFuZ2VgIGxpc3RlbmVyIG9uIHRoaXMgdGlsZSBpbiBgb2wvVGlsZVF1ZXVlI2hhbmRsZVRpbGVDaGFuZ2VgXG4gICAgICB0aGlzLnNldFN0YXRlKFRpbGVTdGF0ZS5FTVBUWSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgKi9cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLmtleSArICcvJyArIHRoaXMudGlsZUNvb3JkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJpbSB0aWxlIG1vc3Qgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB1c2luZyB0aGUgY2hhaW4gb2YgaW50ZXJpbVxuICAgKiB0aWxlcy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgIG1vc3QgcmVjZW50IHRpbGUgdGhhdCBoYXMgYmVlbiBsb2FkZWQsIGlmIG5vXG4gICAqIHN1Y2ggdGlsZSBleGlzdHMsIHRoZSBvcmlnaW5hbCB0aWxlIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshVGlsZX0gQmVzdCB0aWxlIGZvciByZW5kZXJpbmcuXG4gICAqL1xuICBnZXRJbnRlcmltVGlsZSgpIHtcbiAgICBsZXQgdGlsZSA9IHRoaXMuaW50ZXJpbVRpbGU7XG4gICAgaWYgKCF0aWxlKSB7XG4gICAgICAvL2VtcHR5IGNoYWluXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBsb2FkZWQgdGlsZSBhbmQgcmV0dXJuIGl0LiBTaW5jZSB0aGUgY2hhaW4gaXMgc29ydGVkIGluXG4gICAgLy8gZGVjcmVhc2luZyBvcmRlciBvZiBjcmVhdGlvbiB0aW1lLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNlYXJjaCB0aGUgcmVtYWluZGVyXG4gICAgLy8gb2YgdGhlIGxpc3QgKGFsbCB0aG9zZSB0aWxlcyBjb3JyZXNwb25kIHRvIG9sZGVyIHJlcXVlc3RzIGFuZCB3aWxsIGJlXG4gICAgLy8gY2xlYW5lZCB1cCBieSByZWZyZXNoSW50ZXJpbUNoYWluKVxuICAgIGRvIHtcbiAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAvLyBTaG93IHRpbGUgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiBmYWRpbmcgaXQgaW4gYWZ0ZXIgbG9hZGluZywgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgaW50ZXJpbSB0aWxlIGlzIGluIHBsYWNlIGFscmVhZHlcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uXyA9IDA7XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgfVxuICAgICAgdGlsZSA9IHRpbGUuaW50ZXJpbVRpbGU7XG4gICAgfSB3aGlsZSAodGlsZSk7XG5cbiAgICAvLyB3ZSBjYW4gbm90IGZpbmQgYSBiZXR0ZXIgdGlsZVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCB0aGUgY2hhaW4gb2YgaW50ZXJpbSB0aWxlcyBhbmQgZGlzY2FyZHMgc2VjdGlvbnMgb2YgdGhlIGNoYWluXG4gICAqIHRoYXQgYXJlIG5vIGxvbmdlciByZWxldmFudC5cbiAgICovXG4gIHJlZnJlc2hJbnRlcmltQ2hhaW4oKSB7XG4gICAgbGV0IHRpbGUgPSB0aGlzLmludGVyaW1UaWxlO1xuICAgIGlmICghdGlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7VGlsZX0gKi9cbiAgICBsZXQgcHJldiA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIC8vd2UgaGF2ZSBhIGxvYWRlZCB0aWxlLCB3ZSBjYW4gZGlzY2FyZCB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgICAgICAvL3dlIHdvdWxkIGNvdWxkIGFib3J0IGFueSBMT0FESU5HIHRpbGUgcmVxdWVzdFxuICAgICAgICAvL29sZGVyIHRoYW4gdGhpcyB0aWxlIChpLmUuIGFueSBMT0FESU5HIHRpbGUgZm9sbG93aW5nIHRoaXMgZW50cnkgaW4gdGhlIGNoYWluKVxuICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgIC8va2VlcCB0aGlzIExPQURJTkcgdGlsZSBhbnkgbG9hZGVkIHRpbGVzIGxhdGVyIGluIHRoZSBjaGFpbiBhcmVcbiAgICAgICAgLy9vbGRlciB0aGFuIHRoaXMgdGlsZSwgc28gd2UncmUgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGUgcmVxdWVzdFxuICAgICAgICBwcmV2ID0gdGlsZTtcbiAgICAgIH0gZWxzZSBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgIC8vdGhlIGhlYWQgb2YgdGhlIGxpc3QgaXMgdGhlIG1vc3QgY3VycmVudCB0aWxlLCB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vdG8gc3RhcnQgYW55IG90aGVyIHJlcXVlc3RzIGZvciB0aGlzIGNoYWluXG4gICAgICAgIHByZXYuaW50ZXJpbVRpbGUgPSB0aWxlLmludGVyaW1UaWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldiA9IHRpbGU7XG4gICAgICB9XG4gICAgICB0aWxlID0gcHJldi5pbnRlcmltVGlsZTtcbiAgICB9IHdoaWxlICh0aWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBmb3IgdGhpcyB0aWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRoZSB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlQ29vcmQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlU3RhdGUuanNcIikuZGVmYXVsdH0gU3RhdGUuXG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGlzIHRpbGUuIElmIHlvdSB3cml0ZSB5b3VyIG93biB7QGxpbmsgbW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9uIHRpbGVMb2FkRnVuY3Rpb259ICxcbiAgICogaXQgaXMgaW1wb3J0YW50IHRvIHNldCB0aGUgc3RhdGUgY29ycmVjdGx5IHRvIHtAbGluayBtb2R1bGU6b2wvVGlsZVN0YXRlfkVSUk9SfVxuICAgKiB3aGVuIHRoZSB0aWxlIGNhbm5vdCBiZSBsb2FkZWQuIE90aGVyd2lzZSB0aGUgdGlsZSBjYW5ub3QgYmUgcmVtb3ZlZCBmcm9tXG4gICAqIHRoZSB0aWxlIHF1ZXVlIGFuZCB3aWxsIGJsb2NrIG90aGVyIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9IHN0YXRlIFN0YXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBUaWxlU3RhdGUuRVJST1IgJiYgdGhpcy5zdGF0ZSA+IHN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgbG9hZCBzZXF1ZW5jZSB2aW9sYXRpb24nKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGltYWdlIG9yIHJldHJ5IGlmIGxvYWRpbmcgcHJldmlvdXNseSBmYWlsZWQuXG4gICAqIExvYWRpbmcgaXMgdGFrZW4gY2FyZSBvZiBieSB0aGUgdGlsZSBxdWV1ZSwgYW5kIGNhbGxpbmcgdGhpcyBtZXRob2QgaXNcbiAgICogb25seSBuZWVkZWQgZm9yIHByZWxvYWRpbmcgb3IgZm9yIHJlbG9hZGluZyBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQGFwaVxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYWxwaGEgdmFsdWUgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSByZW5kZXIgZnJhbWUgdGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAqL1xuICBnZXRBbHBoYShpZCwgdGltZSkge1xuICAgIGlmICghdGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgbGV0IHN0YXJ0ID0gdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF07XG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgc3RhcnQgPSB0aW1lO1xuICAgICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gPSBzdGFydDtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsdGEgPSB0aW1lIC0gc3RhcnQgKyAxMDAwIC8gNjA7IC8vIGF2b2lkIHJlbmRlcmluZyBhdCAwXG4gICAgaWYgKGRlbHRhID49IHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gZWFzZUluKGRlbHRhIC8gdGhpcy50cmFuc2l0aW9uXyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgdGlsZSBpcyBpbiBhbiBhbHBoYSB0cmFuc2l0aW9uLiAgQSB0aWxlIGlzIGNvbnNpZGVyZWQgaW5cbiAgICogdHJhbnNpdGlvbiBpZiB0aWxlLmdldEFscGhhKCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQgb3IgaGFzIGJlZW4gY2FsbGVkXG4gICAqIGFuZCByZXR1cm5lZCAxLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgaXMgaW4gdHJhbnNpdGlvbi5cbiAgICovXG4gIGluVHJhbnNpdGlvbihpZCkge1xuICAgIGlmICghdGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgYSB0cmFuc2l0aW9uIGFzIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICovXG4gIGVuZFRyYW5zaXRpb24oaWQpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gPSAtMTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VUaWxlXG4gKi9cbmltcG9ydCBUaWxlIGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2xpc3RlbkltYWdlfSBmcm9tICcuL0ltYWdlLmpzJztcblxuY2xhc3MgSW1hZ2VUaWxlIGV4dGVuZHMgVGlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBJbWFnZSBzb3VyY2UgVVJJLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGUgbG9hZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuT3B0aW9uc30gW29wdGlvbnNdIFRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbGVDb29yZCwgc3RhdGUsIHNyYywgY3Jvc3NPcmlnaW4sIHRpbGVMb2FkRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBzdXBlcih0aWxlQ29vcmQsIHN0YXRlLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbl8gPSBjcm9zc09yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIEltYWdlIFVSSVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3JjXyA9IHNyYztcblxuICAgIHRoaXMua2V5ID0gc3JjO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICAgIGlmIChjcm9zc09yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24oKTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMudW5saXN0ZW5fID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyA9IHRpbGVMb2FkRnVuY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBIVE1MIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgdGlsZSAobWF5IGJlIGEgQ2FudmFzLCBJbWFnZSwgb3IgVmlkZW8pLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IEltYWdlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBIVE1MIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgdGlsZSAobWF5IGJlIGEgQ2FudmFzIG9yIHByZWxvYWRlZCBJbWFnZSkuXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gZWxlbWVudCBFbGVtZW50LlxuICAgKi9cbiAgc2V0SW1hZ2UoZWxlbWVudCkge1xuICAgIHRoaXMuaW1hZ2VfID0gZWxlbWVudDtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIGxvYWRpbmcgb3IgcmVhZCBlcnJvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVJbWFnZUVycm9yXygpIHtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmltYWdlXyA9IGdldEJsYW5rSW1hZ2UoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja3Mgc3VjY2Vzc2Z1bCBpbWFnZSBsb2FkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VMb2FkXygpIHtcbiAgICBjb25zdCBpbWFnZSA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKHRoaXMuaW1hZ2VfKTtcbiAgICBpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmIGltYWdlLm5hdHVyYWxIZWlnaHQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH1cbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgaW1hZ2Ugb3IgcmV0cnkgaWYgbG9hZGluZyBwcmV2aW91c2x5IGZhaWxlZC5cbiAgICogTG9hZGluZyBpcyB0YWtlbiBjYXJlIG9mIGJ5IHRoZSB0aWxlIHF1ZXVlLCBhbmQgY2FsbGluZyB0aGlzIG1ldGhvZCBpc1xuICAgKiBvbmx5IG5lZWRlZCBmb3IgcHJlbG9hZGluZyBvciBmb3IgcmVsb2FkaW5nIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gICAqXG4gICAqIFRvIHJldHJ5IGxvYWRpbmcgdGlsZXMgb24gZmFpbGVkIHJlcXVlc3RzLCB1c2UgYSBjdXN0b20gYHRpbGVMb2FkRnVuY3Rpb25gXG4gICAqIHRoYXQgY2hlY2tzIGZvciBlcnJvciBzdGF0dXMgY29kZXMgYW5kIHJlbG9hZHMgb25seSB3aGVuIHRoZSBzdGF0dXMgY29kZSBpc1xuICAgKiA0MDgsIDQyOSwgNTAwLCA1MDIsIDUwMyBhbmQgNTA0LCBhbmQgb25seSB3aGVuIG5vdCB0b28gbWFueSByZXRyaWVzIGhhdmUgYmVlblxuICAgKiBtYWRlIGFscmVhZHk6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJldHJ5Q29kZXMgPSBbNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF07XG4gICAqIGNvbnN0IHJldHJpZXMgPSB7fTtcbiAgICogc291cmNlLnNldFRpbGVMb2FkRnVuY3Rpb24oKHRpbGUsIHNyYykgPT4ge1xuICAgKiAgIGNvbnN0IGltYWdlID0gdGlsZS5nZXRJbWFnZSgpO1xuICAgKiAgIGZldGNoKHNyYylcbiAgICogICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgKiAgICAgICBpZiAocmV0cnlDb2Rlcy5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAqICAgICAgICAgcmV0cmllc1tzcmNdID0gKHJldHJpZXNbc3JjXSB8fCAwKSArIDE7XG4gICAqICAgICAgICAgaWYgKHJldHJpZXNbc3JjXSA8PSAzKSB7XG4gICAqICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRpbGUubG9hZCgpLCByZXRyaWVzW3NyY10gKiAxMDAwKTtcbiAgICogICAgICAgICB9XG4gICAqICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAqICAgICAgIH1cbiAgICogICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICogICAgIH0pXG4gICAqICAgICAudGhlbigoYmxvYikgPT4ge1xuICAgKiAgICAgICBjb25zdCBpbWFnZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAqICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xuICAgKiAgICAgICBzZXRUaW1lb3V0KCgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwoaW1hZ2VVcmwpLCA1MDAwKTtcbiAgICogICAgIH0pXG4gICAqICAgICAuY2F0Y2goKCkgPT4gdGlsZS5zZXRTdGF0ZSgzKSk7IC8vIGVycm9yXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGFwaVxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbmV3IEltYWdlKCk7XG4gICAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luXztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyh0aGlzLCB0aGlzLnNyY18pO1xuICAgICAgdGhpcy51bmxpc3Rlbl8gPSBsaXN0ZW5JbWFnZShcbiAgICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAgIHRoaXMuaGFuZGxlSW1hZ2VMb2FkXy5iaW5kKHRoaXMpLFxuICAgICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfLmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2NhcmRzIGV2ZW50IGhhbmRsZXJzIHdoaWNoIGxpc3RlbiBmb3IgbG9hZCBjb21wbGV0aW9uIG9yIGVycm9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVubGlzdGVuSW1hZ2VfKCkge1xuICAgIGlmICh0aGlzLnVubGlzdGVuXykge1xuICAgICAgdGhpcy51bmxpc3Rlbl8oKTtcbiAgICAgIHRoaXMudW5saXN0ZW5fID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSAxLXBpeGVsIGJsYW5rIGltYWdlLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEJsYW5rIGltYWdlLlxuICovXG5mdW5jdGlvbiBnZXRCbGFua0ltYWdlKCkge1xuICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG4gIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgcmV0dXJuIGN0eC5jYW52YXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlVGlsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIGFsbG93ZWQgdGhyZXNob2xkICAoaW4gcGl4ZWxzKSBmb3IgcmVwcm9qZWN0aW9uXG4gKiB0cmlhbmd1bGF0aW9uLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEVSUk9SX1RIUkVTSE9MRCA9IDAuNTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL1RpbGVcbiAqL1xuaW1wb3J0IHtFUlJPUl9USFJFU0hPTER9IGZyb20gJy4vY29tbW9uLmpzJztcblxuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUaWxlIGZyb20gJy4uL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IFRyaWFuZ3VsYXRpb24gZnJvbSAnLi9Ucmlhbmd1bGF0aW9uLmpzJztcbmltcG9ydCB7XG4gIGNhbGN1bGF0ZVNvdXJjZUV4dGVudFJlc29sdXRpb24sXG4gIGNhbnZhc1Bvb2wsXG4gIHJlbmRlciBhcyByZW5kZXJSZXByb2plY3RlZCxcbn0gZnJvbSAnLi4vcmVwcm9qLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtnZXRBcmVhLCBnZXRJbnRlcnNlY3Rpb259IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7cmVsZWFzZUNhbnZhc30gZnJvbSAnLi4vZG9tLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyKSA6IChpbXBvcnQoXCIuLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdCl9IEZ1bmN0aW9uVHlwZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgZW5jYXBzdWxhdGluZyBzaW5nbGUgcmVwcm9qZWN0ZWQgdGlsZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlSW1hZ2V+VGlsZUltYWdlfS5cbiAqXG4gKi9cbmNsYXNzIFJlcHJvalRpbGUgZXh0ZW5kcyBUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gc291cmNlVGlsZUdyaWQgU291cmNlIHRpbGUgZ3JpZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0YXJnZXRUaWxlR3JpZCBUYXJnZXQgdGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHdyYXBwZWRUaWxlQ29vcmQgQ29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB3cmFwcGVkIGluIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIEd1dHRlciBvZiB0aGUgc291cmNlIHRpbGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uVHlwZX0gZ2V0VGlsZUZ1bmN0aW9uXG4gICAqICAgICBGdW5jdGlvbiByZXR1cm5pbmcgc291cmNlIHRpbGVzICh6LCB4LCB5LCBwaXhlbFJhdGlvKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlcnJvclRocmVzaG9sZF0gQWNjZXB0YWJsZSByZXByb2plY3Rpb24gZXJyb3IgKGluIHB4KS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVuZGVyRWRnZXNdIFJlbmRlciByZXByb2plY3Rpb24gZWRnZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5PcHRpb25zfSBbb3B0aW9uc10gVGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc291cmNlUHJvaixcbiAgICBzb3VyY2VUaWxlR3JpZCxcbiAgICB0YXJnZXRQcm9qLFxuICAgIHRhcmdldFRpbGVHcmlkLFxuICAgIHRpbGVDb29yZCxcbiAgICB3cmFwcGVkVGlsZUNvb3JkLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgZ3V0dGVyLFxuICAgIGdldFRpbGVGdW5jdGlvbixcbiAgICBlcnJvclRocmVzaG9sZCxcbiAgICByZW5kZXJFZGdlcyxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHN1cGVyKHRpbGVDb29yZCwgVGlsZVN0YXRlLklETEUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckVkZ2VzXyA9IHJlbmRlckVkZ2VzICE9PSB1bmRlZmluZWQgPyByZW5kZXJFZGdlcyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ3V0dGVyXyA9IGd1dHRlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlVGlsZUdyaWRfID0gc291cmNlVGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VGlsZUdyaWRfID0gdGFyZ2V0VGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICAgICAqL1xuICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8gPSB3cmFwcGVkVGlsZUNvb3JkID8gd3JhcHBlZFRpbGVDb29yZCA6IHRpbGVDb29yZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVpfID0gMDtcblxuICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRhcmdldFRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF9cbiAgICApO1xuICAgIGNvbnN0IG1heFRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldEV4dGVudCgpO1xuICAgIGxldCBtYXhTb3VyY2VFeHRlbnQgPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcblxuICAgIGNvbnN0IGxpbWl0ZWRUYXJnZXRFeHRlbnQgPSBtYXhUYXJnZXRFeHRlbnRcbiAgICAgID8gZ2V0SW50ZXJzZWN0aW9uKHRhcmdldEV4dGVudCwgbWF4VGFyZ2V0RXh0ZW50KVxuICAgICAgOiB0YXJnZXRFeHRlbnQ7XG5cbiAgICBpZiAoZ2V0QXJlYShsaW1pdGVkVGFyZ2V0RXh0ZW50KSA9PT0gMCkge1xuICAgICAgLy8gVGlsZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgcmFuZ2UgLT4gRU1QVFlcbiAgICAgIC8vIFRPRE86IGlzIGl0IGFjdHVhbGx5IGNvcnJlY3QgdGhhdCB0aGUgc291cmNlIGV2ZW4gY3JlYXRlcyB0aGUgdGlsZSA/XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZVByb2pFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgIGlmIChzb3VyY2VQcm9qRXh0ZW50KSB7XG4gICAgICBpZiAoIW1heFNvdXJjZUV4dGVudCkge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qRXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKG1heFNvdXJjZUV4dGVudCwgc291cmNlUHJvakV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRhcmdldFRpbGVHcmlkLmdldFJlc29sdXRpb24oXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdXG4gICAgKTtcblxuICAgIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VFeHRlbnRSZXNvbHV0aW9uKFxuICAgICAgc291cmNlUHJvaixcbiAgICAgIHRhcmdldFByb2osXG4gICAgICBsaW1pdGVkVGFyZ2V0RXh0ZW50LFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvblxuICAgICk7XG5cbiAgICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgICAgLy8gaW52YWxpZCBzb3VyY2VSZXNvbHV0aW9uIC0+IEVNUFRZXG4gICAgICAvLyBwcm9iYWJseSBlZGdlcyBvZiB0aGUgcHJvamVjdGlvbnMgd2hlbiBubyBleHRlbnQgaXMgZGVmaW5lZFxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvclRocmVzaG9sZEluUGl4ZWxzID1cbiAgICAgIGVycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBlcnJvclRocmVzaG9sZCA6IEVSUk9SX1RIUkVTSE9MRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFpbXBvcnQoXCIuL1RyaWFuZ3VsYXRpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ3VsYXRpb25fID0gbmV3IFRyaWFuZ3VsYXRpb24oXG4gICAgICBzb3VyY2VQcm9qLFxuICAgICAgdGFyZ2V0UHJvaixcbiAgICAgIGxpbWl0ZWRUYXJnZXRFeHRlbnQsXG4gICAgICBtYXhTb3VyY2VFeHRlbnQsXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uICogZXJyb3JUaHJlc2hvbGRJblBpeGVscyxcbiAgICAgIHRhcmdldFJlc29sdXRpb25cbiAgICApO1xuXG4gICAgaWYgKHRoaXMudHJpYW5ndWxhdGlvbl8uZ2V0VHJpYW5nbGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBubyB2YWxpZCB0cmlhbmdsZXMgLT4gRU1QVFlcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VaXyA9IHNvdXJjZVRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKHNvdXJjZVJlc29sdXRpb24pO1xuICAgIGxldCBzb3VyY2VFeHRlbnQgPSB0aGlzLnRyaWFuZ3VsYXRpb25fLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCgpO1xuXG4gICAgaWYgKG1heFNvdXJjZUV4dGVudCkge1xuICAgICAgaWYgKHNvdXJjZVByb2ouY2FuV3JhcFgoKSkge1xuICAgICAgICBzb3VyY2VFeHRlbnRbMV0gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFszXVxuICAgICAgICApO1xuICAgICAgICBzb3VyY2VFeHRlbnRbM10gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbM10sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFszXVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHNvdXJjZUV4dGVudCwgbWF4U291cmNlRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdldEFyZWEoc291cmNlRXh0ZW50KSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc291cmNlUmFuZ2UgPSBzb3VyY2VUaWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICBzb3VyY2VFeHRlbnQsXG4gICAgICAgIHRoaXMuc291cmNlWl9cbiAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IHNyY1ggPSBzb3VyY2VSYW5nZS5taW5YOyBzcmNYIDw9IHNvdXJjZVJhbmdlLm1heFg7IHNyY1grKykge1xuICAgICAgICBmb3IgKGxldCBzcmNZID0gc291cmNlUmFuZ2UubWluWTsgc3JjWSA8PSBzb3VyY2VSYW5nZS5tYXhZOyBzcmNZKyspIHtcbiAgICAgICAgICBjb25zdCB0aWxlID0gZ2V0VGlsZUZ1bmN0aW9uKHRoaXMuc291cmNlWl8sIHNyY1gsIHNyY1ksIHBpeGVsUmF0aW8pO1xuICAgICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVRpbGVzXy5wdXNoKHRpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSFRNTCBDYW52YXMgZWxlbWVudCBmb3IgdGhpcyB0aWxlLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzLlxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwcm9qZWN0XygpIHtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaCgodGlsZSkgPT4ge1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHtcbiAgICAgICAgICBleHRlbnQ6IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudCh0aWxlLnRpbGVDb29yZCksXG4gICAgICAgICAgaW1hZ2U6IHRpbGUuZ2V0SW1hZ2UoKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID0gMDtcblxuICAgIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeiA9IHRoaXMud3JhcHBlZFRpbGVDb29yZF9bMF07XG4gICAgICBjb25zdCBzaXplID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZVNpemUoeik7XG4gICAgICBjb25zdCB3aWR0aCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMV07XG4gICAgICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbih6KTtcbiAgICAgIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKFxuICAgICAgICB0aGlzLnNvdXJjZVpfXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0YXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQoXG4gICAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF9cbiAgICAgICk7XG5cbiAgICAgIHRoaXMuY2FudmFzXyA9IHJlbmRlclJlcHJvamVjdGVkKFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgICBzb3VyY2VSZXNvbHV0aW9uLFxuICAgICAgICB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKSxcbiAgICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICAgICAgdGFyZ2V0RXh0ZW50LFxuICAgICAgICB0aGlzLnRyaWFuZ3VsYXRpb25fLFxuICAgICAgICBzb3VyY2VzLFxuICAgICAgICB0aGlzLmd1dHRlcl8sXG4gICAgICAgIHRoaXMucmVuZGVyRWRnZXNfLFxuICAgICAgICB0aGlzLmludGVycG9sYXRlXG4gICAgICApO1xuXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcblxuICAgICAgbGV0IGxlZnRUb0xvYWQgPSAwO1xuXG4gICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gW107XG4gICAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKCh0aWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUgfHwgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgICBsZWZ0VG9Mb2FkKys7XG5cbiAgICAgICAgICBjb25zdCBzb3VyY2VMaXN0ZW5LZXkgPSBsaXN0ZW4oXG4gICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB1bmxpc3RlbkJ5S2V5KHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18ucHVzaChzb3VyY2VMaXN0ZW5LZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGxlZnRUb0xvYWQgPT09IDApIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnJlcHJvamVjdF8uYmluZCh0aGlzKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0aWxlLCBpLCBhcnIpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlblNvdXJjZXNfKCkge1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZnJvbSB0aGUgY2FjaGUgZHVlIHRvIGV4cGlyeVxuICAgKi9cbiAgcmVsZWFzZSgpIHtcbiAgICBpZiAodGhpcy5jYW52YXNfKSB7XG4gICAgICByZWxlYXNlQ2FudmFzKHRoaXMuY2FudmFzXy5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICAgIGNhbnZhc1Bvb2wucHVzaCh0aGlzLmNhbnZhc18pO1xuICAgICAgdGhpcy5jYW52YXNfID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIucmVsZWFzZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlcHJvalRpbGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9Ucmlhbmd1bGF0aW9uXG4gKi9cbmltcG9ydCB7XG4gIGJvdW5kaW5nRXh0ZW50LFxuICBjcmVhdGVFbXB0eSxcbiAgZXh0ZW5kQ29vcmRpbmF0ZSxcbiAgZ2V0QXJlYSxcbiAgZ2V0Qm90dG9tTGVmdCxcbiAgZ2V0Qm90dG9tUmlnaHQsXG4gIGdldFRvcExlZnQsXG4gIGdldFRvcFJpZ2h0LFxuICBnZXRXaWR0aCxcbiAgaW50ZXJzZWN0cyxcbn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Z2V0VHJhbnNmb3JtfSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuLi9tYXRoLmpzJztcblxuLyoqXG4gKiBTaW5nbGUgdHJpYW5nbGU7IGNvbnNpc3RzIG9mIDMgc291cmNlIHBvaW50cyBhbmQgMyB0YXJnZXQgcG9pbnRzLlxuICogQHR5cGVkZWYge09iamVjdH0gVHJpYW5nbGVcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gc291cmNlIFNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gdGFyZ2V0IFRhcmdldC5cbiAqL1xuXG4vKipcbiAqIE1heGltdW0gbnVtYmVyIG9mIHN1YmRpdmlzaW9uIHN0ZXBzIGR1cmluZyByYXN0ZXIgcmVwcm9qZWN0aW9uIHRyaWFuZ3VsYXRpb24uXG4gKiBQcmV2ZW50cyBoaWdoIG1lbW9yeSB1c2FnZSBhbmQgbGFyZ2UgbnVtYmVyIG9mIHByb2o0IGNhbGxzIChmb3IgY2VydGFpblxuICogdHJhbnNmb3JtYXRpb25zIGFuZCBhcmVhcykuIEF0IG1vc3QgYDIqKDJedGhpcylgIHRyaWFuZ2xlcyBhcmUgY3JlYXRlZCBmb3JcbiAqIGVhY2ggdHJpYW5ndWxhdGVkIGV4dGVudCAodGlsZS9pbWFnZSkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfU1VCRElWSVNJT04gPSAxMDtcblxuLyoqXG4gKiBNYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiB0cmlhbmdsZSByZWxhdGl2ZSB0byB3b3JsZCB3aWR0aC4gV2hlbiB0cmFuc2Zvcm1pbmdcbiAqIGNvcm5lcnMgb2Ygd29ybGQgZXh0ZW50IGJldHdlZW4gY2VydGFpbiBwcm9qZWN0aW9ucywgdGhlIHJlc3VsdGluZ1xuICogdHJpYW5ndWxhdGlvbiBzZWVtcyB0byBoYXZlIHplcm8gZXJyb3IgYW5kIG5vIHN1YmRpdmlzaW9uIGlzIHBlcmZvcm1lZC4gSWZcbiAqIHRoZSB0cmlhbmdsZSB3aWR0aCBpcyBtb3JlIHRoYW4gdGhpcyAocmVsYXRpdmUgdG8gd29ybGQgd2lkdGg7IDAtMSksXG4gKiBzdWJkaXZpc29uIGlzIGZvcmNlZCAodXAgdG8gYE1BWF9TVUJESVZJU0lPTmApLiBEZWZhdWx0IGlzIGAwLjI1YC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9UUklBTkdMRV9XSURUSCA9IDAuMjU7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgY29udGFpbmluZyB0cmlhbmd1bGF0aW9uIG9mIHRoZSBnaXZlbiB0YXJnZXQgZXh0ZW50LlxuICogVXNlZCBmb3IgZGV0ZXJtaW5pbmcgc291cmNlIGRhdGEgYW5kIHRoZSByZXByb2plY3Rpb24gaXRzZWxmLlxuICovXG5jbGFzcyBUcmlhbmd1bGF0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gdGFyZ2V0RXh0ZW50IFRhcmdldCBleHRlbnQgdG8gdHJpYW5ndWxhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4U291cmNlRXh0ZW50IE1heGltYWwgc291cmNlIGV4dGVudCB0aGF0IGNhbiBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZXJyb3JUaHJlc2hvbGQgQWNjZXB0YWJsZSBlcnJvciAoaW4gc291cmNlIHVuaXRzKS5cbiAgICogQHBhcmFtIHs/bnVtYmVyfSBkZXN0aW5hdGlvblJlc29sdXRpb24gVGhlIChvcHRpb25hbCkgcmVzb2x1dGlvbiBvZiB0aGUgZGVzdGluYXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBzb3VyY2VQcm9qLFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0RXh0ZW50LFxuICAgIG1heFNvdXJjZUV4dGVudCxcbiAgICBlcnJvclRocmVzaG9sZCxcbiAgICBkZXN0aW5hdGlvblJlc29sdXRpb25cbiAgKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VQcm9qXyA9IHNvdXJjZVByb2o7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFByb2pfID0gdGFyZ2V0UHJvajtcblxuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovXG4gICAgbGV0IHRyYW5zZm9ybUludkNhY2hlID0ge307XG4gICAgY29uc3QgdHJhbnNmb3JtSW52ID0gZ2V0VHJhbnNmb3JtKHRoaXMudGFyZ2V0UHJval8sIHRoaXMuc291cmNlUHJval8pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgQSBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtSW52XyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBjb25zdCBrZXkgPSBjWzBdICsgJy8nICsgY1sxXTtcbiAgICAgIGlmICghdHJhbnNmb3JtSW52Q2FjaGVba2V5XSkge1xuICAgICAgICB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldID0gdHJhbnNmb3JtSW52KGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybUludkNhY2hlW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhTb3VyY2VFeHRlbnRfID0gbWF4U291cmNlRXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JUaHJlc2hvbGRTcXVhcmVkXyA9IGVycm9yVGhyZXNob2xkICogZXJyb3JUaHJlc2hvbGQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJpYW5nbGU+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmlhbmdsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgdHJpYW5ndWxhdGlvbiBjcm9zc2VzIGVkZ2Ugb2YgdGhlIHNvdXJjZSBwcm9qZWN0aW9uLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYW5XcmFwWEluU291cmNlXyA9XG4gICAgICB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICEhbWF4U291cmNlRXh0ZW50ICYmXG4gICAgICAhIXRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgJiZcbiAgICAgIGdldFdpZHRoKG1heFNvdXJjZUV4dGVudCkgPj0gZ2V0V2lkdGgodGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlV29ybGRXaWR0aF8gPSB0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpXG4gICAgICA/IGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8gPSB0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpXG4gICAgICA/IGdldFdpZHRoKHRoaXMudGFyZ2V0UHJval8uZ2V0RXh0ZW50KCkpXG4gICAgICA6IG51bGw7XG5cbiAgICBjb25zdCBkZXN0aW5hdGlvblRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Ub3BSaWdodCA9IGdldFRvcFJpZ2h0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Cb3R0b21SaWdodCA9IGdldEJvdHRvbVJpZ2h0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Cb3R0b21MZWZ0ID0gZ2V0Qm90dG9tTGVmdCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IHNvdXJjZVRvcExlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BMZWZ0KTtcbiAgICBjb25zdCBzb3VyY2VUb3BSaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcFJpZ2h0KTtcbiAgICBjb25zdCBzb3VyY2VCb3R0b21SaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0KTtcbiAgICBjb25zdCBzb3VyY2VCb3R0b21MZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tTGVmdCk7XG5cbiAgICAvKlxuICAgICAqIFRoZSBtYXhTdWJkaXZpc2lvbiBjb250cm9scyBob3cgbWFueSBzcGxpdHRpbmdzIG9mIHRoZSB0YXJnZXQgYXJlYSBjYW5cbiAgICAgKiBiZSBkb25lLiBUaGUgaWRlYSBoZXJlIGlzIHRvIGRvIGEgbGluZWFyIG1hcHBpbmcgb2YgdGhlIHRhcmdldCBhcmVhc1xuICAgICAqIGJ1dCB0aGUgYWN0dWFsIG92ZXJhbGwgcmVwcm9qZWN0aW9uIChjYW4gYmUpIGV4dHJlbWVseSBub24tbGluZWFyLiBUaGVcbiAgICAgKiBkZWZhdWx0IHZhbHVlIG9mIE1BWF9TVUJESVZJU0lPTiB3YXMgY2hvc2VuIGJhc2VkIG9uIG1hcHBpbmcgYSAyNTZ4MjU2XG4gICAgICogdGlsZSBzaXplLiBIb3dldmVyIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyBjYWxsZWQgdG8gcmVtYXAgY2FudmFzIHJlbmRlcmVkXG4gICAgICogbGF5ZXJzIHdoaWNoIGNhbiBiZSBtdWNoIGxhcmdlci4gVGhpcyBjYWxjdWxhdGlvbiBpbmNyZWFzZXMgdGhlIG1heFN1YmRpdmlzaW9uXG4gICAgICogdmFsdWUgYnkgdGhlIHJpZ2h0IGZhY3RvciBzbyB0aGF0IGVhY2ggMjU2eDI1NiBwaXhlbCBhcmVhIGhhc1xuICAgICAqIE1BWF9TVUJESVZJU0lPTiBkaXZpc2lvbnMuXG4gICAgICovXG4gICAgY29uc3QgbWF4U3ViZGl2aXNpb24gPVxuICAgICAgTUFYX1NVQkRJVklTSU9OICtcbiAgICAgIChkZXN0aW5hdGlvblJlc29sdXRpb25cbiAgICAgICAgPyBNYXRoLm1heChcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgIE1hdGgubG9nMihcbiAgICAgICAgICAgICAgICBnZXRBcmVhKHRhcmdldEV4dGVudCkgL1xuICAgICAgICAgICAgICAgICAgKGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIDI1NiAqIDI1NilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgOiAwKTtcblxuICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICBkZXN0aW5hdGlvblRvcExlZnQsXG4gICAgICBkZXN0aW5hdGlvblRvcFJpZ2h0LFxuICAgICAgZGVzdGluYXRpb25Cb3R0b21SaWdodCxcbiAgICAgIGRlc3RpbmF0aW9uQm90dG9tTGVmdCxcbiAgICAgIHNvdXJjZVRvcExlZnQsXG4gICAgICBzb3VyY2VUb3BSaWdodCxcbiAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0LFxuICAgICAgc291cmNlQm90dG9tTGVmdCxcbiAgICAgIG1heFN1YmRpdmlzaW9uXG4gICAgKTtcblxuICAgIGlmICh0aGlzLndyYXBzWEluU291cmNlXykge1xuICAgICAgbGV0IGxlZnRCb3VuZCA9IEluZmluaXR5O1xuICAgICAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goZnVuY3Rpb24gKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgICAgbGVmdEJvdW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgbGVmdEJvdW5kLFxuICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVswXVswXSxcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sXG4gICAgICAgICAgdHJpYW5nbGUuc291cmNlWzJdWzBdXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hpZnQgdHJpYW5nbGVzIHRvIGJlIGFzIGNsb3NlIHRvIGBsZWZ0Qm91bmRgIGFzIHBvc3NpYmxlXG4gICAgICAvLyAoaWYgdGhlIGRpc3RhbmNlIGlzIG1vcmUgdGhhbiBgd29ybGRXaWR0aCAvIDJgIGl0IGNhbiBiZSBjbG9zZXIuXG4gICAgICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaCgodHJpYW5nbGUpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlWzBdWzBdLFxuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlWzFdWzBdLFxuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlWzJdWzBdXG4gICAgICAgICAgKSAtXG4gICAgICAgICAgICBsZWZ0Qm91bmQgPlxuICAgICAgICAgIHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1RyaWFuZ2xlID0gW1xuICAgICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzBdWzFdXSxcbiAgICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVsxXV0sXG4gICAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzJdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMV1dLFxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKG5ld1RyaWFuZ2xlWzBdWzBdIC0gbGVmdEJvdW5kID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdUcmlhbmdsZVsxXVswXSAtIGxlZnRCb3VuZCA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3VHJpYW5nbGVbMl1bMF0gLSBsZWZ0Qm91bmQgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMl1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSYXJlbHkgKGlmIHRoZSBleHRlbnQgY29udGFpbnMgYm90aCB0aGUgZGF0ZWxpbmUgYW5kIHByaW1lIG1lcmlkaWFuKVxuICAgICAgICAgIC8vIHRoZSBzaGlmdCBjYW4gaW4gdHVybiBicmVhayBzb21lIHRyaWFuZ2xlcy5cbiAgICAgICAgICAvLyBEZXRlY3QgdGhpcyBoZXJlIGFuZCBkb24ndCBzaGlmdCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICAgIGNvbnN0IG1pblggPSBNYXRoLm1pbihcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMF1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSxcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzJdWzBdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobWF4WCAtIG1pblggPCB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlID0gbmV3VHJpYW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdHJpYW5nbGUgdG8gdGhlIHRyaWFuZ3VsYXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhIFRoZSB0YXJnZXQgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYiBUaGUgdGFyZ2V0IGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgVGhlIHRhcmdldCBjIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRUcmlhbmdsZV8oYSwgYiwgYywgYVNyYywgYlNyYywgY1NyYykge1xuICAgIHRoaXMudHJpYW5nbGVzXy5wdXNoKHtcbiAgICAgIHNvdXJjZTogW2FTcmMsIGJTcmMsIGNTcmNdLFxuICAgICAgdGFyZ2V0OiBbYSwgYiwgY10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBxdWFkIChwb2ludHMgaW4gY2xvY2std2lzZSBvcmRlcikgdG8gdGhlIHRyaWFuZ3VsYXRpb25cbiAgICogKGFuZCByZXByb2plY3RzIHRoZSB2ZXJ0aWNlcykgaWYgdmFsaWQuXG4gICAqIFBlcmZvcm1zIHF1YWQgc3ViZGl2aXNpb24gaWYgbmVlZGVkIHRvIGluY3JlYXNlIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGEgVGhlIHRhcmdldCBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGQgVGhlIHRhcmdldCBkIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkU3JjIFRoZSBzb3VyY2UgZCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3ViZGl2aXNpb24gTWF4aW1hbCBhbGxvd2VkIHN1YmRpdmlzaW9uIG9mIHRoZSBxdWFkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkUXVhZF8oYSwgYiwgYywgZCwgYVNyYywgYlNyYywgY1NyYywgZFNyYywgbWF4U3ViZGl2aXNpb24pIHtcbiAgICBjb25zdCBzb3VyY2VRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2FTcmMsIGJTcmMsIGNTcmMsIGRTcmNdKTtcbiAgICBjb25zdCBzb3VyY2VDb3ZlcmFnZVggPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfXG4gICAgICA/IGdldFdpZHRoKHNvdXJjZVF1YWRFeHRlbnQpIC8gdGhpcy5zb3VyY2VXb3JsZFdpZHRoX1xuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHNvdXJjZVdvcmxkV2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuc291cmNlV29ybGRXaWR0aF8pO1xuXG4gICAgLy8gd2hlbiB0aGUgcXVhZCBpcyB3cmFwcGVkIGluIHRoZSBzb3VyY2UgcHJvamVjdGlvblxuICAgIC8vIGl0IGNvdmVycyBtb3N0IG9mIHRoZSBwcm9qZWN0aW9uIGV4dGVudCwgYnV0IG5vdCBmdWxseVxuICAgIGNvbnN0IHdyYXBzWCA9XG4gICAgICB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgIHNvdXJjZUNvdmVyYWdlWCA+IDAuNSAmJlxuICAgICAgc291cmNlQ292ZXJhZ2VYIDwgMTtcblxuICAgIGxldCBuZWVkc1N1YmRpdmlzaW9uID0gZmFsc2U7XG5cbiAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXRQcm9qXy5pc0dsb2JhbCgpICYmIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0UXVhZEV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KFthLCBiLCBjLCBkXSk7XG4gICAgICAgIGNvbnN0IHRhcmdldENvdmVyYWdlWCA9XG4gICAgICAgICAgZ2V0V2lkdGgodGFyZ2V0UXVhZEV4dGVudCkgLyB0aGlzLnRhcmdldFdvcmxkV2lkdGhfO1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID1cbiAgICAgICAgICB0YXJnZXRDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEggfHwgbmVlZHNTdWJkaXZpc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmICghd3JhcHNYICYmIHRoaXMuc291cmNlUHJval8uaXNHbG9iYWwoKSAmJiBzb3VyY2VDb3ZlcmFnZVgpIHtcbiAgICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9XG4gICAgICAgICAgc291cmNlQ292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIIHx8IG5lZWRzU3ViZGl2aXNpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uICYmIHRoaXMubWF4U291cmNlRXh0ZW50Xykge1xuICAgICAgaWYgKFxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzBdKSAmJlxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzFdKSAmJlxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzJdKSAmJlxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzNdKVxuICAgICAgKSB7XG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhzb3VyY2VRdWFkRXh0ZW50LCB0aGlzLm1heFNvdXJjZUV4dGVudF8pKSB7XG4gICAgICAgICAgLy8gd2hvbGUgcXVhZCBvdXRzaWRlIHNvdXJjZSBwcm9qZWN0aW9uIGV4dGVudCAtPiBpZ25vcmVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaXNOb3RGaW5pdGUgPSAwO1xuXG4gICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpc0Zpbml0ZShhU3JjWzBdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYVNyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGJTcmNbMF0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShiU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoY1NyY1swXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGNTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShkU3JjWzBdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoZFNyY1sxXSlcbiAgICAgICkge1xuICAgICAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdGhlIGNhc2UgdGhhdCBvbmx5IDEgb2YgdGhlIHBvaW50cyBpcyBpbmZpbml0ZS4gSW4gdGhpcyBjYXNlXG4gICAgICAgICAgLy8gd2UgY2FuIGRyYXcgYSBzaW5nbGUgdHJpYW5nbGUgd2l0aCB0aGUgb3RoZXIgdGhyZWUgcG9pbnRzXG4gICAgICAgICAgaXNOb3RGaW5pdGUgPVxuICAgICAgICAgICAgKCFpc0Zpbml0ZShhU3JjWzBdKSB8fCAhaXNGaW5pdGUoYVNyY1sxXSkgPyA4IDogMCkgK1xuICAgICAgICAgICAgKCFpc0Zpbml0ZShiU3JjWzBdKSB8fCAhaXNGaW5pdGUoYlNyY1sxXSkgPyA0IDogMCkgK1xuICAgICAgICAgICAgKCFpc0Zpbml0ZShjU3JjWzBdKSB8fCAhaXNGaW5pdGUoY1NyY1sxXSkgPyAyIDogMCkgK1xuICAgICAgICAgICAgKCFpc0Zpbml0ZShkU3JjWzBdKSB8fCAhaXNGaW5pdGUoZFNyY1sxXSkgPyAxIDogMCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gMSAmJlxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gMiAmJlxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gNCAmJlxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gOFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICAgIGlmICghbmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBbKGFbMF0gKyBjWzBdKSAvIDIsIChhWzFdICsgY1sxXSkgLyAyXTtcbiAgICAgICAgY29uc3QgY2VudGVyU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNlbnRlcik7XG5cbiAgICAgICAgbGV0IGR4O1xuICAgICAgICBpZiAod3JhcHNYKSB7XG4gICAgICAgICAgY29uc3QgY2VudGVyU3JjRXN0aW1YID1cbiAgICAgICAgICAgIChtb2R1bG8oYVNyY1swXSwgc291cmNlV29ybGRXaWR0aCkgK1xuICAgICAgICAgICAgICBtb2R1bG8oY1NyY1swXSwgc291cmNlV29ybGRXaWR0aCkpIC9cbiAgICAgICAgICAgIDI7XG4gICAgICAgICAgZHggPSBjZW50ZXJTcmNFc3RpbVggLSBtb2R1bG8oY2VudGVyU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeCA9IChhU3JjWzBdICsgY1NyY1swXSkgLyAyIC0gY2VudGVyU3JjWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR5ID0gKGFTcmNbMV0gKyBjU3JjWzFdKSAvIDIgLSBjZW50ZXJTcmNbMV07XG4gICAgICAgIGNvbnN0IGNlbnRlclNyY0Vycm9yU3F1YXJlZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gY2VudGVyU3JjRXJyb3JTcXVhcmVkID4gdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGFbMF0gLSBjWzBdKSA8PSBNYXRoLmFicyhhWzFdIC0gY1sxXSkpIHtcbiAgICAgICAgICAvLyBzcGxpdCBob3Jpem9udGFsbHkgKHRvcCAmIGJvdHRvbSlcbiAgICAgICAgICBjb25zdCBiYyA9IFsoYlswXSArIGNbMF0pIC8gMiwgKGJbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGJjU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGJjKTtcbiAgICAgICAgICBjb25zdCBkYSA9IFsoZFswXSArIGFbMF0pIC8gMiwgKGRbMV0gKyBhWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGRhU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRhKTtcblxuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGJjLFxuICAgICAgICAgICAgZGEsXG4gICAgICAgICAgICBhU3JjLFxuICAgICAgICAgICAgYlNyYyxcbiAgICAgICAgICAgIGJjU3JjLFxuICAgICAgICAgICAgZGFTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBkYSxcbiAgICAgICAgICAgIGJjLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkYVNyYyxcbiAgICAgICAgICAgIGJjU3JjLFxuICAgICAgICAgICAgY1NyYyxcbiAgICAgICAgICAgIGRTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNwbGl0IHZlcnRpY2FsbHkgKGxlZnQgJiByaWdodClcbiAgICAgICAgICBjb25zdCBhYiA9IFsoYVswXSArIGJbMF0pIC8gMiwgKGFbMV0gKyBiWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGFiU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGFiKTtcbiAgICAgICAgICBjb25zdCBjZCA9IFsoY1swXSArIGRbMF0pIC8gMiwgKGNbMV0gKyBkWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGNkU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNkKTtcblxuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYWIsXG4gICAgICAgICAgICBjZCxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBhU3JjLFxuICAgICAgICAgICAgYWJTcmMsXG4gICAgICAgICAgICBjZFNyYyxcbiAgICAgICAgICAgIGRTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhYixcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgY2QsXG4gICAgICAgICAgICBhYlNyYyxcbiAgICAgICAgICAgIGJTcmMsXG4gICAgICAgICAgICBjU3JjLFxuICAgICAgICAgICAgY2RTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod3JhcHNYKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuV3JhcFhJblNvdXJjZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEV4YWN0bHkgemVybyBvciBvbmUgb2YgKlNyYyBpcyBub3QgZmluaXRlXG4gICAgLy8gVGhlIHRyaWFuZ2xlcyBtdXN0IGhhdmUgdGhlIGRpYWdvbmFsIGxpbmUgYXMgdGhlIGZpcnN0IHNpZGVcbiAgICAvLyBUaGlzIGlzIHRvIGFsbG93IGVhc3kgY29kZSBpbiByZXByb2oucyB0byBtYWtlIGl0IHN0cmFpZ2h0IGZvciBicm9rZW5cbiAgICAvLyBicm93c2VycyB0aGF0IGNhbid0IGhhbmRsZSBkaWFnb25hbCBjbGlwcGluZ1xuICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGIpID09IDApIHtcbiAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGMsIGQsIGFTcmMsIGNTcmMsIGRTcmMpO1xuICAgIH1cbiAgICBpZiAoKGlzTm90RmluaXRlICYgMHhlKSA9PSAwKSB7XG4gICAgICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBjLCBiLCBhU3JjLCBjU3JjLCBiU3JjKTtcbiAgICB9XG4gICAgaWYgKGlzTm90RmluaXRlKSB7XG4gICAgICAvLyBUcnkgdGhlIG90aGVyIHR3byB0cmlhbmdsZXNcbiAgICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGQpID09IDApIHtcbiAgICAgICAgdGhpcy5hZGRUcmlhbmdsZV8oYiwgZCwgYSwgYlNyYywgZFNyYywgYVNyYyk7XG4gICAgICB9XG4gICAgICBpZiAoKGlzTm90RmluaXRlICYgMHg3KSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGIsIGQsIGMsIGJTcmMsIGRTcmMsIGNTcmMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGV4dGVudCBvZiB0aGUgYHNvdXJjZWAgY29vcmRpbmF0ZXMgZnJvbSBhbGwgdGhlIHRyaWFuZ2xlcy5cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gQ2FsY3VsYXRlZCBleHRlbnQuXG4gICAqL1xuICBjYWxjdWxhdGVTb3VyY2VFeHRlbnQoKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBjb25zdCBzcmMgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzBdKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMV0pO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1syXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PFRyaWFuZ2xlPn0gQXJyYXkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJpYW5nbGVzLlxuICAgKi9cbiAgZ2V0VHJpYW5nbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnRyaWFuZ2xlc187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJpYW5ndWxhdGlvbjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qXG4gKi9cbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlRW1wdHksXG4gIGV4dGVuZCxcbiAgZm9yRWFjaENvcm5lcixcbiAgZ2V0Q2VudGVyLFxuICBnZXRIZWlnaHQsXG4gIGdldFRvcExlZnQsXG4gIGdldFdpZHRoLFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRCwgcmVsZWFzZUNhbnZhc30gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtnZXRQb2ludFJlc29sdXRpb24sIHRyYW5zZm9ybX0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7c29sdmVMaW5lYXJTeXN0ZW19IGZyb20gJy4vbWF0aC5qcyc7XG5cbmxldCBicm9rZW5EaWFnb25hbFJlbmRlcmluZ187XG5cbi8qKlxuICogQHR5cGUge0FycmF5PEhUTUxDYW52YXNFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbnZhc1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBUaGlzIGRyYXdzIGEgc21hbGwgdHJpYW5nbGUgaW50byBhIGNhbnZhcyBieSBzZXR0aW5nIHRoZSB0cmlhbmdsZSBhcyB0aGUgY2xpcCByZWdpb25cbiAqIGFuZCB0aGVuIGRyYXdpbmcgYSAodG9vIGxhcmdlKSByZWN0YW5nbGVcbiAqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGRyYXcgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gdTEgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LiBUaGUgZmlyc3QgcG9pbnQgaXMgMCwwLlxuICogQHBhcmFtIHtudW1iZXJ9IHYxIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1MiBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0aGlyZCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2MiBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSB0aGlyZCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gZHJhd1Rlc3RUcmlhbmdsZShjdHgsIHUxLCB2MSwgdTIsIHYyKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgY3R4LmxpbmVUbyh1MSwgdjEpO1xuICBjdHgubGluZVRvKHUyLCB2Mik7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmNsaXAoKTtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIE1hdGgubWF4KHUxLCB1MikgKyAxLCBNYXRoLm1heCh2MSwgdjIpKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgZGF0YSBmcm9tIGdldEltYWdlRGF0YSwgc2VlIGlmIHRoZSByaWdodCB2YWx1ZXMgYXBwZWFyIGF0IHRoZSBwcm92aWRlZCBvZmZzZXQuXG4gKiBSZXR1cm5zIHRydWUgaWYgZWl0aGVyIHRoZSBjb2xvciBvciB0cmFuc3BhcmVuY3kgaXMgb2ZmXG4gKlxuICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheX0gZGF0YSBUaGUgZGF0YSByZXR1cm5lZCBmcm9tIGdldEltYWdlRGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgcGl4ZWwgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIGRhdGEuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBkaWFnb25hbCByZW5kZXJpbmcgaXMgYnJva2VuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeUJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKGRhdGEsIG9mZnNldCkge1xuICAvLyB0aGUgdmFsdWVzIG91Z2h0IHRvIGJlIGNsb3NlIHRvIHRoZSByZ2JhKDIxMCwgMCwgMCwgMC43NSlcbiAgcmV0dXJuIChcbiAgICBNYXRoLmFicyhkYXRhW29mZnNldCAqIDRdIC0gMjEwKSA+IDIgfHxcbiAgICBNYXRoLmFicyhkYXRhW29mZnNldCAqIDQgKyAzXSAtIDAuNzUgKiAyNTUpID4gMlxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBjb25maWd1cmF0aW9uIGNhbiByZW5kZXIgdHJpYW5ndWxhciBjbGlwIHJlZ2lvbnMgY29ycmVjdGx5LlxuICogVGhpcyB2YWx1ZSBpcyBjYWNoZWQgc28gdGhlIGZ1bmN0aW9uIGlzIG9ubHkgZXhwZW5zaXZlIHRoZSBmaXJzdCB0aW1lIGNhbGxlZC5cbiAqIEZpcmVmb3ggb24gV2luZG93cyAoYXMgb2Ygbm93KSBkb2VzIG5vdCBpZiBIV0EgaXMgZW5hYmxlZC4gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MDY5NzZcbiAqIENocm9tZSB3b3JrcywgYW5kIGV2ZXJ5dGhpbmcgc2VlbXMgdG8gd29yayBvbiBPU1ggYW5kIEFuZHJvaWQuIFRoaXMgZnVuY3Rpb24gY2FjaGVzIHRoZVxuICogcmVzdWx0LiBJIHN1cHBvc2UgdGhhdCBpdCBpcyBjb25jZWl2YWJseSBwb3NzaWJsZSB0aGF0IGEgYnJvd3NlciBtaWdodCBmbGlwIG1vZGVzIHdoaWxlIHRoZSBhcHAgaXNcbiAqIHJ1bm5pbmcsIGJ1dCBsZXRzIGhvcGUgbm90LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIERpYWdvbmFsIFJlbmRlcmluZyBpcyBicm9rZW4uXG4gKi9cbmZ1bmN0aW9uIGlzQnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoKSB7XG4gIGlmIChicm9rZW5EaWFnb25hbFJlbmRlcmluZ18gPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCg2LCA2LCBjYW52YXNQb29sKTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2xpZ2h0ZXInO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyMTAsIDAsIDAsIDAuNzUpJztcbiAgICBkcmF3VGVzdFRyaWFuZ2xlKGN0eCwgNCwgNSwgNCwgMCk7XG4gICAgZHJhd1Rlc3RUcmlhbmdsZShjdHgsIDQsIDUsIDAsIDUpO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDMsIDMpLmRhdGE7XG4gICAgYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfID1cbiAgICAgIHZlcmlmeUJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKGRhdGEsIDApIHx8XG4gICAgICB2ZXJpZnlCcm9rZW5EaWFnb25hbFJlbmRlcmluZyhkYXRhLCA0KSB8fFxuICAgICAgdmVyaWZ5QnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoZGF0YSwgOCk7XG4gICAgcmVsZWFzZUNhbnZhcyhjdHgpO1xuICAgIGNhbnZhc1Bvb2wucHVzaChjdHguY2FudmFzKTtcbiAgfVxuXG4gIHJldHVybiBicm9rZW5EaWFnb25hbFJlbmRlcmluZ187XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpZGVhbCByZXNvbHV0aW9uIHRvIHVzZSBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICogcGl4ZWwgbWFwcGluZyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byAxOjEgZHVyaW5nIHJlcHJvamVjdGlvbi5cbiAqIFRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgcmVnYXJkbGVzcyBvZiB3aGF0IHJlc29sdXRpb25zXG4gKiBhcmUgYWN0dWFsbHkgYXZhaWxhYmxlIGluIHRoZSBkYXRhc2V0IChUaWxlR3JpZCwgSW1hZ2UsIC4uLikuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdGFyZ2V0Q2VudGVyIFRhcmdldCBjZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJlc3QgcmVzb2x1dGlvbiB0byB1c2UuIENhbiBiZSArLUluZmluaXR5LCBOYU4gb3IgMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24oXG4gIHNvdXJjZVByb2osXG4gIHRhcmdldFByb2osXG4gIHRhcmdldENlbnRlcixcbiAgdGFyZ2V0UmVzb2x1dGlvblxuKSB7XG4gIGNvbnN0IHNvdXJjZUNlbnRlciA9IHRyYW5zZm9ybSh0YXJnZXRDZW50ZXIsIHRhcmdldFByb2osIHNvdXJjZVByb2opO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgaWRlYWwgcmVzb2x1dGlvbiBvZiB0aGUgc291cmNlIGRhdGFcbiAgbGV0IHNvdXJjZVJlc29sdXRpb24gPSBnZXRQb2ludFJlc29sdXRpb24oXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRSZXNvbHV0aW9uLFxuICAgIHRhcmdldENlbnRlclxuICApO1xuXG4gIGNvbnN0IHRhcmdldE1ldGVyc1BlclVuaXQgPSB0YXJnZXRQcm9qLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgaWYgKHRhcmdldE1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVJlc29sdXRpb24gKj0gdGFyZ2V0TWV0ZXJzUGVyVW5pdDtcbiAgfVxuICBjb25zdCBzb3VyY2VNZXRlcnNQZXJVbml0ID0gc291cmNlUHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmIChzb3VyY2VNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uIC89IHNvdXJjZU1ldGVyc1BlclVuaXQ7XG4gIH1cblxuICAvLyBCYXNlZCBvbiB0aGUgcHJvamVjdGlvbiBwcm9wZXJ0aWVzLCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBhdCB0aGUgc3BlY2lmaWVkXG4gIC8vIGNvb3JkaW5hdGVzIG1heSBiZSBzbGlnaHRseSBkaWZmZXJlbnQuIFdlIG5lZWQgdG8gcmV2ZXJzZS1jb21wZW5zYXRlIHRoaXNcbiAgLy8gaW4gb3JkZXIgdG8gYWNoaWV2ZSBvcHRpbWFsIHJlc3VsdHMuXG5cbiAgY29uc3Qgc291cmNlRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgaWYgKCFzb3VyY2VFeHRlbnQgfHwgY29udGFpbnNDb29yZGluYXRlKHNvdXJjZUV4dGVudCwgc291cmNlQ2VudGVyKSkge1xuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkZhY3RvciA9XG4gICAgICBnZXRQb2ludFJlc29sdXRpb24oc291cmNlUHJvaiwgc291cmNlUmVzb2x1dGlvbiwgc291cmNlQ2VudGVyKSAvXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uO1xuICAgIGlmIChpc0Zpbml0ZShjb21wZW5zYXRpb25GYWN0b3IpICYmIGNvbXBlbnNhdGlvbkZhY3RvciA+IDApIHtcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gLz0gY29tcGVuc2F0aW9uRmFjdG9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2VSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgaWRlYWwgcmVzb2x1dGlvbiB0byB1c2UgZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGFjaGlldmVcbiAqIHBpeGVsIG1hcHBpbmcgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gMToxIGR1cmluZyByZXByb2plY3Rpb24uXG4gKiBUaGUgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkIHJlZ2FyZGxlc3Mgb2Ygd2hhdCByZXNvbHV0aW9uc1xuICogYXJlIGFjdHVhbGx5IGF2YWlsYWJsZSBpbiB0aGUgZGF0YXNldCAoVGlsZUdyaWQsIEltYWdlLCAuLi4pLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudFxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiZXN0IHJlc29sdXRpb24gdG8gdXNlLiBDYW4gYmUgKy1JbmZpbml0eSwgTmFOIG9yIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTb3VyY2VFeHRlbnRSZXNvbHV0aW9uKFxuICBzb3VyY2VQcm9qLFxuICB0YXJnZXRQcm9qLFxuICB0YXJnZXRFeHRlbnQsXG4gIHRhcmdldFJlc29sdXRpb25cbikge1xuICBjb25zdCB0YXJnZXRDZW50ZXIgPSBnZXRDZW50ZXIodGFyZ2V0RXh0ZW50KTtcbiAgbGV0IHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICAgIHNvdXJjZVByb2osXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRDZW50ZXIsXG4gICAgdGFyZ2V0UmVzb2x1dGlvblxuICApO1xuXG4gIGlmICghaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgfHwgc291cmNlUmVzb2x1dGlvbiA8PSAwKSB7XG4gICAgZm9yRWFjaENvcm5lcih0YXJnZXRFeHRlbnQsIGZ1bmN0aW9uIChjb3JuZXIpIHtcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICAgICAgICBzb3VyY2VQcm9qLFxuICAgICAgICB0YXJnZXRQcm9qLFxuICAgICAgICBjb3JuZXIsXG4gICAgICAgIHRhcmdldFJlc29sdXRpb25cbiAgICAgICk7XG4gICAgICByZXR1cm4gaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgJiYgc291cmNlUmVzb2x1dGlvbiA+IDA7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlUmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbWFnZUV4dGVudFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gaW1hZ2UgSW1hZ2UuXG4gKi9cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzb3VyY2UgZGF0YSBpbnRvIG5ldyBjYW52YXMgYmFzZWQgb24gdGhlIHRyaWFuZ3VsYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gc291cmNlUmVzb2x1dGlvbiBTb3VyY2UgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBzb3VyY2VFeHRlbnQgRXh0ZW50IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzXCIpLmRlZmF1bHR9IHRyaWFuZ3VsYXRpb24gQ2FsY3VsYXRlZCB0cmlhbmd1bGF0aW9uLlxuICogQHBhcmFtIHtBcnJheTxJbWFnZUV4dGVudD59IHNvdXJjZXMgQXJyYXkgb2Ygc291cmNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2VzLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVuZGVyRWRnZXNdIFJlbmRlciByZXByb2plY3Rpb24gZWRnZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZV0gVXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdoZW4gcmVzYW1wbGluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RyYXdTaW5nbGVdIERyYXcgc2luZ2xlIHNvdXJjZSBpbWFnZXMgZGlyZWN0bHkgd2l0aG91dCBzdGl0Y2hDb250ZXh0LlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcyB3aXRoIHJlcHJvamVjdGVkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIoXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIHBpeGVsUmF0aW8sXG4gIHNvdXJjZVJlc29sdXRpb24sXG4gIHNvdXJjZUV4dGVudCxcbiAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgdGFyZ2V0RXh0ZW50LFxuICB0cmlhbmd1bGF0aW9uLFxuICBzb3VyY2VzLFxuICBndXR0ZXIsXG4gIHJlbmRlckVkZ2VzLFxuICBpbnRlcnBvbGF0ZSxcbiAgZHJhd1NpbmdsZVxuKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogd2lkdGgpLFxuICAgIE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIGhlaWdodCksXG4gICAgY2FudmFzUG9vbFxuICApO1xuXG4gIGlmICghaW50ZXJwb2xhdGUpIHtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xuICB9XG5cbiAgY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblxuICBmdW5jdGlvbiBwaXhlbFJvdW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gIH1cblxuICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdsaWdodGVyJztcblxuICBjb25zdCBzb3VyY2VEYXRhRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMsIGksIGFycikge1xuICAgIGV4dGVuZChzb3VyY2VEYXRhRXh0ZW50LCBzcmMuZXh0ZW50KTtcbiAgfSk7XG5cbiAgbGV0IHN0aXRjaENvbnRleHQ7XG4gIGlmICghZHJhd1NpbmdsZSB8fCBzb3VyY2VzLmxlbmd0aCAhPT0gMSB8fCBndXR0ZXIgIT09IDApIHtcbiAgICBjb25zdCBjYW52YXNXaWR0aEluVW5pdHMgPSBnZXRXaWR0aChzb3VyY2VEYXRhRXh0ZW50KTtcbiAgICBjb25zdCBjYW52YXNIZWlnaHRJblVuaXRzID0gZ2V0SGVpZ2h0KHNvdXJjZURhdGFFeHRlbnQpO1xuICAgIHN0aXRjaENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICBNYXRoLnJvdW5kKChwaXhlbFJhdGlvICogY2FudmFzV2lkdGhJblVuaXRzKSAvIHNvdXJjZVJlc29sdXRpb24pLFxuICAgICAgTWF0aC5yb3VuZCgocGl4ZWxSYXRpbyAqIGNhbnZhc0hlaWdodEluVW5pdHMpIC8gc291cmNlUmVzb2x1dGlvbiksXG4gICAgICBjYW52YXNQb29sXG4gICAgKTtcblxuICAgIGlmICghaW50ZXJwb2xhdGUpIHtcbiAgICAgIHN0aXRjaENvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RpdGNoU2NhbGUgPSBwaXhlbFJhdGlvIC8gc291cmNlUmVzb2x1dGlvbjtcblxuICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc3JjLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHhQb3MgPSBzcmMuZXh0ZW50WzBdIC0gc291cmNlRGF0YUV4dGVudFswXTtcbiAgICAgIGNvbnN0IHlQb3MgPSAtKHNyYy5leHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKTtcbiAgICAgIGNvbnN0IHNyY1dpZHRoID0gZ2V0V2lkdGgoc3JjLmV4dGVudCk7XG4gICAgICBjb25zdCBzcmNIZWlnaHQgPSBnZXRIZWlnaHQoc3JjLmV4dGVudCk7XG5cbiAgICAgIC8vIFRoaXMgdGVzdCBzaG91bGQgbmV2ZXIgZmFpbCAtLSBidXQgaXQgZG9lcy4gTmVlZCB0byBmaW5kIGEgZml4IHRoZSB1cHN0cmVhbSBjb25kaXRpb25cbiAgICAgIGlmIChzcmMuaW1hZ2Uud2lkdGggPiAwICYmIHNyYy5pbWFnZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHN0aXRjaENvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgIHNyYy5pbWFnZSxcbiAgICAgICAgICBndXR0ZXIsXG4gICAgICAgICAgZ3V0dGVyLFxuICAgICAgICAgIHNyYy5pbWFnZS53aWR0aCAtIDIgKiBndXR0ZXIsXG4gICAgICAgICAgc3JjLmltYWdlLmhlaWdodCAtIDIgKiBndXR0ZXIsXG4gICAgICAgICAgeFBvcyAqIHN0aXRjaFNjYWxlLFxuICAgICAgICAgIHlQb3MgKiBzdGl0Y2hTY2FsZSxcbiAgICAgICAgICBzcmNXaWR0aCAqIHN0aXRjaFNjYWxlLFxuICAgICAgICAgIHNyY0hlaWdodCAqIHN0aXRjaFNjYWxlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VG9wTGVmdCA9IGdldFRvcExlZnQodGFyZ2V0RXh0ZW50KTtcblxuICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24gKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAvKiBDYWxjdWxhdGUgYWZmaW5lIHRyYW5zZm9ybSAoc3JjIC0+IGRzdClcbiAgICAgKiBSZXN1bHRpbmcgbWF0cml4IGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZGluYXRlXG4gICAgICogZnJvbSBgc291cmNlUHJvamVjdGlvbmAgdG8gZGVzdGluYXRpb24gcGl4ZWxzLlxuICAgICAqXG4gICAgICogVG8gb3B0aW1pemUgbnVtYmVyIG9mIGNvbnRleHQgY2FsbHMgYW5kIGluY3JlYXNlIG51bWVyaWNhbCBzdGFiaWxpdHksXG4gICAgICogd2UgYWxzbyBkbyB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gICAgICogdHJhbnMoLXRvcExlZnRFeHRlbnRDb3JuZXIpLCBzY2FsZSgxIC8gdGFyZ2V0UmVzb2x1dGlvbiksIHNjYWxlKDEsIC0xKVxuICAgICAqIGhlcmUgYmVmb3JlIHNvbHZpbmcgdGhlIGxpbmVhciBzeXN0ZW0gc28gW3VpLCB2aV0gYXJlIHBpeGVsIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogU3JjIHBvaW50czogeGksIHlpXG4gICAgICogRHN0IHBvaW50czogdWksIHZpXG4gICAgICogQWZmaW5lIGNvZWZmaWNpZW50czogYWlqXG4gICAgICpcbiAgICAgKiB8IHgwIHkwIDEgIDAgIDAgMCB8ICAgfGEwMHwgICB8dTB8XG4gICAgICogfCB4MSB5MSAxICAwICAwIDAgfCAgIHxhMDF8ICAgfHUxfFxuICAgICAqIHwgeDIgeTIgMSAgMCAgMCAwIHwgeCB8YTAyfCA9IHx1MnxcbiAgICAgKiB8ICAwICAwIDAgeDAgeTAgMSB8ICAgfGExMHwgICB8djB8XG4gICAgICogfCAgMCAgMCAwIHgxIHkxIDEgfCAgIHxhMTF8ICAgfHYxfFxuICAgICAqIHwgIDAgIDAgMCB4MiB5MiAxIHwgICB8YTEyfCAgIHx2MnxcbiAgICAgKi9cbiAgICBjb25zdCBzb3VyY2UgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgY29uc3QgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgIGxldCB4MCA9IHNvdXJjZVswXVswXSxcbiAgICAgIHkwID0gc291cmNlWzBdWzFdO1xuICAgIGxldCB4MSA9IHNvdXJjZVsxXVswXSxcbiAgICAgIHkxID0gc291cmNlWzFdWzFdO1xuICAgIGxldCB4MiA9IHNvdXJjZVsyXVswXSxcbiAgICAgIHkyID0gc291cmNlWzJdWzFdO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgb24gcGl4ZWwgYm91bmRhcmllc1xuICAgIGNvbnN0IHUwID0gcGl4ZWxSb3VuZCgodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uKTtcbiAgICBjb25zdCB2MCA9IHBpeGVsUm91bmQoXG4gICAgICAtKHRhcmdldFswXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvblxuICAgICk7XG4gICAgY29uc3QgdTEgPSBwaXhlbFJvdW5kKCh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb24pO1xuICAgIGNvbnN0IHYxID0gcGl4ZWxSb3VuZChcbiAgICAgIC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uXG4gICAgKTtcbiAgICBjb25zdCB1MiA9IHBpeGVsUm91bmQoKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbik7XG4gICAgY29uc3QgdjIgPSBwaXhlbFJvdW5kKFxuICAgICAgLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb25cbiAgICApO1xuXG4gICAgLy8gU2hpZnQgYWxsIHRoZSBzb3VyY2UgcG9pbnRzIHRvIGltcHJvdmUgbnVtZXJpY2FsIHN0YWJpbGl0eVxuICAgIC8vIG9mIGFsbCB0aGUgc3Vic2VxdWVudCBjYWxjdWxhdGlvbnMuIFRoZSBbeDAsIHkwXSBpcyB1c2VkIGhlcmUuXG4gICAgLy8gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2ltcGxpZnkgdGhlIGxpbmVhciBzeXN0ZW0uXG4gICAgY29uc3Qgc291cmNlTnVtZXJpY2FsU2hpZnRYID0geDA7XG4gICAgY29uc3Qgc291cmNlTnVtZXJpY2FsU2hpZnRZID0geTA7XG4gICAgeDAgPSAwO1xuICAgIHkwID0gMDtcbiAgICB4MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFg7XG4gICAgeTEgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRZO1xuICAgIHgyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MiAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG5cbiAgICBjb25zdCBhdWdtZW50ZWRNYXRyaXggPSBbXG4gICAgICBbeDEsIHkxLCAwLCAwLCB1MSAtIHUwXSxcbiAgICAgIFt4MiwgeTIsIDAsIDAsIHUyIC0gdTBdLFxuICAgICAgWzAsIDAsIHgxLCB5MSwgdjEgLSB2MF0sXG4gICAgICBbMCwgMCwgeDIsIHkyLCB2MiAtIHYwXSxcbiAgICBdO1xuICAgIGNvbnN0IGFmZmluZUNvZWZzID0gc29sdmVMaW5lYXJTeXN0ZW0oYXVnbWVudGVkTWF0cml4KTtcbiAgICBpZiAoIWFmZmluZUNvZWZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChpc0Jyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKCkgfHwgIWludGVycG9sYXRlKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhbGwgbGluZXMgYXJlIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBkaWFnb25hbCBsaW5lLiBEbyBpdCBpbiA0IHN0ZXBzXG4gICAgICBjb25zdCBzdGVwcyA9IDQ7XG4gICAgICBjb25zdCB1ZCA9IHUwIC0gdTE7XG4gICAgICBjb25zdCB2ZCA9IHYwIC0gdjE7XG4gICAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IHN0ZXBzOyBzdGVwKyspIHtcbiAgICAgICAgLy8gR28gaG9yaXpvbnRhbGx5XG4gICAgICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgICAgIHUxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHVkKSAvIHN0ZXBzKSxcbiAgICAgICAgICB2MSArIHBpeGVsUm91bmQoKHN0ZXAgKiB2ZCkgLyAoc3RlcHMgLSAxKSlcbiAgICAgICAgKTtcbiAgICAgICAgLy8gR28gdmVydGljYWxseVxuICAgICAgICBpZiAoc3RlcCAhPSBzdGVwcyAtIDEpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICAgIHUxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHVkKSAvIHN0ZXBzKSxcbiAgICAgICAgICAgIHYxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHZkKSAvIChzdGVwcyAtIDEpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFyZSBhbG1vc3QgYXQgdTByLCB2MHJcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MCwgdjApO1xuICAgICAgY29udGV4dC5saW5lVG8odTIsIHYyKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgIGNvbnRleHQudHJhbnNmb3JtKFxuICAgICAgYWZmaW5lQ29lZnNbMF0sXG4gICAgICBhZmZpbmVDb2Vmc1syXSxcbiAgICAgIGFmZmluZUNvZWZzWzFdLFxuICAgICAgYWZmaW5lQ29lZnNbM10sXG4gICAgICB1MCxcbiAgICAgIHYwXG4gICAgKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgc291cmNlRGF0YUV4dGVudFswXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WCxcbiAgICAgIHNvdXJjZURhdGFFeHRlbnRbM10gLSBzb3VyY2VOdW1lcmljYWxTaGlmdFlcbiAgICApO1xuXG4gICAgbGV0IGltYWdlO1xuICAgIGlmIChzdGl0Y2hDb250ZXh0KSB7XG4gICAgICBpbWFnZSA9IHN0aXRjaENvbnRleHQuY2FudmFzO1xuICAgICAgY29udGV4dC5zY2FsZShcbiAgICAgICAgc291cmNlUmVzb2x1dGlvbiAvIHBpeGVsUmF0aW8sXG4gICAgICAgIC1zb3VyY2VSZXNvbHV0aW9uIC8gcGl4ZWxSYXRpb1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1swXTtcbiAgICAgIGNvbnN0IGV4dGVudCA9IHNvdXJjZS5leHRlbnQ7XG4gICAgICBpbWFnZSA9IHNvdXJjZS5pbWFnZTtcbiAgICAgIGNvbnRleHQuc2NhbGUoXG4gICAgICAgIGdldFdpZHRoKGV4dGVudCkgLyBpbWFnZS53aWR0aCxcbiAgICAgICAgLWdldEhlaWdodChleHRlbnQpIC8gaW1hZ2UuaGVpZ2h0XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgaWYgKHN0aXRjaENvbnRleHQpIHtcbiAgICByZWxlYXNlQ2FudmFzKHN0aXRjaENvbnRleHQpO1xuICAgIGNhbnZhc1Bvb2wucHVzaChzdGl0Y2hDb250ZXh0LmNhbnZhcyk7XG4gIH1cblxuICBpZiAocmVuZGVyRWRnZXMpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG5cbiAgICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24gKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICAgIGNvbnN0IHUwID0gKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB1MSA9ICh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MSA9IC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjIgPSAtKHRhcmdldFsyXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MCwgdjApO1xuICAgICAgY29udGV4dC5saW5lVG8odTIsIHYyKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHJ1Y3RzL0xSVUNhY2hlXG4gKi9cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5XyBLZXkuXG4gKiBAcHJvcGVydHkge0VudHJ5fG51bGx9IG5ld2VyIE5ld2VyLlxuICogQHByb3BlcnR5IHtFbnRyeXxudWxsfSBvbGRlciBPbGRlci5cbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfIFZhbHVlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50cyBhIExlYXN0LVJlY2VudGx5LVVzZWQgY2FjaGUgd2hlcmUgdGhlIGtleXMgZG8gbm90IGNvbmZsaWN0IHdpdGhcbiAqIE9iamVjdCdzIHByb3BlcnRpZXMgKGUuZy4gJ2hhc093blByb3BlcnR5JyBpcyBub3QgYWxsb3dlZCBhcyBhIGtleSkuIEV4cGlyaW5nXG4gKiBpdGVtcyBmcm9tIHRoZSBjYWNoZSBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHVzZXIuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hpZ2hXYXRlck1hcmtdIEhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhpZ2hXYXRlck1hcmspIHtcbiAgICAvKipcbiAgICAgKiBEZXNpcmVkIG1heCBjYWNoZSBzaXplIGFmdGVyIGV4cGlyZUNhY2hlKCkuIElmIHNldCB0byAwLCBubyBjYWNoZSBlbnRyaWVzXG4gICAgICogd2lsbCBiZSBwcnVuZWQgYXQgYWxsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gaGlnaFdhdGVyTWFyayA6IDIwNDg7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb3VudF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEVudHJ5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmVudHJpZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RW50cnl9XG4gICAgICovXG4gICAgdGhpcy5vbGRlc3RfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBjYW5FeHBpcmVDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoV2F0ZXJNYXJrID4gMCAmJiB0aGlzLmdldENvdW50KCkgPiB0aGlzLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogRXhwaXJlIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IFtrZWVwXSBLZXlzIHRvIGtlZXAuIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMuXG4gICAqL1xuICBleHBpcmVDYWNoZShrZWVwKSB7XG4gICAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNvdW50XyA9IDA7XG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMga2V5LlxuICAgKi9cbiAgY29udGFpbnNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc18uaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsIHN0cmluZywgTFJVQ2FjaGU8VD4pOiA/fSBmIFRoZSBmdW5jdGlvblxuICAgKiAgICAgdG8gY2FsbCBmb3IgZXZlcnkgZW50cnkgZnJvbSB0aGUgb2xkZXN0IHRvIHRoZSBuZXdlci4gVGhpcyBmdW5jdGlvbiB0YWtlc1xuICAgKiAgICAgMyBhcmd1bWVudHMgKHRoZSBlbnRyeSB2YWx1ZSwgdGhlIGVudHJ5IGtleSBhbmQgdGhlIExSVUNhY2hlIG9iamVjdCkuXG4gICAqICAgICBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqL1xuICBmb3JFYWNoKGYpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBmKGVudHJ5LnZhbHVlXywgZW50cnkua2V5XywgdGhpcyk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3B0aW9ucyAocmVzZXJ2ZWQgZm9yIHN1YmNsYXNzZXMpLlxuICAgKiBAcmV0dXJuIHtUfSBWYWx1ZS5cbiAgICovXG4gIGdldChrZXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoXG4gICAgICBlbnRyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgJ1RyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZSdcbiAgICApO1xuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICAgIH1cbiAgICBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKHRoaXMub2xkZXN0Xy5uZXdlcik7XG4gICAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZW50cnkubmV3ZXIgPSBudWxsO1xuICAgIGVudHJ5Lm9sZGVyID0gdGhpcy5uZXdlc3RfO1xuICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBlbnRyeSBrZXkuXG4gICAqIEByZXR1cm4ge1R9IFRoZSByZW1vdmVkIGVudHJ5LlxuICAgKi9cbiAgcmVtb3ZlKGtleSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChcbiAgICAgIGVudHJ5ICE9PSB1bmRlZmluZWQsXG4gICAgICAnVHJpZWQgdG8gZ2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlJ1xuICAgICk7XG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLm5ld2VzdF8pIHtcbiAgICAgIHRoaXMubmV3ZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5vbGRlcik7XG4gICAgICBpZiAodGhpcy5uZXdlc3RfKSB7XG4gICAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbnRyeSA9PT0gdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgICAgaWYgKHRoaXMub2xkZXN0Xykge1xuICAgICAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZW50cmllc19ba2V5XTtcbiAgICAtLXRoaXMuY291bnRfO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBDb3VudC5cbiAgICovXG4gIGdldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvdW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBLZXlzLlxuICAgKi9cbiAgZ2V0S2V5cygpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KHRoaXMuY291bnRfKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGVudHJ5O1xuICAgIGZvciAoZW50cnkgPSB0aGlzLm5ld2VzdF87IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm9sZGVyKSB7XG4gICAgICBrZXlzW2krK10gPSBlbnRyeS5rZXlfO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn0gVmFsdWVzLlxuICAgKi9cbiAgZ2V0VmFsdWVzKCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLmNvdW50Xyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBlbnRyeTtcbiAgICBmb3IgKGVudHJ5ID0gdGhpcy5uZXdlc3RfOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5vbGRlcikge1xuICAgICAgdmFsdWVzW2krK10gPSBlbnRyeS52YWx1ZV87XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VH0gTGFzdCB2YWx1ZS5cbiAgICovXG4gIHBlZWtMYXN0KCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8udmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTGFzdCBrZXkuXG4gICAqL1xuICBwZWVrTGFzdEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5vbGRlc3RfLmtleV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBrZXkgb2YgdGhlIG5ld2VzdCBpdGVtIGluIHRoZSBjYWNoZS4gIFRocm93cyBpZiB0aGUgY2FjaGUgaXMgZW1wdHkuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5ld2VzdCBrZXkuXG4gICAqL1xuICBwZWVrRmlyc3RLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3ZXN0Xy5rZXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBlbnRyeSB3aXRob3V0IHVwZGF0aW5nIGxlYXN0IHJlY2VudGx5IHVzZWQgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBWYWx1ZS5cbiAgICovXG4gIHBlZWsoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc19ba2V5XT8udmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgcG9wKCkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2VudHJ5LmtleV9dO1xuICAgIGlmIChlbnRyeS5uZXdlcikge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgIGlmICghdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICAgIH1cbiAgICAtLXRoaXMuY291bnRfO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICByZXBsYWNlKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmdldChrZXkpOyAvLyB1cGRhdGUgYG5ld2VzdF9gXG4gICAgdGhpcy5lbnRyaWVzX1trZXldLnZhbHVlXyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoXG4gICAgICAhKGtleSBpbiB0aGlzLmVudHJpZXNfKSxcbiAgICAgICdUcmllZCB0byBzZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBpcyB1c2VkIGFscmVhZHknXG4gICAgKTtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGtleV86IGtleSxcbiAgICAgIG5ld2VyOiBudWxsLFxuICAgICAgb2xkZXI6IHRoaXMubmV3ZXN0XyxcbiAgICAgIHZhbHVlXzogdmFsdWUsXG4gICAgfTtcbiAgICBpZiAoIXRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gZW50cnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIH1cbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICB0aGlzLmVudHJpZXNfW2tleV0gPSBlbnRyeTtcbiAgICArK3RoaXMuY291bnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgZm9yIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQ2FjaGUgc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2l6ZShzaXplKSB7XG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gc2l6ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMUlVDYWNoZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWNvb3JkXG4gKi9cblxuLyoqXG4gKiBBbiBhcnJheSBvZiB0aHJlZSBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSB0aWxlIGluIGEgdGlsZVxuICogZ3JpZC4gVGhlIG9yZGVyIGlzIGB6YCAoem9vbSBsZXZlbCksIGB4YCAoY29sdW1uKSwgYW5kIGB5YCAocm93KS5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBUaWxlQ29vcmRcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSBbdGlsZUNvb3JkXSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtUaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKHosIHgsIHksIHRpbGVDb29yZCkge1xuICBpZiAodGlsZUNvb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aWxlQ29vcmRbMF0gPSB6O1xuICAgIHRpbGVDb29yZFsxXSA9IHg7XG4gICAgdGlsZUNvb3JkWzJdID0geTtcbiAgICByZXR1cm4gdGlsZUNvb3JkO1xuICB9XG4gIHJldHVybiBbeiwgeCwgeV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlaWFkoeiwgeCwgeSkge1xuICByZXR1cm4geiArICcvJyArIHggKyAnLycgKyB5O1xufVxuXG4vKipcbiAqIEdldCB0aGUga2V5IGZvciBhIHRpbGUgY29vcmQuXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRoZSB0aWxlIGNvb3JkLlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkodGlsZUNvb3JkKSB7XG4gIHJldHVybiBnZXRLZXlaWFkodGlsZUNvb3JkWzBdLCB0aWxlQ29vcmRbMV0sIHRpbGVDb29yZFsyXSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0aWxlIGNhY2hlIGtleSBmb3IgYSB0aWxlIGtleSBvYnRhaW5lZCB0aHJvdWdoIGB0aWxlLmdldEtleSgpYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlS2V5IFRoZSB0aWxlIGtleS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNhY2hlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlS2V5Rm9yVGlsZUtleSh0aWxlS2V5KSB7XG4gIGNvbnN0IFt6LCB4LCB5XSA9IHRpbGVLZXlcbiAgICAuc3Vic3RyaW5nKHRpbGVLZXkubGFzdEluZGV4T2YoJy8nKSArIDEsIHRpbGVLZXkubGVuZ3RoKVxuICAgIC5zcGxpdCgnLCcpXG4gICAgLm1hcChOdW1iZXIpO1xuICByZXR1cm4gZ2V0S2V5WlhZKHosIHgsIHkpO1xufVxuXG4vKipcbiAqIEdldCBhIHRpbGUgY29vcmQgZ2l2ZW4gYSBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSB0aWxlIGNvb3JkIGtleS5cbiAqIEByZXR1cm4ge1RpbGVDb29yZH0gVGhlIHRpbGUgY29vcmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnNwbGl0KCcvJykubWFwKE51bWJlcik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkLlxuICogQHJldHVybiB7bnVtYmVyfSBIYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaCh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuICh0aWxlQ29vcmRbMV0gPDwgdGlsZUNvb3JkWzBdKSArIHRpbGVDb29yZFsyXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7IWltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBjb29yZGluYXRlIGlzIHdpdGhpbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpIHtcbiAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgY29uc3QgeCA9IHRpbGVDb29yZFsxXTtcbiAgY29uc3QgeSA9IHRpbGVDb29yZFsyXTtcblxuICBpZiAodGlsZUdyaWQuZ2V0TWluWm9vbSgpID4geiB8fCB6ID4gdGlsZUdyaWQuZ2V0TWF4Wm9vbSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gIGlmICghdGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHRpbGVSYW5nZS5jb250YWluc1hZKHgsIHkpO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlQ2FjaGVcbiAqL1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4vc3RydWN0cy9MUlVDYWNoZS5qcyc7XG5pbXBvcnQge2Zyb21LZXksIGdldEtleX0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG5jbGFzcyBUaWxlQ2FjaGUgZXh0ZW5kcyBMUlVDYWNoZSB7XG4gIGNsZWFyKCkge1xuICAgIHdoaWxlICh0aGlzLmdldENvdW50KCkgPiAwKSB7XG4gICAgICB0aGlzLnBvcCgpLnJlbGVhc2UoKTtcbiAgICB9XG4gICAgc3VwZXIuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gdXNlZFRpbGVzIFVzZWQgdGlsZXMuXG4gICAqL1xuICBleHBpcmVDYWNoZSh1c2VkVGlsZXMpIHtcbiAgICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICBjb25zdCB0aWxlID0gdGhpcy5wZWVrTGFzdCgpO1xuICAgICAgaWYgKHRpbGUuZ2V0S2V5KCkgaW4gdXNlZFRpbGVzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3AoKS5yZWxlYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBydW5lIGFsbCB0aWxlcyBmcm9tIHRoZSBjYWNoZSB0aGF0IGRvbid0IGhhdmUgdGhlIHNhbWUgeiBhcyB0aGUgbmV3ZXN0IHRpbGUuXG4gICAqL1xuICBwcnVuZUV4Y2VwdE5ld2VzdFooKSB7XG4gICAgaWYgKHRoaXMuZ2V0Q291bnQoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLnBlZWtGaXJzdEtleSgpO1xuICAgIGNvbnN0IHRpbGVDb29yZCA9IGZyb21LZXkoa2V5KTtcbiAgICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICAgIHRoaXMuZm9yRWFjaCgodGlsZSkgPT4ge1xuICAgICAgaWYgKHRpbGUudGlsZUNvb3JkWzBdICE9PSB6KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGdldEtleSh0aWxlLnRpbGVDb29yZCkpO1xuICAgICAgICB0aWxlLnJlbGVhc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlQ2FjaGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgc3RhcnRzIGxvYWRpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGUuVGlsZVNvdXJjZUV2ZW50I3RpbGVsb2Fkc3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURTVEFSVDogJ3RpbGVsb2Fkc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgZmluaXNoZXMgbG9hZGluZywgZWl0aGVyIHdoZW4gaXRzIGRhdGEgaXMgbG9hZGVkLFxuICAgKiBvciB3aGVuIGxvYWRpbmcgd2FzIGFib3J0ZWQgYmVjYXVzZSB0aGUgdGlsZSBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BREVORDogJ3RpbGVsb2FkZW5kJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGlmIHRpbGUgbG9hZGluZyByZXN1bHRzIGluIGFuIGVycm9yLiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgdGhlXG4gICAqIHJpZ2h0IHBsYWNlIHRvIHJlLWZldGNoIHRpbGVzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC9JbWFnZVRpbGV+SW1hZ2VUaWxlI2xvYWR9XG4gICAqIGZvciBkZXRhaWxzLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FERVJST1I6ICd0aWxlbG9hZGVycm9yJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeyd0aWxlbG9hZHN0YXJ0J3wndGlsZWxvYWRlbmQnfCd0aWxlbG9hZGVycm9yJ30gVGlsZVNvdXJjZUV2ZW50VHlwZXNcbiAqL1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZVxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IFRpbGVDYWNoZSBmcm9tICcuLi9UaWxlQ2FjaGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnR9IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRLZXlaWFksIHdpdGhpbkV4dGVudEFuZFp9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge1xuICBnZXRGb3JQcm9qZWN0aW9uIGFzIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbixcbiAgd3JhcFgsXG59IGZyb20gJy4uL3RpbGVncmlkLmpzJztcbmltcG9ydCB7c2NhbGUgYXMgc2NhbGVTaXplLCB0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXMsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9UaWxlRXZlbnRUeXBlXCIpLlRpbGVTb3VyY2VFdmVudFR5cGVzLCBUaWxlU291cmNlRXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICBpbXBvcnQoXCIuL1RpbGVFdmVudFR5cGVcIikuVGlsZVNvdXJjZUV2ZW50VHlwZXMsIFJldHVybj59IFRpbGVTb3VyY2VPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gQ2FjaGVTaXplLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPWZhbHNlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXSBUaWxlUGl4ZWxSYXRpby5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGVdIFN0YXRlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGVHcmlkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXBYLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBUcmFuc2l0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldIEtleS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF0gWkRpcmVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPWZhbHNlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogdGhlIG5lYXJlc3QgbmVpZ2hib3IgaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyBpbWFnZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkLlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRpbGVTb3VyY2UgZXh0ZW5kcyBTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFNvdXJjZVRpbGUgc291cmNlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgIH0pO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtUaWxlU291cmNlT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VGlsZVNvdXJjZU9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VGlsZVNvdXJjZU9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3BhcXVlXyA9IG9wdGlvbnMub3BhcXVlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYXF1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW9fID1cbiAgICAgIG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6IG51bGw7XG5cbiAgICBjb25zdCB0aWxlU2l6ZSA9IFsyNTYsIDI1Nl07XG4gICAgaWYgKHRoaXMudGlsZUdyaWQpIHtcbiAgICAgIHRvU2l6ZSh0aGlzLnRpbGVHcmlkLmdldFRpbGVTaXplKHRoaXMudGlsZUdyaWQuZ2V0TWluWm9vbSgpKSwgdGlsZVNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZUNhY2hlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGUgPSBuZXcgVGlsZUNhY2hlKG9wdGlvbnMuY2FjaGVTaXplIHx8IDApO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50bXBTaXplID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5XyA9IG9wdGlvbnMua2V5IHx8ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLk9wdGlvbnN9XG4gICAgICovXG4gICAgdGhpcy50aWxlT3B0aW9ucyA9IHtcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB6RGlyZWN0aW9uIGhpbnQsIHJlYWQgYnkgdGhlIHJlbmRlcmVyLiBJbmRpY2F0ZXMgd2hpY2ggcmVzb2x1dGlvbiBzaG91bGQgYmUgdXNlZFxuICAgICAqIGJ5IGEgcmVuZGVyZXIgaWYgdGhlIHZpZXdzIHJlc29sdXRpb24gZG9lcyBub3QgbWF0Y2ggYW55IHJlc29sdXRpb24gb2YgdGhlIHRpbGUgc291cmNlLlxuICAgICAqIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAxLCB0aGUgbmVhcmVzdCBsb3dlciByZXNvbHV0aW9uXG4gICAgICogd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3QgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ8aW1wb3J0KFwiLi4vYXJyYXkuanNcIikuTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuekRpcmVjdGlvbiA9IG9wdGlvbnMuekRpcmVjdGlvbiA/IG9wdGlvbnMuekRpcmVjdGlvbiA6IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKi9cbiAgZXhwaXJlQ2FjaGUocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gICAgY29uc3QgdGlsZUNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmICh0aWxlQ2FjaGUpIHtcbiAgICAgIHRpbGVDYWNoZS5leHBpcmVDYWNoZSh1c2VkVGlsZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdCk6KGJvb2xlYW58dm9pZCl9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2hcbiAgICogICAgIGxvYWRlZCB0aWxlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgdGhlIHRpbGUgd2lsbCBub3QgYmVcbiAgICogICAgIGNvbnNpZGVyZWQgbG9hZGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSByYW5nZSBpcyBmdWxseSBjb3ZlcmVkIHdpdGggbG9hZGVkIHRpbGVzLlxuICAgKi9cbiAgZm9yRWFjaExvYWRlZFRpbGUocHJvamVjdGlvbiwgeiwgdGlsZVJhbmdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAoIXRpbGVDYWNoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjb3ZlcmVkID0gdHJ1ZTtcbiAgICBsZXQgdGlsZSwgdGlsZUNvb3JkS2V5LCBsb2FkZWQ7XG4gICAgZm9yIChsZXQgeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgIGZvciAobGV0IHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgIHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aWxlQ2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgICAgIHRpbGUgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgIHRpbGVDYWNoZS5nZXQodGlsZUNvb3JkS2V5KVxuICAgICAgICAgICk7XG4gICAgICAgICAgbG9hZGVkID0gdGlsZS5nZXRTdGF0ZSgpID09PSBUaWxlU3RhdGUuTE9BREVEO1xuICAgICAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGNhbGxiYWNrKHRpbGUpICE9PSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICovXG4gIGdldEd1dHRlckZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUga2V5IHRvIGJlIHVzZWQgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBrZXkgZm9yIGFsbCB0aWxlcy5cbiAgICovXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUga2V5IGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aWxlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0S2V5KGtleSkge1xuICAgIGlmICh0aGlzLmtleV8gIT09IGtleSkge1xuICAgICAgdGhpcy5rZXlfID0ga2V5O1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gT3BhcXVlLlxuICAgKi9cbiAgZ2V0T3BhcXVlKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5vcGFxdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uXCIpLmRlZmF1bHR9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFJlc29sdXRpb25zLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMocHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVHcmlkID0gcHJvamVjdGlvblxuICAgICAgPyB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKVxuICAgICAgOiB0aGlzLnRpbGVHcmlkO1xuICAgIGlmICghdGlsZUdyaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICovXG4gIGdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBncmlkIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIGdyaWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICovXG4gIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLnRpbGVHcmlkKSB7XG4gICAgICByZXR1cm4gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVDYWNoZS5qc1wiKS5kZWZhdWx0fSBUaWxlIGNhY2hlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICBjb25zdCBzb3VyY2VQcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgYXNzZXJ0KFxuICAgICAgc291cmNlUHJvamVjdGlvbiA9PT0gbnVsbCB8fCBlcXVpdmFsZW50KHNvdXJjZVByb2plY3Rpb24sIHByb2plY3Rpb24pLFxuICAgICAgJ0EgVmVjdG9yVGlsZSBzb3VyY2UgY2FuIG9ubHkgYmUgcmVuZGVyZWQgaWYgaXQgaGFzIGEgcHJvamVjdGlvbiBjb21wYXRpYmxlIHdpdGggdGhlIHZpZXcgcHJvamVjdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIHBpeGVsIHJhdGlvIGZvciB0aGlzIHNvdXJjZS4gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuICAgKiBtZXRob2QsIHdoaWNoIGlzIG1lYW50IHRvIHJldHVybiBhIHN1cHBvcnRlZCBwaXhlbCByYXRpbyB0aGF0IG1hdGNoZXMgdGhlXG4gICAqIHByb3ZpZGVkIGBwaXhlbFJhdGlvYCBhcyBjbG9zZSBhcyBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwaXhlbCByYXRpby5cbiAgICovXG4gIGdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy50aWxlUGl4ZWxSYXRpb187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBUaWxlIHNpemUuXG4gICAqL1xuICBnZXRUaWxlUGl4ZWxTaXplKHosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aWxlR3JpZC5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplKTtcbiAgICBpZiAodGlsZVBpeGVsUmF0aW8gPT0gMSkge1xuICAgICAgcmV0dXJuIHRpbGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGVTaXplKHRpbGVTaXplLCB0aWxlUGl4ZWxSYXRpbywgdGhpcy50bXBTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGlsZSBjb29yZGluYXRlIHdyYXBwZWQgYXJvdW5kIHRoZSB4LWF4aXMuIFdoZW4gdGhlIHRpbGUgY29vcmRpbmF0ZVxuICAgKiBpcyBvdXRzaWRlIHRoZSByZXNvbHV0aW9uIGFuZCBleHRlbnQgcmFuZ2Ugb2YgdGhlIHRpbGUgZ3JpZCwgYG51bGxgIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZSB0byBiZSBwYXNzZWQgdG8gdGhlIHRpbGVVcmxGdW5jdGlvbiBvclxuICAgKiAgICAgbnVsbCBpZiBubyB0aWxlIFVSTCBzaG91bGQgYmUgY3JlYXRlZCBmb3IgdGhlIHBhc3NlZCBgdGlsZUNvb3JkYC5cbiAgICovXG4gIGdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIHByb2plY3Rpb24pIHtcbiAgICBwcm9qZWN0aW9uID0gcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gcHJvamVjdGlvbiA6IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKHRoaXMuZ2V0V3JhcFgoKSAmJiBwcm9qZWN0aW9uLmlzR2xvYmFsKCkpIHtcbiAgICAgIHRpbGVDb29yZCA9IHdyYXBYKHRpbGVHcmlkLCB0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gd2l0aGluRXh0ZW50QW5kWih0aWxlQ29vcmQsIHRpbGVHcmlkKSA/IHRpbGVDb29yZCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBjYWNoZWQgdGlsZXMgZnJvbSB0aGUgc291cmNlLiBUaGUgbmV4dCByZW5kZXIgY3ljbGUgd2lsbCBmZXRjaCBuZXcgdGlsZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMudGlsZUNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBzdXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSBjYWNoZSBzaXplIGlmIG5lZWRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlsZUNvdW50IE1pbmltdW0gbnVtYmVyIG9mIHRpbGVzIG5lZWRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKi9cbiAgdXBkYXRlQ2FjaGVTaXplKHRpbGVDb3VudCwgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZUNvdW50ID4gdGlsZUNhY2hlLmhpZ2hXYXRlck1hcmspIHtcbiAgICAgIHRpbGVDYWNoZS5oaWdoV2F0ZXJNYXJrID0gdGlsZUNvdW50O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrcyBhIHRpbGUgY29vcmQgYXMgYmVpbmcgdXNlZCwgd2l0aG91dCB0cmlnZ2VyaW5nIGEgbG9hZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICovXG4gIHVzZVRpbGUoeiwgeCwgeSwgcHJvamVjdGlvbikge31cbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaWxlU291cmNlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaGUgdGlsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHRpbGUpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aWxlIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudGlsZSA9IHRpbGU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVNvdXJjZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVJhbmdlXG4gKi9cblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29udGlndW91cyBibG9jayBvZiB0aWxlcy4gIEEgdGlsZSByYW5nZSBpcyBzcGVjaWZpZWRcbiAqIGJ5IGl0cyBtaW4vbWF4IHRpbGUgY29vcmRpbmF0ZXMgYW5kIGlzIGluY2x1c2l2ZSBvZiBjb29yZGluYXRlcy5cbiAqL1xuY2xhc3MgVGlsZVJhbmdlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWSBNaW5pbXVtIFkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWCA9IG1pblg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWSA9IG1pblk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIHRpbGUgY29vcmRpbmF0ZS5cbiAgICovXG4gIGNvbnRhaW5zKHRpbGVDb29yZCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zWFkodGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMuXG4gICAqL1xuICBjb250YWluc1RpbGVSYW5nZSh0aWxlUmFuZ2UpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5taW5YIDw9IHRpbGVSYW5nZS5taW5YICYmXG4gICAgICB0aWxlUmFuZ2UubWF4WCA8PSB0aGlzLm1heFggJiZcbiAgICAgIHRoaXMubWluWSA8PSB0aWxlUmFuZ2UubWluWSAmJlxuICAgICAgdGlsZVJhbmdlLm1heFkgPD0gdGhpcy5tYXhZXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGNvb3JkaW5hdGUuXG4gICAqL1xuICBjb250YWluc1hZKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YIDw9IHggJiYgeCA8PSB0aGlzLm1heFggJiYgdGhpcy5taW5ZIDw9IHkgJiYgeSA8PSB0aGlzLm1heFk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBFcXVhbHMuXG4gICAqL1xuICBlcXVhbHModGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWluWCA9PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICAgdGhpcy5taW5ZID09IHRpbGVSYW5nZS5taW5ZICYmXG4gICAgICB0aGlzLm1heFggPT0gdGlsZVJhbmdlLm1heFggJiZcbiAgICAgIHRoaXMubWF4WSA9PSB0aWxlUmFuZ2UubWF4WVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZXh0ZW5kKHRpbGVSYW5nZSkge1xuICAgIGlmICh0aWxlUmFuZ2UubWluWCA8IHRoaXMubWluWCkge1xuICAgICAgdGhpcy5taW5YID0gdGlsZVJhbmdlLm1pblg7XG4gICAgfVxuICAgIGlmICh0aWxlUmFuZ2UubWF4WCA+IHRoaXMubWF4WCkge1xuICAgICAgdGhpcy5tYXhYID0gdGlsZVJhbmdlLm1heFg7XG4gICAgfVxuICAgIGlmICh0aWxlUmFuZ2UubWluWSA8IHRoaXMubWluWSkge1xuICAgICAgdGhpcy5taW5ZID0gdGlsZVJhbmdlLm1pblk7XG4gICAgfVxuICAgIGlmICh0aWxlUmFuZ2UubWF4WSA+IHRoaXMubWF4WSkge1xuICAgICAgdGhpcy5tYXhZID0gdGlsZVJhbmdlLm1heFk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0LlxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1heFkgLSB0aGlzLm1pblkgKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gW3RoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKV07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblggKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSW50ZXJzZWN0cy5cbiAgICovXG4gIGludGVyc2VjdHModGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWluWCA8PSB0aWxlUmFuZ2UubWF4WCAmJlxuICAgICAgdGhpcy5tYXhYID49IHRpbGVSYW5nZS5taW5YICYmXG4gICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1heFkgJiZcbiAgICAgIHRoaXMubWF4WSA+PSB0aWxlUmFuZ2UubWluWVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WCBNYXhpbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWSBNaW5pbXVtIFkuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gKiBAcGFyYW0ge1RpbGVSYW5nZX0gW3RpbGVSYW5nZV0gVGlsZVJhbmdlLlxuICogQHJldHVybiB7VGlsZVJhbmdlfSBUaWxlIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGlsZVJhbmdlKSB7XG4gIGlmICh0aWxlUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbGVSYW5nZS5taW5YID0gbWluWDtcbiAgICB0aWxlUmFuZ2UubWF4WCA9IG1heFg7XG4gICAgdGlsZVJhbmdlLm1pblkgPSBtaW5ZO1xuICAgIHRpbGVSYW5nZS5tYXhZID0gbWF4WTtcbiAgICByZXR1cm4gdGlsZVJhbmdlO1xuICB9XG4gIHJldHVybiBuZXcgVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlUmFuZ2U7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL1RpbGVHcmlkXG4gKi9cbmltcG9ydCBUaWxlUmFuZ2UsIHtcbiAgY3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UsXG59IGZyb20gJy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NlaWwsIGNsYW1wLCBmbG9vcn0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBnZXRUb3BMZWZ0fSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZH0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVhclJpbmd9IGZyb20gJy4uL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7aXNTb3J0ZWQsIGxpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICovXG5jb25zdCB0bXBUaWxlQ29vcmQgPSBbMCwgMCwgMF07XG5cbi8qKlxuICogTnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzIHRvIGNvbnNpZGVyIGluIGludGVnZXIgdmFsdWVzIHdoZW4gcm91bmRpbmcuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBERUNJTUFMUyA9IDU7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIE5vIHRpbGVzIG91dHNpZGUgdGhpc1xuICogZXh0ZW50IHdpbGwgYmUgcmVxdWVzdGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZX0gc291cmNlcy4gV2hlbiBubyBgb3JpZ2luYCBvclxuICogYG9yaWdpbnNgIGFyZSBjb25maWd1cmVkLCB0aGUgYG9yaWdpbmAgd2lsbCBiZSBzZXQgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbb3JpZ2luXSBUaGUgdGlsZSBncmlkIG9yaWdpbiwgaS5lLiB3aGVyZSB0aGUgYHhgXG4gKiBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLiBUaWxlIGNvb3JkaW5hdGVzIGluY3JlYXNlIGxlZnQgdG8gcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90XG4gKiBzcGVjaWZpZWQsIGBleHRlbnRgIG9yIGBvcmlnaW5zYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBbb3JpZ2luc10gVGlsZSBncmlkIG9yaWdpbnMsIGkuZS4gd2hlcmVcbiAqIHRoZSBgeGAgYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKSwgZm9yIGVhY2ggem9vbSBsZXZlbC4gSWYgZ2l2ZW4sIHRoZSBhcnJheSBsZW5ndGhcbiAqIHNob3VsZCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBgcmVzb2x1dGlvbnNgIGFycmF5LCBpLmUuIGVhY2ggcmVzb2x1dGlvbiBjYW4gaGF2ZSBhIGRpZmZlcmVudFxuICogb3JpZ2luLiBUaWxlIGNvb3JkaW5hdGVzIGluY3JlYXNlIGxlZnQgdG8gcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3JcbiAqIGBvcmlnaW5gIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgeyFBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy4gVGhlIGFycmF5IGluZGV4IG9mIGVhY2ggcmVzb2x1dGlvbiBuZWVkc1xuICogdG8gbWF0Y2ggdGhlIHpvb20gbGV2ZWwuIFRoaXMgbWVhbnMgdGhhdCBldmVuIGlmIGEgYG1pblpvb21gIGlzIGNvbmZpZ3VyZWQsIHRoZSByZXNvbHV0aW9uc1xuICogYXJyYXkgd2lsbCBoYXZlIGEgbGVuZ3RoIG9mIGBtYXhab29tICsgMWAuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFtzaXplc10gTnVtYmVyIG9mIHRpbGUgcm93cyBhbmQgY29sdW1uc1xuICogb2YgdGhlIGdyaWQgZm9yIGVhY2ggem9vbSBsZXZlbC4gSWYgc3BlY2lmaWVkIHRoZSB2YWx1ZXNcbiAqIGRlZmluZSBlYWNoIHpvb20gbGV2ZWwncyBleHRlbnQgdG9nZXRoZXIgd2l0aCB0aGUgYG9yaWdpbmAgb3IgYG9yaWdpbnNgLlxuICogQSBncmlkIGBleHRlbnRgIGNhbiBiZSBjb25maWd1cmVkIGluIGFkZGl0aW9uLCBhbmQgd2lsbCBmdXJ0aGVyIGxpbWl0IHRoZSBleHRlbnRcbiAqIGZvciB3aGljaCB0aWxlIHJlcXVlc3RzIGFyZSBtYWRlIGJ5IHNvdXJjZXMuIElmIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2ZcbiAqIGFuIGV4dGVudCBpcyB1c2VkIGFzIGBvcmlnaW5gIG9yIGBvcmlnaW5zYCwgdGhlbiB0aGUgYHlgIHZhbHVlIG11c3QgYmVcbiAqIG5lZ2F0aXZlIGJlY2F1c2UgT3BlbkxheWVycyB0aWxlIGNvb3JkaW5hdGVzIHVzZSB0aGUgdG9wIGxlZnQgYXMgdGhlIG9yaWdpbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUuXG4gKiBEZWZhdWx0IGlzIGBbMjU2LCAyNTZdYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIHRpbGUgc2l6ZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNldHRpbmcgdGhlIGdyaWQgcGF0dGVybiBmb3Igc291cmNlcyBhY2Nlc3NpbmcgdGlsZWQtaW1hZ2VcbiAqIHNlcnZlcnMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRpbGVHcmlkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBUaWxlIGdyaWQgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG4gICAgYXNzZXJ0KFxuICAgICAgaXNTb3J0ZWQoXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnNfLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGEgRmlyc3QgcmVzb2x1dGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYiBTZWNvbmQgcmVzb2x1dGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvbXBhcmlzb24gcmVzdWx0XG4gICAgICAgICAqL1xuICAgICAgICAoYSwgYikgPT4gYiAtIGEsXG4gICAgICAgIHRydWVcbiAgICAgICksXG4gICAgICAnYHJlc29sdXRpb25zYCBtdXN0IGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyJ1xuICAgICk7XG5cbiAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYSBjb25zaXN0ZW50IHpvb20gZmFjdG9yIGFuZCBvcmlnaW5cbiAgICBsZXQgem9vbUZhY3RvcjtcbiAgICBpZiAoIW9wdGlvbnMub3JpZ2lucykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgaWYgKCF6b29tRmFjdG9yKSB7XG4gICAgICAgICAgem9vbUZhY3RvciA9IHRoaXMucmVzb2x1dGlvbnNfW2ldIC8gdGhpcy5yZXNvbHV0aW9uc19baSArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXSAhPT0gem9vbUZhY3Rvcikge1xuICAgICAgICAgICAgem9vbUZhY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHpvb21GYWN0b3I7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFpvb20gPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gb3B0aW9ucy5vcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3JpZ2luIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5zXyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMub3JpZ2lucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9yaWdpbnNfID0gb3B0aW9ucy5vcmlnaW5zO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0aGlzLm9yaWdpbnNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAgICdOdW1iZXIgb2YgYG9yaWdpbnNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWwnXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50O1xuXG4gICAgaWYgKGV4dGVudCAhPT0gdW5kZWZpbmVkICYmICF0aGlzLm9yaWdpbl8gJiYgIXRoaXMub3JpZ2luc18pIHtcbiAgICAgIHRoaXMub3JpZ2luXyA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICB9XG5cbiAgICBhc3NlcnQoXG4gICAgICAoIXRoaXMub3JpZ2luXyAmJiB0aGlzLm9yaWdpbnNfKSB8fCAodGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSxcbiAgICAgICdFaXRoZXIgYG9yaWdpbmAgb3IgYG9yaWdpbnNgIG11c3QgYmUgY29uZmlndXJlZCwgbmV2ZXIgYm90aCdcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59XG4gICAgICovXG4gICAgdGhpcy50aWxlU2l6ZXNfID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy50aWxlU2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50aWxlU2l6ZXNfID0gb3B0aW9ucy50aWxlU2l6ZXM7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMudGlsZVNpemVzXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgICAnTnVtYmVyIG9mIGB0aWxlU2l6ZXNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWwnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50aWxlU2l6ZV8gPVxuICAgICAgb3B0aW9ucy50aWxlU2l6ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy50aWxlU2l6ZVxuICAgICAgICA6ICF0aGlzLnRpbGVTaXplc19cbiAgICAgICAgPyBERUZBVUxUX1RJTEVfU0laRVxuICAgICAgICA6IG51bGw7XG4gICAgYXNzZXJ0KFxuICAgICAgKCF0aGlzLnRpbGVTaXplXyAmJiB0aGlzLnRpbGVTaXplc18pIHx8XG4gICAgICAgICh0aGlzLnRpbGVTaXplXyAmJiAhdGhpcy50aWxlU2l6ZXNfKSxcbiAgICAgICdFaXRoZXIgYHRpbGVTaXplYCBvciBgdGlsZVNpemVzYCBtdXN0IGJlIGNvbmZpZ3VyZWQsIG5ldmVyIGJvdGgnXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50ICE9PSB1bmRlZmluZWQgPyBleHRlbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFNpemVfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcEV4dGVudF8gPSBbMCwgMCwgMCwgMF07XG5cbiAgICBpZiAob3B0aW9ucy5zaXplcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IG9wdGlvbnMuc2l6ZXMubWFwKChzaXplLCB6KSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbGVSYW5nZSA9IG5ldyBUaWxlUmFuZ2UoXG4gICAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVswXSksXG4gICAgICAgICAgTWF0aC5tYXgoc2l6ZVswXSAtIDEsIC0xKSxcbiAgICAgICAgICBNYXRoLm1pbigwLCBzaXplWzFdKSxcbiAgICAgICAgICBNYXRoLm1heChzaXplWzFdIC0gMSwgLTEpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICBjb25zdCByZXN0cmljdGVkVGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gICAgICAgICAgdGlsZVJhbmdlLm1pblggPSBNYXRoLm1heChyZXN0cmljdGVkVGlsZVJhbmdlLm1pblgsIHRpbGVSYW5nZS5taW5YKTtcbiAgICAgICAgICB0aWxlUmFuZ2UubWF4WCA9IE1hdGgubWluKHJlc3RyaWN0ZWRUaWxlUmFuZ2UubWF4WCwgdGlsZVJhbmdlLm1heFgpO1xuICAgICAgICAgIHRpbGVSYW5nZS5taW5ZID0gTWF0aC5tYXgocmVzdHJpY3RlZFRpbGVSYW5nZS5taW5ZLCB0aWxlUmFuZ2UubWluWSk7XG4gICAgICAgICAgdGlsZVJhbmdlLm1heFkgPSBNYXRoLm1pbihyZXN0cmljdGVkVGlsZVJhbmdlLm1heFksIHRpbGVSYW5nZS5tYXhZKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZVJhbmdlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChleHRlbnQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdpdGggZWFjaCB0aWxlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gZXh0ZW50IGFuZCB6b29tIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkKTogdm9pZH0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2hUaWxlQ29vcmQoZXh0ZW50LCB6b29tLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHpvb20pO1xuICAgIGZvciAobGV0IGkgPSB0aWxlUmFuZ2UubWluWCwgaWkgPSB0aWxlUmFuZ2UubWF4WDsgaSA8PSBpaTsgKytpKSB7XG4gICAgICBmb3IgKGxldCBqID0gdGlsZVJhbmdlLm1pblksIGpqID0gdGlsZVJhbmdlLm1heFk7IGogPD0gamo7ICsraikge1xuICAgICAgICBjYWxsYmFjayhbem9vbSwgaSwgal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGNhbGxiYWNrIENhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBbdGVtcFRpbGVSYW5nZV0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0IG9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbdGVtcEV4dGVudF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDYWxsYmFjayBzdWNjZWVkZWQuXG4gICAqL1xuICBmb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlKFxuICAgIHRpbGVDb29yZCxcbiAgICBjYWxsYmFjayxcbiAgICB0ZW1wVGlsZVJhbmdlLFxuICAgIHRlbXBFeHRlbnRcbiAgKSB7XG4gICAgbGV0IHRpbGVSYW5nZSwgeCwgeTtcbiAgICBsZXQgdGlsZUNvb3JkRXh0ZW50ID0gbnVsbDtcbiAgICBsZXQgeiA9IHRpbGVDb29yZFswXSAtIDE7XG4gICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICAgIHggPSB0aWxlQ29vcmRbMV07XG4gICAgICB5ID0gdGlsZUNvb3JkWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIHRlbXBFeHRlbnQpO1xuICAgIH1cbiAgICB3aGlsZSAoeiA+PSB0aGlzLm1pblpvb20pIHtcbiAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQgJiYgeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHggPSBNYXRoLmZsb29yKHggLyAyKTtcbiAgICAgICAgeSA9IE1hdGguZmxvb3IoeSAvIDIpO1xuICAgICAgICB0aWxlUmFuZ2UgPSBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZSh4LCB4LCB5LCB5LCB0ZW1wVGlsZVJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgICB0aWxlQ29vcmRFeHRlbnQsXG4gICAgICAgICAgeixcbiAgICAgICAgICB0ZW1wVGlsZVJhbmdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2soeiwgdGlsZVJhbmdlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC0tejtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZCwgaWYgaXQgd2FzIGNvbmZpZ3VyZWQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1heCB6b29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhab29tKCkge1xuICAgIHJldHVybiB0aGlzLm1heFpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbiB6b29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNaW5ab29tKCkge1xuICAgIHJldHVybiB0aGlzLm1pblpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gZm9yIHRoZSBncmlkIGF0IHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gT3JpZ2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcmlnaW4oeikge1xuICAgIGlmICh0aGlzLm9yaWdpbl8pIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yaWdpbnNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKHopIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bel07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIHJlc29sdXRpb25zIGZvciB0aGUgdGlsZSBncmlkLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBSZXNvbHV0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gW3RlbXBUaWxlUmFuZ2VdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3RlbXBFeHRlbnRdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR8bnVsbH0gVGlsZSByYW5nZS5cbiAgICovXG4gIGdldFRpbGVDb29yZENoaWxkVGlsZVJhbmdlKHRpbGVDb29yZCwgdGVtcFRpbGVSYW5nZSwgdGVtcEV4dGVudCkge1xuICAgIGlmICh0aWxlQ29vcmRbMF0gPCB0aGlzLm1heFpvb20pIHtcbiAgICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICAgIGNvbnN0IG1pblggPSB0aWxlQ29vcmRbMV0gKiAyO1xuICAgICAgICBjb25zdCBtaW5ZID0gdGlsZUNvb3JkWzJdICogMjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKFxuICAgICAgICAgIG1pblgsXG4gICAgICAgICAgbWluWCArIDEsXG4gICAgICAgICAgbWluWSxcbiAgICAgICAgICBtaW5ZICsgMSxcbiAgICAgICAgICB0ZW1wVGlsZVJhbmdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgICAgdGlsZUNvb3JkLFxuICAgICAgICB0ZW1wRXh0ZW50IHx8IHRoaXMudG1wRXh0ZW50X1xuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgIHRpbGVDb29yZEV4dGVudCxcbiAgICAgICAgdGlsZUNvb3JkWzBdICsgMSxcbiAgICAgICAgdGVtcFRpbGVSYW5nZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFt0ZW1wVGlsZVJhbmdlXSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZ2V0VGlsZVJhbmdlRm9yVGlsZUNvb3JkQW5kWih0aWxlQ29vcmQsIHosIHRlbXBUaWxlUmFuZ2UpIHtcbiAgICBpZiAoeiA+IHRoaXMubWF4Wm9vbSB8fCB6IDwgdGhpcy5taW5ab29tKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB0aWxlQ29vcmRaID0gdGlsZUNvb3JkWzBdO1xuICAgIGNvbnN0IHRpbGVDb29yZFggPSB0aWxlQ29vcmRbMV07XG4gICAgY29uc3QgdGlsZUNvb3JkWSA9IHRpbGVDb29yZFsyXTtcblxuICAgIGlmICh6ID09PSB0aWxlQ29vcmRaKSB7XG4gICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoXG4gICAgICAgIHRpbGVDb29yZFgsXG4gICAgICAgIHRpbGVDb29yZFksXG4gICAgICAgIHRpbGVDb29yZFgsXG4gICAgICAgIHRpbGVDb29yZFksXG4gICAgICAgIHRlbXBUaWxlUmFuZ2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8pIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgucG93KHRoaXMuem9vbUZhY3Rvcl8sIHogLSB0aWxlQ29vcmRaKTtcbiAgICAgIGNvbnN0IG1pblggPSBNYXRoLmZsb29yKHRpbGVDb29yZFggKiBmYWN0b3IpO1xuICAgICAgY29uc3QgbWluWSA9IE1hdGguZmxvb3IodGlsZUNvb3JkWSAqIGZhY3Rvcik7XG4gICAgICBpZiAoeiA8IHRpbGVDb29yZFopIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1pblgsIG1pblksIG1pblksIHRlbXBUaWxlUmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXhYID0gTWF0aC5mbG9vcihmYWN0b3IgKiAodGlsZUNvb3JkWCArIDEpKSAtIDE7XG4gICAgICBjb25zdCBtYXhZID0gTWF0aC5mbG9vcihmYWN0b3IgKiAodGlsZUNvb3JkWSArIDEpKSAtIDE7XG4gICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGVtcFRpbGVSYW5nZSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0aGlzLnRtcEV4dGVudF8pO1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFoodGlsZUNvb3JkRXh0ZW50LCB6LCB0ZW1wVGlsZVJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0aWxlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gZXh0ZW50IGFuZCBpbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBbdGVtcFRpbGVSYW5nZV0gVGVtcG9yYXJ5IHRpbGUgcmFuZ2Ugb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gVGlsZSByYW5nZS5cbiAgICovXG4gIGdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6LCB0ZW1wVGlsZVJhbmdlKSB7XG4gICAgdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKGV4dGVudFswXSwgZXh0ZW50WzNdLCB6LCBmYWxzZSwgdG1wVGlsZUNvb3JkKTtcbiAgICBjb25zdCBtaW5YID0gdG1wVGlsZUNvb3JkWzFdO1xuICAgIGNvbnN0IG1pblkgPSB0bXBUaWxlQ29vcmRbMl07XG4gICAgdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKGV4dGVudFsyXSwgZXh0ZW50WzFdLCB6LCB0cnVlLCB0bXBUaWxlQ29vcmQpO1xuICAgIGNvbnN0IG1heFggPSB0bXBUaWxlQ29vcmRbMV07XG4gICAgY29uc3QgbWF4WSA9IHRtcFRpbGVDb29yZFsyXTtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGVtcFRpbGVSYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRpbGUgY2VudGVyLlxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGVDb29yZCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHRpbGVDb29yZFswXSk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUodGlsZUNvb3JkWzBdKSwgdGhpcy50bXBTaXplXyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG9yaWdpblswXSArICh0aWxlQ29vcmRbMV0gKyAwLjUpICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uLFxuICAgICAgb3JpZ2luWzFdIC0gKHRpbGVDb29yZFsyXSArIDAuNSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb24sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiBhIHRpbGUgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFt0ZW1wRXh0ZW50XSBUZW1wb3JhcnkgZXh0ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0ZW1wRXh0ZW50KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHRpbGVDb29yZFswXSk7XG4gICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgICBjb25zdCBtaW5YID0gb3JpZ2luWzBdICsgdGlsZUNvb3JkWzFdICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IG1pblkgPSBvcmlnaW5bMV0gLSAodGlsZUNvb3JkWzJdICsgMSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWF4WCA9IG1pblggKyB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWF4WSA9IG1pblkgKyB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIHRlbXBFeHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBjb29yZGluYXRlIGZvciB0aGUgZ2l2ZW4gbWFwIGNvb3JkaW5hdGUgYW5kIHJlc29sdXRpb24uICBUaGlzXG4gICAqIG1ldGhvZCBjb25zaWRlcnMgdGhhdCBjb29yZGluYXRlcyB0aGF0IGludGVyc2VjdCB0aWxlIGJvdW5kYXJpZXMgc2hvdWxkIGJlXG4gICAqIGFzc2lnbmVkIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFtvcHRfdGlsZUNvb3JkXSBEZXN0aW5hdGlvbiBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlQ29vcmRGb3JDb29yZEFuZFJlc29sdXRpb24oY29vcmRpbmF0ZSwgcmVzb2x1dGlvbiwgb3B0X3RpbGVDb29yZCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oXG4gICAgICBjb29yZGluYXRlWzBdLFxuICAgICAgY29vcmRpbmF0ZVsxXSxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdF90aWxlQ29vcmRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgdGhhdCBjb3JyZXNwb25kXG4gICAqIHRvIGFuIGludGVnZXIgem9vbSBsZXZlbC4gIEluc3RlYWQgY2FsbCB0aGUgYGdldFRpbGVDb29yZEZvclhZQW5kWl9gIG1ldGhvZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbiAoZm9yIGEgbm9uLWludGVnZXIgem9vbSBsZXZlbCkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICAgKiAgICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICAgKiAgICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fKFxuICAgIHgsXG4gICAgeSxcbiAgICByZXNvbHV0aW9uLFxuICAgIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksXG4gICAgb3B0X3RpbGVDb29yZFxuICApIHtcbiAgICBjb25zdCB6ID0gdGhpcy5nZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICBjb25zdCBzY2FsZSA9IHJlc29sdXRpb24gLyB0aGlzLmdldFJlc29sdXRpb24oeik7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplXyk7XG5cbiAgICBsZXQgdGlsZUNvb3JkWCA9IChzY2FsZSAqICh4IC0gb3JpZ2luWzBdKSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMF07XG4gICAgbGV0IHRpbGVDb29yZFkgPSAoc2NhbGUgKiAob3JpZ2luWzFdIC0geSkpIC8gcmVzb2x1dGlvbiAvIHRpbGVTaXplWzFdO1xuXG4gICAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICAgIHRpbGVDb29yZFggPSBjZWlsKHRpbGVDb29yZFgsIERFQ0lNQUxTKSAtIDE7XG4gICAgICB0aWxlQ29vcmRZID0gY2VpbCh0aWxlQ29vcmRZLCBERUNJTUFMUykgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlQ29vcmRYID0gZmxvb3IodGlsZUNvb3JkWCwgREVDSU1BTFMpO1xuICAgICAgdGlsZUNvb3JkWSA9IGZsb29yKHRpbGVDb29yZFksIERFQ0lNQUxTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmQoeiwgdGlsZUNvb3JkWCwgdGlsZUNvb3JkWSwgb3B0X3RpbGVDb29yZCk7XG4gIH1cblxuICAvKipcbiAgICogQWx0aG91Z2ggdGhlcmUgaXMgcmVwZXRpdGlvbiBiZXR3ZWVuIHRoaXMgbWV0aG9kIGFuZCBgZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uX2AsXG4gICAqIHRoZXkgc2hvdWxkIGhhdmUgc2VwYXJhdGUgaW1wbGVtZW50YXRpb25zLiAgVGhpcyBtZXRob2QgaXMgZm9yIGludGVnZXIgem9vbVxuICAgKiBsZXZlbHMuICBUaGUgb3RoZXIgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgY29ycmVzcG9uZGluZ1xuICAgKiB0byBub24taW50ZWdlciB6b29tIGxldmVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTWFwIHggY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgTWFwIHkgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgSW5zdGVhZCBvZiBsZXR0aW5nIGVkZ2VcbiAgICogICAgIGludGVyc2VjdGlvbnMgZ28gdG8gdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUsIGxldCBlZGdlIGludGVyc2VjdGlvbnNcbiAgICogICAgIGdvIHRvIHRoZSBsb3dlciB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gW29wdF90aWxlQ29vcmRdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyh4LCB5LCB6LCByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5LCBvcHRfdGlsZUNvb3JkKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICAgIGxldCB0aWxlQ29vcmRYID0gKHggLSBvcmlnaW5bMF0pIC8gcmVzb2x1dGlvbiAvIHRpbGVTaXplWzBdO1xuICAgIGxldCB0aWxlQ29vcmRZID0gKG9yaWdpblsxXSAtIHkpIC8gcmVzb2x1dGlvbiAvIHRpbGVTaXplWzFdO1xuXG4gICAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICAgIHRpbGVDb29yZFggPSBjZWlsKHRpbGVDb29yZFgsIERFQ0lNQUxTKSAtIDE7XG4gICAgICB0aWxlQ29vcmRZID0gY2VpbCh0aWxlQ29vcmRZLCBERUNJTUFMUykgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlQ29vcmRYID0gZmxvb3IodGlsZUNvb3JkWCwgREVDSU1BTFMpO1xuICAgICAgdGlsZUNvb3JkWSA9IGZsb29yKHRpbGVDb29yZFksIERFQ0lNQUxTKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmQoeiwgdGlsZUNvb3JkWCwgdGlsZUNvb3JkWSwgb3B0X3RpbGVDb29yZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGlsZSBjb29yZGluYXRlIGdpdmVuIGEgbWFwIGNvb3JkaW5hdGUgYW5kIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbCwgZS5nLiB0aGUgcmVzdWx0IG9mIGEgYGdldFpGb3JSZXNvbHV0aW9uKClgIG1ldGhvZCBjYWxsXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gW29wdF90aWxlQ29vcmRdIERlc3RpbmF0aW9uIGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjb29yZGluYXRlLCB6LCBvcHRfdGlsZUNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhcbiAgICAgIGNvb3JkaW5hdGVbMF0sXG4gICAgICBjb29yZGluYXRlWzFdLFxuICAgICAgeixcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0X3RpbGVDb29yZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFRpbGVDb29yZFJlc29sdXRpb24odGlsZUNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3RpbGVDb29yZFswXV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIHNpemUgZm9yIGEgem9vbSBsZXZlbC4gVGhlIHR5cGUgb2YgdGhlIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZVxuICAgKiBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIHRoYXQgdGhlIHRpbGUgZ3JpZCB3YXMgY29uZmlndXJlZCB3aXRoLiBUbyBhbHdheXNcbiAgICogZ2V0IGFuIHtAbGluayBpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9LCBydW4gdGhlIHJlc3VsdCB0aHJvdWdoIHtAbGluayBtb2R1bGU6b2wvc2l6ZS50b1NpemV9LlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBUaWxlIHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVTaXplKHopIHtcbiAgICBpZiAodGhpcy50aWxlU2l6ZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplXztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlsZVNpemVzX1t6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdHxudWxsfSBFeHRlbnQgdGlsZSByYW5nZSBmb3IgdGhlIHNwZWNpZmllZCB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0RnVsbFRpbGVSYW5nZSh6KSB7XG4gICAgaWYgKCF0aGlzLmZ1bGxUaWxlUmFuZ2VzXykge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50X1xuICAgICAgICA/IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWih0aGlzLmV4dGVudF8sIHopXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRpbGVSYW5nZXNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW29wdF9kaXJlY3Rpb25dXG4gICAqICAgICBJZiAwLCB0aGUgbmVhcmVzdCByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC5cbiAgICogICAgIElmIDEsIHRoZSBuZWFyZXN0IGhpZ2hlciByZXNvbHV0aW9uIChsb3dlciBaKSB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGVcbiAgICogICAgIG5lYXJlc3QgbG93ZXIgcmVzb2x1dGlvbiAoaGlnaGVyIFopIHdpbGwgYmUgdXNlZC4gRGVmYXVsdCBpcyAwLlxuICAgKiAgICAgVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9hcnJheX5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IGZvciBtb3JlIHByZWNpc2UgY29udHJvbC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUgdG8gY2hhbmdlIHRpbGUgWiBhdCB0aGUgbWlkcG9pbnQgb2Ygem9vbSBsZXZlbHNcbiAgICogYGBganNcbiAgICogZnVuY3Rpb24odmFsdWUsIGhpZ2gsIGxvdykge1xuICAgKiAgIHJldHVybiB2YWx1ZSAtIGxvdyAqIE1hdGguc3FydChoaWdoIC8gbG93KTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7bnVtYmVyfSBaLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeiA9IGxpbmVhckZpbmROZWFyZXN0KFxuICAgICAgdGhpcy5yZXNvbHV0aW9uc18sXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgb3B0X2RpcmVjdGlvbiB8fCAwXG4gICAgKTtcbiAgICByZXR1cm4gY2xhbXAoeiwgdGhpcy5taW5ab29tLCB0aGlzLm1heFpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aWxlIHdpdGggdGhlIHByb3ZpZGVkIHRpbGUgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3RpbGVjb29yZC5qcycpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2aWV3cG9ydCBWaWV3cG9ydCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50LmdldFJvdGF0ZWRWaWV3cG9ydH0uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHdpdGggdGhlIHByb3ZpZGVkIHRpbGUgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiB2aWV3cG9ydC5cbiAgICovXG4gIHRpbGVDb29yZEludGVyc2VjdHNWaWV3cG9ydCh0aWxlQ29vcmQsIHZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lYXJSaW5nKFxuICAgICAgdmlld3BvcnQsXG4gICAgICAwLFxuICAgICAgdmlld3BvcnQubGVuZ3RoLFxuICAgICAgMixcbiAgICAgIHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxUaWxlUmFuZ2VzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgICBmdWxsVGlsZVJhbmdlc1t6XSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IGZ1bGxUaWxlUmFuZ2VzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVHcmlkO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZFxuICovXG5pbXBvcnQgVGlsZUdyaWQgZnJvbSAnLi90aWxlZ3JpZC9UaWxlR3JpZC5qcyc7XG5pbXBvcnQge0RFRkFVTFRfTUFYX1pPT00sIERFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL3RpbGVncmlkL2NvbW1vbi5qcyc7XG5pbXBvcnQge01FVEVSU19QRVJfVU5JVCwgZ2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4vcHJvai5qcyc7XG5pbXBvcnQge1xuICBjb250YWluc0Nvb3JkaW5hdGUsXG4gIGNyZWF0ZU9yVXBkYXRlLFxuICBnZXRDb3JuZXIsXG4gIGdldEhlaWdodCxcbiAgZ2V0V2lkdGgsXG59IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuL3NpemUuanMnO1xuXG5leHBvcnQge1RpbGVHcmlkfTtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXTVRTfSBmcm9tICcuL3RpbGVncmlkL1dNVFMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7IVRpbGVHcmlkfSBEZWZhdWx0IHRpbGUgZ3JpZCBmb3IgdGhlXG4gKiBwYXNzZWQgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBsZXQgdGlsZUdyaWQgPSBwcm9qZWN0aW9uLmdldERlZmF1bHRUaWxlR3JpZCgpO1xuICBpZiAoIXRpbGVHcmlkKSB7XG4gICAgdGlsZUdyaWQgPSBjcmVhdGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIHByb2plY3Rpb24uc2V0RGVmYXVsdFRpbGVHcmlkKHRpbGVHcmlkKTtcbiAgfVxuICByZXR1cm4gdGlsZUdyaWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFgodGlsZUdyaWQsIHRpbGVDb29yZCwgcHJvamVjdGlvbikge1xuICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICBjb25zdCBjZW50ZXIgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRDZW50ZXIodGlsZUNvb3JkKTtcbiAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBpZiAoIWNvbnRhaW5zQ29vcmRpbmF0ZShwcm9qZWN0aW9uRXh0ZW50LCBjZW50ZXIpKSB7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgIGNvbnN0IHdvcmxkc0F3YXkgPSBNYXRoLmNlaWwoXG4gICAgICAocHJvamVjdGlvbkV4dGVudFswXSAtIGNlbnRlclswXSkgLyB3b3JsZFdpZHRoXG4gICAgKTtcbiAgICBjZW50ZXJbMF0gKz0gd29ybGRXaWR0aCAqIHdvcmxkc0F3YXk7XG4gICAgcmV0dXJuIHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjZW50ZXIsIHopO1xuICB9XG4gIHJldHVybiB0aWxlQ29vcmQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkNvcm5lcn0gW2Nvcm5lcl0gRXh0ZW50IGNvcm5lciAoZGVmYXVsdCBpcyBgJ3RvcC1sZWZ0J2ApLlxuICogQHJldHVybiB7IVRpbGVHcmlkfSBUaWxlR3JpZCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvckV4dGVudChleHRlbnQsIG1heFpvb20sIHRpbGVTaXplLCBjb3JuZXIpIHtcbiAgY29ybmVyID0gY29ybmVyICE9PSB1bmRlZmluZWQgPyBjb3JuZXIgOiAndG9wLWxlZnQnO1xuXG4gIGNvbnN0IHJlc29sdXRpb25zID0gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUpO1xuXG4gIHJldHVybiBuZXcgVGlsZUdyaWQoe1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG9yaWdpbjogZ2V0Q29ybmVyKGV4dGVudCwgY29ybmVyKSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnMsXG4gICAgdGlsZVNpemU6IHRpbGVTaXplLFxuICB9KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYWVpPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50IGZvciB0aGUgdGlsZSBncmlkLiBUaGUgb3JpZ2luIGZvciBhbiBYWVogdGlsZSBncmlkIGlzIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBleHRlbnQuIElmIGBtYXhSZXNvbHV0aW9uYCBpcyBub3QgcHJvdmlkZWQgdGhlIHplcm8gbGV2ZWwgb2YgdGhlIGdyaWQgaXMgZGVmaW5lZCBieSB0aGUgcmVzb2x1dGlvblxuICogYXQgd2hpY2ggb25lIHRpbGUgZml0cyBpbiB0aGUgcHJvdmlkZWQgZXh0ZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBleHRlbnQgb2YgdGhlIEVQU0c6Mzg1NyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFJlc29sdXRpb24gYXQgbGV2ZWwgemVyby5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tLiBUaGUgZGVmYXVsdCBpcyBgNDJgLiBUaGlzIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBsZXZlbHNcbiAqIGluIHRoZSBncmlkIHNldC4gRm9yIGV4YW1wbGUsIGEgYG1heFpvb21gIG9mIDIxIG1lYW5zIHRoZXJlIGFyZSAyMiBsZXZlbHMgaW4gdGhlIGdyaWQgc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGlsZSBzaXplIGluIHBpeGVscy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aWxlIGdyaWQgd2l0aCBhIHN0YW5kYXJkIFhZWiB0aWxpbmcgc2NoZW1lLlxuICogQHBhcmFtIHtYWVpPcHRpb25zfSBbb3B0aW9uc10gVGlsZSBncmlkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGUgZ3JpZCBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhZWihvcHRpb25zKSB7XG4gIGNvbnN0IHh5ek9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGV4dGVudCA9IHh5ek9wdGlvbnMuZXh0ZW50IHx8IGdldFByb2plY3Rpb24oJ0VQU0c6Mzg1NycpLmdldEV4dGVudCgpO1xuXG4gIGNvbnN0IGdyaWRPcHRpb25zID0ge1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG1pblpvb206IHh5ek9wdGlvbnMubWluWm9vbSxcbiAgICB0aWxlU2l6ZTogeHl6T3B0aW9ucy50aWxlU2l6ZSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnNGcm9tRXh0ZW50KFxuICAgICAgZXh0ZW50LFxuICAgICAgeHl6T3B0aW9ucy5tYXhab29tLFxuICAgICAgeHl6T3B0aW9ucy50aWxlU2l6ZSxcbiAgICAgIHh5ek9wdGlvbnMubWF4UmVzb2x1dGlvblxuICAgICksXG4gIH07XG4gIHJldHVybiBuZXcgVGlsZUdyaWQoZ3JpZE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlc29sdXRpb25zIGFycmF5IGZyb20gYW4gZXh0ZW50LiAgQSB6b29tIGZhY3RvciBvZiAyIGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gUmVzb2x1dGlvbiBhdCBsZXZlbCB6ZXJvLlxuICogQHJldHVybiB7IUFycmF5PG51bWJlcj59IFJlc29sdXRpb25zIGFycmF5LlxuICovXG5mdW5jdGlvbiByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBtYXhab29tLCB0aWxlU2l6ZSwgbWF4UmVzb2x1dGlvbikge1xuICBtYXhab29tID0gbWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IERFRkFVTFRfTUFYX1pPT007XG4gIHRpbGVTaXplID0gdG9TaXplKHRpbGVTaXplICE9PSB1bmRlZmluZWQgPyB0aWxlU2l6ZSA6IERFRkFVTFRfVElMRV9TSVpFKTtcblxuICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgY29uc3Qgd2lkdGggPSBnZXRXaWR0aChleHRlbnQpO1xuXG4gIG1heFJlc29sdXRpb24gPVxuICAgIG1heFJlc29sdXRpb24gPiAwXG4gICAgICA/IG1heFJlc29sdXRpb25cbiAgICAgIDogTWF0aC5tYXgod2lkdGggLyB0aWxlU2l6ZVswXSwgaGVpZ2h0IC8gdGlsZVNpemVbMV0pO1xuXG4gIGNvbnN0IGxlbmd0aCA9IG1heFpvb20gKyAxO1xuICBjb25zdCByZXNvbHV0aW9ucyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCB6ID0gMDsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgcmVzb2x1dGlvbnNbel0gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coMiwgeik7XG4gIH1cbiAgcmV0dXJuIHJlc29sdXRpb25zO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkNvcm5lcn0gW2Nvcm5lcl0gRXh0ZW50IGNvcm5lciAoZGVmYXVsdCBpcyBgJ3RvcC1sZWZ0J2ApLlxuICogQHJldHVybiB7IVRpbGVHcmlkfSBUaWxlR3JpZCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbiwgbWF4Wm9vbSwgdGlsZVNpemUsIGNvcm5lcikge1xuICBjb25zdCBleHRlbnQgPSBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgcmV0dXJuIGNyZWF0ZUZvckV4dGVudChleHRlbnQsIG1heFpvb20sIHRpbGVTaXplLCBjb3JuZXIpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdGlsZSBncmlkIGV4dGVudCBmcm9tIGEgcHJvamVjdGlvbi4gIElmIHRoZSBwcm9qZWN0aW9uIGhhcyBhblxuICogZXh0ZW50LCBpdCBpcyB1c2VkLiAgSWYgbm90LCBhIGdsb2JhbCBleHRlbnQgaXMgYXNzdW1lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgcHJvamVjdGlvbiA9IGdldFByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGxldCBleHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICBpZiAoIWV4dGVudCkge1xuICAgIGNvbnN0IGhhbGYgPVxuICAgICAgKDE4MCAqIE1FVEVSU19QRVJfVU5JVC5kZWdyZWVzKSAvIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlKC1oYWxmLCAtaGFsZiwgaGFsZiwgaGFsZik7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZXVybGZ1bmN0aW9uXG4gKi9cbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtoYXNoIGFzIHRpbGVDb29yZEhhc2h9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVGVtcGxhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdGlsZUdyaWQpIHtcbiAgY29uc3QgelJlZ0V4ID0gL1xce3pcXH0vZztcbiAgY29uc3QgeFJlZ0V4ID0gL1xce3hcXH0vZztcbiAgY29uc3QgeVJlZ0V4ID0gL1xce3lcXH0vZztcbiAgY29uc3QgZGFzaFlSZWdFeCA9IC9cXHsteVxcfS9nO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBDb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRpbGUgVVJMLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICAgIGlmICghdGlsZUNvb3JkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVtcGxhdGVcbiAgICAgICAgLnJlcGxhY2UoelJlZ0V4LCB0aWxlQ29vcmRbMF0udG9TdHJpbmcoKSlcbiAgICAgICAgLnJlcGxhY2UoeFJlZ0V4LCB0aWxlQ29vcmRbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgLnJlcGxhY2UoeVJlZ0V4LCB0aWxlQ29vcmRbMl0udG9TdHJpbmcoKSlcbiAgICAgICAgLnJlcGxhY2UoZGFzaFlSZWdFeCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWxlR3JpZC5nZXRGdWxsVGlsZVJhbmdlKHopO1xuICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1RoZSB7LXl9IHBsYWNlaG9sZGVyIHJlcXVpcmVzIGEgdGlsZSBncmlkIHdpdGggZXh0ZW50J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeSA9IHJhbmdlLmdldEhlaWdodCgpIC0gdGlsZUNvb3JkWzJdIC0gMTtcbiAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB0ZW1wbGF0ZXMgVGVtcGxhdGVzLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGVtcGxhdGVzKHRlbXBsYXRlcywgdGlsZUdyaWQpIHtcbiAgY29uc3QgbGVuID0gdGVtcGxhdGVzLmxlbmd0aDtcbiAgY29uc3QgdGlsZVVybEZ1bmN0aW9ucyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGlsZVVybEZ1bmN0aW9uc1tpXSA9IGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZXNbaV0sIHRpbGVHcmlkKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRnJvbVRpbGVVcmxGdW5jdGlvbnModGlsZVVybEZ1bmN0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb24+fSB0aWxlVXJsRnVuY3Rpb25zIFRpbGUgVVJMIEZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKSB7XG4gIGlmICh0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zWzBdO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGggPSB0aWxlQ29vcmRIYXNoKHRpbGVDb29yZCk7XG4gICAgICBjb25zdCBpbmRleCA9IG1vZHVsbyhoLCB0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGlsZVVybEZ1bmN0aW9uc1tpbmRleF0odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFVybCh1cmwpIHtcbiAgY29uc3QgdXJscyA9IFtdO1xuICBsZXQgbWF0Y2ggPSAvXFx7KFthLXpdKS0oW2Etel0pXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIGNoYXIgcmFuZ2VcbiAgICBjb25zdCBzdGFydENoYXJDb2RlID0gbWF0Y2hbMV0uY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBzdG9wQ2hhckNvZGUgPSBtYXRjaFsyXS5jaGFyQ29kZUF0KDApO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICBmb3IgKGNoYXJDb2RlID0gc3RhcnRDaGFyQ29kZTsgY2hhckNvZGUgPD0gc3RvcENoYXJDb2RlOyArK2NoYXJDb2RlKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIG1hdGNoID0gL1xceyhcXGQrKS0oXFxkKylcXH0vLmV4ZWModXJsKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgLy8gbnVtYmVyIHJhbmdlXG4gICAgY29uc3Qgc3RvcCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgZm9yIChsZXQgaSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7IGkgPD0gc3RvcDsgaSsrKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIGkudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICB1cmxzLnB1c2godXJsKTtcbiAgcmV0dXJuIHVybHM7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9VcmxUaWxlXG4gKi9cbmltcG9ydCBUaWxlRXZlbnRUeXBlIGZyb20gJy4vVGlsZUV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGlsZVNvdXJjZSwge1RpbGVTb3VyY2VFdmVudH0gZnJvbSAnLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlRnJvbVRlbXBsYXRlcywgZXhwYW5kVXJsfSBmcm9tICcuLi90aWxldXJsZnVuY3Rpb24uanMnO1xuaW1wb3J0IHtnZXRLZXlaWFl9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gQ2FjaGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZT1mYWxzZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IFtzdGF0ZV0gU3RhdGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFt0aWxlR3JpZF0gVGlsZUdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGVMb2FkRnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXSBUaWxlUGl4ZWxSYXRpby5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gVGlsZVVybEZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVybC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIFVybHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwWC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gVHJhbnNpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XSBLZXkuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFt6RGlyZWN0aW9uPTBdIFpEaXJlY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgdGlsZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkIG92ZXIgaHR0cC5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9UaWxlLmpzXCIpLlRpbGVTb3VyY2VFdmVudFxuICovXG5jbGFzcyBVcmxUaWxlIGV4dGVuZHMgVGlsZVNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgSW1hZ2UgdGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgdGlsZUdyaWQ6IG9wdGlvbnMudGlsZUdyaWQsXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUsXG4gICAgICB6RGlyZWN0aW9uOiBvcHRpb25zLnpEaXJlY3Rpb24sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2VuZXJhdGVUaWxlVXJsRnVuY3Rpb25fID1cbiAgICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID09PSBVcmxUaWxlLnByb3RvdHlwZS50aWxlVXJsRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbjtcblxuICAgIGlmIChvcHRpb25zLnRpbGVVcmxGdW5jdGlvbikge1xuICAgICAgdGhpcy50aWxlVXJsRnVuY3Rpb24gPSBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy51cmxzID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLnVybHMpIHtcbiAgICAgIHRoaXMuc2V0VXJscyhvcHRpb25zLnVybHMpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgIHRoaXMuc2V0VXJsKG9wdGlvbnMudXJsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZGluZ0tleXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aWxlIGxvYWQgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFRpbGVMb2FkRnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUxvYWRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlTG9hZEZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBVUkwgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZVVybEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVVcmxGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnRpbGVVcmxGdW5jdGlvbiA9PT0gdGhpcy50aWxlVXJsRnVuY3Rpb25cbiAgICAgID8gdGhpcy50aWxlVXJsRnVuY3Rpb24uYmluZCh0aGlzKVxuICAgICAgOiB0aGlzLnRpbGVVcmxGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIFVSTHMgdXNlZCBmb3IgdGhpcyBzb3VyY2UuXG4gICAqIFdoZW4gYSB0aWxlVXJsRnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIHVybCBvciB1cmxzLFxuICAgKiBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fG51bGx9IFVSTHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJscztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGlsZSBjaGFuZ2UgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlVGlsZUNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgY29uc3QgdWlkID0gZ2V0VWlkKHRpbGUpO1xuICAgIGNvbnN0IHRpbGVTdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgdHlwZTtcbiAgICBpZiAodGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXSA9IHRydWU7XG4gICAgICB0eXBlID0gVGlsZUV2ZW50VHlwZS5USUxFTE9BRFNUQVJUO1xuICAgIH0gZWxzZSBpZiAodWlkIGluIHRoaXMudGlsZUxvYWRpbmdLZXlzXykge1xuICAgICAgZGVsZXRlIHRoaXMudGlsZUxvYWRpbmdLZXlzX1t1aWRdO1xuICAgICAgdHlwZSA9XG4gICAgICAgIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1JcbiAgICAgICAgICA/IFRpbGVFdmVudFR5cGUuVElMRUxPQURFUlJPUlxuICAgICAgICAgIDogdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FERURcbiAgICAgICAgICA/IFRpbGVFdmVudFR5cGUuVElMRUxPQURFTkRcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRpbGVTb3VyY2VFdmVudCh0eXBlLCB0aWxlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IHRpbGVMb2FkRnVuY3Rpb24gVGlsZSBsb2FkIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUaWxlTG9hZEZ1bmN0aW9uKHRpbGVMb2FkRnVuY3Rpb24pIHtcbiAgICB0aGlzLnRpbGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IHRpbGVMb2FkRnVuY3Rpb247XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0aWxlIFVSTCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IHRpbGVVcmxGdW5jdGlvbiBUaWxlIFVSTCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIE9wdGlvbmFsIG5ldyB0aWxlIGtleSBmb3IgdGhlIHNvdXJjZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGlsZVVybEZ1bmN0aW9uKHRpbGVVcmxGdW5jdGlvbiwga2V5KSB7XG4gICAgdGhpcy50aWxlVXJsRnVuY3Rpb24gPSB0aWxlVXJsRnVuY3Rpb247XG4gICAgdGhpcy50aWxlQ2FjaGUucHJ1bmVFeGNlcHROZXdlc3RaKCk7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnNldEtleShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBVUkwgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFVybCh1cmwpIHtcbiAgICBjb25zdCB1cmxzID0gZXhwYW5kVXJsKHVybCk7XG4gICAgdGhpcy51cmxzID0gdXJscztcbiAgICB0aGlzLnNldFVybHModXJscyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBVUkxzIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdXJscyBVUkxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRVcmxzKHVybHMpIHtcbiAgICB0aGlzLnVybHMgPSB1cmxzO1xuICAgIGNvbnN0IGtleSA9IHVybHMuam9pbignXFxuJyk7XG4gICAgaWYgKHRoaXMuZ2VuZXJhdGVUaWxlVXJsRnVuY3Rpb25fKSB7XG4gICAgICB0aGlzLnNldFRpbGVVcmxGdW5jdGlvbihjcmVhdGVGcm9tVGVtcGxhdGVzKHVybHMsIHRoaXMudGlsZUdyaWQpLCBrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEtleShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRpbGUgVVJMLlxuICAgKi9cbiAgdGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgYSB0aWxlIGNvb3JkIGFzIGJlaW5nIHVzZWQsIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGxvYWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqL1xuICB1c2VUaWxlKHosIHgsIHkpIHtcbiAgICBjb25zdCB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVcmxUaWxlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvWFlaXG4gKi9cblxuaW1wb3J0IFRpbGVJbWFnZSBmcm9tICcuL1RpbGVJbWFnZS5qcyc7XG5pbXBvcnQge2NyZWF0ZVhZWiwgZXh0ZW50RnJvbVByb2plY3Rpb259IGZyb20gJy4uL3RpbGVncmlkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXSBJbml0aWFsIHRpbGUgY2FjaGUgc2l6ZS4gV2lsbCBhdXRvLWdyb3cgdG8gaG9sZCBhdCBsZWFzdCB0aGUgbnVtYmVyIG9mIHRpbGVzIGluIHRoZSB2aWV3cG9ydC5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9dHJ1ZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLiAgU2V0IHRvIGZhbHNlIHRvIHVzZSB0aGUgbmVhcmVzdCBuZWlnaGJvciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPWZhbHNlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXSBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209NDJdIE9wdGlvbmFsIG1heCB6b29tIGxldmVsLiBOb3QgdXNlZCBpZiBgdGlsZUdyaWRgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE9wdGlvbmFsIG1pbiB6b29tIGxldmVsLiBOb3QgdXNlZCBpZiBgdGlsZUdyaWRgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBPcHRpb25hbCB0aWxlIGdyaWQgcmVzb2x1dGlvbiBhdCBsZXZlbCB6ZXJvLiBOb3QgdXNlZCBpZiBgdGlsZUdyaWRgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpbGUgc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZT1bMjU2LCAyNTZdXSBUaGUgdGlsZSBzaXplIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS5cbiAqIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2d1dHRlcj0wXSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGd1dHRlciBhcm91bmQgaW1hZ2UgdGlsZXMgdG8gaWdub3JlLlxuICogVGhpcyBhbGxvd3MgYXJ0aWZhY3RzIG9mIHJlbmRlcmluZyBhdCB0aWxlIGVkZ2VzIHRvIGJlIGlnbm9yZWQuXG4gKiBTdXBwb3J0ZWQgaW1hZ2VzIHNob3VsZCBiZSB3aWRlciBhbmQgdGFsbGVyIHRoYW4gdGhlIHRpbGUgc2l6ZSBieSBhIHZhbHVlIG9mIGAyIHggZ3V0dGVyYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZ2V0XG4gKiB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBSZXF1aXJlZCBpZiBgdXJsYCBvciBgdXJsc2AgYXJlIG5vdCBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLFxuICogYW5kIGB7en1gIHBsYWNlaG9sZGVycy4gQSBgez8tP31gIHRlbXBsYXRlIHBhdHRlcm4sIGZvciBleGFtcGxlIGBzdWJkb21haW57YS1mfS5kb21haW4uY29tYCxcbiAqIG1heSBiZSB1c2VkIGluc3RlYWQgb2YgZGVmaW5pbmcgZWFjaCBvbmUgc2VwYXJhdGVseSBpbiB0aGUgYHVybHNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIEFuIGFycmF5IG9mIFVSTCB0ZW1wbGF0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbj0yNTBdIER1cmF0aW9uIG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24gZm9yIHJlbmRlcmluZy5cbiAqIFRvIGRpc2FibGUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiwgcGFzcyBgdHJhbnNpdGlvbjogMGAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFt6RGlyZWN0aW9uPTBdXG4gKiBDaG9vc2Ugd2hldGhlciB0byB1c2UgdGlsZXMgd2l0aCBhIGhpZ2hlciBvciBsb3dlciB6b29tIGxldmVsIHdoZW4gYmV0d2VlbiBpbnRlZ2VyXG4gKiB6b29tIGxldmVscy4gU2VlIHtAbGluayBtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR+VGlsZUdyaWQjZ2V0WkZvclJlc29sdXRpb259LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aWxlIGRhdGEgd2l0aCBVUkxzIGluIGEgc2V0IFhZWiBmb3JtYXQgdGhhdCBhcmVcbiAqIGRlZmluZWQgaW4gYSBVUkwgdGVtcGxhdGUuIEJ5IGRlZmF1bHQsIHRoaXMgZm9sbG93cyB0aGUgd2lkZWx5LXVzZWRcbiAqIEdvb2dsZSBncmlkIHdoZXJlIGB4YCAwIGFuZCBgeWAgMCBhcmUgaW4gdGhlIHRvcCBsZWZ0LiBHcmlkcyBsaWtlXG4gKiBUTVMgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgYm90dG9tIGxlZnQgY2FuIGJlIHVzZWQgYnlcbiAqIHVzaW5nIHRoZSBgey15fWAgcGxhY2Vob2xkZXIgaW4gdGhlIFVSTCB0ZW1wbGF0ZSwgc28gbG9uZyBhcyB0aGVcbiAqIHNvdXJjZSBkb2VzIG5vdCBoYXZlIGEgY3VzdG9tIHRpbGUgZ3JpZC4gSW4gdGhpcyBjYXNlXG4gKiBhIGB0aWxlVXJsRnVuY3Rpb25gIGNhbiBiZSB1c2VkLCBzdWNoIGFzOlxuICogYGBganNcbiAqICB0aWxlVXJsRnVuY3Rpb246IGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcbiAqICAgIHJldHVybiAnaHR0cDovL21hcHNlcnZlci5jb20vJyArIGNvb3JkaW5hdGVbMF0gKyAnLycgK1xuICogICAgICBjb29yZGluYXRlWzFdICsgJy8nICsgKC1jb29yZGluYXRlWzJdIC0gMSkgKyAnLnBuZyc7XG4gKiAgfVxuICogYGBgXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFhZWiBleHRlbmRzIFRpbGVJbWFnZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBYWVogb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IHByb2plY3Rpb24gPVxuICAgICAgb3B0aW9ucy5wcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnByb2plY3Rpb24gOiAnRVBTRzozODU3JztcblxuICAgIGNvbnN0IHRpbGVHcmlkID1cbiAgICAgIG9wdGlvbnMudGlsZUdyaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudGlsZUdyaWRcbiAgICAgICAgOiBjcmVhdGVYWVooe1xuICAgICAgICAgICAgZXh0ZW50OiBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKSxcbiAgICAgICAgICAgIG1heFJlc29sdXRpb246IG9wdGlvbnMubWF4UmVzb2x1dGlvbixcbiAgICAgICAgICAgIG1heFpvb206IG9wdGlvbnMubWF4Wm9vbSxcbiAgICAgICAgICAgIG1pblpvb206IG9wdGlvbnMubWluWm9vbSxcbiAgICAgICAgICAgIHRpbGVTaXplOiBvcHRpb25zLnRpbGVTaXplLFxuICAgICAgICAgIH0pO1xuXG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBjcm9zc09yaWdpbjogb3B0aW9ucy5jcm9zc09yaWdpbixcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgIHByb2plY3Rpb246IHByb2plY3Rpb24sXG4gICAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICAgIHRpbGVHcmlkOiB0aWxlR3JpZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHRpbGVQaXhlbFJhdGlvOiBvcHRpb25zLnRpbGVQaXhlbFJhdGlvLFxuICAgICAgdGlsZVVybEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbixcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICB1cmxzOiBvcHRpb25zLnVybHMsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IHRydWUsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSxcbiAgICAgIHpEaXJlY3Rpb246IG9wdGlvbnMuekRpcmVjdGlvbixcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmd1dHRlcl8gPSBvcHRpb25zLmd1dHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5ndXR0ZXIgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgZ2V0R3V0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLmd1dHRlcl87XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWFlaO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvT1NNXG4gKi9cblxuaW1wb3J0IFhZWiBmcm9tICcuL1hZWi5qcyc7XG5cbi8qKlxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRhaW5pbmcgYSBsaW5rIHRvIHRoZSBPcGVuU3RyZWV0TWFwIENvcHlyaWdodCBhbmQgTGljZW5zZVxuICogcGFnZS5cbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IEFUVFJJQlVUSU9OID1cbiAgJyYjMTY5OyAnICtcbiAgJzxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5PcGVuU3RyZWV0TWFwPC9hPiAnICtcbiAgJ2NvbnRyaWJ1dG9ycy4nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gSW5pdGlhbCB0aWxlIGNhY2hlIHNpemUuIFdpbGwgYXV0by1ncm93IHRvIGhvbGQgYXQgbGVhc3QgdGhlIG51bWJlciBvZiB0aWxlcyBpbiB0aGUgdmlld3BvcnQuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW49J2Fub255bW91cyddIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPXRydWVdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy4gIFNldCB0byBmYWxzZSB0byB1c2UgdGhlIG5lYXJlc3QgbmVpZ2hib3IgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT0xOV0gTWF4IHpvb20uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9dHJ1ZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsPSdodHRwczovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJ10gVVJMIHRlbXBsYXRlLlxuICogTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF1cbiAqIENob29zZSB3aGV0aGVyIHRvIHVzZSB0aWxlcyB3aXRoIGEgaGlnaGVyIG9yIGxvd2VyIHpvb20gbGV2ZWwgd2hlbiBiZXR3ZWVuIGludGVnZXJcbiAqIHpvb20gbGV2ZWxzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5UaWxlR3JpZCNnZXRaRm9yUmVzb2x1dGlvbn0uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRoZSBPcGVuU3RyZWV0TWFwIHRpbGUgc2VydmVyLlxuICogQGFwaVxuICovXG5jbGFzcyBPU00gZXh0ZW5kcyBYWVoge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3BlbiBTdHJlZXQgTWFwIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBsZXQgYXR0cmlidXRpb25zO1xuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGlvbnMgPSBvcHRpb25zLmF0dHJpYnV0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRpb25zID0gW0FUVFJJQlVUSU9OXTtcbiAgICB9XG5cbiAgICBjb25zdCBjcm9zc09yaWdpbiA9XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNyb3NzT3JpZ2luIDogJ2Fub255bW91cyc7XG5cbiAgICBjb25zdCB1cmwgPVxuICAgICAgb3B0aW9ucy51cmwgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudXJsXG4gICAgICAgIDogJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnO1xuXG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBhdHRyaWJ1dGlvbnMsXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogZmFsc2UsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4Wm9vbSA6IDE5LFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFxdWUgOiB0cnVlLFxuICAgICAgcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ6IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgekRpcmVjdGlvbjogb3B0aW9ucy56RGlyZWN0aW9uLFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9TTTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvQmFzZVRpbGVcbiAqL1xuaW1wb3J0IExheWVyIGZyb20gJy4vTGF5ZXIuanMnO1xuaW1wb3J0IFRpbGVQcm9wZXJ0eSBmcm9tICcuL1RpbGVQcm9wZXJ0eS5qcyc7XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfFxuICogICAgIGltcG9ydChcIi4vTGF5ZXIuanNcIikuTGF5ZXJFdmVudFR5cGV8J2NoYW5nZTpwcmVsb2FkJ3wnY2hhbmdlOnVzZUludGVyaW1UaWxlc09uRXJyb3InLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL3JlbmRlci9FdmVudFR5cGVcIikuTGF5ZXJSZW5kZXJFdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi9CYXNlXCIpLkJhc2VMYXllck9iamVjdEV2ZW50VHlwZXN8XG4gKiAgIGltcG9ydChcIi4vTGF5ZXIuanNcIikuTGF5ZXJFdmVudFR5cGV8J2NoYW5nZTpwcmVsb2FkJ3wnY2hhbmdlOnVzZUludGVyaW1UaWxlc09uRXJyb3InfGltcG9ydChcIi4uL3JlbmRlci9FdmVudFR5cGVcIikuTGF5ZXJSZW5kZXJFdmVudFR5cGVzLCBSZXR1cm4+fSBCYXNlVGlsZUxheWVyT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZVNvdXJjZVR5cGVcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1sYXllciddIEEgQ1NTIGNsYXNzIG5hbWUgdG8gc2V0IHRvIHRoZSBsYXllciBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIFRoZSBtaW5pbXVtIHZpZXcgem9vbSBsZXZlbCAoZXhjbHVzaXZlKSBhYm92ZSB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIFRoZSBtYXhpbXVtIHZpZXcgem9vbSBsZXZlbCAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZWxvYWQ9MF0gUHJlbG9hZC4gTG9hZCBsb3ctcmVzb2x1dGlvbiB0aWxlcyB1cCB0byBgcHJlbG9hZGAgbGV2ZWxzLiBgMGBcbiAqIG1lYW5zIG5vIHByZWxvYWRpbmcuXG4gKiBAcHJvcGVydHkge1RpbGVTb3VyY2VUeXBlfSBbc291cmNlXSBTb3VyY2UgZm9yIHRoaXMgbGF5ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBbbWFwXSBTZXRzIHRoZSBsYXllciBhcyBvdmVybGF5IG9uIGEgbWFwLiBUaGUgbWFwIHdpbGwgbm90IG1hbmFnZVxuICogdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24sIGFuZCB0aGUgbGF5ZXIgd2lsbCBiZSByZW5kZXJlZCBvbiB0b3AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICogdGVtcG9yYXJ5IGxheWVycy4gVGhlIHN0YW5kYXJkIHdheSB0byBhZGQgYSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAgaXMgdG9cbiAqIHVzZSB7QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHQjYWRkTGF5ZXIgbWFwLmFkZExheWVyKCl9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXNlSW50ZXJpbVRpbGVzT25FcnJvcj10cnVlXSBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGb3IgbGF5ZXIgc291cmNlcyB0aGF0IHByb3ZpZGUgcHJlLXJlbmRlcmVkLCB0aWxlZCBpbWFnZXMgaW4gZ3JpZHMgdGhhdCBhcmVcbiAqIG9yZ2FuaXplZCBieSB6b29tIGxldmVscyBmb3Igc3BlY2lmaWMgcmVzb2x1dGlvbnMuXG4gKiBOb3RlIHRoYXQgYW55IHByb3BlcnR5IHNldCBpbiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fVxuICogcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdDsgZm9yIGV4YW1wbGUsIHNldHRpbmcgYHRpdGxlOiAnTXkgVGl0bGUnYCBpbiB0aGVcbiAqIG9wdGlvbnMgbWVhbnMgdGhhdCBgdGl0bGVgIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlU291cmNlVHlwZVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9yZW5kZXJlci9MYXllci5qc1wiKS5kZWZhdWx0fSBSZW5kZXJlclR5cGVcbiAqIEBleHRlbmRzIHtMYXllcjxUaWxlU291cmNlVHlwZSwgUmVuZGVyZXJUeXBlPn1cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQmFzZVRpbGVMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uczxUaWxlU291cmNlVHlwZT59IFtvcHRpb25zXSBUaWxlIGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBiYXNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnByZWxvYWQ7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3I7XG4gICAgc3VwZXIoYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtCYXNlVGlsZUxheWVyT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZVRpbGVMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZVRpbGVMYXllck9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICB0aGlzLnNldFByZWxvYWQob3B0aW9ucy5wcmVsb2FkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnByZWxvYWQgOiAwKTtcbiAgICB0aGlzLnNldFVzZUludGVyaW1UaWxlc09uRXJyb3IoXG4gICAgICBvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudXNlSW50ZXJpbVRpbGVzT25FcnJvclxuICAgICAgICA6IHRydWVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGV2ZWwgYXMgbnVtYmVyIHRvIHdoaWNoIHdlIHdpbGwgcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGV2ZWwgdG8gcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJlbG9hZCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChUaWxlUHJvcGVydHkuUFJFTE9BRCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGV2ZWwgYXMgbnVtYmVyIHRvIHdoaWNoIHdlIHdpbGwgcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWxvYWQgVGhlIGxldmVsIHRvIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFByZWxvYWQocHJlbG9hZCkge1xuICAgIHRoaXMuc2V0KFRpbGVQcm9wZXJ0eS5QUkVMT0FELCBwcmVsb2FkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoXG4gICAgICB0aGlzLmdldChUaWxlUHJvcGVydHkuVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1IpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB3ZSB1c2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VJbnRlcmltVGlsZXNPbkVycm9yIFVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKHVzZUludGVyaW1UaWxlc09uRXJyb3IpIHtcbiAgICB0aGlzLnNldChUaWxlUHJvcGVydHkuVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1IsIHVzZUludGVyaW1UaWxlc09uRXJyb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGZvciBhIHBpeGVsIGxvY2F0aW9uLiAgVGhlIHJldHVybiB0eXBlIGRlcGVuZHMgb24gdGhlIHNvdXJjZSBkYXRhLiAgRm9yIGltYWdlIHRpbGVzLFxuICAgKiBhIGZvdXIgZWxlbWVudCBSR0JBIGFycmF5IHdpbGwgYmUgcmV0dXJuZWQuICBGb3IgZGF0YSB0aWxlcywgdGhlIGFycmF5IGxlbmd0aCB3aWxsIG1hdGNoIHRoZVxuICAgKiBudW1iZXIgb2YgYmFuZHMgaW4gdGhlIGRhdGFzZXQuICBGb3IgcmVxdWVzdHMgb3V0c2lkZSB0aGUgbGF5ZXIgZXh0ZW50LCBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogRGF0YSBmb3IgYSBpbWFnZSB0aWxlcyBjYW4gb25seSBiZSByZXRyaWV2ZWQgaWYgdGhlIHNvdXJjZSdzIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgaXMgc2V0LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBkaXNwbGF5IGxheWVyIGRhdGEgb24gZXZlcnkgcG9pbnRlciBtb3ZlXG4gICAqIG1hcC5vbigncG9pbnRlcm1vdmUnLCAoZXZlbnQpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhsYXllci5nZXREYXRhKGV2ZW50LnBpeGVsKSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbFwiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fFVpbnQ4QXJyYXl8RmxvYXQzMkFycmF5fERhdGFWaWV3fG51bGx9IFBpeGVsIGRhdGEuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RGF0YShwaXhlbCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVRpbGVMYXllcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVGlsZVByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSRUxPQUQ6ICdwcmVsb2FkJyxcbiAgVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1I6ICd1c2VJbnRlcmltVGlsZXNPbkVycm9yJyxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uLy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi8uLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlIGZyb20gJy4uLy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uLy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge1xuICBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSxcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxuICBtYWtlSW52ZXJzZSxcbiAgdG9TdHJpbmcgYXMgdG9UcmFuc2Zvcm1TdHJpbmcsXG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2FzY2VuZGluZ30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtcbiAgY29udGFpbnNDb29yZGluYXRlLFxuICBjcmVhdGVFbXB0eSxcbiAgZXF1YWxzLFxuICBnZXRIZWlnaHQsXG4gIGdldEludGVyc2VjdGlvbixcbiAgZ2V0Um90YXRlZFZpZXdwb3J0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRXaWR0aCxcbiAgaW50ZXJzZWN0cyxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZnJvbVVzZXJFeHRlbnR9IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uLy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdGlsZSBsYXllcnMuXG4gKiBAYXBpXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0PnxpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9IFtMYXllclR5cGU9aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHQ+fGltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdF1cbiAqIEBleHRlbmRzIHtDYW52YXNMYXllclJlbmRlcmVyPExheWVyVHlwZT59XG4gKi9cbmNsYXNzIENhbnZhc1RpbGVMYXllclJlbmRlcmVyIGV4dGVuZHMgQ2FudmFzTGF5ZXJSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xheWVyVHlwZX0gdGlsZUxheWVyIFRpbGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlTGF5ZXIpIHtcbiAgICBzdXBlcih0aWxlTGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyZWQgZXh0ZW50IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBwcmV2aW91cyBgcmVuZGVyRnJhbWUoKWAgY2FsbFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50Q2hhbmdlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb24gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXk8aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVGlsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5uZXdUaWxlc18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFRpbGVSYW5nZV8gPSBuZXcgVGlsZVJhbmdlKDAsIDAsIDAsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBpcyBkcmF3YWJsZS5cbiAgICovXG4gIGlzRHJhd2FibGVUaWxlKHRpbGUpIHtcbiAgICBjb25zdCB0aWxlTGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgY29uc3QgdGlsZVN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHVzZUludGVyaW1UaWxlc09uRXJyb3IgPSB0aWxlTGF5ZXIuZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpO1xuICAgIHJldHVybiAoXG4gICAgICB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWSB8fFxuICAgICAgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgJiYgIXVzZUludGVyaW1UaWxlc09uRXJyb3IpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlLlxuICAgKi9cbiAgZ2V0VGlsZSh6LCB4LCB5LCBmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICBjb25zdCB0aWxlTGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgY29uc3QgdGlsZVNvdXJjZSA9IHRpbGVMYXllci5nZXRTb3VyY2UoKTtcbiAgICBsZXQgdGlsZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5FUlJPUikge1xuICAgICAgaWYgKHRpbGVMYXllci5nZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKCkgJiYgdGlsZUxheWVyLmdldFByZWxvYWQoKSA+IDApIHtcbiAgICAgICAgLy8gUHJlbG9hZGVkIHRpbGVzIGZvciBsb3dlciByZXNvbHV0aW9ucyBtaWdodCBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgIHRoaXMubmV3VGlsZXNfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRHJhd2FibGVUaWxlKHRpbGUpKSB7XG4gICAgICB0aWxlID0gdGlsZS5nZXRJbnRlcmltVGlsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl9IERhdGEgYXQgdGhlIHBpeGVsIGxvY2F0aW9uLlxuICAgKi9cbiAgZ2V0RGF0YShwaXhlbCkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGU7XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBjb25zdCBjb29yZGluYXRlID0gYXBwbHlUcmFuc2Zvcm0oXG4gICAgICBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLFxuICAgICAgcGl4ZWwuc2xpY2UoKVxuICAgICk7XG5cbiAgICBjb25zdCBsYXllckV4dGVudCA9IGxheWVyLmdldEV4dGVudCgpO1xuICAgIGlmIChsYXllckV4dGVudCkge1xuICAgICAgaWYgKCFjb250YWluc0Nvb3JkaW5hdGUobGF5ZXJFeHRlbnQsIGNvb3JkaW5hdGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3Qgc291cmNlID0gbGF5ZXIuZ2V0UmVuZGVyU291cmNlKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHZpZXdTdGF0ZS5wcm9qZWN0aW9uKTtcbiAgICBjb25zdCB0aWxlUGl4ZWxSYXRpbyA9IHNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhmcmFtZVN0YXRlLnBpeGVsUmF0aW8pO1xuXG4gICAgZm9yIChcbiAgICAgIGxldCB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24odmlld1N0YXRlLnJlc29sdXRpb24pO1xuICAgICAgeiA+PSB0aWxlR3JpZC5nZXRNaW5ab29tKCk7XG4gICAgICAtLXpcbiAgICApIHtcbiAgICAgIGNvbnN0IHRpbGVDb29yZCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjb29yZGluYXRlLCB6KTtcbiAgICAgIGNvbnN0IHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShcbiAgICAgICAgeixcbiAgICAgICAgdGlsZUNvb3JkWzFdLFxuICAgICAgICB0aWxlQ29vcmRbMl0sXG4gICAgICAgIHBpeGVsUmF0aW8sXG4gICAgICAgIHByb2plY3Rpb25cbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgICEodGlsZSBpbnN0YW5jZW9mIEltYWdlVGlsZSB8fCB0aWxlIGluc3RhbmNlb2YgUmVwcm9qVGlsZSkgfHxcbiAgICAgICAgKHRpbGUgaW5zdGFuY2VvZiBSZXByb2pUaWxlICYmIHRpbGUuZ2V0U3RhdGUoKSA9PT0gVGlsZVN0YXRlLkVNUFRZKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpICE9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aWxlT3JpZ2luID0gdGlsZUdyaWQuZ2V0T3JpZ2luKHopO1xuICAgICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGlsZUdyaWQuZ2V0VGlsZVNpemUoeikpO1xuICAgICAgY29uc3QgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuXG4gICAgICBjb25zdCBjb2wgPSBNYXRoLmZsb29yKFxuICAgICAgICB0aWxlUGl4ZWxSYXRpbyAqXG4gICAgICAgICAgKChjb29yZGluYXRlWzBdIC0gdGlsZU9yaWdpblswXSkgLyB0aWxlUmVzb2x1dGlvbiAtXG4gICAgICAgICAgICB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoXG4gICAgICAgIHRpbGVQaXhlbFJhdGlvICpcbiAgICAgICAgICAoKHRpbGVPcmlnaW5bMV0gLSBjb29yZGluYXRlWzFdKSAvIHRpbGVSZXNvbHV0aW9uIC1cbiAgICAgICAgICAgIHRpbGVDb29yZFsyXSAqIHRpbGVTaXplWzFdKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZ3V0dGVyID0gTWF0aC5yb3VuZChcbiAgICAgICAgdGlsZVBpeGVsUmF0aW8gKiBzb3VyY2UuZ2V0R3V0dGVyRm9yUHJvamVjdGlvbih2aWV3U3RhdGUucHJvamVjdGlvbilcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmdldEltYWdlRGF0YSh0aWxlLmdldEltYWdlKCksIGNvbCArIGd1dHRlciwgcm93ICsgZ3V0dGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdD4+fSB0aWxlcyBMb29rdXAgb2YgbG9hZGVkIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dm9pZH0gSWYgYGZhbHNlYCwgdGhlIHRpbGUgd2lsbCBub3QgYmUgY29uc2lkZXJlZCBsb2FkZWQuXG4gICAqL1xuICBsb2FkZWRUaWxlQ2FsbGJhY2sodGlsZXMsIHpvb20sIHRpbGUpIHtcbiAgICBpZiAodGhpcy5pc0RyYXdhYmxlVGlsZSh0aWxlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmxvYWRlZFRpbGVDYWxsYmFjayh0aWxlcywgem9vbSwgdGlsZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciByZW5kZXIgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gTGF5ZXIgaXMgcmVhZHkgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBwcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgdG8uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgcmVuZGVyZWQgZWxlbWVudC5cbiAgICovXG4gIHJlbmRlckZyYW1lKGZyYW1lU3RhdGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGxheWVyU3RhdGUgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXlbZnJhbWVTdGF0ZS5sYXllckluZGV4XTtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3Qgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCB2aWV3Q2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuXG4gICAgY29uc3QgdGlsZUxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGNvbnN0IHRpbGVTb3VyY2UgPSB0aWxlTGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgY29uc3Qgc291cmNlUmV2aXNpb24gPSB0aWxlU291cmNlLmdldFJldmlzaW9uKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSB0aWxlU291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBjb25zdCB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24odmlld1Jlc29sdXRpb24sIHRpbGVTb3VyY2UuekRpcmVjdGlvbik7XG4gICAgY29uc3QgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuXG4gICAgbGV0IGV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgICAvLyBkZXNpcmVkIGRpbWVuc2lvbnMgb2YgdGhlIGNhbnZhcyBpbiBwaXhlbHNcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoKGdldFdpZHRoKGV4dGVudCkgLyByZXNvbHV0aW9uKSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoKGdldEhlaWdodChleHRlbnQpIC8gcmVzb2x1dGlvbikgKiBwaXhlbFJhdGlvKTtcblxuICAgIGNvbnN0IGxheWVyRXh0ZW50ID1cbiAgICAgIGxheWVyU3RhdGUuZXh0ZW50ICYmIGZyb21Vc2VyRXh0ZW50KGxheWVyU3RhdGUuZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICBpZiAobGF5ZXJFeHRlbnQpIHtcbiAgICAgIGV4dGVudCA9IGdldEludGVyc2VjdGlvbihcbiAgICAgICAgZXh0ZW50LFxuICAgICAgICBmcm9tVXNlckV4dGVudChsYXllclN0YXRlLmV4dGVudCwgcHJvamVjdGlvbilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZHggPSAodGlsZVJlc29sdXRpb24gKiB3aWR0aCkgLyAyIC8gdGlsZVBpeGVsUmF0aW87XG4gICAgY29uc3QgZHkgPSAodGlsZVJlc29sdXRpb24gKiBoZWlnaHQpIC8gMiAvIHRpbGVQaXhlbFJhdGlvO1xuICAgIGNvbnN0IGNhbnZhc0V4dGVudCA9IFtcbiAgICAgIHZpZXdDZW50ZXJbMF0gLSBkeCxcbiAgICAgIHZpZXdDZW50ZXJbMV0gLSBkeSxcbiAgICAgIHZpZXdDZW50ZXJbMF0gKyBkeCxcbiAgICAgIHZpZXdDZW50ZXJbMV0gKyBkeSxcbiAgICBdO1xuXG4gICAgY29uc3QgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdD4+fVxuICAgICAqL1xuICAgIGNvbnN0IHRpbGVzVG9EcmF3QnlaID0ge307XG4gICAgdGlsZXNUb0RyYXdCeVpbel0gPSB7fTtcblxuICAgIGNvbnN0IGZpbmRMb2FkZWRUaWxlcyA9IHRoaXMuY3JlYXRlTG9hZGVkVGlsZUZpbmRlcihcbiAgICAgIHRpbGVTb3VyY2UsXG4gICAgICBwcm9qZWN0aW9uLFxuICAgICAgdGlsZXNUb0RyYXdCeVpcbiAgICApO1xuXG4gICAgY29uc3QgdG1wRXh0ZW50ID0gdGhpcy50bXBFeHRlbnQ7XG4gICAgY29uc3QgdG1wVGlsZVJhbmdlID0gdGhpcy50bXBUaWxlUmFuZ2VfO1xuICAgIHRoaXMubmV3VGlsZXNfID0gZmFsc2U7XG4gICAgY29uc3Qgdmlld3BvcnQgPSByb3RhdGlvblxuICAgICAgPyBnZXRSb3RhdGVkVmlld3BvcnQoXG4gICAgICAgICAgdmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGZyYW1lU3RhdGUuc2l6ZVxuICAgICAgICApXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCB4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgICAgZm9yIChsZXQgeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJvdGF0aW9uICYmXG4gICAgICAgICAgIXRpbGVHcmlkLnRpbGVDb29yZEludGVyc2VjdHNWaWV3cG9ydChbeiwgeCwgeV0sIHZpZXdwb3J0KVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5nZXRUaWxlKHosIHgsIHksIGZyYW1lU3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5pc0RyYXdhYmxlVGlsZSh0aWxlKSkge1xuICAgICAgICAgIGNvbnN0IHVpZCA9IGdldFVpZCh0aGlzKTtcbiAgICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICAgIHRpbGVzVG9EcmF3QnlaW3pdW3RpbGUudGlsZUNvb3JkLnRvU3RyaW5nKCldID0gdGlsZTtcbiAgICAgICAgICAgIGxldCBpblRyYW5zaXRpb24gPSB0aWxlLmluVHJhbnNpdGlvbih1aWQpO1xuICAgICAgICAgICAgaWYgKGluVHJhbnNpdGlvbiAmJiBsYXllclN0YXRlLm9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gU2tpcHBpbmcgdHJhbnNpdGlvbiB3aGVuIGxheWVyIGlzIG5vdCBmdWxseSBvcGFxdWUgYXZvaWRzIHZpc3VhbCBhcnRpZmFjdHMuXG4gICAgICAgICAgICAgIHRpbGUuZW5kVHJhbnNpdGlvbih1aWQpO1xuICAgICAgICAgICAgICBpblRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXRoaXMubmV3VGlsZXNfICYmXG4gICAgICAgICAgICAgIChpblRyYW5zaXRpb24gfHwgIXRoaXMucmVuZGVyZWRUaWxlcy5pbmNsdWRlcyh0aWxlKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLm5ld1RpbGVzXyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aWxlLmdldEFscGhhKHVpZCwgZnJhbWVTdGF0ZS50aW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgbG9vayBmb3IgYWx0IHRpbGVzIGlmIGFscGhhIGlzIDFcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkVGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UoXG4gICAgICAgICAgdGlsZS50aWxlQ29vcmQsXG4gICAgICAgICAgdG1wVGlsZVJhbmdlLFxuICAgICAgICAgIHRtcEV4dGVudFxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGlsZFRpbGVSYW5nZSkge1xuICAgICAgICAgIGNvdmVyZWQgPSBmaW5kTG9hZGVkVGlsZXMoeiArIDEsIGNoaWxkVGlsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvdmVyZWQpIHtcbiAgICAgICAgICB0aWxlR3JpZC5mb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlKFxuICAgICAgICAgICAgdGlsZS50aWxlQ29vcmQsXG4gICAgICAgICAgICBmaW5kTG9hZGVkVGlsZXMsXG4gICAgICAgICAgICB0bXBUaWxlUmFuZ2UsXG4gICAgICAgICAgICB0bXBFeHRlbnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzU2NhbGUgPVxuICAgICAgKCh0aWxlUmVzb2x1dGlvbiAvIHZpZXdSZXNvbHV0aW9uKSAqIHBpeGVsUmF0aW8pIC8gdGlsZVBpeGVsUmF0aW87XG5cbiAgICAvLyBzZXQgZm9yd2FyZCBhbmQgaW52ZXJzZSBwaXhlbCB0cmFuc2Zvcm1zXG4gICAgY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIHRoaXMucGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBmcmFtZVN0YXRlLnNpemVbMF0gLyAyLFxuICAgICAgZnJhbWVTdGF0ZS5zaXplWzFdIC8gMixcbiAgICAgIDEgLyBwaXhlbFJhdGlvLFxuICAgICAgMSAvIHBpeGVsUmF0aW8sXG4gICAgICByb3RhdGlvbixcbiAgICAgIC13aWR0aCAvIDIsXG4gICAgICAtaGVpZ2h0IC8gMlxuICAgICk7XG5cbiAgICBjb25zdCBjYW52YXNUcmFuc2Zvcm0gPSB0b1RyYW5zZm9ybVN0cmluZyh0aGlzLnBpeGVsVHJhbnNmb3JtKTtcblxuICAgIHRoaXMudXNlQ29udGFpbmVyKHRhcmdldCwgY2FudmFzVHJhbnNmb3JtLCB0aGlzLmdldEJhY2tncm91bmQoZnJhbWVTdGF0ZSkpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG5cbiAgICBtYWtlSW52ZXJzZSh0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSwgdGhpcy5waXhlbFRyYW5zZm9ybSk7XG5cbiAgICAvLyBzZXQgc2NhbGUgdHJhbnNmb3JtIGZvciBjYWxjdWxhdGluZyB0aWxlIHBvc2l0aW9ucyBvbiB0aGUgY2FudmFzXG4gICAgY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIHRoaXMudGVtcFRyYW5zZm9ybSxcbiAgICAgIHdpZHRoIC8gMixcbiAgICAgIGhlaWdodCAvIDIsXG4gICAgICBjYW52YXNTY2FsZSxcbiAgICAgIGNhbnZhc1NjYWxlLFxuICAgICAgMCxcbiAgICAgIC13aWR0aCAvIDIsXG4gICAgICAtaGVpZ2h0IC8gMlxuICAgICk7XG5cbiAgICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChsYXllckV4dGVudCkge1xuICAgICAgdGhpcy5jbGlwVW5yb3RhdGVkKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyRXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIXRpbGVTb3VyY2UuZ2V0SW50ZXJwb2xhdGUoKSkge1xuICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZVJlbmRlcihjb250ZXh0LCBmcmFtZVN0YXRlKTtcblxuICAgIHRoaXMucmVuZGVyZWRUaWxlcy5sZW5ndGggPSAwO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBsZXQgenMgPSBPYmplY3Qua2V5cyh0aWxlc1RvRHJhd0J5WikubWFwKE51bWJlcik7XG4gICAgenMuc29ydChhc2NlbmRpbmcpO1xuXG4gICAgbGV0IGNsaXBzLCBjbGlwWnMsIGN1cnJlbnRDbGlwO1xuICAgIGlmIChcbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSA9PT0gMSAmJlxuICAgICAgKCF0aGlzLmNvbnRhaW5lclJldXNlZCB8fFxuICAgICAgICB0aWxlU291cmNlLmdldE9wYXF1ZShmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uKSlcbiAgICApIHtcbiAgICAgIHpzID0genMucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwcyA9IFtdO1xuICAgICAgY2xpcFpzID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB6cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgY3VycmVudFogPSB6c1tpXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaWxlUGl4ZWxTaXplID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxTaXplKFxuICAgICAgICBjdXJyZW50WixcbiAgICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgICAgcHJvamVjdGlvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbihjdXJyZW50Wik7XG4gICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSBjdXJyZW50UmVzb2x1dGlvbiAvIHRpbGVSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgZHggPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVswXSAqIGN1cnJlbnRTY2FsZSAqIGNhbnZhc1NjYWxlO1xuICAgICAgY29uc3QgZHkgPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVsxXSAqIGN1cnJlbnRTY2FsZSAqIGNhbnZhc1NjYWxlO1xuICAgICAgY29uc3Qgb3JpZ2luVGlsZUNvb3JkID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKFxuICAgICAgICBnZXRUb3BMZWZ0KGNhbnZhc0V4dGVudCksXG4gICAgICAgIGN1cnJlbnRaXG4gICAgICApO1xuICAgICAgY29uc3Qgb3JpZ2luVGlsZUV4dGVudCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChvcmlnaW5UaWxlQ29vcmQpO1xuICAgICAgY29uc3Qgb3JpZ2luID0gYXBwbHlUcmFuc2Zvcm0odGhpcy50ZW1wVHJhbnNmb3JtLCBbXG4gICAgICAgICh0aWxlUGl4ZWxSYXRpbyAqIChvcmlnaW5UaWxlRXh0ZW50WzBdIC0gY2FudmFzRXh0ZW50WzBdKSkgL1xuICAgICAgICAgIHRpbGVSZXNvbHV0aW9uLFxuICAgICAgICAodGlsZVBpeGVsUmF0aW8gKiAoY2FudmFzRXh0ZW50WzNdIC0gb3JpZ2luVGlsZUV4dGVudFszXSkpIC9cbiAgICAgICAgICB0aWxlUmVzb2x1dGlvbixcbiAgICAgIF0pO1xuICAgICAgY29uc3QgdGlsZUd1dHRlciA9XG4gICAgICAgIHRpbGVQaXhlbFJhdGlvICogdGlsZVNvdXJjZS5nZXRHdXR0ZXJGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgY29uc3QgdGlsZXNUb0RyYXcgPSB0aWxlc1RvRHJhd0J5WltjdXJyZW50Wl07XG4gICAgICBmb3IgKGNvbnN0IHRpbGVDb29yZEtleSBpbiB0aWxlc1RvRHJhdykge1xuICAgICAgICBjb25zdCB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIHRpbGVzVG9EcmF3W3RpbGVDb29yZEtleV1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdGlsZUNvb3JkID0gdGlsZS50aWxlQ29vcmQ7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGludGVnZXIgcG9zaXRpb25zIGFuZCBzaXplcyBzbyB0aGF0IHRpbGVzIGFsaWduXG4gICAgICAgIGNvbnN0IHhJbmRleCA9IG9yaWdpblRpbGVDb29yZFsxXSAtIHRpbGVDb29yZFsxXTtcbiAgICAgICAgY29uc3QgbmV4dFggPSBNYXRoLnJvdW5kKG9yaWdpblswXSAtICh4SW5kZXggLSAxKSAqIGR4KTtcbiAgICAgICAgY29uc3QgeUluZGV4ID0gb3JpZ2luVGlsZUNvb3JkWzJdIC0gdGlsZUNvb3JkWzJdO1xuICAgICAgICBjb25zdCBuZXh0WSA9IE1hdGgucm91bmQob3JpZ2luWzFdIC0gKHlJbmRleCAtIDEpICogZHkpO1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChvcmlnaW5bMF0gLSB4SW5kZXggKiBkeCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKG9yaWdpblsxXSAtIHlJbmRleCAqIGR5KTtcbiAgICAgICAgY29uc3QgdyA9IG5leHRYIC0geDtcbiAgICAgICAgY29uc3QgaCA9IG5leHRZIC0geTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHogPT09IGN1cnJlbnRaO1xuXG4gICAgICAgIGNvbnN0IGluVHJhbnNpdGlvbiA9XG4gICAgICAgICAgdHJhbnNpdGlvbiAmJiB0aWxlLmdldEFscGhhKGdldFVpZCh0aGlzKSwgZnJhbWVTdGF0ZS50aW1lKSAhPT0gMTtcbiAgICAgICAgbGV0IGNvbnRleHRTYXZlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWluVHJhbnNpdGlvbikge1xuICAgICAgICAgIGlmIChjbGlwcykge1xuICAgICAgICAgICAgLy8gQ2xpcCBtYXNrIGZvciByZWdpb25zIGluIHRoaXMgdGlsZSB0aGF0IGFscmVhZHkgZmlsbGVkIGJ5IGEgaGlnaGVyIHogdGlsZVxuICAgICAgICAgICAgY3VycmVudENsaXAgPSBbeCwgeSwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgeCwgeSArIGhdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2xpcHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoeiAhPT0gY3VycmVudFogJiYgY3VycmVudFogPCBjbGlwWnNbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhcbiAgICAgICAgICAgICAgICAgICAgW3gsIHksIHggKyB3LCB5ICsgaF0sXG4gICAgICAgICAgICAgICAgICAgIFtjbGlwWzBdLCBjbGlwWzNdLCBjbGlwWzRdLCBjbGlwWzddXVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0U2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRTYXZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2UgKG91dGVyIHJpbmcpIGZvciBjdXJyZW50IHRpbGVcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGN1cnJlbnRDbGlwWzBdLCBjdXJyZW50Q2xpcFsxXSk7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFsyXSwgY3VycmVudENsaXBbM10pO1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbNF0sIGN1cnJlbnRDbGlwWzVdKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzZdLCBjdXJyZW50Q2xpcFs3XSk7XG4gICAgICAgICAgICAgICAgICAvLyBjbG9ja3dpc2UgKGlubmVyIHJpbmcpIGZvciBoaWdoZXIgeiB0aWxlXG4gICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjbGlwWzZdLCBjbGlwWzddKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbNF0sIGNsaXBbNV0pO1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFsyXSwgY2xpcFszXSk7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzBdLCBjbGlwWzFdKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpcHMucHVzaChjdXJyZW50Q2xpcCk7XG4gICAgICAgICAgICBjbGlwWnMucHVzaChjdXJyZW50Wik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdUaWxlSW1hZ2UoXG4gICAgICAgICAgdGlsZSxcbiAgICAgICAgICBmcmFtZVN0YXRlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgdGlsZUd1dHRlcixcbiAgICAgICAgICB0cmFuc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjbGlwcyAmJiAhaW5UcmFuc2l0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbnRleHRTYXZlZCkge1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy51bnNoaWZ0KHRpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy5wdXNoKHRpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVXNlZFRpbGVzKGZyYW1lU3RhdGUudXNlZFRpbGVzLCB0aWxlU291cmNlLCB0aWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb24gPSBzb3VyY2VSZXZpc2lvbjtcbiAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbiA9IHRpbGVSZXNvbHV0aW9uO1xuICAgIHRoaXMuZXh0ZW50Q2hhbmdlZCA9XG4gICAgICAhdGhpcy5yZW5kZXJlZEV4dGVudF8gfHwgIWVxdWFscyh0aGlzLnJlbmRlcmVkRXh0ZW50XywgY2FudmFzRXh0ZW50KTtcbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IGNhbnZhc0V4dGVudDtcbiAgICB0aGlzLnJlbmRlcmVkUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuXG4gICAgdGhpcy5tYW5hZ2VUaWxlUHlyYW1pZChcbiAgICAgIGZyYW1lU3RhdGUsXG4gICAgICB0aWxlU291cmNlLFxuICAgICAgdGlsZUdyaWQsXG4gICAgICBwaXhlbFJhdGlvLFxuICAgICAgcHJvamVjdGlvbixcbiAgICAgIGV4dGVudCxcbiAgICAgIHosXG4gICAgICB0aWxlTGF5ZXIuZ2V0UHJlbG9hZCgpXG4gICAgKTtcbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSk7XG5cbiAgICB0aGlzLnBvc3RSZW5kZXIoY29udGV4dCwgZnJhbWVTdGF0ZSk7XG5cbiAgICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQpIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG5cbiAgICBpZiAoY2FudmFzVHJhbnNmb3JtICE9PSBjYW52YXMuc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICBjYW52YXMuc3R5bGUudHJhbnNmb3JtID0gY2FudmFzVHJhbnNmb3JtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IExlZnQgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRvcCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGggb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBUaWxlIGd1dHRlci5cbiAgICogQHBhcmFtIHtib29sZWFufSB0cmFuc2l0aW9uIEFwcGx5IGFuIGFscGhhIHRyYW5zaXRpb24uXG4gICAqL1xuICBkcmF3VGlsZUltYWdlKHRpbGUsIGZyYW1lU3RhdGUsIHgsIHksIHcsIGgsIGd1dHRlciwgdHJhbnNpdGlvbikge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5nZXRUaWxlSW1hZ2UodGlsZSk7XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1aWQgPSBnZXRVaWQodGhpcyk7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheVtmcmFtZVN0YXRlLmxheWVySW5kZXhdO1xuICAgIGNvbnN0IGFscGhhID1cbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSAqXG4gICAgICAodHJhbnNpdGlvbiA/IHRpbGUuZ2V0QWxwaGEodWlkLCBmcmFtZVN0YXRlLnRpbWUpIDogMSk7XG4gICAgY29uc3QgYWxwaGFDaGFuZ2VkID0gYWxwaGEgIT09IHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICBpZiAoYWxwaGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBpbWFnZSxcbiAgICAgIGd1dHRlcixcbiAgICAgIGd1dHRlcixcbiAgICAgIGltYWdlLndpZHRoIC0gMiAqIGd1dHRlcixcbiAgICAgIGltYWdlLmhlaWdodCAtIDIgKiBndXR0ZXIsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHcsXG4gICAgICBoXG4gICAgKTtcblxuICAgIGlmIChhbHBoYUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChhbHBoYSAhPT0gbGF5ZXJTdGF0ZS5vcGFjaXR5KSB7XG4gICAgICBmcmFtZVN0YXRlLmFuaW1hdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdGlsZS5lbmRUcmFuc2l0aW9uKHVpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZVxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuY2FudmFzIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGZyb20gYSB0aWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gSW1hZ2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGVJbWFnZSh0aWxlKSB7XG4gICAgcmV0dXJuIHRpbGUuZ2V0SW1hZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNjaGVkdWxlRXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSkge1xuICAgIGlmICh0aWxlU291cmNlLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHBvc3RSZW5kZXJGdW5jdGlvbiA9IGZ1bmN0aW9uICh0aWxlU291cmNlLCBtYXAsIGZyYW1lU3RhdGUpIHtcbiAgICAgICAgY29uc3QgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICAgICAgaWYgKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS51c2VkVGlsZXMpIHtcbiAgICAgICAgICB0aWxlU291cmNlLmV4cGlyZUNhY2hlKFxuICAgICAgICAgICAgZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbixcbiAgICAgICAgICAgIGZyYW1lU3RhdGUudXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKG51bGwsIHRpbGVTb3VyY2UpO1xuXG4gICAgICBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMucHVzaChcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuUG9zdFJlbmRlckZ1bmN0aW9ufSAqLyAoXG4gICAgICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9UaWxlLmpzJykuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVVc2VkVGlsZXModXNlZFRpbGVzLCB0aWxlU291cmNlLCB0aWxlKSB7XG4gICAgLy8gRklYTUUgc2hvdWxkIHdlIHVzZSB0aWxlc1RvRHJhd0J5WiBpbnN0ZWFkP1xuICAgIGNvbnN0IHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgaWYgKCEodGlsZVNvdXJjZUtleSBpbiB1c2VkVGlsZXMpKSB7XG4gICAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV0gPSB7fTtcbiAgICB9XG4gICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldW3RpbGUuZ2V0S2V5KCldID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGlsZSBweXJhbWlkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGEgbnVtYmVyIG9mIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHRoZSB0aWxlcyBhdCB0aGVcbiAgICogY3VycmVudCB6b29tIGFuZCBsb3dlciB6b29tIGxldmVsczpcbiAgICogLSByZWdpc3RlcnMgaWRsZSB0aWxlcyBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzIHNvIHRoYXQgdGhleSBhcmUgbm90XG4gICAqICAgZGlzY2FyZGVkIGJ5IHRoZSB0aWxlIHF1ZXVlXG4gICAqIC0gZW5xdWV1ZXMgbWlzc2luZyB0aWxlc1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50WiBDdXJyZW50IFouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVsb2FkIExvYWQgbG93IHJlc29sdXRpb24gdGlsZXMgdXAgdG8gYHByZWxvYWRgIGxldmVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHQpOnZvaWR9IFt0aWxlQ2FsbGJhY2tdIFRpbGUgY2FsbGJhY2suXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG1hbmFnZVRpbGVQeXJhbWlkKFxuICAgIGZyYW1lU3RhdGUsXG4gICAgdGlsZVNvdXJjZSxcbiAgICB0aWxlR3JpZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIHByb2plY3Rpb24sXG4gICAgZXh0ZW50LFxuICAgIGN1cnJlbnRaLFxuICAgIHByZWxvYWQsXG4gICAgdGlsZUNhbGxiYWNrXG4gICkge1xuICAgIGNvbnN0IHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgaWYgKCEodGlsZVNvdXJjZUtleSBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzKSkge1xuICAgICAgZnJhbWVTdGF0ZS53YW50ZWRUaWxlc1t0aWxlU291cmNlS2V5XSA9IHt9O1xuICAgIH1cbiAgICBjb25zdCB3YW50ZWRUaWxlcyA9IGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV07XG4gICAgY29uc3QgdGlsZVF1ZXVlID0gZnJhbWVTdGF0ZS50aWxlUXVldWU7XG4gICAgY29uc3QgbWluWm9vbSA9IHRpbGVHcmlkLmdldE1pblpvb20oKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gcm90YXRpb25cbiAgICAgID8gZ2V0Um90YXRlZFZpZXdwb3J0KFxuICAgICAgICAgIGZyYW1lU3RhdGUudmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgICBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGZyYW1lU3RhdGUuc2l6ZVxuICAgICAgICApXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBsZXQgdGlsZUNvdW50ID0gMDtcbiAgICBsZXQgdGlsZSwgdGlsZVJhbmdlLCB0aWxlUmVzb2x1dGlvbiwgeCwgeSwgejtcbiAgICBmb3IgKHogPSBtaW5ab29tOyB6IDw9IGN1cnJlbnRaOyArK3opIHtcbiAgICAgIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6LCB0aWxlUmFuZ2UpO1xuICAgICAgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuICAgICAgZm9yICh4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgICAgICBmb3IgKHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcm90YXRpb24gJiZcbiAgICAgICAgICAgICF0aWxlR3JpZC50aWxlQ29vcmRJbnRlcnNlY3RzVmlld3BvcnQoW3osIHgsIHldLCB2aWV3cG9ydClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFogLSB6IDw9IHByZWxvYWQpIHtcbiAgICAgICAgICAgICsrdGlsZUNvdW50O1xuICAgICAgICAgICAgdGlsZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgICAgd2FudGVkVGlsZXNbdGlsZS5nZXRLZXkoKV0gPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoIXRpbGVRdWV1ZS5pc0tleVF1ZXVlZCh0aWxlLmdldEtleSgpKSkge1xuICAgICAgICAgICAgICAgIHRpbGVRdWV1ZS5lbnF1ZXVlKFtcbiAgICAgICAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICAgICAgICB0aWxlU291cmNlS2V5LFxuICAgICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGUudGlsZUNvb3JkKSxcbiAgICAgICAgICAgICAgICAgIHRpbGVSZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGlsZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGlsZUNhbGxiYWNrKHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlU291cmNlLnVzZVRpbGUoeiwgeCwgeSwgcHJvamVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRpbGVTb3VyY2UudXBkYXRlQ2FjaGVTaXplKHRpbGVDb3VudCwgcHJvamVjdGlvbik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1RpbGVcbiAqL1xuaW1wb3J0IEJhc2VUaWxlTGF5ZXIgZnJvbSAnLi9CYXNlVGlsZS5qcyc7XG5pbXBvcnQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgZnJvbSAnLi4vcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRm9yIGxheWVyIHNvdXJjZXMgdGhhdCBwcm92aWRlIHByZS1yZW5kZXJlZCwgdGlsZWQgaW1hZ2VzIGluIGdyaWRzIHRoYXQgYXJlXG4gKiBvcmdhbml6ZWQgYnkgem9vbSBsZXZlbHMgZm9yIHNwZWNpZmljIHJlc29sdXRpb25zLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZVNvdXJjZVR5cGVcbiAqIEBleHRlbmRzIEJhc2VUaWxlTGF5ZXI8VGlsZVNvdXJjZVR5cGUsIENhbnZhc1RpbGVMYXllclJlbmRlcmVyPlxuICogQGFwaVxuICovXG5jbGFzcyBUaWxlTGF5ZXIgZXh0ZW5kcyBCYXNlVGlsZUxheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9CYXNlVGlsZS5qc1wiKS5PcHRpb25zPFRpbGVTb3VyY2VUeXBlPn0gW29wdGlvbnNdIFRpbGUgbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIGNyZWF0ZVJlbmRlcmVyKCkge1xuICAgIHJldHVybiBuZXcgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIodGhpcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUxheWVyO1xuIiwgImltcG9ydCBNYXAgZnJvbSAnb2wvTWFwJ1xuaW1wb3J0IE1vdXNlUG9zaXRpb24gZnJvbSAnb2wvY29udHJvbC9Nb3VzZVBvc2l0aW9uJ1xuaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNJ1xuaW1wb3J0IFRpbGVMYXllciBmcm9tICdvbC9sYXllci9UaWxlJ1xuaW1wb3J0IFZpZXcgZnJvbSAnb2wvVmlldydcbmltcG9ydCB7IENvb3JkaW5hdGUsIGNyZWF0ZVN0cmluZ1hZIH0gZnJvbSAnb2wvY29vcmRpbmF0ZSdcbmltcG9ydCB7IGRlZmF1bHRzIGFzIGRlZmF1bHRDb250cm9scyB9IGZyb20gJ29sL2NvbnRyb2wnXG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnb2wnXG5pbXBvcnQgeyBmcm9tTG9uTGF0LCBQcm9qZWN0aW9uTGlrZSB9IGZyb20gJ29sL3Byb2onXG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJ29sL3NvdXJjZS9WZWN0b3InXG5pbXBvcnQgVmVjdG9yTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVmVjdG9yJ1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICdvbC9nZW9tJ1xuaW1wb3J0IEdlb2NvZGVyIGZyb20gJ29sLWdlb2NvZGVyJ1xuaW1wb3J0IHsgSWNvbiwgU3R5bGUgfSBmcm9tICdvbC9zdHlsZSdcblxuXG5jbGFzcyBtUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB2aWV3OiBWaWV3LCBwdWJsaWMgcHJvamVjdGlvbjogUHJvamVjdGlvbkxpa2UpIHtcbiAgICAgICAgYWxlcnQoJ21Qb2ludCcpXG4gICAgfVxuXG4gICAgcHVibGljIG9uQ2hhbmdlKGNhbGxiYWNrOiAobG9uOiBudW1iZXIsIGxhdDogbnVtYmVyKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMudmlldy5vbignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2xhdCwgbG9uXSA9IHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKVxuICAgICAgICAgICAgY2FsbGJhY2sobGF0LCBsb24pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHVibGljIGdldENvb3JkaW5hdGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldENlbnRlcigpXG4gICAgfVxuXG4gICAgcHVibGljIHNldENvb3JkaW5hdGVzKGxhdDogbnVtYmVyLCBsb246IG51bWJlcikge1xuICAgICAgICB0aGlzLnZpZXcuc2V0Q2VudGVyKGZyb21Mb25MYXQoW2xhdCwgbG9uXSwgdGhpcy5wcm9qZWN0aW9uKSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEdldFBvaW50TWFwKGlkOiBzdHJpbmcsIGxhdDogbnVtYmVyID0gMCwgbG9uOiBudW1iZXIgPSAwLHpvb206bnVtYmVyPTEwKXtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gJ0VQU0c6NDMyNidcblxuICAgIGNvbnN0IG1vdXNlUG9zaXRpb25Db250cm9sID0gbmV3IE1vdXNlUG9zaXRpb24oe1xuICAgICAgICBjb29yZGluYXRlRm9ybWF0OiBjcmVhdGVTdHJpbmdYWSg0KSxcbiAgICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvbixcbiAgICAgICAgY2xhc3NOYW1lOiBgbW91c2UtcG9zaXRpb24tJHtpZH1gLFxuICAgICAgICB0YXJnZXQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBPU01hcC0ke2lkfWApLFxuICAgIH0pXG4gICAgbGV0IHBvaW50ID0gbmV3IEZlYXR1cmUoe1xuICAgICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxuICAgICAgICBnZW9tZXRyeTogbmV3IFBvaW50KGZyb21Mb25MYXQoW2xhdCwgbG9uXSwgcHJvamVjdGlvbikpLFxuICAgIH0pXG4gICAgY29uc3QgdmVjdG9yU291cmNlID0gbmV3IFZlY3RvclNvdXJjZSh7XG4gICAgICAgIGZlYXR1cmVzOiBbcG9pbnRdLFxuICAgIH0pXG4gICAgY29uc3QgdmVjdG9yTGF5ZXIgPSBuZXcgVmVjdG9yTGF5ZXIoe1xuICAgICAgICBzb3VyY2U6IHZlY3RvclNvdXJjZSxcbiAgICB9KVxuICAgIGNvbnN0IE1hcExheWVyID0gbmV3IFRpbGVMYXllcih7XG4gICAgICAgIHNvdXJjZTogbmV3IE9TTSgpLFxuICAgIH0pXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYE9TTWFwLSR7aWR9YCk7XG5cbiAgICBjb25zdCB2aWV3ID0gbmV3IFZpZXcoe1xuICAgICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxuICAgICAgICBjZW50ZXI6IGZyb21Mb25MYXQoW2xhdCwgbG9uXSwgcHJvamVjdGlvbiksXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgfSlcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKHtcbiAgICAgICAgY29udHJvbHM6IGRlZmF1bHRDb250cm9scygpLmV4dGVuZChbbW91c2VQb3NpdGlvbkNvbnRyb2xdKSxcbiAgICAgICAgbGF5ZXJzOiBbXG4gICAgICAgICAgICBNYXBMYXllcixcbiAgICAgICAgICAgIHZlY3RvckxheWVyLFxuICAgICAgICBdLFxuICAgICAgICB0YXJnZXQ6dGFyZ2V0LFxuICAgICAgICB2aWV3OiB2aWV3LFxuICAgIH0pXG4vL2dldCBkb21haW4gZnJvbSB1cmwgaWYgdGhlcmUgaXMgYSBsYW5ndWFnZSBwcmVmaXggaW4gdGhlIHVybFxuICAgIGNvbnN0IGdlb2NvZGVyID0gbmV3IEdlb2NvZGVyKCdub21pbmF0aW0nLCB7XG4gICAgICAgIHByb3ZpZGVyOiAnb3NtJyxcbiAgICAgICAgbGltaXQ6IDUsXG4gICAgICAgIGtlZXBPcGVuOiB0cnVlLFxuICAgIH0pXG4gICAgbWFwLmFkZENvbnRyb2woZ2VvY29kZXIpXG4gICAgZ2VvY29kZXIub24oJ2FkZHJlc3NjaG9zZW4nLCBmdW5jdGlvbihldnQ6IGFueSkge1xuICAgICAgICBjb25zb2xlLmxvZyhldnQpXG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBldnQuZmVhdHVyZSBhcyBGZWF0dXJlPFBvaW50PlxuICAgICAgICBjb25zdCBjb29yZGluYXRlID0gZXZ0LmNvb3JkaW5hdGUgYXMgQ29vcmRpbmF0ZVxuICAgICAgICBmZWF0dXJlLnNldFN0eWxlKG5ldyBTdHlsZSh7XG4gICAgICAgICAgICBpbWFnZTogbmV3IEljb24oe1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnLFxuICAgICAgICAgICAgICAgIHNyYzogJ2h0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2V4YW1wbGVzL2RhdGEvZG90LnBuZycsXG4gICAgICAgICAgICAgICAgc2NhbGU6IDAuMDEsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSkpXG4gICAgICAgIC8vIGFwcGxpY2F0aW9uIHNwZWNpZmljXG4gICAgICAgIHZpZXcuc2V0Q2VudGVyKGZyb21Mb25MYXQoW2Nvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV1dLCBwcm9qZWN0aW9uKSlcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgICAvLyBcdTA0MUZcdTA0M0VcdTA0M0JcdTA0NDNcdTA0NDdcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDNEXHUwNDNFXHUwNDMyXHUwNDRCXHUwNDM1IFx1MDQzQVx1MDQzRVx1MDQzRVx1MDQ0MFx1MDQzNFx1MDQzOFx1MDQzRFx1MDQzMFx1MDQ0Mlx1MDQ0QiBcdTA0NDZcdTA0MzVcdTA0M0RcdTA0NDJcdTA0NDBcdTA0MzAgXHUwNDNBXHUwNDMwXHUwNDQwXHUwNDQyXHUwNDRCXG4gICAgICAgIGNvbnN0IFtsYXQsIGxvbl0gPSBtYXAuZ2V0VmlldygpLmdldENlbnRlcigpXG4gICAgICAgIC8vIFx1MDQxRVx1MDQzMVx1MDQzRFx1MDQzRVx1MDQzMlx1MDQzQlx1MDQ0Rlx1MDQzNVx1MDQzQyBcdTA0M0FcdTA0M0VcdTA0M0VcdTA0NDBcdTA0MzRcdTA0MzhcdTA0M0RcdTA0MzBcdTA0NDJcdTA0NEIgXHUwNDQyXHUwNDNFXHUwNDQ3XHUwNDNBXHUwNDM4XG4gICAgICAgIHBvaW50LmdldEdlb21ldHJ5KCkuc2V0Q29vcmRpbmF0ZXMoW2xhdCwgbG9uXSlcbiAgICB9XG5cbiAgICBtYXAub24oJ21vdmVzdGFydCcsIHVwZGF0ZUNlbnRlcilcbiAgICBtYXAub24oJ21vdmVlbmQnLCB1cGRhdGVDZW50ZXIpXG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ21hcC1kb25lJylcbiAgICByZXR1cm4gbmV3IG1Qb2ludCh2aWV3LCBwcm9qZWN0aW9uKVxufVxuXG53aW5kb3dbJ3RyYWluZXJhdHdvdCddID0ge31cbndpbmRvd1sndHJhaW5lcmF0d290J10uR2V0UG9pbnRNYXAgPSBHZXRQb2ludE1hcFxuXG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sXG4gKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIENvbGxlY3Rpb259IGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRGlzcG9zYWJsZX0gZnJvbSAnLi9EaXNwb3NhYmxlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGZWF0dXJlfSBmcm9tICcuL0ZlYXR1cmUuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEdlb2xvY2F0aW9ufSBmcm9tICcuL0dlb2xvY2F0aW9uLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBHcmF0aWN1bGV9IGZyb20gJy4vbGF5ZXIvR3JhdGljdWxlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJbWFnZX0gZnJvbSAnLi9JbWFnZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgSW1hZ2VXcmFwcGVyfSBmcm9tICcuL0ltYWdlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJbWFnZUNhbnZhc30gZnJvbSAnLi9JbWFnZUNhbnZhcy5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgSW1hZ2VUaWxlfSBmcm9tICcuL0ltYWdlVGlsZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgS2luZXRpY30gZnJvbSAnLi9LaW5ldGljLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNYXB9IGZyb20gJy4vTWFwLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNYXBCcm93c2VyRXZlbnR9IGZyb20gJy4vTWFwQnJvd3NlckV2ZW50LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNYXBCcm93c2VyRXZlbnRIYW5kbGVyfSBmcm9tICcuL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1hcEV2ZW50fSBmcm9tICcuL01hcEV2ZW50LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBPYmplY3R9IGZyb20gJy4vT2JqZWN0LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBPYnNlcnZhYmxlfSBmcm9tICcuL09ic2VydmFibGUuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE92ZXJsYXl9IGZyb20gJy4vT3ZlcmxheS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgVGlsZX0gZnJvbSAnLi9UaWxlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUaWxlQ2FjaGV9IGZyb20gJy4vVGlsZUNhY2hlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUaWxlUXVldWV9IGZyb20gJy4vVGlsZVF1ZXVlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUaWxlUmFuZ2V9IGZyb20gJy4vVGlsZVJhbmdlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWZWN0b3JSZW5kZXJUaWxlfSBmcm9tICcuL1ZlY3RvclJlbmRlclRpbGUuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFZlY3RvclRpbGV9IGZyb20gJy4vVmVjdG9yVGlsZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgVmlld30gZnJvbSAnLi9WaWV3LmpzJztcblxuZXhwb3J0IHtnZXRVaWQsIFZFUlNJT059IGZyb20gJy4vdXRpbC5qcyc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBY00sV0E4REM7QUE1RVA7QUFBQTtBQWNBLElBQU0sWUFBTixNQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSWQsWUFBWSxNQUFNO0FBSWhCLGFBQUs7QUFLTCxhQUFLO0FBT0wsYUFBSyxPQUFPO0FBT1osYUFBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxpQkFBaUI7QUFDZixhQUFLLG1CQUFtQjtBQUFBLE1BQzFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGtCQUFrQjtBQUNoQixhQUFLLHFCQUFxQjtBQUFBLE1BQzVCO0FBQUEsSUFDRjtBQWdCQSxJQUFPLGdCQUFRO0FBQUE7QUFBQTs7O0FDNUVmLElBT087QUFQUDtBQUFBO0FBT0EsSUFBTywwQkFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1iLGdCQUFnQjtB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QUFHO0FBQUEsTUFDN0IsaUJBQWlCLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFBQSxNQUM1QixpQkFBaUIsQ0FBQyxJQUFJLElBQUksRUFBRTtBQUFBLE1BQzVCLGlCQUFpQixDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDN0IsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDMUIsWUFBWSxDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDekIsZUFBZSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDM0IsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsY0FBYyxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDekIsZUFBZSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDN0IsZUFBZSxDQUFDLElBQUksS0FBSyxFQUFFO0FBQUEsTUFDM0IsV0FBVyxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDdkIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsUUFBUSxDQUFDLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFDcEIsYUFBYSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDMUIsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsU0FBUyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQUEsTUFDbkIsZUFBZSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDNUIsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDekIsVUFBVSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsTUFDckIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsaUJBQWlCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUMvQixhQUFhLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUN6QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLHdCQUF3QixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEMsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsZUFBZSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDN0IsaUJBQWlCLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxNQUM5QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGtCQUFrQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDaEMsa0JBQWtCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUNoQyxrQkFBa0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ2hDLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzdCLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztBQUFBLE1BQ2xCLGFBQWEsQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUFBLE1BQ3pCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3ZCLFdBQVcsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQ3ZCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsQ0FBQztBQUFBLE1BQ3BCLG9CQUFvQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDbEMsY0FBYyxDQUFDLEdBQUcsR0FBRyxHQUFHO0FBQUEsTUFDeEIsZ0JBQWdCLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUM3QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGtCQUFrQixDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDL0IsbUJBQW1CLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUNqQyxxQkFBcUIsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQ2pDLG1CQUFtQixDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDaEMsbUJBQW1CLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUNoQyxnQkFBZ0IsQ0FBQyxJQUFJLElBQUksR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLFlBQVksQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzFCLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzdCLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztBQUFBLE1BQ2xCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLFNBQVMsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3JCLGFBQWEsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQzFCLFVBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3RCLGFBQWEsQ0FBQyxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3hCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3hCLGlCQUFpQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDL0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsaUJBQWlCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUMvQixpQkFBaUIsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQy9CLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQ3JCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQ3RCLGlCQUFpQixDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDOUIsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDO0FBQUEsTUFDakIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsZUFBZSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDM0IsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsY0FBYyxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDM0IsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFO0FBQUEsTUFDeEIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDdEIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsYUFBYSxDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDMUIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsZUFBZSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsT0FBTyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDckIsUUFBUSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDcEIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDdEIsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsVUFBVSxDQUFDLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFDdEIsZUFBZSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsSUFDN0I7QUFBQTtBQUFBOzs7QUM3SEEsU0FBUyxNQUFNLE1BQU07QUFDcEIsTUFBSSxHQUFHLFFBQVEsQ0FBQyxHQUFHLFFBQVEsR0FBRztBQUc5QixNQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzdCLFdBQU8sRUFBRSxPQUFPLE9BQU8sUUFBUSxDQUFDLFNBQVMsS0FBSyxPQUFPLFdBQWMsR0FBRyxPQUFPLEdBQVEsR0FBRyxPQUFPLEVBQUU7QUFBQSxFQUNsRztBQUNBLE1BQUksT0FBTyxTQUFTO0FBQVUsV0FBTyxFQUFFLE9BQU8sT0FBTyxRQUFRLENBQUMsU0FBUyxLQUFLLE9BQU8sV0FBYyxHQUFHLE9BQU8sR0FBUSxHQUFHLE9BQU8sRUFBRTtBQUUvSCxTQUFPLE9BQU8sSUFBSSxFQUFFLFlBQVk7QUFHaEMsTUFBSSxrQkFBQUssUUFBTSxJQUFJLEdBQUc7QUFDaEIsWUFBUSxrQkFBQUEsUUFBTSxJQUFJLEVBQUUsTUFBTTtBQUMxQixZQUFRO0FBQUEsRUFDVCxXQUdTLFNBQVMsZUFBZTtBQUNoQyxZQUFRO0FBQ1IsWUFBUTtBQUNSLFlBQVEsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLEVBQ2pCLFdBR1MsS0FBSyxDQUFDLE1BQU0sS0FBSztBQUN6QixRQUFJLE9BQU8sS0FBSyxNQUFNLENBQUM7QUFDdkIsUUFBSSxPQUFPLEtBQUs7QUFDaEIsUUFBSSxVQUFVLFFBQVE7QUFDdEIsWUFBUTtBQUVSLFFBQUksU0FBUztBQUNaLGNBQVE7QUFBQSxRQUNQLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUFBLFFBQzlCLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUFBLFFBQzlCLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUFBLE1BQy9CO0FBQ0EsVUFBSSxTQUFTLEdBQUc7QUFDZixnQkFBUSxTQUFTLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSTtBQUFBLE1BQzNDO0FBQUEsSUFDRCxPQUNLO0FBQ0osY0FBUTtBQUFBLFFBQ1AsU0FBUyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQUEsUUFDOUIsU0FBUyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQUEsUUFDOUIsU0FBUyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFO0FBQUEsTUFDL0I7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNmLGdCQUFRLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRSxJQUFJO0FBQUEsTUFDM0M7QUFBQSxJQUNEO0FBRUEsUUFBSSxDQUFDLE1BQU0sQ0FBQztBQUFHLFlBQU0sQ0FBQyxJQUFJO0FBQzFCLFFBQUksQ0FBQyxNQUFNLENBQUM7QUFBRyxZQUFNLENBQUMsSUFBSTtBQUMxQixRQUFJLENBQUMsTUFBTSxDQUFDO0FBQUcsWUFBTSxDQUFDLElBQUk7QUFFMUIsWUFBUTtBQUFBLEVBQ1QsV0FHUyxJQUFJLHlHQUF5RyxLQUFLLElBQUksR0FBRztBQUNqSSxRQUFJLE9BQU8sRUFBRSxDQUFDO0FBQ2QsWUFBUSxLQUFLLFFBQVEsTUFBTSxFQUFFO0FBQzdCLFFBQUksT0FBTyxVQUFVLFNBQVMsSUFBSSxVQUFVLFNBQVMsSUFBSTtBQUN6RCxZQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQjtBQUczQyxRQUFJLFVBQVU7QUFBUyxjQUFRLE1BQU0sTUFBTTtBQUUzQyxZQUFRLE1BQU0sSUFBSSxTQUFVLEdBQUcsR0FBRztBQUVqQyxVQUFJLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTSxLQUFLO0FBQzVCLFlBQUksV0FBVyxDQUFDLElBQUk7QUFFcEIsWUFBSSxNQUFNO0FBQUcsaUJBQU87QUFFcEIsWUFBSSxVQUFVO0FBQU8saUJBQU8sSUFBSTtBQUVoQyxZQUFJLE1BQU0sQ0FBQyxNQUFNO0FBQUssaUJBQU8sSUFBSTtBQUVqQyxZQUFJLE1BQU0sQ0FBQyxNQUFNLE9BQU8sQ0FBQztBQUFHLGlCQUFPLElBQUk7QUFFdkMsWUFBSSxVQUFVO0FBQU8saUJBQU8sSUFBSTtBQUVoQyxZQUFJLFVBQVU7QUFBTyxpQkFBTyxJQUFJLElBQUksSUFBSSxNQUFNLElBQUk7QUFFbEQsWUFBSSxNQUFNLENBQUMsTUFBTSxPQUFPLENBQUM7QUFBRyxpQkFBTztBQUVuQyxZQUFJLFVBQVU7QUFBUyxpQkFBTyxJQUFJO0FBRWxDLFlBQUksVUFBVTtBQUFTLGlCQUFPLElBQUksSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUVwRCxlQUFPO0FBQUEsTUFDUjtBQUdBLFVBQUksTUFBTSxDQUFDLE1BQU0sT0FBUSxNQUFNLEtBQUssTUFBTSxNQUFNLFNBQVMsQ0FBQyxNQUFNLEtBQU07QUFFckUsWUFBSSxTQUFTLENBQUMsTUFBTTtBQUFXLGlCQUFPLFNBQVMsQ0FBQztBQUVoRCxZQUFJLEVBQUUsU0FBUyxLQUFLO0FBQUcsaUJBQU8sV0FBVyxDQUFDO0FBRTFDLFlBQUksRUFBRSxTQUFTLE1BQU07QUFBRyxpQkFBTyxXQUFXLENBQUMsSUFBSTtBQUMvQyxZQUFJLEVBQUUsU0FBUyxNQUFNO0FBQUcsaUJBQU8sV0FBVyxDQUFDLElBQUksTUFBTTtBQUNyRCxZQUFJLEVBQUUsU0FBUyxLQUFLO0FBQUcsaUJBQU8sV0FBVyxDQUFDLElBQUksTUFBTSxLQUFLO0FBQUEsTUFDMUQ7QUFDQSxVQUFJLE1BQU07QUFBUSxlQUFPO0FBQ3pCLGFBQU8sV0FBVyxDQUFDO0FBQUEsSUFDcEIsQ0FBQztBQUVELFlBQVEsTUFBTSxTQUFTLE9BQU8sTUFBTSxJQUFJLElBQUk7QUFBQSxFQUM3QyxXQUdTLG1CQUFtQixLQUFLLElBQUksR0FBRztBQUN2QyxZQUFRLEtBQUssTUFBTSxXQUFXLEVBQUUsSUFBSSxTQUFVLE9BQU87QUFDcEQsYUFBTyxXQUFXLEtBQUs7QUFBQSxJQUN4QixDQUFDO0FBRUQsWUFBUSxLQUFLLE1BQU0sV0FBVyxHQUFHLEtBQUssRUFBRSxHQUFHLFlBQVksS0FBSztBQUFBLEVBQzdEO0FBRUEsU0FBTztBQUFBLElBQ047QUFBQSxJQUNBLFFBQVE7QUFBQSxJQUNSO0FBQUEsRUFDRDtBQUNEO0FBekpBLElBR0EsbUJBRU8scUJBT0g7QUFaSjtBQUFBO0FBR0Esd0JBQWtCO0FBRWxCLElBQU8sc0JBQVE7QUFPZixJQUFJLFdBQVc7QUFBQSxNQUNkLEtBQUs7QUFBQSxNQUNMLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLE1BQU07QUFBQSxNQUNOLFFBQVE7QUFBQSxJQUNUO0FBQUE7QUFBQTs7O0FDbkJBLElBS087QUFMUDtBQUFBO0FBR0E7QUFFQSxJQUFPLGNBQVE7QUFBQSxNQUNkLE1BQU07QUFBQSxNQUNOLEtBQUssQ0FBQyxHQUFFLEdBQUUsQ0FBQztBQUFBLE1BQ1gsS0FBSyxDQUFDLEtBQUksS0FBSSxHQUFHO0FBQUEsTUFDakIsU0FBUyxDQUFDLE9BQU8sY0FBYyxXQUFXO0FBQUEsTUFDMUMsT0FBTyxDQUFDLEtBQUs7QUFBQSxNQUViLEtBQUssU0FBUyxLQUFLO0FBQ2xCLFlBQUksSUFBSSxJQUFJLENBQUMsSUFBRSxLQUFLLElBQUksSUFBSSxDQUFDLElBQUUsS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFFLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxLQUFLLElBQUU7QUFFNUUsWUFBSSxNQUFNO0FBQUcsaUJBQU8sTUFBTSxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssR0FBRztBQUVqRCxhQUFLLElBQUksTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJLElBQUksSUFBSTtBQUN6QyxhQUFLLElBQUksSUFBSTtBQUViLGNBQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNkLGVBQU0sSUFBRSxLQUFJO0FBQ1gsZUFBSyxJQUFJLElBQUksSUFBSSxFQUFHLElBQUk7QUFDeEIsZUFBSyxJQUFJLE9BQU8sS0FBSyxLQUFLO0FBQzFCLGdCQUFNLElBQUksS0FBSyxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksS0FDeEMsSUFBSSxLQUFLLElBQUksS0FDYixJQUFJLEtBQUssSUFBSyxNQUFNLEtBQUssT0FBTyxJQUFJLElBQUksTUFBTSxJQUM5QztBQUNBLGNBQUksR0FBRyxJQUFJLE1BQU07QUFBQSxRQUNsQjtBQUVBLGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRDtBQUlBLGdCQUFJLE1BQU0sU0FBUyxLQUFLO0FBQ3ZCLFVBQUksSUFBSSxJQUFJLENBQUMsSUFBRSxLQUNiLElBQUksSUFBSSxDQUFDLElBQUUsS0FDWCxJQUFJLElBQUksQ0FBQyxJQUFFLEtBQ1gsTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLENBQUMsR0FDdEIsTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLENBQUMsR0FDdEIsUUFBUSxNQUFNLEtBQ2QsR0FBRyxHQUFHO0FBRVIsVUFBSSxRQUFRLEtBQUs7QUFDaEIsWUFBSTtBQUFBLE1BQ0wsV0FDUyxNQUFNLEtBQUs7QUFDbkIsYUFBSyxJQUFJLEtBQUs7QUFBQSxNQUNmLFdBQ1MsTUFBTSxLQUFLO0FBQ25CLFlBQUksS0FBSyxJQUFJLEtBQUs7QUFBQSxNQUNuQixXQUNTLE1BQU0sS0FBSztBQUNuQixZQUFJLEtBQUssSUFBSSxLQUFJO0FBQUEsTUFDbEI7QUFFQSxVQUFJLEtBQUssSUFBSSxJQUFJLElBQUksR0FBRztBQUV4QixVQUFJLElBQUksR0FBRztBQUNWLGFBQUs7QUFBQSxNQUNOO0FBRUEsV0FBSyxNQUFNLE9BQU87QUFFbEIsVUFBSSxRQUFRLEtBQUs7QUFDaEIsWUFBSTtBQUFBLE1BQ0wsV0FDUyxLQUFLLEtBQUs7QUFDbEIsWUFBSSxTQUFTLE1BQU07QUFBQSxNQUNwQixPQUNLO0FBQ0osWUFBSSxTQUFTLElBQUksTUFBTTtBQUFBLE1BQ3hCO0FBRUEsYUFBTyxDQUFDLEdBQUcsSUFBSSxLQUFLLElBQUksR0FBRztBQUFBLElBQzVCO0FBQUE7QUFBQTs7O0FDekVlLFNBQVIsS0FBc0IsT0FBTztBQUVuQyxNQUFJLE1BQU0sUUFBUSxLQUFLLEtBQUssTUFBTTtBQUFLLFlBQVEsT0FBTyxJQUFJLEdBQUcsU0FBUztBQUN0RSxNQUFJLGlCQUFpQjtBQUFRLFlBQVEsQ0FBQztBQUV0QyxNQUFJLFFBQVEsR0FBRztBQUdmLE1BQUksU0FBUyxvQkFBTSxLQUFLO0FBRXhCLE1BQUksQ0FBQyxPQUFPO0FBQU8sV0FBTyxDQUFDO0FBRTNCLFFBQU0sTUFBTSxPQUFPLE1BQU0sQ0FBQyxNQUFNLE1BQU0sWUFBSSxNQUFNLFlBQUk7QUFDcEQsUUFBTSxNQUFNLE9BQU8sTUFBTSxDQUFDLE1BQU0sTUFBTSxZQUFJLE1BQU0sWUFBSTtBQUVwRCxXQUFTLE1BQU0sQ0FBQztBQUNoQixTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUMvRCxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUMvRCxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUUvRCxNQUFJLE9BQU8sTUFBTSxDQUFDLE1BQU0sS0FBSztBQUM1QixhQUFTLFlBQUksSUFBSSxNQUFNO0FBQUEsRUFDeEI7QUFFQSxTQUFPLEtBQUssS0FBSyxJQUFJLEtBQUssSUFBSSxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVsRCxTQUFPO0FBQ1I7QUFoQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7OztBQ1NPLFNBQVMsTUFBTSxPQUFPLEtBQUssS0FBSztBQUNyQyxTQUFPLEtBQUssSUFBSSxLQUFLLElBQUksT0FBTyxHQUFHLEdBQUcsR0FBRztBQUMzQztBQWFPLFNBQVMsdUJBQXVCLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJO0FBQzNELFFBQU0sS0FBSyxLQUFLO0FBQ2hCLFFBQU0sS0FBSyxLQUFLO0FBQ2hCLE1BQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN4QixVQUFNLE1BQU0sSUFBSSxNQUFNLE1BQU0sSUFBSSxNQUFNLE9BQU8sS0FBSyxLQUFLLEtBQUs7QUFDNUQsUUFBSSxJQUFJLEdBQUc7QUFDVCxXQUFLO0FBQ0wsV0FBSztBQUFBLElBQ1AsV0FBVyxJQUFJLEdBQUc7QUFDaEIsWUFBTSxLQUFLO0FBQ1gsWUFBTSxLQUFLO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFDQSxTQUFPLGdCQUFnQixHQUFHLEdBQUcsSUFBSSxFQUFFO0FBQ3JDO0FBVU8sU0FBUyxnQkFBZ0IsSUFBSSxJQUFJLElBQUksSUFBSTtBQUM5QyxRQUFNLEtBQUssS0FBSztBQUNoQixRQUFNLEtBQUssS0FBSztBQUNoQixTQUFPLEtBQUssS0FBSyxLQUFLO0FBQ3hCO0FBU08sU0FBUyxrQkFBa0IsS0FBSztBQUNyQyxRQUFNLElBQUksSUFBSTtBQUVkLFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO0FBRTFCLFFBQUksU0FBUztBQUNiLFFBQUksUUFBUSxLQUFLLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzlCLGFBQVMsSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDOUIsWUFBTSxXQUFXLEtBQUssSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbkMsVUFBSSxXQUFXLE9BQU87QUFDcEIsZ0JBQVE7QUFDUixpQkFBUztBQUFBLE1BQ1g7QUFBQSxJQUNGO0FBRUEsUUFBSSxVQUFVLEdBQUc7QUFDZixhQUFPO0FBQUEsSUFDVDtBQUdBLFVBQU0sTUFBTSxJQUFJLE1BQU07QUFDdEIsUUFBSSxNQUFNLElBQUksSUFBSSxDQUFDO0FBQ25CLFFBQUksQ0FBQyxJQUFJO0FBR1QsYUFBUyxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUM5QixZQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUNsQyxlQUFTLElBQUksR0FBRyxJQUFJLElBQUksR0FBRyxLQUFLO0FBQzlCLFlBQUksS0FBSyxHQUFHO0FBQ1YsY0FBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQUEsUUFDZCxPQUFPO0FBQ0wsY0FBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUFBLFFBQzlCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBR0EsUUFBTSxJQUFJLElBQUksTUFBTSxDQUFDO0FBQ3JCLFdBQVMsSUFBSSxJQUFJLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDL0IsTUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUM7QUFDM0IsYUFBUyxJQUFJLElBQUksR0FBRyxLQUFLLEdBQUcsS0FBSztBQUMvQixVQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUFBLElBQzlCO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQWtCTyxTQUFTLFVBQVUsZ0JBQWdCO0FBQ3hDLFNBQVEsaUJBQWlCLEtBQUssS0FBTTtBQUN0QztBQVNPLFNBQVMsT0FBTyxHQUFHLEdBQUc7QUFDM0IsUUFBTSxJQUFJLElBQUk7QUFDZCxTQUFPLElBQUksSUFBSSxJQUFJLElBQUksSUFBSTtBQUM3QjtBQVVPLFNBQVMsS0FBSyxHQUFHLEdBQUcsR0FBRztBQUM1QixTQUFPLElBQUksS0FBSyxJQUFJO0FBQ3RCO0FBUU8sU0FBUyxRQUFRLEdBQUcsVUFBVTtBQUNuQyxRQUFNLFNBQVMsS0FBSyxJQUFJLElBQUksUUFBUTtBQUNwQyxTQUFPLEtBQUssTUFBTSxJQUFJLE1BQU0sSUFBSTtBQUNsQztBQW9CTyxTQUFTLE1BQU0sR0FBRyxVQUFVO0FBQ2pDLFNBQU8sS0FBSyxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDeEM7QUFTTyxTQUFTLEtBQUssR0FBRyxVQUFVO0FBQ2hDLFNBQU8sS0FBSyxLQUFLLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDdkM7QUF0TUE7QUFBQTtBQUFBO0FBQUE7OztBQ3dCTyxTQUFTLFNBQVMsT0FBTztBQUM5QixNQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzdCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBT0MsVUFBUyxLQUFLO0FBQ3ZCO0FBMEJPLFNBQVMsVUFBVSxPQUFPO0FBQy9CLE1BQUksTUFBTSxXQUFXLEdBQUc7QUFDdEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLFNBQVMsTUFBTSxNQUFNO0FBQzNCLFNBQU8sQ0FBQyxJQUFJO0FBQ1osU0FBTztBQUNUO0FBTU8sU0FBUyxXQUFXLE9BQU87QUFDaEMsUUFBTSxTQUFTLFlBQUksTUFBTSxZQUFJLElBQUksS0FBSyxDQUFDO0FBQ3ZDLFNBQU8sQ0FBQyxJQUFJLE1BQU0sQ0FBQztBQUNuQixTQUFPO0FBQ1Q7QUFNTyxTQUFTLFdBQVcsT0FBTztBQUNoQyxRQUFNLFNBQVMsWUFBSSxJQUFJLGNBQU0sSUFBSSxLQUFLLENBQUM7QUFDdkMsU0FBTyxDQUFDLElBQUksTUFBTSxDQUFDO0FBQ25CLFNBQU87QUFDVDtBQU1PLFNBQVMsV0FBVyxHQUFHO0FBQzVCLE1BQUksTUFBTSxlQUFlLENBQUMsR0FBRztBQUMzQixXQUFPLE1BQU0sQ0FBQztBQUFBLEVBQ2hCO0FBQ0EsTUFBSSxhQUFhLGdCQUFnQjtBQUMvQixRQUFJLElBQUk7QUFDUixlQUFXLE9BQU8sT0FBTztBQUN2QixXQUFLLE1BQU0sT0FBTyxHQUFHO0FBQ25CLGVBQU8sTUFBTSxHQUFHO0FBQ2hCLFVBQUU7QUFBQSxNQUNKO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFFQSxRQUFNLFFBQVEsS0FBVSxDQUFDO0FBQ3pCLE1BQUksTUFBTSxXQUFXLEdBQUc7QUFDdEIsVUFBTSxJQUFJLE1BQU0sc0JBQXNCLElBQUksWUFBWTtBQUFBLEVBQ3hEO0FBQ0EsYUFBVyxLQUFLLE9BQU87QUFDckIsUUFBSSxNQUFNLENBQUMsR0FBRztBQUNaLFlBQU0sSUFBSSxNQUFNLHNCQUFzQixJQUFJLFlBQVk7QUFBQSxJQUN4RDtBQUFBLEVBQ0Y7QUFDQSxZQUFVLEtBQUs7QUFDZixRQUFNLENBQUMsSUFBSTtBQUNYLElBQUU7QUFDRixTQUFPO0FBQ1Q7QUFTTyxTQUFTLFFBQVEsT0FBTztBQUM3QixNQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDeEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPLFdBQVcsS0FBSztBQUN6QjtBQU9PLFNBQVMsVUFBVSxPQUFPO0FBQy9CLFFBQU0sQ0FBQyxJQUFJLE1BQU8sTUFBTSxDQUFDLElBQUksTUFBTyxHQUFHLEdBQUcsR0FBRztBQUM3QyxRQUFNLENBQUMsSUFBSSxNQUFPLE1BQU0sQ0FBQyxJQUFJLE1BQU8sR0FBRyxHQUFHLEdBQUc7QUFDN0MsUUFBTSxDQUFDLElBQUksTUFBTyxNQUFNLENBQUMsSUFBSSxNQUFPLEdBQUcsR0FBRyxHQUFHO0FBQzdDLFFBQU0sQ0FBQyxJQUFJLE1BQU0sTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQy9CLFNBQU87QUFDVDtBQU1PLFNBQVNBLFVBQVMsT0FBTztBQUM5QixNQUFJLElBQUksTUFBTSxDQUFDO0FBQ2YsTUFBSSxNQUFNLElBQUksSUFBSTtBQUNoQixRQUFLLElBQUksTUFBTztBQUFBLEVBQ2xCO0FBQ0EsTUFBSSxJQUFJLE1BQU0sQ0FBQztBQUNmLE1BQUksTUFBTSxJQUFJLElBQUk7QUFDaEIsUUFBSyxJQUFJLE1BQU87QUFBQSxFQUNsQjtBQUNBLE1BQUksSUFBSSxNQUFNLENBQUM7QUFDZixNQUFJLE1BQU0sSUFBSSxJQUFJO0FBQ2hCLFFBQUssSUFBSSxNQUFPO0FBQUEsRUFDbEI7QUFDQSxRQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sU0FBWSxJQUFJLEtBQUssTUFBTSxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUk7QUFDcEUsU0FBTyxVQUFVLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDckQ7QUFNTyxTQUFTLGNBQWMsR0FBRztBQUMvQixNQUFJO0FBQ0YsZUFBVyxDQUFDO0FBQ1osV0FBTztBQUFBLEVBQ1QsU0FBUyxHQUFHO0FBQ1YsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQWhMQSxJQWtDTSxnQkFRQSxPQUtGO0FBL0NKO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMkJBLElBQU0saUJBQWlCO0FBUXZCLElBQU0sUUFBUSxDQUFDO0FBS2YsSUFBSSxZQUFZO0FBQUE7QUFBQTs7O0FDd0RoQixTQUFTLE9BQU8sS0FBSyxhQUFhLE9BQU87QUFDdkMsUUFBTSxjQUFjLFFBQVEsU0FBUyxLQUFLLElBQUk7QUFDOUMsU0FBTyxjQUFjLE1BQU0sTUFBTSxNQUFNO0FBQ3pDO0FBMUdBLElBU00sZ0JBMEdPO0FBbkhiO0FBQUE7QUFHQTtBQU1BLElBQU0saUJBQU4sTUFBcUI7QUFBQSxNQUNuQixjQUFjO0FBS1osYUFBSyxTQUFTLENBQUM7QUFNZixhQUFLLGFBQWE7QUFNbEIsYUFBSyxnQkFBZ0I7QUFBQSxNQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsUUFBUTtBQUNOLGFBQUssU0FBUyxDQUFDO0FBQ2YsYUFBSyxhQUFhO0FBQUEsTUFDcEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGlCQUFpQjtBQUNmLGVBQU8sS0FBSyxhQUFhLEtBQUs7QUFBQSxNQUNoQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsU0FBUztBQUNQLFlBQUksS0FBSyxlQUFlLEdBQUc7QUFDekIsY0FBSSxJQUFJO0FBQ1IscUJBQVcsT0FBTyxLQUFLLFFBQVE7QUFDN0Isa0JBQU0sWUFBWSxLQUFLLE9BQU8sR0FBRztBQUNqQyxpQkFBSyxNQUFNLE9BQU8sS0FBSyxDQUFDLFVBQVUsWUFBWSxHQUFHO0FBQy9DLHFCQUFPLEtBQUssT0FBTyxHQUFHO0FBQ3RCLGdCQUFFLEtBQUs7QUFBQSxZQUNUO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxJQUFJLEtBQUssYUFBYSxPQUFPO0FBQzNCLGNBQU0sTUFBTSxPQUFPLEtBQUssYUFBYSxLQUFLO0FBQzFDLGVBQU8sT0FBTyxLQUFLLFNBQVMsS0FBSyxPQUFPLEdBQUcsSUFBSTtBQUFBLE1BQ2pEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxJQUFJLEtBQUssYUFBYSxPQUFPLFdBQVc7QUFDdEMsY0FBTSxNQUFNLE9BQU8sS0FBSyxhQUFhLEtBQUs7QUFDMUMsYUFBSyxPQUFPLEdBQUcsSUFBSTtBQUNuQixVQUFFLEtBQUs7QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFFBQVEsY0FBYztBQUNwQixhQUFLLGdCQUFnQjtBQUNyQixhQUFLLE9BQU87QUFBQSxNQUNkO0FBQUEsSUFDRjtBQW9CTyxJQUFNLFNBQVMsSUFBSSxlQUFlO0FBQUE7QUFBQTs7O0FDbkh6QyxJQU9PO0FBUFA7QUFBQTtBQU9BLElBQU8sbUJBQVE7QUFBQSxNQUNiLFNBQVM7QUFBQSxNQUNULFNBQVM7QUFBQSxNQUNULFFBQVE7QUFBQSxNQUNSLFNBQVM7QUFBQSxNQUNULGdCQUFnQjtBQUFBLE1BQ2hCLGdCQUFnQjtBQUFBLE1BQ2hCLFVBQVU7QUFBQSxNQUNWLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLEtBQUs7QUFBQSxJQUNQO0FBQUE7QUFBQTs7O0FDbEJBLElBOERNLFdBc1ZDO0FBcFpQO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdURBLElBQU0sWUFBTixjQUF3QixlQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJakMsWUFBWSxTQUFTO0FBQ25CLGNBQU07QUFLTixhQUFLO0FBS0wsYUFBSztBQUtMLGFBQUs7QUFNTCxhQUFLLGNBQWMsUUFBUTtBQUszQixjQUFNLGFBQWEsT0FBTyxPQUFPLENBQUMsR0FBRyxPQUFPO0FBQzVDLFlBQUksT0FBTyxRQUFRLGVBQWUsVUFBVTtBQUMxQyxpQkFBTyxXQUFXO0FBQ2xCLGlCQUFPLE9BQU8sWUFBWSxRQUFRLFVBQVU7QUFBQSxRQUM5QztBQUVBLG1CQUFXLGlCQUFjLE9BQU8sSUFDOUIsUUFBUSxZQUFZLFNBQVksUUFBUSxVQUFVO0FBQ3BEO0FBQUEsVUFDRSxPQUFPLFdBQVcsaUJBQWMsT0FBTyxNQUFNO0FBQUEsVUFDN0M7QUFBQSxRQUNGO0FBRUEsbUJBQVcsaUJBQWMsT0FBTyxJQUM5QixRQUFRLFlBQVksU0FBWSxRQUFRLFVBQVU7QUFDcEQsbUJBQVcsaUJBQWMsT0FBTyxJQUFJLFFBQVE7QUFDNUMsbUJBQVcsaUJBQWMsY0FBYyxJQUNyQyxRQUFRLGtCQUFrQixTQUFZLFFBQVEsZ0JBQWdCO0FBQ2hFLG1CQUFXLGlCQUFjLGNBQWMsSUFDckMsUUFBUSxrQkFBa0IsU0FBWSxRQUFRLGdCQUFnQjtBQUNoRSxtQkFBVyxpQkFBYyxRQUFRLElBQy9CLFFBQVEsWUFBWSxTQUFZLFFBQVEsVUFBVTtBQUNwRCxtQkFBVyxpQkFBYyxRQUFRLElBQy9CLFFBQVEsWUFBWSxTQUFZLFFBQVEsVUFBVTtBQU1wRCxhQUFLLGFBQ0gsV0FBVyxjQUFjLFNBQVksV0FBVyxZQUFZO0FBQzlELGVBQU8sV0FBVztBQUVsQixhQUFLLGNBQWMsVUFBVTtBQU03QixhQUFLLFNBQVM7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxlQUFlO0FBQ2IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxjQUFjLFNBQVM7QUFFckIsY0FBTSxRQUNKLEtBQUs7QUFBQSxRQUNhO0FBQUEsVUFDaEIsT0FBTztBQUFBLFVBQ1AsU0FBUyxZQUFZLFNBQVksT0FBTztBQUFBLFFBQzFDO0FBQ0YsY0FBTSxTQUFTLEtBQUssVUFBVTtBQUM5QixjQUFNLFVBQVUsTUFBTSxLQUFLLE1BQU0sS0FBSyxXQUFXLElBQUksR0FBRyxJQUFJLEtBQUssR0FBRyxDQUFDO0FBQ3JFLGNBQU0sVUFBVSxLQUFLLFdBQVc7QUFDaEMsY0FBTSxTQUFTLEtBQUssVUFBVTtBQUM5QixjQUFNLFNBQVMsV0FBVyxVQUFhLENBQUMsTUFBTSxVQUFVLFdBQVc7QUFDbkUsY0FBTSxnQkFBZ0IsS0FBSyxpQkFBaUI7QUFDNUMsY0FBTSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssaUJBQWlCLEdBQUcsQ0FBQztBQUN6RCxjQUFNLFVBQVUsS0FBSyxXQUFXO0FBQ2hDLGNBQU0sVUFBVSxLQUFLLFdBQVc7QUFDaEMsYUFBSyxTQUFTO0FBRWQsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGVBQWUsT0FBTztBQUNwQixlQUFPLFNBQVM7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsb0JBQW9CLFFBQVE7QUFDMUIsZUFBTyxTQUFTO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsWUFBWTtBQUNWO0FBQUE7QUFBQSxVQUNFLEtBQUssSUFBSSxpQkFBYyxNQUFNO0FBQUE7QUFBQSxNQUVqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxtQkFBbUI7QUFDakI7QUFBQTtBQUFBLFVBQThCLEtBQUssSUFBSSxpQkFBYyxjQUFjO0FBQUE7QUFBQSxNQUNyRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxtQkFBbUI7QUFDakI7QUFBQTtBQUFBLFVBQThCLEtBQUssSUFBSSxpQkFBYyxjQUFjO0FBQUE7QUFBQSxNQUNyRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxhQUFhO0FBQ1g7QUFBQTtBQUFBLFVBQThCLEtBQUssSUFBSSxpQkFBYyxRQUFRO0FBQUE7QUFBQSxNQUMvRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxhQUFhO0FBQ1g7QUFBQTtBQUFBLFVBQThCLEtBQUssSUFBSSxpQkFBYyxRQUFRO0FBQUE7QUFBQSxNQUMvRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsYUFBYTtBQUNYO0FBQUE7QUFBQSxVQUE4QixLQUFLLElBQUksaUJBQWMsT0FBTztBQUFBO0FBQUEsTUFDOUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsaUJBQWlCO0FBQ2YsZUFBTyxTQUFTO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsYUFBYTtBQUNYO0FBQUE7QUFBQSxVQUErQixLQUFLLElBQUksaUJBQWMsT0FBTztBQUFBO0FBQUEsTUFDL0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsWUFBWTtBQUNWO0FBQUE7QUFBQSxVQUF3QyxLQUFLLElBQUksaUJBQWMsT0FBTztBQUFBO0FBQUEsTUFDeEU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsY0FBYyxZQUFZO0FBQ3hCLGFBQUssY0FBYztBQUNuQixhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFVBQVUsUUFBUTtBQUNoQixhQUFLLElBQUksaUJBQWMsUUFBUSxNQUFNO0FBQUEsTUFDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGlCQUFpQixlQUFlO0FBQzlCLGFBQUssSUFBSSxpQkFBYyxnQkFBZ0IsYUFBYTtBQUFBLE1BQ3REO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxpQkFBaUIsZUFBZTtBQUM5QixhQUFLLElBQUksaUJBQWMsZ0JBQWdCLGFBQWE7QUFBQSxNQUN0RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLFdBQVcsU0FBUztBQUNsQixhQUFLLElBQUksaUJBQWMsVUFBVSxPQUFPO0FBQUEsTUFDMUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxXQUFXLFNBQVM7QUFDbEIsYUFBSyxJQUFJLGlCQUFjLFVBQVUsT0FBTztBQUFBLE1BQzFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXLFNBQVM7QUFDbEIsZUFBTyxPQUFPLFlBQVksVUFBVSxnQ0FBZ0M7QUFDcEUsYUFBSyxJQUFJLGlCQUFjLFNBQVMsT0FBTztBQUFBLE1BQ3pDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXLFNBQVM7QUFDbEIsYUFBSyxJQUFJLGlCQUFjLFNBQVMsT0FBTztBQUFBLE1BQ3pDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFVBQVUsUUFBUTtBQUNoQixhQUFLLElBQUksaUJBQWMsU0FBUyxNQUFNO0FBQUEsTUFDeEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGtCQUFrQjtBQUNoQixZQUFJLEtBQUssUUFBUTtBQUNmLGVBQUssT0FBTyxRQUFRO0FBQ3BCLGVBQUssU0FBUztBQUFBLFFBQ2hCO0FBQ0EsY0FBTSxnQkFBZ0I7QUFBQSxNQUN4QjtBQUFBLElBQ0Y7QUFFQSxJQUFPLGVBQVE7QUFBQTtBQUFBOzs7QUNwWmYsSUFPT0M7QUFQUCxJQUFBQyxrQkFBQTtBQUFBO0FBT0EsSUFBT0QscUJBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNYixXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT1gsWUFBWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTWixZQUFZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNaLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU2IsZ0JBQWdCO0FBQUEsSUFDbEI7QUFBQTtBQUFBOzs7QUNoREEsSUFPTztBQVBQO0FBQUE7QUFPQSxJQUFPLG1CQUFRO0FBQUEsTUFDYixXQUFXO0FBQUEsTUFDWCxhQUFhO0FBQUEsSUFDZjtBQUFBO0FBQUE7OztBQ1ZBLElBT087QUFQUDtBQUFBO0FBT0EsSUFBTyx1QkFBUTtBQUFBLE1BQ2IsUUFBUTtBQUFBLE1BQ1IsWUFBWTtBQUFBLE1BQ1osVUFBVTtBQUFBLElBQ1o7QUFBQTtBQUFBOzs7QUNYQSxJQVFhLGtCQU1BO0FBZGI7QUFBQTtBQVFPLElBQU0sbUJBQW1CO0FBTXpCLElBQU0sb0JBQW9CO0FBQUE7QUFBQTs7O0FDZGpDLElBNENhO0FBNUNiO0FBQUE7QUE0Q08sSUFBTSxrQkFBa0I7QUFBQTtBQUFBLE1BRTdCLFdBQVcsV0FBVyxJQUFJLEtBQUs7QUFBQSxNQUMvQixXQUFZLElBQUksS0FBSyxLQUFLLFVBQVc7QUFBQSxNQUNyQyxNQUFNO0FBQUEsTUFDTixLQUFLO0FBQUEsTUFDTCxTQUFTLE9BQU87QUFBQSxJQUNsQjtBQUFBO0FBQUE7OztBQ25EQSxJQW1ETSxZQTJOQztBQTlRUDtBQUFBO0FBR0E7QUFnREEsSUFBTSxhQUFOLE1BQWlCO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJZixZQUFZLFNBQVM7QUFLbkIsYUFBSyxRQUFRLFFBQVE7QUFTckIsYUFBSztBQUFBLFFBQW9ELFFBQVE7QUFTakUsYUFBSyxVQUFVLFFBQVEsV0FBVyxTQUFZLFFBQVEsU0FBUztBQVMvRCxhQUFLLGVBQ0gsUUFBUSxnQkFBZ0IsU0FBWSxRQUFRLGNBQWM7QUFNNUQsYUFBSyxtQkFDSCxRQUFRLG9CQUFvQixTQUFZLFFBQVEsa0JBQWtCO0FBTXBFLGFBQUssVUFBVSxRQUFRLFdBQVcsU0FBWSxRQUFRLFNBQVM7QUFNL0QsYUFBSyxZQUFZLENBQUMsRUFBRSxLQUFLLFdBQVcsS0FBSztBQU16QyxhQUFLLDBCQUEwQixRQUFRO0FBTXZDLGFBQUssbUJBQW1CO0FBTXhCLGFBQUssaUJBQWlCLFFBQVE7QUFBQSxNQUNoQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsV0FBVztBQUNULGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVk7QUFDVixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsV0FBVztBQUNULGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsbUJBQW1CO0FBQ2pCLGVBQU8sS0FBSyxrQkFBa0IsZ0JBQWdCLEtBQUssTUFBTTtBQUFBLE1BQzNEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQWFBLHFCQUFxQjtBQUNuQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsV0FBVztBQUNULGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxZQUFZLENBQUMsRUFBRSxVQUFVLEtBQUs7QUFBQSxNQUNyQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EscUJBQXFCO0FBQ25CLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLG1CQUFtQixVQUFVO0FBQzNCLGFBQUssbUJBQW1CO0FBQUEsTUFDMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxZQUFZLENBQUMsRUFBRSxLQUFLLFdBQVc7QUFBQSxNQUN0QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsZUFBZSxhQUFhO0FBQzFCLGFBQUssZUFBZTtBQUFBLE1BQ3RCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxzQkFBc0IsTUFBTTtBQUMxQixhQUFLLDBCQUEwQjtBQUFBLE1BQ2pDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EseUJBQXlCO0FBQ3ZCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQSxJQUNGO0FBRUEsSUFBTyxxQkFBUTtBQUFBO0FBQUE7OztBQzNMUixTQUFTLGFBQWEsT0FBTyxRQUFRLFdBQVc7QUFDckQsUUFBTSxTQUFTLE1BQU07QUFDckIsY0FBWSxZQUFZLElBQUksWUFBWTtBQUN4QyxNQUFJLFdBQVcsUUFBVztBQUN4QixRQUFJLFlBQVksR0FBRztBQUVqQixlQUFTLE1BQU0sTUFBTTtBQUFBLElBQ3ZCLE9BQU87QUFDTCxlQUFTLElBQUksTUFBTSxNQUFNO0FBQUEsSUFDM0I7QUFBQSxFQUNGO0FBQ0EsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUssV0FBVztBQUMxQyxXQUFPLENBQUMsSUFBSyxZQUFZLE1BQU0sQ0FBQyxJQUFLO0FBQ3JDLFFBQUksSUFBSSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUssS0FBSyxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxNQUFPLEdBQUcsQ0FBQztBQUMxRSxRQUFJLElBQUksWUFBWTtBQUNsQixVQUFJO0FBQUEsSUFDTixXQUFXLElBQUksQ0FBQyxZQUFZO0FBQzFCLFVBQUksQ0FBQztBQUFBLElBQ1A7QUFDQSxXQUFPLElBQUksQ0FBQyxJQUFJO0FBQUEsRUFDbEI7QUFDQSxTQUFPO0FBQ1Q7QUFVTyxTQUFTLFdBQVcsT0FBTyxRQUFRLFdBQVc7QUFDbkQsUUFBTSxTQUFTLE1BQU07QUFDckIsY0FBWSxZQUFZLElBQUksWUFBWTtBQUN4QyxNQUFJLFdBQVcsUUFBVztBQUN4QixRQUFJLFlBQVksR0FBRztBQUVqQixlQUFTLE1BQU0sTUFBTTtBQUFBLElBQ3ZCLE9BQU87QUFDTCxlQUFTLElBQUksTUFBTSxNQUFNO0FBQUEsSUFDM0I7QUFBQSxFQUNGO0FBQ0EsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUssV0FBVztBQUMxQyxXQUFPLENBQUMsSUFBSyxNQUFNLE1BQU0sQ0FBQyxJQUFLO0FBQy9CLFdBQU8sSUFBSSxDQUFDLElBQ1QsTUFBTSxLQUFLLEtBQUssS0FBSyxJQUFJLE1BQU0sSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLElBQUssS0FBSyxLQUFLO0FBQUEsRUFDbkU7QUFDQSxTQUFPO0FBQ1Q7QUFwSUEsSUFXYSxRQU1BLFdBTUEsUUFNQSxjQU9BLFlBTVAsb0JBd0JPO0FBbEViO0FBQUE7QUFHQTtBQVFPLElBQU0sU0FBUztBQU1mLElBQU0sWUFBWSxLQUFLLEtBQUs7QUFNNUIsSUFBTSxTQUFTLENBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxXQUFXLFNBQVM7QUFNNUQsSUFBTSxlQUFlLENBQUMsTUFBTSxLQUFLLEtBQUssRUFBRTtBQU94QyxJQUFNLGFBQWEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUM7QUFNakUsSUFBTSxxQkFBTixjQUFpQyxtQkFBVztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSTFDLFlBQVksTUFBTTtBQUNoQixjQUFNO0FBQUEsVUFDSjtBQUFBLFVBQ0EsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsYUFBYTtBQUFBLFVBQ2Isb0JBQW9CLFNBQVUsWUFBWSxPQUFPO0FBQy9DLG1CQUFPLGFBQWEsS0FBSyxLQUFLLE1BQU0sQ0FBQyxJQUFJLE1BQU07QUFBQSxVQUNqRDtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0g7QUFBQSxJQUNGO0FBUU8sSUFBTSxjQUFjO0FBQUEsTUFDekIsSUFBSSxtQkFBbUIsV0FBVztBQUFBLE1BQ2xDLElBQUksbUJBQW1CLGFBQWE7QUFBQSxNQUNwQyxJQUFJLG1CQUFtQixhQUFhO0FBQUEsTUFDcEMsSUFBSSxtQkFBbUIsYUFBYTtBQUFBLE1BQ3BDLElBQUksbUJBQW1CLDRDQUE0QztBQUFBLE1BQ25FLElBQUksbUJBQW1CLDhDQUE4QztBQUFBLElBQ3ZFO0FBQUE7QUFBQTs7O0FDekVBLElBV2FFLFNBUUFDLFNBTUFDLGtCQVVQLG9CQXdCT0M7QUEzRGI7QUFBQTtBQUdBO0FBUU8sSUFBTUgsVUFBUztBQVFmLElBQU1DLFVBQVMsQ0FBQyxNQUFNLEtBQUssS0FBSyxFQUFFO0FBTWxDLElBQU1DLG1CQUFtQixLQUFLLEtBQUtGLFVBQVU7QUFVcEQsSUFBTSxxQkFBTixjQUFpQyxtQkFBVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLMUMsWUFBWSxNQUFNLGlCQUFpQjtBQUNqQyxjQUFNO0FBQUEsVUFDSjtBQUFBLFVBQ0EsT0FBTztBQUFBLFVBQ1AsUUFBUUM7QUFBQSxVQUNSO0FBQUEsVUFDQSxRQUFRO0FBQUEsVUFDUixlQUFlQztBQUFBLFVBQ2YsYUFBYUQ7QUFBQSxRQUNmLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQVFPLElBQU1FLGVBQWM7QUFBQSxNQUN6QixJQUFJLG1CQUFtQixRQUFRO0FBQUEsTUFDL0IsSUFBSSxtQkFBbUIsYUFBYSxLQUFLO0FBQUEsTUFDekMsSUFBSSxtQkFBbUIsK0JBQStCO0FBQUEsTUFDdEQsSUFBSSxtQkFBbUIsMEJBQTBCO0FBQUEsTUFDakQsSUFBSSxtQkFBbUIsOENBQThDO0FBQUEsTUFDckUsSUFBSSxtQkFBbUIsZ0RBQWdELEtBQUs7QUFBQSxNQUM1RSxJQUFJLG1CQUFtQiw4Q0FBOEMsS0FBSztBQUFBLElBQzVFO0FBQUE7QUFBQTs7O0FDdkRPLFNBQVNDLFNBQVE7QUFDdEIsRUFBQUMsU0FBUSxDQUFDO0FBQ1g7QUFPTyxTQUFTLElBQUksTUFBTTtBQUN4QixTQUNFQSxPQUFNLElBQUksS0FDVkEsT0FBTSxLQUFLLFFBQVEsMENBQTBDLFNBQVMsQ0FBQyxLQUN2RTtBQUVKO0FBT08sU0FBUyxJQUFJLE1BQU0sWUFBWTtBQUNwQyxFQUFBQSxPQUFNLElBQUksSUFBSTtBQUNoQjtBQXBDQSxJQU9JQTtBQVBKO0FBQUE7QUFPQSxJQUFJQSxTQUFRLENBQUM7QUFBQTtBQUFBOzs7QUNPTixTQUFTQyxTQUFRO0FBQ3RCLGVBQWEsQ0FBQztBQUNoQjtBQVVPLFNBQVNDLEtBQUksUUFBUSxhQUFhLGFBQWE7QUFDcEQsUUFBTSxhQUFhLE9BQU8sUUFBUTtBQUNsQyxRQUFNLGtCQUFrQixZQUFZLFFBQVE7QUFDNUMsTUFBSSxFQUFFLGNBQWMsYUFBYTtBQUMvQixlQUFXLFVBQVUsSUFBSSxDQUFDO0FBQUEsRUFDNUI7QUFDQSxhQUFXLFVBQVUsRUFBRSxlQUFlLElBQUk7QUFDNUM7QUE0Qk8sU0FBU0MsS0FBSSxZQUFZLGlCQUFpQjtBQUMvQyxNQUFJQztBQUNKLE1BQUksY0FBYyxjQUFjLG1CQUFtQixXQUFXLFVBQVUsR0FBRztBQUN6RSxJQUFBQSxhQUFZLFdBQVcsVUFBVSxFQUFFLGVBQWU7QUFBQSxFQUNwRDtBQUNBLFNBQU9BO0FBQ1Q7QUFuRUEsSUFTSTtBQVRKO0FBQUE7QUFTQSxJQUFJLGFBQWEsQ0FBQztBQUFBO0FBQUE7OztBQytCWCxTQUFTQyxLQUFJLFlBQVksT0FBTztBQUNyQyxhQUFXLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUN6QixhQUFXLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUN6QixTQUFPO0FBQ1Q7QUFtR08sU0FBUyxlQUFlLGdCQUFnQjtBQUM3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFLRSxTQUFVLFlBQVk7QUFDcEIsYUFBTyxXQUFXLFlBQVksY0FBYztBQUFBLElBQzlDO0FBQUE7QUFFSjtBQXlFTyxTQUFTLE9BQU8sWUFBWSxVQUFVLGdCQUFnQjtBQUMzRCxNQUFJLFlBQVk7QUFDZCxXQUFPLFNBQ0osUUFBUSxPQUFPLFdBQVcsQ0FBQyxFQUFFLFFBQVEsY0FBYyxDQUFDLEVBQ3BELFFBQVEsT0FBTyxXQUFXLENBQUMsRUFBRSxRQUFRLGNBQWMsQ0FBQztBQUFBLEVBQ3pEO0FBQ0EsU0FBTztBQUNUO0FBT08sU0FBU0MsUUFBTyxhQUFhLGFBQWE7QUFDL0MsTUFBSUEsVUFBUztBQUNiLFdBQVMsSUFBSSxZQUFZLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ2hELFFBQUksWUFBWSxDQUFDLEtBQUssWUFBWSxDQUFDLEdBQUc7QUFDcEMsTUFBQUEsVUFBUztBQUNUO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxTQUFPQTtBQUNUO0FBb0JPLFNBQVMsT0FBTyxZQUFZLE9BQU87QUFDeEMsUUFBTSxXQUFXLEtBQUssSUFBSSxLQUFLO0FBQy9CLFFBQU0sV0FBVyxLQUFLLElBQUksS0FBSztBQUMvQixRQUFNLElBQUksV0FBVyxDQUFDLElBQUksV0FBVyxXQUFXLENBQUMsSUFBSTtBQUNyRCxRQUFNLElBQUksV0FBVyxDQUFDLElBQUksV0FBVyxXQUFXLENBQUMsSUFBSTtBQUNyRCxhQUFXLENBQUMsSUFBSTtBQUNoQixhQUFXLENBQUMsSUFBSTtBQUNoQixTQUFPO0FBQ1Q7QUFtQk8sU0FBUyxNQUFNLFlBQVlDLFFBQU87QUFDdkMsYUFBVyxDQUFDLEtBQUtBO0FBQ2pCLGFBQVcsQ0FBQyxLQUFLQTtBQUNqQixTQUFPO0FBQ1Q7QUFnR08sU0FBUyxXQUFXLFlBQVksZ0JBQWdCO0FBQ3JELFNBQU8sT0FBTyxZQUFZLFlBQVksY0FBYztBQUN0RDtBQVdPLFNBQVNDLE9BQU0sWUFBWSxZQUFZO0FBQzVDLE1BQUksV0FBVyxTQUFTLEdBQUc7QUFDekIsVUFBTSxhQUFhLFNBQVMsV0FBVyxVQUFVLENBQUM7QUFDbEQsVUFBTSxhQUFhLGNBQWMsWUFBWSxZQUFZLFVBQVU7QUFDbkUsUUFBSSxZQUFZO0FBQ2QsaUJBQVcsQ0FBQyxLQUFLLGFBQWE7QUFBQSxJQUNoQztBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFPTyxTQUFTLGNBQWMsWUFBWSxZQUFZLG1CQUFtQjtBQUN2RSxRQUFNLG1CQUFtQixXQUFXLFVBQVU7QUFDOUMsTUFBSSxhQUFhO0FBQ2pCLE1BQ0UsV0FBVyxTQUFTLE1BQ25CLFdBQVcsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEtBQUssV0FBVyxDQUFDLElBQUksaUJBQWlCLENBQUMsSUFDMUU7QUFDQSx3QkFBb0IscUJBQXFCLFNBQVMsZ0JBQWdCO0FBQ2xFLGlCQUFhLEtBQUs7QUFBQSxPQUNmLFdBQVcsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEtBQUs7QUFBQSxJQUMxQztBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUF0YkE7QUFBQTtBQUdBO0FBQUE7QUFBQTs7O0FDOEJPLFNBQVMsWUFBWSxJQUFJLElBQUksUUFBUTtBQUMxQyxXQUFTLFVBQVU7QUFDbkIsUUFBTSxPQUFPLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDNUIsUUFBTSxPQUFPLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDNUIsUUFBTSxlQUFlLE9BQU8sUUFBUTtBQUNwQyxRQUFNLGNBQWMsVUFBVSxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJO0FBQy9DLFFBQU0sSUFDSixLQUFLLElBQUksV0FBVyxJQUFJLEtBQUssSUFBSSxXQUFXLElBQzVDLEtBQUssSUFBSSxXQUFXLElBQ2xCLEtBQUssSUFBSSxXQUFXLElBQ3BCLEtBQUssSUFBSSxJQUFJLElBQ2IsS0FBSyxJQUFJLElBQUk7QUFDakIsU0FBTyxJQUFJLFNBQVMsS0FBSyxNQUFNLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQy9EO0FBOUNBLElBc0JhO0FBdEJiO0FBQUE7QUFHQTtBQW1CTyxJQUFNLGlCQUFpQjtBQUFBO0FBQUE7OztBQ3lCdkIsU0FBUyxRQUFRLE1BQU07QUFDNUIsTUFBSSxRQUFRLE9BQU8sTUFBTTtBQUN2QjtBQUFBLEVBQ0Y7QUFDQSxVQUFRLEtBQUssR0FBRyxJQUFJO0FBQ3RCO0FBcERBLElBV00sUUFVRjtBQXJCSjtBQUFBO0FBV0EsSUFBTSxTQUFTO0FBQUEsTUFDYixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsSUFDUjtBQUtBLElBQUksUUFBUSxPQUFPO0FBQUE7QUFBQTs7O0FDckJuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5R08sU0FBUyx5QkFBeUJDLFVBQVM7QUFDaEQsUUFBTSxPQUFPQSxhQUFZLFNBQVksT0FBT0E7QUFDNUMsMEJBQXdCLENBQUM7QUFDM0I7QUFRTyxTQUFTLGVBQWUsT0FBTyxRQUFRO0FBQzVDLE1BQUksV0FBVyxRQUFXO0FBQ3hCLGFBQVMsSUFBSSxHQUFHLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDOUMsYUFBTyxDQUFDLElBQUksTUFBTSxDQUFDO0FBQUEsSUFDckI7QUFDQSxhQUFTO0FBQUEsRUFDWCxPQUFPO0FBQ0wsYUFBUyxNQUFNLE1BQU07QUFBQSxFQUN2QjtBQUNBLFNBQU87QUFDVDtBQU9PLFNBQVMsa0JBQWtCLE9BQU8sUUFBUTtBQUMvQyxNQUFJLFdBQVcsVUFBYSxVQUFVLFFBQVE7QUFDNUMsYUFBUyxJQUFJLEdBQUcsS0FBSyxNQUFNLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM5QyxhQUFPLENBQUMsSUFBSSxNQUFNLENBQUM7QUFBQSxJQUNyQjtBQUNBLFlBQVE7QUFBQSxFQUNWO0FBQ0EsU0FBTztBQUNUO0FBU08sU0FBUyxjQUFjLFlBQVk7QUFDeEMsTUFBUSxXQUFXLFFBQVEsR0FBRyxVQUFVO0FBQ3hDLEVBQUFDLEtBQWlCLFlBQVksWUFBWSxjQUFjO0FBQ3pEO0FBS08sU0FBUyxlQUFlLGFBQWE7QUFDMUMsY0FBWSxRQUFRLGFBQWE7QUFDbkM7QUFXTyxTQUFTRixLQUFJLGdCQUFnQjtBQUNsQyxTQUFPLE9BQU8sbUJBQW1CLFdBQzdCO0FBQUE7QUFBQSxJQUErQjtBQUFBLEVBQWU7QUFBQTtBQUFBLElBQ25CLGtCQUFtQjtBQUFBO0FBQ3BEO0FBc0JPLFNBQVMsbUJBQW1CLFlBQVksWUFBWSxPQUFPLE9BQU87QUFDdkUsZUFBYUEsS0FBSSxVQUFVO0FBQzNCLE1BQUk7QUFDSixRQUFNLFNBQVMsV0FBVyx1QkFBdUI7QUFDakQsTUFBSSxRQUFRO0FBQ1Ysc0JBQWtCLE9BQU8sWUFBWSxLQUFLO0FBQzFDLFFBQUksU0FBUyxVQUFVLFdBQVcsU0FBUyxHQUFHO0FBQzVDLFlBQU0sZ0JBQWdCLFdBQVcsaUJBQWlCO0FBQ2xELFVBQUksZUFBZTtBQUNqQiwwQkFDRyxrQkFBa0IsZ0JBQWlCLGdCQUFnQixLQUFLO0FBQUEsTUFDN0Q7QUFBQSxJQUNGO0FBQUEsRUFDRixPQUFPO0FBQ0wsVUFBTSxZQUFZLFdBQVcsU0FBUztBQUN0QyxRQUFLLGFBQWEsYUFBYSxDQUFDLFNBQVUsU0FBUyxXQUFXO0FBQzVELHdCQUFrQjtBQUFBLElBQ3BCLE9BQU87QUFJTCxZQUFNRyxjQUFhO0FBQUEsUUFDakI7QUFBQSxRQUNBSCxLQUFJLFdBQVc7QUFBQSxNQUNqQjtBQUNBLFVBQUlHLGdCQUFlLHFCQUFxQixjQUFjLFdBQVc7QUFFL0QsMEJBQWtCLGFBQWEsV0FBVyxpQkFBaUI7QUFBQSxNQUM3RCxPQUFPO0FBQ0wsWUFBSSxXQUFXO0FBQUEsVUFDYixNQUFNLENBQUMsSUFBSSxhQUFhO0FBQUEsVUFDeEIsTUFBTSxDQUFDO0FBQUEsVUFDUCxNQUFNLENBQUMsSUFBSSxhQUFhO0FBQUEsVUFDeEIsTUFBTSxDQUFDO0FBQUEsVUFDUCxNQUFNLENBQUM7QUFBQSxVQUNQLE1BQU0sQ0FBQyxJQUFJLGFBQWE7QUFBQSxVQUN4QixNQUFNLENBQUM7QUFBQSxVQUNQLE1BQU0sQ0FBQyxJQUFJLGFBQWE7QUFBQSxRQUMxQjtBQUNBLG1CQUFXQSxZQUFXLFVBQVUsVUFBVSxDQUFDO0FBQzNDLGNBQU0sUUFBUSxZQUFZLFNBQVMsTUFBTSxHQUFHLENBQUMsR0FBRyxTQUFTLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDcEUsY0FBTSxTQUFTLFlBQVksU0FBUyxNQUFNLEdBQUcsQ0FBQyxHQUFHLFNBQVMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNyRSwyQkFBbUIsUUFBUSxVQUFVO0FBQUEsTUFDdkM7QUFDQSxZQUFNLGdCQUFnQixRQUNsQixnQkFBZ0IsS0FBSyxJQUNyQixXQUFXLGlCQUFpQjtBQUNoQyxVQUFJLGtCQUFrQixRQUFXO0FBQy9CLDJCQUFtQjtBQUFBLE1BQ3JCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFTTyxTQUFTLHlCQUF5QixhQUFhO0FBQ3BELGlCQUFlLFdBQVc7QUFDMUIsY0FBWSxRQUFRLFNBQVUsUUFBUTtBQUNwQyxnQkFBWSxRQUFRLFNBQVUsYUFBYTtBQUN6QyxVQUFJLFdBQVcsYUFBYTtBQUMxQixRQUFBRCxLQUFpQixRQUFRLGFBQWEsY0FBYztBQUFBLE1BQ3REO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSCxDQUFDO0FBQ0g7QUFlTyxTQUFTLHdCQUNkLGNBQ0EsY0FDQSxrQkFDQSxrQkFDQTtBQUNBLGVBQWEsUUFBUSxTQUFVLGFBQWE7QUFDMUMsaUJBQWEsUUFBUSxTQUFVLGFBQWE7QUFDMUMsTUFBQUEsS0FBaUIsYUFBYSxhQUFhLGdCQUFnQjtBQUMzRCxNQUFBQSxLQUFpQixhQUFhLGFBQWEsZ0JBQWdCO0FBQUEsSUFDN0QsQ0FBQztBQUFBLEVBQ0gsQ0FBQztBQUNIO0FBS08sU0FBUyxzQkFBc0I7QUFDcEMsRUFBQUUsT0FBVTtBQUNWLEVBQUFBLE9BQW9CO0FBQ3RCO0FBT08sU0FBUyxpQkFBaUIsWUFBWSxhQUFhO0FBQ3hELE1BQUksQ0FBQyxZQUFZO0FBQ2YsV0FBT0osS0FBSSxXQUFXO0FBQUEsRUFDeEI7QUFDQSxNQUFJLE9BQU8sZUFBZSxVQUFVO0FBQ2xDLFdBQU9BLEtBQUksVUFBVTtBQUFBLEVBQ3ZCO0FBQ0E7QUFBQTtBQUFBLElBQWtDO0FBQUE7QUFDcEM7QUFTTyxTQUFTLHVDQUF1QyxnQkFBZ0I7QUFDckU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQU9FLFNBQVUsT0FBTyxRQUFRLFdBQVc7QUFDbEMsWUFBTSxTQUFTLE1BQU07QUFDckIsa0JBQVksY0FBYyxTQUFZLFlBQVk7QUFDbEQsZUFBUyxXQUFXLFNBQVksU0FBUyxJQUFJLE1BQU0sTUFBTTtBQUN6RCxlQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsS0FBSyxXQUFXO0FBQzFDLGNBQU0sUUFBUSxlQUFlLE1BQU0sTUFBTSxHQUFHLElBQUksU0FBUyxDQUFDO0FBQzFELGNBQU0sY0FBYyxNQUFNO0FBQzFCLGlCQUFTLElBQUksR0FBRyxLQUFLLFdBQVcsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUMzQyxpQkFBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsTUFBTSxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUM7QUFBQSxRQUMzRDtBQUFBLE1BQ0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUFBO0FBRUo7QUF3Qk8sU0FBUyx3QkFBd0IsUUFBUSxhQUFhLFNBQVMsU0FBUztBQUM3RSxRQUFNLGFBQWFBLEtBQUksTUFBTTtBQUM3QixRQUFNLFdBQVdBLEtBQUksV0FBVztBQUNoQyxFQUFBRTtBQUFBLElBQ0U7QUFBQSxJQUNBO0FBQUEsSUFDQSx1Q0FBdUMsT0FBTztBQUFBLEVBQ2hEO0FBQ0EsRUFBQUE7QUFBQSxJQUNFO0FBQUEsSUFDQTtBQUFBLElBQ0EsdUNBQXVDLE9BQU87QUFBQSxFQUNoRDtBQUNGO0FBV08sU0FBUyxXQUFXLFlBQVksWUFBWTtBQUNqRCwyQkFBeUI7QUFDekIsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQSxlQUFlLFNBQVksYUFBYTtBQUFBLEVBQzFDO0FBQ0Y7QUFXTyxTQUFTLFNBQVMsWUFBWSxZQUFZO0FBQy9DLFFBQU0sU0FBUztBQUFBLElBQ2I7QUFBQSxJQUNBLGVBQWUsU0FBWSxhQUFhO0FBQUEsSUFDeEM7QUFBQSxFQUNGO0FBQ0EsUUFBTSxNQUFNLE9BQU8sQ0FBQztBQUNwQixNQUFJLE1BQU0sUUFBUSxNQUFNLEtBQUs7QUFDM0IsV0FBTyxDQUFDLElBQUksT0FBTyxNQUFNLEtBQUssR0FBRyxJQUFJO0FBQUEsRUFDdkM7QUFDQSxTQUFPO0FBQ1Q7QUFZTyxTQUFTLFdBQVcsYUFBYSxhQUFhO0FBQ25ELE1BQUksZ0JBQWdCLGFBQWE7QUFDL0IsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLGFBQWEsWUFBWSxTQUFTLE1BQU0sWUFBWSxTQUFTO0FBQ25FLE1BQUksWUFBWSxRQUFRLE1BQU0sWUFBWSxRQUFRLEdBQUc7QUFDbkQsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLGdCQUFnQiw0QkFBNEIsYUFBYSxXQUFXO0FBQzFFLFNBQU8sa0JBQWtCLGtCQUFrQjtBQUM3QztBQVdPLFNBQVMsNEJBQ2Qsa0JBQ0EsdUJBQ0E7QUFDQSxRQUFNLGFBQWEsaUJBQWlCLFFBQVE7QUFDNUMsUUFBTSxrQkFBa0Isc0JBQXNCLFFBQVE7QUFDdEQsTUFBSSxnQkFBZ0JGLEtBQWlCLFlBQVksZUFBZTtBQUNoRSxNQUFJLENBQUMsZUFBZTtBQUNsQixvQkFBZ0I7QUFBQSxFQUNsQjtBQUNBLFNBQU87QUFDVDtBQVlPLFNBQVMsYUFBYSxRQUFRLGFBQWE7QUFDaEQsUUFBTSxtQkFBbUJBLEtBQUksTUFBTTtBQUNuQyxRQUFNLHdCQUF3QkEsS0FBSSxXQUFXO0FBQzdDLFNBQU8sNEJBQTRCLGtCQUFrQixxQkFBcUI7QUFDNUU7QUFnQk8sU0FBUyxVQUFVLFlBQVksUUFBUSxhQUFhO0FBQ3pELFFBQU0sZ0JBQWdCLGFBQWEsUUFBUSxXQUFXO0FBQ3RELFNBQU8sY0FBYyxZQUFZLFFBQVcsV0FBVyxNQUFNO0FBQy9EO0FBY08sU0FBUyxnQkFBZ0IsUUFBUSxRQUFRLGFBQWEsT0FBTztBQUNsRSxRQUFNLGdCQUFnQixhQUFhLFFBQVEsV0FBVztBQUN0RCxTQUFPLGVBQWUsUUFBUSxlQUFlLFFBQVcsS0FBSztBQUMvRDtBQVVPLFNBQVMseUJBQ2QsT0FDQSxrQkFDQSx1QkFDQTtBQUNBLFFBQU0sZ0JBQWdCO0FBQUEsSUFDcEI7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNBLFNBQU8sY0FBYyxLQUFLO0FBQzVCO0FBY08sU0FBUyxrQkFBa0IsWUFBWTtBQUM1QyxtQkFBaUJBLEtBQUksVUFBVTtBQUNqQztBQU1PLFNBQVMsc0JBQXNCO0FBQ3BDLG1CQUFpQjtBQUNuQjtBQU9PLFNBQVMsb0JBQW9CO0FBQ2xDLFNBQU87QUFDVDtBQVFPLFNBQVMsZ0JBQWdCO0FBQzlCLG9CQUFrQixXQUFXO0FBQy9CO0FBU08sU0FBUyxpQkFBaUIsWUFBWSxrQkFBa0I7QUFDN0QsTUFBSSxDQUFDLGdCQUFnQjtBQUNuQixXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU8sVUFBVSxZQUFZLGtCQUFrQixjQUFjO0FBQy9EO0FBU08sU0FBUyxtQkFBbUIsWUFBWSxnQkFBZ0I7QUFDN0QsTUFBSSxDQUFDLGdCQUFnQjtBQUNuQixRQUNFLHlCQUNBLENBQUNLLFFBQU8sWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQzFCLFdBQVcsQ0FBQyxLQUFLLFFBQ2pCLFdBQVcsQ0FBQyxLQUFLLE9BQ2pCLFdBQVcsQ0FBQyxLQUFLLE9BQ2pCLFdBQVcsQ0FBQyxLQUFLLElBQ2pCO0FBQ0EsOEJBQXdCO0FBQ3hCO0FBQUEsUUFDRTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPLFVBQVUsWUFBWSxnQkFBZ0IsY0FBYztBQUM3RDtBQVNPLFNBQVMsYUFBYSxRQUFRLGtCQUFrQjtBQUNyRCxNQUFJLENBQUMsZ0JBQWdCO0FBQ25CLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxnQkFBZ0IsUUFBUSxrQkFBa0IsY0FBYztBQUNqRTtBQVNPLFNBQVMsZUFBZSxRQUFRLGdCQUFnQjtBQUNyRCxNQUFJLENBQUMsZ0JBQWdCO0FBQ25CLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxnQkFBZ0IsUUFBUSxnQkFBZ0IsY0FBYztBQUMvRDtBQVVPLFNBQVMsaUJBQWlCLFlBQVksa0JBQWtCO0FBQzdELE1BQUksQ0FBQyxnQkFBZ0I7QUFDbkIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLHNCQUFzQkwsS0FBSSxnQkFBZ0IsRUFBRSxpQkFBaUI7QUFDbkUsUUFBTSxvQkFBb0IsZUFBZSxpQkFBaUI7QUFDMUQsU0FBTyx1QkFBdUIsb0JBQ3pCLGFBQWEsc0JBQXVCLG9CQUNyQztBQUNOO0FBVU8sU0FBUyxtQkFBbUIsWUFBWSxnQkFBZ0I7QUFDN0QsTUFBSSxDQUFDLGdCQUFnQjtBQUNuQixXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sb0JBQW9CQSxLQUFJLGNBQWMsRUFBRSxpQkFBaUI7QUFDL0QsUUFBTSxvQkFBb0IsZUFBZSxpQkFBaUI7QUFDMUQsU0FBTyxxQkFBcUIsb0JBQ3ZCLGFBQWEsb0JBQXFCLG9CQUNuQztBQUNOO0FBWU8sU0FBUyw4QkFBOEIsWUFBWSxVQUFVTSxZQUFXO0FBQzdFLFNBQU8sU0FBVSxPQUFPO0FBQ3RCLFFBQUksYUFBYTtBQUNqQixRQUFJLFdBQVcsU0FBUyxHQUFHO0FBQ3pCLFlBQU0sZUFBZSxXQUFXLFVBQVU7QUFDMUMsWUFBTSxvQkFBb0IsU0FBUyxZQUFZO0FBQy9DLGNBQVEsTUFBTSxNQUFNLENBQUM7QUFDckIsbUJBQWEsY0FBYyxPQUFPLFlBQVksaUJBQWlCO0FBQy9ELFVBQUksWUFBWTtBQUVkLGNBQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLGFBQWE7QUFBQSxNQUNyQztBQUNBLFlBQU0sQ0FBQyxJQUFJLE1BQU0sTUFBTSxDQUFDLEdBQUcsYUFBYSxDQUFDLEdBQUcsYUFBYSxDQUFDLENBQUM7QUFDM0QsWUFBTSxDQUFDLElBQUksTUFBTSxNQUFNLENBQUMsR0FBRyxhQUFhLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQztBQUMzRCxvQkFBY0EsV0FBVSxLQUFLO0FBQUEsSUFDL0IsT0FBTztBQUNMLG9CQUFjQSxXQUFVLEtBQUs7QUFBQSxJQUMvQjtBQUNBLFFBQUksY0FBYyxTQUFTLFNBQVMsR0FBRztBQUVyQyxrQkFBWSxDQUFDLEtBQUssYUFBYSxTQUFTLFNBQVMsVUFBVSxDQUFDO0FBQUEsSUFDOUQ7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBT08sU0FBUyxZQUFZO0FBRzFCLDJCQUF5QixXQUFvQjtBQUM3QywyQkFBeUJDLFlBQW9CO0FBRzdDO0FBQUEsSUFDRUE7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0Y7QUE1dUJBLElBb0dJLHVCQStiQTtBQW5pQko7QUFBQTtBQXVEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdUJBLElBQUksd0JBQXdCO0FBK2I1QixJQUFJLGlCQUFpQjtBQTJNckIsY0FBVTtBQUFBO0FBQUE7OztBQzl0QkgsU0FBUyxhQUFhLFFBQVEsWUFBWSxRQUFRO0FBQ3ZEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBU0UsU0FBVSxRQUFRLFlBQVksTUFBTSxVQUFVLGFBQWE7QUFDekQsVUFBSSxDQUFDLFFBQVE7QUFDWCxlQUFPO0FBQUEsTUFDVDtBQUNBLFVBQUksQ0FBQyxjQUFjLENBQUMsWUFBWTtBQUM5QixlQUFPO0FBQUEsTUFDVDtBQUNBLFlBQU0sWUFBWSxhQUFhLElBQUksS0FBSyxDQUFDLElBQUk7QUFDN0MsWUFBTSxhQUFhLGFBQWEsSUFBSSxLQUFLLENBQUMsSUFBSTtBQUM5QyxZQUFNLFNBQVMsY0FBYyxZQUFZLENBQUMsSUFBSTtBQUM5QyxZQUFNLFNBQVMsY0FBYyxZQUFZLENBQUMsSUFBSTtBQUM5QyxVQUFJLE9BQU8sT0FBTyxDQUFDLElBQUksWUFBWSxJQUFJO0FBQ3ZDLFVBQUksT0FBTyxPQUFPLENBQUMsSUFBSSxZQUFZLElBQUk7QUFDdkMsVUFBSSxPQUFPLE9BQU8sQ0FBQyxJQUFJLGFBQWEsSUFBSTtBQUN4QyxVQUFJLE9BQU8sT0FBTyxDQUFDLElBQUksYUFBYSxJQUFJO0FBSXhDLFVBQUksT0FBTyxNQUFNO0FBQ2YsZ0JBQVEsT0FBTyxRQUFRO0FBQ3ZCLGVBQU87QUFBQSxNQUNUO0FBQ0EsVUFBSSxPQUFPLE1BQU07QUFDZixnQkFBUSxPQUFPLFFBQVE7QUFDdkIsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLElBQUksTUFBTSxPQUFPLENBQUMsR0FBRyxNQUFNLElBQUk7QUFDbkMsVUFBSSxJQUFJLE1BQU0sT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJO0FBR25DLFVBQUksWUFBWSxVQUFVLFlBQVk7QUFDcEMsY0FBTSxRQUFRLEtBQUs7QUFDbkIsYUFDRSxDQUFDLFFBQVEsS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLEdBQUcsT0FBTyxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFDM0QsUUFBUSxLQUFLLElBQUksSUFBSSxLQUFLLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksS0FBSztBQUM1RCxhQUNFLENBQUMsUUFBUSxLQUFLLElBQUksSUFBSSxLQUFLLElBQUksR0FBRyxPQUFPLE9BQU8sQ0FBQyxDQUFDLElBQUksS0FBSyxJQUMzRCxRQUFRLEtBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLO0FBQUEsTUFDOUQ7QUFFQSxhQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsSUFDZDtBQUFBO0FBRUo7QUFNTyxTQUFTLEtBQUssUUFBUTtBQUMzQixTQUFPO0FBQ1Q7QUE5RUE7QUFBQTtBQUdBO0FBQUE7QUFBQTs7O0FDaUJBLFNBQVMsNkJBQ1AsWUFDQSxXQUNBLGNBQ0EsZ0JBQ0E7QUFDQSxRQUFNLGNBQWMsU0FBUyxTQUFTLElBQUksYUFBYSxDQUFDO0FBQ3hELFFBQU0sY0FBYyxVQUFVLFNBQVMsSUFBSSxhQUFhLENBQUM7QUFFekQsTUFBSSxnQkFBZ0I7QUFDbEIsV0FBTyxLQUFLLElBQUksWUFBWSxLQUFLLElBQUksYUFBYSxXQUFXLENBQUM7QUFBQSxFQUNoRTtBQUNBLFNBQU8sS0FBSyxJQUFJLFlBQVksS0FBSyxJQUFJLGFBQWEsV0FBVyxDQUFDO0FBQ2hFO0FBY0EsU0FBUywyQkFBMkIsWUFBWSxlQUFlLGVBQWU7QUFDNUUsTUFBSSxTQUFTLEtBQUssSUFBSSxZQUFZLGFBQWE7QUFDL0MsUUFBTSxRQUFRO0FBRWQsWUFDRSxLQUFLLElBQUksSUFBSSxRQUFRLEtBQUssSUFBSSxHQUFHLGFBQWEsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLFFBQ3BFO0FBQ0YsTUFBSSxlQUFlO0FBQ2pCLGFBQVMsS0FBSyxJQUFJLFFBQVEsYUFBYTtBQUN2QyxjQUNFLEtBQUssSUFBSSxJQUFJLFFBQVEsS0FBSyxJQUFJLEdBQUcsZ0JBQWdCLGFBQWEsQ0FBQyxDQUFDLElBQzlELFFBQ0Y7QUFBQSxFQUNKO0FBQ0EsU0FBTyxNQUFNLFFBQVEsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDM0Q7QUFTTyxTQUFTLHdCQUNkLGFBQ0EsUUFDQSxXQUNBLGdCQUNBO0FBQ0EsV0FBUyxXQUFXLFNBQVksU0FBUztBQUN6QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFRRSxTQUFVLFlBQVksV0FBVyxNQUFNLFVBQVU7QUFDL0MsVUFBSSxlQUFlLFFBQVc7QUFDNUIsY0FBTSxnQkFBZ0IsWUFBWSxDQUFDO0FBQ25DLGNBQU0sZ0JBQWdCLFlBQVksWUFBWSxTQUFTLENBQUM7QUFDeEQsY0FBTSxlQUFlLFlBQ2pCO0FBQUEsVUFDRTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0YsSUFDQTtBQUdKLFlBQUksVUFBVTtBQUNaLGNBQUksQ0FBQyxRQUFRO0FBQ1gsbUJBQU8sTUFBTSxZQUFZLGVBQWUsWUFBWTtBQUFBLFVBQ3REO0FBQ0EsaUJBQU87QUFBQSxZQUNMO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUVBLGNBQU0sU0FBUyxLQUFLLElBQUksY0FBYyxVQUFVO0FBQ2hELGNBQU0sSUFBSSxLQUFLLE1BQU0sa0JBQWtCLGFBQWEsUUFBUSxTQUFTLENBQUM7QUFDdEUsWUFBSSxZQUFZLENBQUMsSUFBSSxnQkFBZ0IsSUFBSSxZQUFZLFNBQVMsR0FBRztBQUMvRCxpQkFBTyxZQUFZLElBQUksQ0FBQztBQUFBLFFBQzFCO0FBQ0EsZUFBTyxZQUFZLENBQUM7QUFBQSxNQUN0QjtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUE7QUFFSjtBQVdPLFNBQVMsa0JBQ2QsT0FDQSxlQUNBLGVBQ0EsUUFDQSxXQUNBLGdCQUNBO0FBQ0EsV0FBUyxXQUFXLFNBQVksU0FBUztBQUN6QyxrQkFBZ0Isa0JBQWtCLFNBQVksZ0JBQWdCO0FBRTlEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQVFFLFNBQVUsWUFBWSxXQUFXLE1BQU0sVUFBVTtBQUMvQyxVQUFJLGVBQWUsUUFBVztBQUM1QixjQUFNLGVBQWUsWUFDakI7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRixJQUNBO0FBR0osWUFBSSxVQUFVO0FBQ1osY0FBSSxDQUFDLFFBQVE7QUFDWCxtQkFBTyxNQUFNLFlBQVksZUFBZSxZQUFZO0FBQUEsVUFDdEQ7QUFDQSxpQkFBTztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBRUEsY0FBTSxZQUFZO0FBQ2xCLGNBQU0sZUFBZSxLQUFLO0FBQUEsVUFDeEIsS0FBSyxJQUFJLGdCQUFnQixZQUFZLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSTtBQUFBLFFBQzdEO0FBQ0EsY0FBTSxTQUFTLENBQUMsYUFBYSxNQUFNLGFBQWE7QUFDaEQsY0FBTSxTQUFTLEtBQUssSUFBSSxjQUFjLFVBQVU7QUFDaEQsY0FBTSxrQkFBa0IsS0FBSztBQUFBLFVBQzNCLEtBQUssSUFBSSxnQkFBZ0IsTUFBTSxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUk7QUFBQSxRQUN2RDtBQUNBLGNBQU0sWUFBWSxLQUFLLElBQUksY0FBYyxlQUFlO0FBQ3hELGNBQU0sZ0JBQWdCLGdCQUFnQixLQUFLLElBQUksT0FBTyxTQUFTO0FBQy9ELGVBQU8sTUFBTSxlQUFlLGVBQWUsWUFBWTtBQUFBLE1BQ3pEO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFBQTtBQUVKO0FBVU8sU0FBUyx1QkFDZCxlQUNBLGVBQ0EsUUFDQSxXQUNBLGdCQUNBO0FBQ0EsV0FBUyxXQUFXLFNBQVksU0FBUztBQUV6QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFRRSxTQUFVLFlBQVksV0FBVyxNQUFNLFVBQVU7QUFDL0MsVUFBSSxlQUFlLFFBQVc7QUFDNUIsY0FBTSxlQUFlLFlBQ2pCO0FBQUEsVUFDRTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0YsSUFDQTtBQUVKLFlBQUksQ0FBQyxVQUFVLENBQUMsVUFBVTtBQUN4QixpQkFBTyxNQUFNLFlBQVksZUFBZSxZQUFZO0FBQUEsUUFDdEQ7QUFDQSxlQUFPO0FBQUEsVUFDTDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSxhQUFPO0FBQUEsSUFDVDtBQUFBO0FBRUo7QUFoUEE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7OztBQ1FPLFNBQVMsUUFBUSxVQUFVO0FBQ2hDLE1BQUksYUFBYSxRQUFXO0FBQzFCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTztBQUNUO0FBTU8sU0FBU0MsTUFBSyxVQUFVO0FBQzdCLE1BQUksYUFBYSxRQUFXO0FBQzFCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTztBQUNUO0FBTU8sU0FBUyxjQUFjLEdBQUc7QUFDL0IsUUFBTSxRQUFTLElBQUksS0FBSyxLQUFNO0FBQzlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBTUUsU0FBVSxVQUFVLFVBQVU7QUFDNUIsVUFBSSxVQUFVO0FBQ1osZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLGFBQWEsUUFBVztBQUMxQixtQkFBVyxLQUFLLE1BQU0sV0FBVyxRQUFRLEdBQUcsSUFBSTtBQUNoRCxlQUFPO0FBQUEsTUFDVDtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUE7QUFFSjtBQU1PLFNBQVMsaUJBQWlCLFdBQVc7QUFDMUMsUUFBTSxJQUFJLGNBQWMsU0FBWSxVQUFVLENBQUMsSUFBSTtBQUNuRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQU1FLFNBQVUsVUFBVSxVQUFVO0FBQzVCLFVBQUksWUFBWSxhQUFhLFFBQVc7QUFDdEMsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLEtBQUssSUFBSSxRQUFRLEtBQUssR0FBRztBQUMzQixlQUFPO0FBQUEsTUFDVDtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUE7QUFFSjtBQWhGQTtBQUFBO0FBR0E7QUFBQTtBQUFBOzs7QUNPTyxTQUFTLE9BQU8sR0FBRztBQUN4QixTQUFPLEtBQUssSUFBSSxHQUFHLENBQUM7QUFDdEI7QUFRTyxTQUFTLFFBQVEsR0FBRztBQUN6QixTQUFPLElBQUksT0FBTyxJQUFJLENBQUM7QUFDekI7QUFRTyxTQUFTLFNBQVMsR0FBRztBQUMxQixTQUFPLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQ2pDO0FBUU8sU0FBUyxPQUFPLEdBQUc7QUFDeEIsU0FBTztBQUNUO0FBMUNBO0FBQUE7QUFBQTtBQUFBOzs7QUNhTyxTQUFTLFlBQ2QsaUJBQ0EsUUFDQSxLQUNBLFFBQ0FDLFlBQ0EsTUFDQTtBQUNBLFNBQU8sT0FBTyxPQUFPLENBQUM7QUFDdEIsTUFBSSxJQUFJO0FBQ1IsV0FBUyxJQUFJLFFBQVEsSUFBSSxLQUFLLEtBQUssUUFBUTtBQUN6QyxVQUFNLElBQUksZ0JBQWdCLENBQUM7QUFDM0IsVUFBTSxJQUFJLGdCQUFnQixJQUFJLENBQUM7QUFDL0IsU0FBSyxHQUFHLElBQUlBLFdBQVUsQ0FBQyxJQUFJLElBQUlBLFdBQVUsQ0FBQyxJQUFJLElBQUlBLFdBQVUsQ0FBQztBQUM3RCxTQUFLLEdBQUcsSUFBSUEsV0FBVSxDQUFDLElBQUksSUFBSUEsV0FBVSxDQUFDLElBQUksSUFBSUEsV0FBVSxDQUFDO0FBQUEsRUFDL0Q7QUFDQSxNQUFJLFFBQVEsS0FBSyxVQUFVLEdBQUc7QUFDNUIsU0FBSyxTQUFTO0FBQUEsRUFDaEI7QUFDQSxTQUFPO0FBQ1Q7QUFZTyxTQUFTQyxRQUNkLGlCQUNBLFFBQ0EsS0FDQSxRQUNBLE9BQ0EsUUFDQSxNQUNBO0FBQ0EsU0FBTyxPQUFPLE9BQU8sQ0FBQztBQUN0QixRQUFNLE1BQU0sS0FBSyxJQUFJLEtBQUs7QUFDMUIsUUFBTSxNQUFNLEtBQUssSUFBSSxLQUFLO0FBQzFCLFFBQU0sVUFBVSxPQUFPLENBQUM7QUFDeEIsUUFBTSxVQUFVLE9BQU8sQ0FBQztBQUN4QixNQUFJLElBQUk7QUFDUixXQUFTLElBQUksUUFBUSxJQUFJLEtBQUssS0FBSyxRQUFRO0FBQ3pDLFVBQU0sU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJO0FBQ3BDLFVBQU0sU0FBUyxnQkFBZ0IsSUFBSSxDQUFDLElBQUk7QUFDeEMsU0FBSyxHQUFHLElBQUksVUFBVSxTQUFTLE1BQU0sU0FBUztBQUM5QyxTQUFLLEdBQUcsSUFBSSxVQUFVLFNBQVMsTUFBTSxTQUFTO0FBQzlDLGFBQVMsSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQ3ZDLFdBQUssR0FBRyxJQUFJLGdCQUFnQixDQUFDO0FBQUEsSUFDL0I7QUFBQSxFQUNGO0FBQ0EsTUFBSSxRQUFRLEtBQUssVUFBVSxHQUFHO0FBQzVCLFNBQUssU0FBUztBQUFBLEVBQ2hCO0FBQ0EsU0FBTztBQUNUO0FBY08sU0FBU0MsT0FDZCxpQkFDQSxRQUNBLEtBQ0EsUUFDQSxJQUNBLElBQ0EsUUFDQSxNQUNBO0FBQ0EsU0FBTyxPQUFPLE9BQU8sQ0FBQztBQUN0QixRQUFNLFVBQVUsT0FBTyxDQUFDO0FBQ3hCLFFBQU0sVUFBVSxPQUFPLENBQUM7QUFDeEIsTUFBSSxJQUFJO0FBQ1IsV0FBUyxJQUFJLFFBQVEsSUFBSSxLQUFLLEtBQUssUUFBUTtBQUN6QyxVQUFNLFNBQVMsZ0JBQWdCLENBQUMsSUFBSTtBQUNwQyxVQUFNLFNBQVMsZ0JBQWdCLElBQUksQ0FBQyxJQUFJO0FBQ3hDLFNBQUssR0FBRyxJQUFJLFVBQVUsS0FBSztBQUMzQixTQUFLLEdBQUcsSUFBSSxVQUFVLEtBQUs7QUFDM0IsYUFBUyxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDdkMsV0FBSyxHQUFHLElBQUksZ0JBQWdCLENBQUM7QUFBQSxJQUMvQjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLFFBQVEsS0FBSyxVQUFVLEdBQUc7QUFDNUIsU0FBSyxTQUFTO0FBQUEsRUFDaEI7QUFDQSxTQUFPO0FBQ1Q7QUFZTyxTQUFTLFVBQ2QsaUJBQ0EsUUFDQSxLQUNBLFFBQ0EsUUFDQSxRQUNBLE1BQ0E7QUFDQSxTQUFPLE9BQU8sT0FBTyxDQUFDO0FBQ3RCLE1BQUksSUFBSTtBQUNSLFdBQVMsSUFBSSxRQUFRLElBQUksS0FBSyxLQUFLLFFBQVE7QUFDekMsU0FBSyxHQUFHLElBQUksZ0JBQWdCLENBQUMsSUFBSTtBQUNqQyxTQUFLLEdBQUcsSUFBSSxnQkFBZ0IsSUFBSSxDQUFDLElBQUk7QUFDckMsYUFBUyxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDdkMsV0FBSyxHQUFHLElBQUksZ0JBQWdCLENBQUM7QUFBQSxJQUMvQjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLFFBQVEsS0FBSyxVQUFVLEdBQUc7QUFDNUIsU0FBSyxTQUFTO0FBQUEsRUFDaEI7QUFDQSxTQUFPO0FBQ1Q7QUFwSkEsSUFBQUMsa0JBQUE7QUFBQTtBQUFBO0FBQUE7OztBQ0FBLElBbUNNLGNBY0EsVUF1U0M7QUF4VlA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBTUE7QUFDQTtBQUNBLElBQUFDO0FBa0JBLElBQU0sZUFBZSxPQUFnQjtBQWNyQyxJQUFNLFdBQU4sY0FBdUIsZUFBVztBQUFBLE1BQ2hDLGNBQWM7QUFDWixjQUFNO0FBTU4sYUFBSyxVQUFVLFlBQVk7QUFNM0IsYUFBSyxrQkFBa0I7QUFNdkIsYUFBSywyQ0FBMkM7QUFNaEQsYUFBSyw2QkFBNkI7QUFVbEMsYUFBSyw4QkFBOEI7QUFBQSxVQUNqQyxDQUFDLFVBQVUsa0JBQWtCQyxlQUFjO0FBQ3pDLGdCQUFJLENBQUNBLFlBQVc7QUFDZCxxQkFBTyxLQUFLLHNCQUFzQixnQkFBZ0I7QUFBQSxZQUNwRDtBQUNBLGtCQUFNQyxTQUFRLEtBQUssTUFBTTtBQUN6QixZQUFBQSxPQUFNLGVBQWVELFVBQVM7QUFDOUIsbUJBQU9DLE9BQU0sc0JBQXNCLGdCQUFnQjtBQUFBLFVBQ3JEO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0Esb0JBQW9CLGtCQUFrQkQsWUFBVztBQUMvQyxlQUFPLEtBQUs7QUFBQSxVQUNWLEtBQUssWUFBWTtBQUFBLFVBQ2pCO0FBQUEsVUFDQUE7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixlQUFPLFNBQVM7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLGVBQWUsR0FBRyxHQUFHLGNBQWMsb0JBQW9CO0FBQ3JELGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsV0FBVyxHQUFHLEdBQUc7QUFDZixjQUFNLFFBQVEsS0FBSyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN6QyxlQUFPLE1BQU0sQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLE1BQU07QUFBQSxNQUN4QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLGdCQUFnQixPQUFPLGNBQWM7QUFDbkMsdUJBQWUsZUFBZSxlQUFlLENBQUMsS0FBSyxHQUFHO0FBQ3RELGFBQUssZUFBZSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxjQUFjLFFBQVE7QUFDOUQsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EscUJBQXFCLFlBQVk7QUFDL0IsZUFBTyxLQUFLLFdBQVcsV0FBVyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUM7QUFBQSxNQUNyRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsY0FBYyxRQUFRO0FBQ3BCLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxVQUFVLFFBQVE7QUFDaEIsWUFBSSxLQUFLLG1CQUFtQixLQUFLLFlBQVksR0FBRztBQUM5QyxnQkFBTUUsVUFBUyxLQUFLLGNBQWMsS0FBSyxPQUFPO0FBQzlDLGNBQUksTUFBTUEsUUFBTyxDQUFDLENBQUMsS0FBSyxNQUFNQSxRQUFPLENBQUMsQ0FBQyxHQUFHO0FBQ3hDLGdDQUFvQkEsT0FBTTtBQUFBLFVBQzVCO0FBQ0EsZUFBSyxrQkFBa0IsS0FBSyxZQUFZO0FBQUEsUUFDMUM7QUFDQSxlQUFPLGVBQWUsS0FBSyxTQUFTLE1BQU07QUFBQSxNQUM1QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLE9BQU8sT0FBTyxRQUFRO0FBQ3BCLGlCQUFTO0FBQUEsTUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFZQSxNQUFNLElBQUksSUFBSSxRQUFRO0FBQ3BCLGlCQUFTO0FBQUEsTUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BV0EsU0FBUyxXQUFXO0FBQ2xCLGVBQU8sS0FBSyxzQkFBc0IsWUFBWSxTQUFTO0FBQUEsTUFDekQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxzQkFBc0Isa0JBQWtCO0FBQ3RDLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFXQSxlQUFlLGFBQWE7QUFDMUIsaUJBQVM7QUFBQSxNQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxpQkFBaUIsUUFBUTtBQUN2QixlQUFPLFNBQVM7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLFVBQVUsUUFBUSxRQUFRO0FBQ3hCLGlCQUFTO0FBQUEsTUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BaUJBLFVBQVUsUUFBUSxhQUFhO0FBRTdCLGNBQU0sYUFBYUMsS0FBYyxNQUFNO0FBQ3ZDLGNBQU0sY0FDSixXQUFXLFNBQVMsS0FBSyxnQkFDckIsU0FBVSxlQUFlLGdCQUFnQixRQUFRO0FBQy9DLGdCQUFNLGNBQWMsV0FBVyxVQUFVO0FBQ3pDLGdCQUFNLGtCQUFrQixXQUFXLGVBQWU7QUFDbEQsZ0JBQU1DLFNBQVEsVUFBVSxlQUFlLElBQUksVUFBVSxXQUFXO0FBQ2hFO0FBQUEsWUFDRTtBQUFBLFlBQ0EsZ0JBQWdCLENBQUM7QUFBQSxZQUNqQixnQkFBZ0IsQ0FBQztBQUFBLFlBQ2pCQTtBQUFBLFlBQ0EsQ0FBQ0E7QUFBQSxZQUNEO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0E7QUFBQSxZQUNFO0FBQUEsWUFDQTtBQUFBLFlBQ0EsY0FBYztBQUFBLFlBQ2Q7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFDQSxpQkFBTyxhQUFhLFlBQVksV0FBVztBQUFBLFlBQ3pDO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsUUFDRixJQUNBLGFBQWEsWUFBWSxXQUFXO0FBQzFDLGFBQUssZUFBZSxXQUFXO0FBQy9CLGVBQU87QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUVBLElBQU8sbUJBQVE7QUFBQTtBQUFBOzs7QUMvQ1IsU0FBUyxtQkFBbUIsUUFBUTtBQUN6QyxNQUFJO0FBQ0osTUFBSSxVQUFVLEdBQUc7QUFDZixhQUFTO0FBQUEsRUFDWCxXQUFXLFVBQVUsR0FBRztBQUN0QixhQUFTO0FBQUEsRUFDWCxXQUFXLFVBQVUsR0FBRztBQUN0QixhQUFTO0FBQUEsRUFDWDtBQUNBO0FBQUE7QUFBQSxJQUE4RDtBQUFBO0FBQ2hFO0FBTU8sU0FBUyxtQkFBbUIsUUFBUTtBQUN6QyxNQUFJO0FBQ0osTUFBSSxVQUFVLE1BQU07QUFDbEIsYUFBUztBQUFBLEVBQ1gsV0FBVyxVQUFVLFNBQVMsVUFBVSxPQUFPO0FBQzdDLGFBQVM7QUFBQSxFQUNYLFdBQVcsVUFBVSxRQUFRO0FBQzNCLGFBQVM7QUFBQSxFQUNYO0FBQ0E7QUFBQTtBQUFBLElBQThCO0FBQUE7QUFDaEM7QUFRTyxTQUFTLGdCQUFnQixnQkFBZ0JDLFlBQVcsTUFBTTtBQUMvRCxRQUFNLGtCQUFrQixlQUFlLG1CQUFtQjtBQUMxRCxNQUFJLENBQUMsaUJBQWlCO0FBQ3BCLFdBQU87QUFBQSxFQUNUO0FBQ0EsUUFBTSxTQUFTLGVBQWUsVUFBVTtBQUN4QyxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxJQUNBLGdCQUFnQjtBQUFBLElBQ2hCO0FBQUEsSUFDQUE7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUNGO0FBelZBLElBZ0JNLGdCQTJVQztBQTNWUDtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBQUM7QUFVQSxJQUFNLGlCQUFOLGNBQTZCLGlCQUFTO0FBQUEsTUFDcEMsY0FBYztBQUNaLGNBQU07QUFNTixhQUFLLFNBQVM7QUFNZCxhQUFLLFNBQVM7QUFNZCxhQUFLO0FBQUEsTUFDUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGNBQWMsUUFBUTtBQUNwQixlQUFPO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTDtBQUFBLFVBQ0EsS0FBSyxnQkFBZ0I7QUFBQSxVQUNyQixLQUFLO0FBQUEsVUFDTDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGlCQUFpQjtBQUNmLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EscUJBQXFCO0FBQ25CLGVBQU8sS0FBSyxnQkFBZ0IsTUFBTSxHQUFHLEtBQUssTUFBTTtBQUFBLE1BQ2xEO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxxQkFBcUI7QUFDbkIsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG9CQUFvQjtBQUNsQixlQUFPLEtBQUssZ0JBQWdCO0FBQUEsVUFDMUIsS0FBSyxnQkFBZ0IsU0FBUyxLQUFLO0FBQUEsUUFDckM7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxzQkFBc0Isa0JBQWtCO0FBQ3RDLFlBQUksS0FBSywrQkFBK0IsS0FBSyxZQUFZLEdBQUc7QUFDMUQsZUFBSywyQ0FBMkM7QUFDaEQsZUFBSyw2QkFBNkIsS0FBSyxZQUFZO0FBQUEsUUFDckQ7QUFHQSxZQUNFLG1CQUFtQixLQUNsQixLQUFLLDZDQUE2QyxLQUNqRCxvQkFBb0IsS0FBSywwQ0FDM0I7QUFDQSxpQkFBTztBQUFBLFFBQ1Q7QUFFQSxjQUFNLHFCQUNKLEtBQUssOEJBQThCLGdCQUFnQjtBQUNyRCxjQUFNLDRCQUE0QixtQkFBbUIsbUJBQW1CO0FBQ3hFLFlBQUksMEJBQTBCLFNBQVMsS0FBSyxnQkFBZ0IsUUFBUTtBQUNsRSxpQkFBTztBQUFBLFFBQ1Q7QUFPQSxhQUFLLDJDQUEyQztBQUNoRCxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLDhCQUE4QixrQkFBa0I7QUFDOUMsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFlBQVk7QUFDVixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLG1CQUFtQixRQUFRLGlCQUFpQjtBQUMxQyxhQUFLLFNBQVMsbUJBQW1CLE1BQU07QUFDdkMsYUFBSyxTQUFTO0FBQ2QsYUFBSyxrQkFBa0I7QUFBQSxNQUN6QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGVBQWVDLGNBQWEsUUFBUTtBQUNsQyxpQkFBUztBQUFBLE1BQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFVBQVUsUUFBUUEsY0FBYSxTQUFTO0FBQ3RDLFlBQUk7QUFDSixZQUFJLFFBQVE7QUFDVixtQkFBUyxtQkFBbUIsTUFBTTtBQUFBLFFBQ3BDLE9BQU87QUFDTCxtQkFBUyxJQUFJLEdBQUcsSUFBSSxTQUFTLEVBQUUsR0FBRztBQUNoQyxnQkFBSUEsYUFBWSxXQUFXLEdBQUc7QUFDNUIsbUJBQUssU0FBUztBQUNkLG1CQUFLLFNBQVM7QUFDZDtBQUFBLFlBQ0Y7QUFDQSxZQUFBQTtBQUFBLFlBQTZDQSxhQUFZLENBQUM7QUFBQSxVQUM1RDtBQUNBLG1CQUFTQSxhQUFZO0FBQ3JCLG1CQUFTLG1CQUFtQixNQUFNO0FBQUEsUUFDcEM7QUFDQSxhQUFLLFNBQVM7QUFDZCxhQUFLLFNBQVM7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BV0EsZUFBZSxhQUFhO0FBQzFCLFlBQUksS0FBSyxpQkFBaUI7QUFDeEIsc0JBQVksS0FBSyxpQkFBaUIsS0FBSyxpQkFBaUIsS0FBSyxNQUFNO0FBQ25FLGVBQUssUUFBUTtBQUFBLFFBQ2Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLE9BQU8sT0FBTyxRQUFRO0FBQ3BCLGNBQU0sa0JBQWtCLEtBQUssbUJBQW1CO0FBQ2hELFlBQUksaUJBQWlCO0FBQ25CLGdCQUFNLFNBQVMsS0FBSyxVQUFVO0FBQzlCLFVBQUFDO0FBQUEsWUFDRTtBQUFBLFlBQ0E7QUFBQSxZQUNBLGdCQUFnQjtBQUFBLFlBQ2hCO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUNBLGVBQUssUUFBUTtBQUFBLFFBQ2Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFXQSxNQUFNLElBQUksSUFBSSxRQUFRO0FBQ3BCLFlBQUksT0FBTyxRQUFXO0FBQ3BCLGVBQUs7QUFBQSxRQUNQO0FBQ0EsWUFBSSxDQUFDLFFBQVE7QUFDWCxtQkFBUyxVQUFVLEtBQUssVUFBVSxDQUFDO0FBQUEsUUFDckM7QUFDQSxjQUFNLGtCQUFrQixLQUFLLG1CQUFtQjtBQUNoRCxZQUFJLGlCQUFpQjtBQUNuQixnQkFBTSxTQUFTLEtBQUssVUFBVTtBQUM5QixVQUFBQztBQUFBLFlBQ0U7QUFBQSxZQUNBO0FBQUEsWUFDQSxnQkFBZ0I7QUFBQSxZQUNoQjtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0EsZUFBSyxRQUFRO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsVUFBVSxRQUFRLFFBQVE7QUFDeEIsY0FBTSxrQkFBa0IsS0FBSyxtQkFBbUI7QUFDaEQsWUFBSSxpQkFBaUI7QUFDbkIsZ0JBQU0sU0FBUyxLQUFLLFVBQVU7QUFDOUI7QUFBQSxZQUNFO0FBQUEsWUFDQTtBQUFBLFlBQ0EsZ0JBQWdCO0FBQUEsWUFDaEI7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0EsZUFBSyxRQUFRO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBd0RBLElBQU8seUJBQVE7QUFBQTtBQUFBOzs7QUMxVWYsU0FBUyxjQUNQLGlCQUNBLFNBQ0EsU0FDQSxRQUNBLEdBQ0EsR0FDQSxjQUNBO0FBQ0EsUUFBTSxLQUFLLGdCQUFnQixPQUFPO0FBQ2xDLFFBQU0sS0FBSyxnQkFBZ0IsVUFBVSxDQUFDO0FBQ3RDLFFBQU0sS0FBSyxnQkFBZ0IsT0FBTyxJQUFJO0FBQ3RDLFFBQU0sS0FBSyxnQkFBZ0IsVUFBVSxDQUFDLElBQUk7QUFDMUMsTUFBSTtBQUNKLE1BQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN4QixhQUFTO0FBQUEsRUFDWCxPQUFPO0FBQ0wsVUFBTSxNQUFNLElBQUksTUFBTSxNQUFNLElBQUksTUFBTSxPQUFPLEtBQUssS0FBSyxLQUFLO0FBQzVELFFBQUksSUFBSSxHQUFHO0FBQ1QsZUFBUztBQUFBLElBQ1gsV0FBVyxJQUFJLEdBQUc7QUFDaEIsZUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUMvQixxQkFBYSxDQUFDLElBQUk7QUFBQSxVQUNoQixnQkFBZ0IsVUFBVSxDQUFDO0FBQUEsVUFDM0IsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBLFVBQzNCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSxtQkFBYSxTQUFTO0FBQ3RCO0FBQUEsSUFDRixPQUFPO0FBQ0wsZUFBUztBQUFBLElBQ1g7QUFBQSxFQUNGO0FBQ0EsV0FBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUMvQixpQkFBYSxDQUFDLElBQUksZ0JBQWdCLFNBQVMsQ0FBQztBQUFBLEVBQzlDO0FBQ0EsZUFBYSxTQUFTO0FBQ3hCO0FBWU8sU0FBUyxnQkFBZ0IsaUJBQWlCLFFBQVEsS0FBSyxRQUFRLEtBQUs7QUFDekUsTUFBSSxLQUFLLGdCQUFnQixNQUFNO0FBQy9CLE1BQUksS0FBSyxnQkFBZ0IsU0FBUyxDQUFDO0FBQ25DLE9BQUssVUFBVSxRQUFRLFNBQVMsS0FBSyxVQUFVLFFBQVE7QUFDckQsVUFBTSxLQUFLLGdCQUFnQixNQUFNO0FBQ2pDLFVBQU0sS0FBSyxnQkFBZ0IsU0FBUyxDQUFDO0FBQ3JDLFVBQU0sZUFBZSxnQkFBVSxJQUFJLElBQUksSUFBSSxFQUFFO0FBQzdDLFFBQUksZUFBZSxLQUFLO0FBQ3RCLFlBQU07QUFBQSxJQUNSO0FBQ0EsU0FBSztBQUNMLFNBQUs7QUFBQSxFQUNQO0FBQ0EsU0FBTztBQUNUO0FBVU8sU0FBUyxxQkFDZCxpQkFDQSxRQUNBLE1BQ0EsUUFDQSxLQUNBO0FBQ0EsV0FBUyxJQUFJLEdBQUcsS0FBSyxLQUFLLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM3QyxVQUFNLE1BQU0sS0FBSyxDQUFDO0FBQ2xCLFVBQU0sZ0JBQWdCLGlCQUFpQixRQUFRLEtBQUssUUFBUSxHQUFHO0FBQy9ELGFBQVM7QUFBQSxFQUNYO0FBQ0EsU0FBTztBQUNUO0FBdUNPLFNBQVMsbUJBQ2QsaUJBQ0EsUUFDQSxLQUNBLFFBQ0EsVUFDQSxRQUNBLEdBQ0EsR0FDQSxjQUNBLG9CQUNBLFVBQ0E7QUFDQSxNQUFJLFVBQVUsS0FBSztBQUNqQixXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksR0FBR0M7QUFDUCxNQUFJLGFBQWEsR0FBRztBQUVsQixJQUFBQSxtQkFBa0I7QUFBQSxNQUNoQjtBQUFBLE1BQ0E7QUFBQSxNQUNBLGdCQUFnQixNQUFNO0FBQUEsTUFDdEIsZ0JBQWdCLFNBQVMsQ0FBQztBQUFBLElBQzVCO0FBQ0EsUUFBSUEsbUJBQWtCLG9CQUFvQjtBQUN4QyxXQUFLLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQzNCLHFCQUFhLENBQUMsSUFBSSxnQkFBZ0IsU0FBUyxDQUFDO0FBQUEsTUFDOUM7QUFDQSxtQkFBYSxTQUFTO0FBQ3RCLGFBQU9BO0FBQUEsSUFDVDtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0EsYUFBVyxXQUFXLFdBQVcsQ0FBQyxLQUFLLEdBQUc7QUFDMUMsTUFBSSxRQUFRLFNBQVM7QUFDckIsU0FBTyxRQUFRLEtBQUs7QUFDbEI7QUFBQSxNQUNFO0FBQUEsTUFDQSxRQUFRO0FBQUEsTUFDUjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQ0EsSUFBQUEsbUJBQWtCLGdCQUFVLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztBQUMxRCxRQUFJQSxtQkFBa0Isb0JBQW9CO0FBQ3hDLDJCQUFxQkE7QUFDckIsV0FBSyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUMzQixxQkFBYSxDQUFDLElBQUksU0FBUyxDQUFDO0FBQUEsTUFDOUI7QUFDQSxtQkFBYSxTQUFTO0FBQ3RCLGVBQVM7QUFBQSxJQUNYLE9BQU87QUFXTCxlQUNFLFNBQ0EsS0FBSztBQUFBLFNBQ0QsS0FBSyxLQUFLQSxnQkFBZSxJQUFJLEtBQUssS0FBSyxrQkFBa0IsS0FDekQsV0FDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDSjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLFFBQVE7QUFFVjtBQUFBLE1BQ0U7QUFBQSxNQUNBLE1BQU07QUFBQSxNQUNOO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFDQSxJQUFBQSxtQkFBa0IsZ0JBQVUsR0FBRyxHQUFHLFNBQVMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBQzFELFFBQUlBLG1CQUFrQixvQkFBb0I7QUFDeEMsMkJBQXFCQTtBQUNyQixXQUFLLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRSxHQUFHO0FBQzNCLHFCQUFhLENBQUMsSUFBSSxTQUFTLENBQUM7QUFBQSxNQUM5QjtBQUNBLG1CQUFhLFNBQVM7QUFBQSxJQUN4QjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFnQk8sU0FBUyx3QkFDZCxpQkFDQSxRQUNBLE1BQ0EsUUFDQSxVQUNBLFFBQ0EsR0FDQSxHQUNBLGNBQ0Esb0JBQ0EsVUFDQTtBQUNBLGFBQVcsV0FBVyxXQUFXLENBQUMsS0FBSyxHQUFHO0FBQzFDLFdBQVMsSUFBSSxHQUFHLEtBQUssS0FBSyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDN0MsVUFBTSxNQUFNLEtBQUssQ0FBQztBQUNsQix5QkFBcUI7QUFBQSxNQUNuQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQ0EsYUFBUztBQUFBLEVBQ1g7QUFDQSxTQUFPO0FBQ1Q7QUEvUkE7QUFBQTtBQUdBO0FBQUE7QUFBQTs7O0FDUU8sU0FBUyxrQkFBa0IsaUJBQWlCLFFBQVEsWUFBWSxRQUFRO0FBQzdFLFdBQVMsSUFBSSxHQUFHLEtBQUssV0FBVyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDbkQsb0JBQWdCLFFBQVEsSUFBSSxXQUFXLENBQUM7QUFBQSxFQUMxQztBQUNBLFNBQU87QUFDVDtBQVNPLFNBQVMsbUJBQ2QsaUJBQ0EsUUFDQUMsY0FDQSxRQUNBO0FBQ0EsV0FBUyxJQUFJLEdBQUcsS0FBS0EsYUFBWSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDcEQsVUFBTSxhQUFhQSxhQUFZLENBQUM7QUFDaEMsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUMvQixzQkFBZ0IsUUFBUSxJQUFJLFdBQVcsQ0FBQztBQUFBLElBQzFDO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQVVPLFNBQVMsd0JBQ2QsaUJBQ0EsUUFDQSxjQUNBLFFBQ0EsTUFDQTtBQUNBLFNBQU8sT0FBTyxPQUFPLENBQUM7QUFDdEIsTUFBSSxJQUFJO0FBQ1IsV0FBUyxJQUFJLEdBQUcsS0FBSyxhQUFhLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUNyRCxVQUFNLE1BQU07QUFBQSxNQUNWO0FBQUEsTUFDQTtBQUFBLE1BQ0EsYUFBYSxDQUFDO0FBQUEsTUFDZDtBQUFBLElBQ0Y7QUFDQSxTQUFLLEdBQUcsSUFBSTtBQUNaLGFBQVM7QUFBQSxFQUNYO0FBQ0EsT0FBSyxTQUFTO0FBQ2QsU0FBTztBQUNUO0FBckVBO0FBQUE7QUFBQTtBQUFBOzs7QUMwRk8sU0FBUyxlQUNkLGlCQUNBLFFBQ0EsS0FDQSxRQUNBLGtCQUNBLDJCQUNBLGtCQUNBO0FBQ0EsUUFBTSxLQUFLLE1BQU0sVUFBVTtBQUMzQixNQUFJLElBQUksR0FBRztBQUNULFdBQU8sU0FBUyxLQUFLLFVBQVUsUUFBUTtBQUNyQyxnQ0FBMEIsa0JBQWtCLElBQUksZ0JBQWdCLE1BQU07QUFDdEUsZ0NBQTBCLGtCQUFrQixJQUMxQyxnQkFBZ0IsU0FBUyxDQUFDO0FBQUEsSUFDOUI7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUVBLFFBQU0sVUFBVSxJQUFJLE1BQU0sQ0FBQztBQUMzQixVQUFRLENBQUMsSUFBSTtBQUNiLFVBQVEsSUFBSSxDQUFDLElBQUk7QUFFakIsUUFBTSxRQUFRLENBQUMsUUFBUSxNQUFNLE1BQU07QUFDbkMsTUFBSSxRQUFRO0FBQ1osU0FBTyxNQUFNLFNBQVMsR0FBRztBQUN2QixVQUFNLE9BQU8sTUFBTSxJQUFJO0FBQ3ZCLFVBQU0sUUFBUSxNQUFNLElBQUk7QUFDeEIsUUFBSSxxQkFBcUI7QUFDekIsVUFBTSxLQUFLLGdCQUFnQixLQUFLO0FBQ2hDLFVBQU0sS0FBSyxnQkFBZ0IsUUFBUSxDQUFDO0FBQ3BDLFVBQU0sS0FBSyxnQkFBZ0IsSUFBSTtBQUMvQixVQUFNLEtBQUssZ0JBQWdCLE9BQU8sQ0FBQztBQUNuQyxhQUFTLElBQUksUUFBUSxRQUFRLElBQUksTUFBTSxLQUFLLFFBQVE7QUFDbEQsWUFBTSxJQUFJLGdCQUFnQixDQUFDO0FBQzNCLFlBQU0sSUFBSSxnQkFBZ0IsSUFBSSxDQUFDO0FBQy9CLFlBQU1DLG1CQUFrQix1QkFBdUIsR0FBRyxHQUFHLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDbkUsVUFBSUEsbUJBQWtCLG9CQUFvQjtBQUN4QyxnQkFBUTtBQUNSLDZCQUFxQkE7QUFBQSxNQUN2QjtBQUFBLElBQ0Y7QUFDQSxRQUFJLHFCQUFxQixrQkFBa0I7QUFDekMsZUFBUyxRQUFRLFVBQVUsTUFBTSxJQUFJO0FBQ3JDLFVBQUksUUFBUSxTQUFTLE9BQU87QUFDMUIsY0FBTSxLQUFLLE9BQU8sS0FBSztBQUFBLE1BQ3pCO0FBQ0EsVUFBSSxRQUFRLFNBQVMsTUFBTTtBQUN6QixjQUFNLEtBQUssT0FBTyxJQUFJO0FBQUEsTUFDeEI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLFdBQVMsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDMUIsUUFBSSxRQUFRLENBQUMsR0FBRztBQUNkLGdDQUEwQixrQkFBa0IsSUFDMUMsZ0JBQWdCLFNBQVMsSUFBSSxNQUFNO0FBQ3JDLGdDQUEwQixrQkFBa0IsSUFDMUMsZ0JBQWdCLFNBQVMsSUFBSSxTQUFTLENBQUM7QUFBQSxJQUMzQztBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFjTyxTQUFTLG9CQUNkLGlCQUNBLFFBQ0EsTUFDQSxRQUNBLGtCQUNBLDJCQUNBLGtCQUNBLGdCQUNBO0FBQ0EsV0FBUyxJQUFJLEdBQUcsS0FBSyxLQUFLLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM3QyxVQUFNLE1BQU0sS0FBSyxDQUFDO0FBQ2xCLHVCQUFtQjtBQUFBLE1BQ2pCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUNBLG1CQUFlLEtBQUssZ0JBQWdCO0FBQ3BDLGFBQVM7QUFBQSxFQUNYO0FBQ0EsU0FBTztBQUNUO0FBd0dPLFNBQVMsS0FBSyxPQUFPLFdBQVc7QUFDckMsU0FBTyxZQUFZLEtBQUssTUFBTSxRQUFRLFNBQVM7QUFDakQ7QUFxQk8sU0FBUyxTQUNkLGlCQUNBLFFBQ0EsS0FDQSxRQUNBLFdBQ0EsMkJBQ0Esa0JBQ0E7QUFFQSxNQUFJLFVBQVUsS0FBSztBQUNqQixXQUFPO0FBQUEsRUFDVDtBQUVBLE1BQUksS0FBSyxLQUFLLGdCQUFnQixNQUFNLEdBQUcsU0FBUztBQUNoRCxNQUFJLEtBQUssS0FBSyxnQkFBZ0IsU0FBUyxDQUFDLEdBQUcsU0FBUztBQUNwRCxZQUFVO0FBRVYsNEJBQTBCLGtCQUFrQixJQUFJO0FBQ2hELDRCQUEwQixrQkFBa0IsSUFBSTtBQUdoRCxNQUFJLElBQUk7QUFDUixLQUFHO0FBQ0QsU0FBSyxLQUFLLGdCQUFnQixNQUFNLEdBQUcsU0FBUztBQUM1QyxTQUFLLEtBQUssZ0JBQWdCLFNBQVMsQ0FBQyxHQUFHLFNBQVM7QUFDaEQsY0FBVTtBQUNWLFFBQUksVUFBVSxLQUFLO0FBS2pCLGdDQUEwQixrQkFBa0IsSUFBSTtBQUNoRCxnQ0FBMEIsa0JBQWtCLElBQUk7QUFDaEQsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGLFNBQVMsTUFBTSxNQUFNLE1BQU07QUFDM0IsU0FBTyxTQUFTLEtBQUs7QUFFbkIsVUFBTSxLQUFLLEtBQUssZ0JBQWdCLE1BQU0sR0FBRyxTQUFTO0FBQ2xELFVBQU0sS0FBSyxLQUFLLGdCQUFnQixTQUFTLENBQUMsR0FBRyxTQUFTO0FBQ3RELGNBQVU7QUFFVixRQUFJLE1BQU0sTUFBTSxNQUFNLElBQUk7QUFDeEI7QUFBQSxJQUNGO0FBRUEsVUFBTSxNQUFNLEtBQUs7QUFDakIsVUFBTSxNQUFNLEtBQUs7QUFFakIsVUFBTSxNQUFNLEtBQUs7QUFDakIsVUFBTSxNQUFNLEtBQUs7QUFJakIsUUFDRSxNQUFNLE9BQU8sTUFBTSxRQUNqQixNQUFNLEtBQUssTUFBTSxPQUFRLE9BQU8sT0FBUSxNQUFNLEtBQUssTUFBTSxTQUN6RCxNQUFNLEtBQUssTUFBTSxPQUFRLE9BQU8sT0FBUSxNQUFNLEtBQUssTUFBTSxNQUMzRDtBQUVBLFdBQUs7QUFDTCxXQUFLO0FBQ0w7QUFBQSxJQUNGO0FBSUEsOEJBQTBCLGtCQUFrQixJQUFJO0FBQ2hELDhCQUEwQixrQkFBa0IsSUFBSTtBQUNoRCxTQUFLO0FBQ0wsU0FBSztBQUNMLFNBQUs7QUFDTCxTQUFLO0FBQUEsRUFDUDtBQUVBLDRCQUEwQixrQkFBa0IsSUFBSTtBQUNoRCw0QkFBMEIsa0JBQWtCLElBQUk7QUFDaEQsU0FBTztBQUNUO0FBY08sU0FBUyxjQUNkLGlCQUNBLFFBQ0EsTUFDQSxRQUNBLFdBQ0EsMkJBQ0Esa0JBQ0EsZ0JBQ0E7QUFDQSxXQUFTLElBQUksR0FBRyxLQUFLLEtBQUssUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQzdDLFVBQU0sTUFBTSxLQUFLLENBQUM7QUFDbEIsdUJBQW1CO0FBQUEsTUFDakI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQ0EsbUJBQWUsS0FBSyxnQkFBZ0I7QUFDcEMsYUFBUztBQUFBLEVBQ1g7QUFDQSxTQUFPO0FBQ1Q7QUFuYkE7QUFBQTtBQTZCQTtBQUFBO0FBQUE7OztBQ2pCTyxTQUFTLG1CQUNkLGlCQUNBLFFBQ0EsS0FDQSxRQUNBQyxjQUNBO0FBQ0EsRUFBQUEsZUFBY0EsaUJBQWdCLFNBQVlBLGVBQWMsQ0FBQztBQUN6RCxNQUFJLElBQUk7QUFDUixXQUFTLElBQUksUUFBUSxJQUFJLEtBQUssS0FBSyxRQUFRO0FBQ3pDLElBQUFBLGFBQVksR0FBRyxJQUFJLGdCQUFnQixNQUFNLEdBQUcsSUFBSSxNQUFNO0FBQUEsRUFDeEQ7QUFDQSxFQUFBQSxhQUFZLFNBQVM7QUFDckIsU0FBT0E7QUFDVDtBQVVPLFNBQVMsd0JBQ2QsaUJBQ0EsUUFDQSxNQUNBLFFBQ0EsY0FDQTtBQUNBLGlCQUFlLGlCQUFpQixTQUFZLGVBQWUsQ0FBQztBQUM1RCxNQUFJLElBQUk7QUFDUixXQUFTLElBQUksR0FBRyxLQUFLLEtBQUssUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQzdDLFVBQU0sTUFBTSxLQUFLLENBQUM7QUFDbEIsaUJBQWEsR0FBRyxJQUFJO0FBQUEsTUFDbEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLGFBQWEsQ0FBQztBQUFBLElBQ2hCO0FBQ0EsYUFBUztBQUFBLEVBQ1g7QUFDQSxlQUFhLFNBQVM7QUFDdEIsU0FBTztBQUNUO0FBV08sU0FBUyw2QkFDZCxpQkFDQSxRQUNBLE9BQ0EsUUFDQSxlQUNBO0FBQ0Esa0JBQWdCLGtCQUFrQixTQUFZLGdCQUFnQixDQUFDO0FBQy9ELE1BQUksSUFBSTtBQUNSLFdBQVMsSUFBSSxHQUFHLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDOUMsVUFBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixrQkFBYyxHQUFHLElBQ2YsS0FBSyxXQUFXLEtBQUssS0FBSyxDQUFDLE1BQU0sU0FDN0IsQ0FBQyxJQUNEO0FBQUEsTUFDRTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0EsY0FBYyxDQUFDO0FBQUEsSUFDakI7QUFDTixhQUFTLEtBQUssS0FBSyxTQUFTLENBQUM7QUFBQSxFQUMvQjtBQUNBLGdCQUFjLFNBQVM7QUFDdkIsU0FBTztBQUNUO0FBOUZBO0FBQUE7QUFBQTtBQUFBOzs7QUNXTyxTQUFTLFdBQVcsaUJBQWlCLFFBQVEsS0FBSyxRQUFRO0FBQy9ELE1BQUksWUFBWTtBQUNoQixNQUFJLEtBQUssZ0JBQWdCLE1BQU0sTUFBTTtBQUNyQyxNQUFJLEtBQUssZ0JBQWdCLE1BQU0sU0FBUyxDQUFDO0FBQ3pDLFNBQU8sU0FBUyxLQUFLLFVBQVUsUUFBUTtBQUNyQyxVQUFNLEtBQUssZ0JBQWdCLE1BQU07QUFDakMsVUFBTSxLQUFLLGdCQUFnQixTQUFTLENBQUM7QUFDckMsaUJBQWEsS0FBSyxLQUFLLEtBQUs7QUFDNUIsU0FBSztBQUNMLFNBQUs7QUFBQSxFQUNQO0FBQ0EsU0FBTyxZQUFZO0FBQ3JCO0FBU08sU0FBUyxZQUFZLGlCQUFpQixRQUFRLE1BQU0sUUFBUTtBQUNqRSxNQUFJLE9BQU87QUFDWCxXQUFTLElBQUksR0FBRyxLQUFLLEtBQUssUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQzdDLFVBQU0sTUFBTSxLQUFLLENBQUM7QUFDbEIsWUFBUSxXQUFXLGlCQUFpQixRQUFRLEtBQUssTUFBTTtBQUN2RCxhQUFTO0FBQUEsRUFDWDtBQUNBLFNBQU87QUFDVDtBQXhDQTtBQUFBO0FBQUE7QUFBQTs7O0FDQUEsSUFrQk0sWUEwS0M7QUE1TFA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0EsSUFBTSxhQUFOLE1BQU0sb0JBQW1CLHVCQUFlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTXRDLFlBQVlDLGNBQWEsUUFBUTtBQUMvQixjQUFNO0FBTU4sYUFBSyxZQUFZO0FBTWpCLGFBQUssb0JBQW9CO0FBRXpCLFlBQUksV0FBVyxVQUFhLENBQUMsTUFBTSxRQUFRQSxhQUFZLENBQUMsQ0FBQyxHQUFHO0FBQzFELGVBQUs7QUFBQSxZQUNIO0FBQUE7QUFBQSxZQUM4QkE7QUFBQSxVQUNoQztBQUFBLFFBQ0YsT0FBTztBQUNMLGVBQUs7QUFBQTtBQUFBLFlBRURBO0FBQUEsWUFFRjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixlQUFPLElBQUksWUFBVyxLQUFLLGdCQUFnQixNQUFNLEdBQUcsS0FBSyxNQUFNO0FBQUEsTUFDakU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsZUFBZSxHQUFHLEdBQUcsY0FBYyxvQkFBb0I7QUFDckQsWUFBSSxxQkFBcUIseUJBQXlCLEtBQUssVUFBVSxHQUFHLEdBQUcsQ0FBQyxHQUFHO0FBQ3pFLGlCQUFPO0FBQUEsUUFDVDtBQUNBLFlBQUksS0FBSyxxQkFBcUIsS0FBSyxZQUFZLEdBQUc7QUFDaEQsZUFBSyxZQUFZLEtBQUs7QUFBQSxZQUNwQjtBQUFBLGNBQ0UsS0FBSztBQUFBLGNBQ0w7QUFBQSxjQUNBLEtBQUssZ0JBQWdCO0FBQUEsY0FDckIsS0FBSztBQUFBLGNBQ0w7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUNBLGVBQUssb0JBQW9CLEtBQUssWUFBWTtBQUFBLFFBQzVDO0FBQ0EsZUFBTztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBLEtBQUssZ0JBQWdCO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBLEtBQUssZ0JBQWdCO0FBQUEsVUFDckIsS0FBSztBQUFBLFFBQ1A7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsaUJBQWlCO0FBQ2YsZUFBTztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBLEtBQUssZ0JBQWdCO0FBQUEsVUFDckIsS0FBSztBQUFBLFFBQ1A7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsOEJBQThCLGtCQUFrQjtBQUU5QyxjQUFNLDRCQUE0QixDQUFDO0FBQ25DLGtDQUEwQixTQUFTO0FBQUEsVUFDakMsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBLEtBQUssZ0JBQWdCO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFDQSxlQUFPLElBQUksWUFBVywyQkFBMkIsSUFBSTtBQUFBLE1BQ3ZEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxpQkFBaUIsUUFBUTtBQUN2QixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsZUFBZUEsY0FBYSxRQUFRO0FBQ2xDLGFBQUssVUFBVSxRQUFRQSxjQUFhLENBQUM7QUFDckMsWUFBSSxDQUFDLEtBQUssaUJBQWlCO0FBQ3pCLGVBQUssa0JBQWtCLENBQUM7QUFBQSxRQUMxQjtBQUNBLGFBQUssZ0JBQWdCLFNBQVM7QUFBQSxVQUM1QixLQUFLO0FBQUEsVUFDTDtBQUFBLFVBQ0FBO0FBQUEsVUFDQSxLQUFLO0FBQUEsUUFDUDtBQUNBLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNGO0FBRUEsSUFBTyxxQkFBUTtBQUFBO0FBQUE7OztBQzVMZjtBQUFBO0FBQUE7QUFBQTtBQUFBLElBY00sT0F3R0M7QUF0SFA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBUUEsSUFBTSxRQUFOLE1BQU0sZUFBYyx1QkFBZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLakMsWUFBWUMsY0FBYSxRQUFRO0FBQy9CLGNBQU07QUFDTixhQUFLLGVBQWVBLGNBQWEsTUFBTTtBQUFBLE1BQ3pDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsUUFBUTtBQUNOLGNBQU0sUUFBUSxJQUFJLE9BQU0sS0FBSyxnQkFBZ0IsTUFBTSxHQUFHLEtBQUssTUFBTTtBQUNqRSxjQUFNLGdCQUFnQixJQUFJO0FBQzFCLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGVBQWUsR0FBRyxHQUFHLGNBQWMsb0JBQW9CO0FBQ3JELGNBQU0sa0JBQWtCLEtBQUs7QUFDN0IsY0FBTUMsbUJBQWtCO0FBQUEsVUFDdEI7QUFBQSxVQUNBO0FBQUEsVUFDQSxnQkFBZ0IsQ0FBQztBQUFBLFVBQ2pCLGdCQUFnQixDQUFDO0FBQUEsUUFDbkI7QUFDQSxZQUFJQSxtQkFBa0Isb0JBQW9CO0FBQ3hDLGdCQUFNLFNBQVMsS0FBSztBQUNwQixtQkFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUMvQix5QkFBYSxDQUFDLElBQUksZ0JBQWdCLENBQUM7QUFBQSxVQUNyQztBQUNBLHVCQUFhLFNBQVM7QUFDdEIsaUJBQU9BO0FBQUEsUUFDVDtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLLGdCQUFnQixNQUFNO0FBQUEsTUFDcEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxjQUFjLFFBQVE7QUFDcEIsZUFBTyw2QkFBNkIsS0FBSyxpQkFBaUIsTUFBTTtBQUFBLE1BQ2xFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxpQkFBaUIsUUFBUTtBQUN2QixlQUFPLFdBQVcsUUFBUSxLQUFLLGdCQUFnQixDQUFDLEdBQUcsS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQUEsTUFDNUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxlQUFlRCxjQUFhLFFBQVE7QUFDbEMsYUFBSyxVQUFVLFFBQVFBLGNBQWEsQ0FBQztBQUNyQyxZQUFJLENBQUMsS0FBSyxpQkFBaUI7QUFDekIsZUFBSyxrQkFBa0IsQ0FBQztBQUFBLFFBQzFCO0FBQ0EsYUFBSyxnQkFBZ0IsU0FBUztBQUFBLFVBQzVCLEtBQUs7QUFBQSxVQUNMO0FBQUEsVUFDQUE7QUFBQSxVQUNBLEtBQUs7QUFBQSxRQUNQO0FBQ0EsYUFBSyxRQUFRO0FBQUEsTUFDZjtBQUFBLElBQ0Y7QUFFQSxJQUFPLGdCQUFRO0FBQUE7QUFBQTs7O0FDekdSLFNBQVMseUJBQ2QsaUJBQ0EsUUFDQSxLQUNBLFFBQ0EsUUFDQTtBQUNBLFFBQU0sVUFBVTtBQUFBLElBQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBS0EsU0FBVSxZQUFZO0FBQ3BCLGFBQU8sQ0FBQztBQUFBLFFBQ047QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBLFdBQVcsQ0FBQztBQUFBLFFBQ1osV0FBVyxDQUFDO0FBQUEsTUFDZDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTyxDQUFDO0FBQ1Y7QUFXTyxTQUFTLHFCQUNkLGlCQUNBLFFBQ0EsS0FDQSxRQUNBLEdBQ0EsR0FDQTtBQVFBLE1BQUksS0FBSztBQUNULE1BQUksS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3JDLE1BQUksS0FBSyxnQkFBZ0IsTUFBTSxTQUFTLENBQUM7QUFDekMsU0FBTyxTQUFTLEtBQUssVUFBVSxRQUFRO0FBQ3JDLFVBQU0sS0FBSyxnQkFBZ0IsTUFBTTtBQUNqQyxVQUFNLEtBQUssZ0JBQWdCLFNBQVMsQ0FBQztBQUNyQyxRQUFJLE1BQU0sR0FBRztBQUNYLFVBQUksS0FBSyxNQUFNLEtBQUssT0FBTyxJQUFJLE9BQU8sSUFBSSxPQUFPLEtBQUssTUFBTSxHQUFHO0FBQzdEO0FBQUEsTUFDRjtBQUFBLElBQ0YsV0FBVyxNQUFNLE1BQU0sS0FBSyxPQUFPLElBQUksT0FBTyxJQUFJLE9BQU8sS0FBSyxNQUFNLEdBQUc7QUFDckU7QUFBQSxJQUNGO0FBQ0EsU0FBSztBQUNMLFNBQUs7QUFBQSxFQUNQO0FBQ0EsU0FBTyxPQUFPO0FBQ2hCO0FBV08sU0FBUyxzQkFDZCxpQkFDQSxRQUNBLE1BQ0EsUUFDQSxHQUNBLEdBQ0E7QUFDQSxNQUFJLEtBQUssV0FBVyxHQUFHO0FBQ3JCLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxDQUFDLHFCQUFxQixpQkFBaUIsUUFBUSxLQUFLLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxHQUFHO0FBQ3pFLFdBQU87QUFBQSxFQUNUO0FBQ0EsV0FBUyxJQUFJLEdBQUcsS0FBSyxLQUFLLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM3QyxRQUNFLHFCQUFxQixpQkFBaUIsS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxHQUN4RTtBQUNBLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQWxIQTtBQUFBO0FBR0E7QUFBQTtBQUFBOzs7QUNnQk8sU0FBUyx3QkFDZCxpQkFDQSxRQUNBLE1BQ0EsUUFDQSxhQUNBLG1CQUNBLE1BQ0E7QUFDQSxNQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJO0FBQzFCLFFBQU0sSUFBSSxZQUFZLG9CQUFvQixDQUFDO0FBRTNDLFFBQU0sZ0JBQWdCLENBQUM7QUFFdkIsV0FBUyxJQUFJLEdBQUcsS0FBSyxLQUFLLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM3QyxVQUFNLE1BQU0sS0FBSyxDQUFDO0FBQ2xCLFNBQUssZ0JBQWdCLE1BQU0sTUFBTTtBQUNqQyxTQUFLLGdCQUFnQixNQUFNLFNBQVMsQ0FBQztBQUNyQyxTQUFLLElBQUksUUFBUSxJQUFJLEtBQUssS0FBSyxRQUFRO0FBQ3JDLFdBQUssZ0JBQWdCLENBQUM7QUFDdEIsV0FBSyxnQkFBZ0IsSUFBSSxDQUFDO0FBQzFCLFVBQUssS0FBSyxNQUFNLE1BQU0sS0FBTyxNQUFNLEtBQUssS0FBSyxJQUFLO0FBQ2hELGFBQU0sSUFBSSxPQUFPLEtBQUssT0FBUSxLQUFLLE1BQU07QUFDekMsc0JBQWMsS0FBSyxDQUFDO0FBQUEsTUFDdEI7QUFDQSxXQUFLO0FBQ0wsV0FBSztBQUFBLElBQ1A7QUFBQSxFQUNGO0FBR0EsTUFBSSxTQUFTO0FBQ2IsTUFBSSxtQkFBbUI7QUFDdkIsZ0JBQWMsS0FBSyxTQUFTO0FBQzVCLE9BQUssY0FBYyxDQUFDO0FBQ3BCLE9BQUssSUFBSSxHQUFHLEtBQUssY0FBYyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDbEQsU0FBSyxjQUFjLENBQUM7QUFDcEIsVUFBTSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssRUFBRTtBQUN0QyxRQUFJLGdCQUFnQixrQkFBa0I7QUFDcEMsV0FBSyxLQUFLLE1BQU07QUFDaEIsVUFBSSxzQkFBc0IsaUJBQWlCLFFBQVEsTUFBTSxRQUFRLEdBQUcsQ0FBQyxHQUFHO0FBQ3RFLGlCQUFTO0FBQ1QsMkJBQW1CO0FBQUEsTUFDckI7QUFBQSxJQUNGO0FBQ0EsU0FBSztBQUFBLEVBQ1A7QUFDQSxNQUFJLE1BQU0sTUFBTSxHQUFHO0FBR2pCLGFBQVMsWUFBWSxpQkFBaUI7QUFBQSxFQUN4QztBQUNBLE1BQUksTUFBTTtBQUNSLFNBQUssS0FBSyxRQUFRLEdBQUcsZ0JBQWdCO0FBQ3JDLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxDQUFDLFFBQVEsR0FBRyxnQkFBZ0I7QUFDckM7QUFXTyxTQUFTLDhCQUNkLGlCQUNBLFFBQ0EsT0FDQSxRQUNBLGFBQ0E7QUFFQSxNQUFJLGlCQUFpQixDQUFDO0FBQ3RCLFdBQVMsSUFBSSxHQUFHLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDOUMsVUFBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixxQkFBaUI7QUFBQSxNQUNmO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0EsSUFBSTtBQUFBLE1BQ0o7QUFBQSxJQUNGO0FBQ0EsYUFBUyxLQUFLLEtBQUssU0FBUyxDQUFDO0FBQUEsRUFDL0I7QUFDQSxTQUFPO0FBQ1Q7QUE5R0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBOzs7QUNhTyxTQUFTLFFBQVEsaUJBQWlCLFFBQVEsS0FBSyxRQUFRLFVBQVU7QUFDdEUsTUFBSTtBQUNKLFlBQVU7QUFDVixTQUFPLFNBQVMsS0FBSyxVQUFVLFFBQVE7QUFDckMsVUFBTTtBQUFBLE1BQ0osZ0JBQWdCLE1BQU0sU0FBUyxRQUFRLE1BQU07QUFBQSxNQUM3QyxnQkFBZ0IsTUFBTSxRQUFRLFNBQVMsTUFBTTtBQUFBLElBQy9DO0FBQ0EsUUFBSSxLQUFLO0FBQ1AsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUO0FBOUJBO0FBQUE7QUFBQTtBQUFBOzs7QUNxQk8sU0FBUyxxQkFDZCxpQkFDQSxRQUNBLEtBQ0EsUUFDQSxRQUNBO0FBQ0EsUUFBTSxvQkFBb0I7QUFBQSxJQUN4QixZQUFZO0FBQUEsSUFDWjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxNQUFJLENBQUMsV0FBVyxRQUFRLGlCQUFpQixHQUFHO0FBQzFDLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxlQUFlLFFBQVEsaUJBQWlCLEdBQUc7QUFDN0MsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUFJLGtCQUFrQixDQUFDLEtBQUssT0FBTyxDQUFDLEtBQUssa0JBQWtCLENBQUMsS0FBSyxPQUFPLENBQUMsR0FBRztBQUMxRSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksa0JBQWtCLENBQUMsS0FBSyxPQUFPLENBQUMsS0FBSyxrQkFBa0IsQ0FBQyxLQUFLLE9BQU8sQ0FBQyxHQUFHO0FBQzFFLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQU9BLFNBQVUsUUFBUSxRQUFRO0FBQ3hCLGFBQU8sa0JBQWtCLFFBQVEsUUFBUSxNQUFNO0FBQUEsSUFDakQ7QUFBQSxFQUNGO0FBQ0Y7QUFvQ08sU0FBUyxxQkFDZCxpQkFDQSxRQUNBLEtBQ0EsUUFDQSxRQUNBO0FBQ0EsTUFBSSxxQkFBcUIsaUJBQWlCLFFBQVEsS0FBSyxRQUFRLE1BQU0sR0FBRztBQUN0RSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQ0U7QUFBQSxJQUNFO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxPQUFPLENBQUM7QUFBQSxJQUNSLE9BQU8sQ0FBQztBQUFBLEVBQ1YsR0FDQTtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFDRTtBQUFBLElBQ0U7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLE9BQU8sQ0FBQztBQUFBLElBQ1IsT0FBTyxDQUFDO0FBQUEsRUFDVixHQUNBO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxNQUNFO0FBQUEsSUFDRTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0EsT0FBTyxDQUFDO0FBQUEsSUFDUixPQUFPLENBQUM7QUFBQSxFQUNWLEdBQ0E7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQ0U7QUFBQSxJQUNFO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxPQUFPLENBQUM7QUFBQSxJQUNSLE9BQU8sQ0FBQztBQUFBLEVBQ1YsR0FDQTtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTztBQUNUO0FBVU8sU0FBUywwQkFDZCxpQkFDQSxRQUNBLE1BQ0EsUUFDQSxRQUNBO0FBQ0EsTUFBSSxDQUFDLHFCQUFxQixpQkFBaUIsUUFBUSxLQUFLLENBQUMsR0FBRyxRQUFRLE1BQU0sR0FBRztBQUMzRSxXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxXQUFTLElBQUksR0FBRyxLQUFLLEtBQUssUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQzdDLFFBQ0U7QUFBQSxNQUNFO0FBQUEsTUFDQSxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ1YsS0FBSyxDQUFDO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxJQUNGLEdBQ0E7QUFDQSxVQUNFLENBQUM7QUFBQSxRQUNDO0FBQUEsUUFDQSxLQUFLLElBQUksQ0FBQztBQUFBLFFBQ1YsS0FBSyxDQUFDO0FBQUEsUUFDTjtBQUFBLFFBQ0E7QUFBQSxNQUNGLEdBQ0E7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUO0FBNU1BO0FBQUE7QUFHQTtBQU9BO0FBQ0E7QUFBQTtBQUFBOzs7QUNETyxTQUFTLFlBQVksaUJBQWlCLFFBQVEsS0FBSyxRQUFRO0FBQ2hFLFNBQU8sU0FBUyxNQUFNLFFBQVE7QUFDNUIsYUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUUsR0FBRztBQUMvQixZQUFNLE1BQU0sZ0JBQWdCLFNBQVMsQ0FBQztBQUN0QyxzQkFBZ0IsU0FBUyxDQUFDLElBQUksZ0JBQWdCLE1BQU0sU0FBUyxDQUFDO0FBQzlELHNCQUFnQixNQUFNLFNBQVMsQ0FBQyxJQUFJO0FBQUEsSUFDdEM7QUFDQSxjQUFVO0FBQ1YsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQXBCQTtBQUFBO0FBQUE7QUFBQTs7O0FDZU8sU0FBUyxzQkFBc0IsaUJBQWlCLFFBQVEsS0FBSyxRQUFRO0FBRzFFLE1BQUksT0FBTztBQUNYLE1BQUksS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3JDLE1BQUksS0FBSyxnQkFBZ0IsTUFBTSxTQUFTLENBQUM7QUFDekMsU0FBTyxTQUFTLEtBQUssVUFBVSxRQUFRO0FBQ3JDLFVBQU0sS0FBSyxnQkFBZ0IsTUFBTTtBQUNqQyxVQUFNLEtBQUssZ0JBQWdCLFNBQVMsQ0FBQztBQUNyQyxhQUFTLEtBQUssT0FBTyxLQUFLO0FBQzFCLFNBQUs7QUFDTCxTQUFLO0FBQUEsRUFDUDtBQUNBLFNBQU8sU0FBUyxJQUFJLFNBQVksT0FBTztBQUN6QztBQWVPLFNBQVMsdUJBQ2QsaUJBQ0EsUUFDQSxNQUNBLFFBQ0EsT0FDQTtBQUNBLFVBQVEsVUFBVSxTQUFZLFFBQVE7QUFDdEMsV0FBUyxJQUFJLEdBQUcsS0FBSyxLQUFLLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM3QyxVQUFNLE1BQU0sS0FBSyxDQUFDO0FBQ2xCLFVBQU0sY0FBYztBQUFBLE1BQ2xCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUNBLFFBQUksTUFBTSxHQUFHO0FBQ1gsVUFBSyxTQUFTLGVBQWlCLENBQUMsU0FBUyxDQUFDLGFBQWM7QUFDdEQsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGLE9BQU87QUFDTCxVQUFLLFNBQVMsQ0FBQyxlQUFpQixDQUFDLFNBQVMsYUFBYztBQUN0RCxlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFDQSxhQUFTO0FBQUEsRUFDWDtBQUNBLFNBQU87QUFDVDtBQStDTyxTQUFTLGtCQUNkLGlCQUNBLFFBQ0EsTUFDQSxRQUNBLE9BQ0E7QUFDQSxVQUFRLFVBQVUsU0FBWSxRQUFRO0FBQ3RDLFdBQVMsSUFBSSxHQUFHLEtBQUssS0FBSyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDN0MsVUFBTSxNQUFNLEtBQUssQ0FBQztBQUNsQixVQUFNLGNBQWM7QUFBQSxNQUNsQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFDQSxVQUFNLFVBQ0osTUFBTSxJQUNELFNBQVMsZUFBaUIsQ0FBQyxTQUFTLENBQUMsY0FDckMsU0FBUyxDQUFDLGVBQWlCLENBQUMsU0FBUztBQUM1QyxRQUFJLFNBQVM7QUFDWCxrQkFBbUIsaUJBQWlCLFFBQVEsS0FBSyxNQUFNO0FBQUEsSUFDekQ7QUFDQSxhQUFTO0FBQUEsRUFDWDtBQUNBLFNBQU87QUFDVDtBQXlDTyxTQUFTLFlBQVksaUJBQWlCLE1BQU07QUFDakQsUUFBTSxRQUFRLENBQUM7QUFDZixNQUFJLFNBQVM7QUFDYixNQUFJLGVBQWU7QUFDbkIsTUFBSTtBQUNKLFdBQVMsSUFBSSxHQUFHLEtBQUssS0FBSyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDN0MsVUFBTSxNQUFNLEtBQUssQ0FBQztBQUVsQixVQUFNLGNBQWMsc0JBQXNCLGlCQUFpQixRQUFRLEtBQUssQ0FBQztBQUN6RSxRQUFJLHFCQUFxQixRQUFXO0FBQ2xDLHlCQUFtQjtBQUFBLElBQ3JCO0FBQ0EsUUFBSSxnQkFBZ0Isa0JBQWtCO0FBQ3BDLFlBQU0sS0FBSyxLQUFLLE1BQU0sY0FBYyxJQUFJLENBQUMsQ0FBQztBQUFBLElBQzVDLE9BQU87QUFDTCxVQUFJLE1BQU0sV0FBVyxHQUFHO0FBQ3RCO0FBQUEsTUFDRjtBQUNBLFlBQU0sTUFBTSxTQUFTLENBQUMsRUFBRSxLQUFLLEtBQUssWUFBWSxDQUFDO0FBQUEsSUFDakQ7QUFDQSxtQkFBZSxJQUFJO0FBQ25CLGFBQVM7QUFBQSxFQUNYO0FBQ0EsU0FBTztBQUNUO0FBbE5BO0FBQUE7QUFHQTtBQUFBO0FBQUE7OztBQ3diTyxTQUFTLFdBQVcsUUFBUTtBQUNqQyxNQUFJRSxTQUFRLE1BQU0sR0FBRztBQUNuQixVQUFNLElBQUksTUFBTSx5Q0FBeUM7QUFBQSxFQUMzRDtBQUNBLFFBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsUUFBTSxPQUFPLE9BQU8sQ0FBQztBQUNyQixRQUFNLE9BQU8sT0FBTyxDQUFDO0FBQ3JCLFFBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsUUFBTSxrQkFBa0I7QUFBQSxJQUN0QjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxTQUFPLElBQUksUUFBUSxpQkFBaUIsTUFBTSxDQUFDLGdCQUFnQixNQUFNLENBQUM7QUFDcEU7QUFoZEEsSUEwQk0sU0ErWEM7QUF6WlA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQSxJQUFNLFVBQU4sTUFBTSxpQkFBZ0IsdUJBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFZbkMsWUFBWUMsY0FBYSxRQUFRLE1BQU07QUFDckMsY0FBTTtBQU1OLGFBQUssUUFBUSxDQUFDO0FBTWQsYUFBSyw2QkFBNkI7QUFNbEMsYUFBSyxxQkFBcUI7QUFNMUIsYUFBSyxZQUFZO0FBTWpCLGFBQUssb0JBQW9CO0FBTXpCLGFBQUssb0JBQW9CO0FBTXpCLGFBQUssMkJBQTJCO0FBRWhDLFlBQUksV0FBVyxVQUFhLE1BQU07QUFDaEMsZUFBSztBQUFBLFlBQ0g7QUFBQTtBQUFBLFlBQzhCQTtBQUFBLFVBQ2hDO0FBQ0EsZUFBSyxRQUFRO0FBQUEsUUFDZixPQUFPO0FBQ0wsZUFBSztBQUFBO0FBQUEsWUFFREE7QUFBQSxZQUVGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsaUJBQWlCQyxhQUFZO0FBQzNCLFlBQUksQ0FBQyxLQUFLLGlCQUFpQjtBQUN6QixlQUFLLGtCQUFrQkEsWUFBVyxtQkFBbUIsRUFBRSxNQUFNO0FBQUEsUUFDL0QsT0FBTztBQUNMLGlCQUFPLEtBQUssaUJBQWlCQSxZQUFXLG1CQUFtQixDQUFDO0FBQUEsUUFDOUQ7QUFDQSxhQUFLLE1BQU0sS0FBSyxLQUFLLGdCQUFnQixNQUFNO0FBQzNDLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxRQUFRO0FBQ04sY0FBTSxVQUFVLElBQUk7QUFBQSxVQUNsQixLQUFLLGdCQUFnQixNQUFNO0FBQUEsVUFDM0IsS0FBSztBQUFBLFVBQ0wsS0FBSyxNQUFNLE1BQU07QUFBQSxRQUNuQjtBQUNBLGdCQUFRLGdCQUFnQixJQUFJO0FBQzVCLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGVBQWUsR0FBRyxHQUFHLGNBQWMsb0JBQW9CO0FBQ3JELFlBQUkscUJBQXFCLHlCQUF5QixLQUFLLFVBQVUsR0FBRyxHQUFHLENBQUMsR0FBRztBQUN6RSxpQkFBTztBQUFBLFFBQ1Q7QUFDQSxZQUFJLEtBQUsscUJBQXFCLEtBQUssWUFBWSxHQUFHO0FBQ2hELGVBQUssWUFBWSxLQUFLO0FBQUEsWUFDcEI7QUFBQSxjQUNFLEtBQUs7QUFBQSxjQUNMO0FBQUEsY0FDQSxLQUFLO0FBQUEsY0FDTCxLQUFLO0FBQUEsY0FDTDtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQ0EsZUFBSyxvQkFBb0IsS0FBSyxZQUFZO0FBQUEsUUFDNUM7QUFDQSxlQUFPO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTDtBQUFBLFVBQ0EsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXLEdBQUcsR0FBRztBQUNmLGVBQU87QUFBQSxVQUNMLEtBQUssMkJBQTJCO0FBQUEsVUFDaEM7QUFBQSxVQUNBLEtBQUs7QUFBQSxVQUNMLEtBQUs7QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU87QUFBQSxVQUNMLEtBQUssMkJBQTJCO0FBQUEsVUFDaEM7QUFBQSxVQUNBLEtBQUs7QUFBQSxVQUNMLEtBQUs7QUFBQSxRQUNQO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFlQSxlQUFlLE9BQU87QUFDcEIsWUFBSTtBQUNKLFlBQUksVUFBVSxRQUFXO0FBQ3ZCLDRCQUFrQixLQUFLLDJCQUEyQixFQUFFLE1BQU07QUFDMUQsNEJBQWtCLGlCQUFpQixHQUFHLEtBQUssT0FBTyxLQUFLLFFBQVEsS0FBSztBQUFBLFFBQ3RFLE9BQU87QUFDTCw0QkFBa0IsS0FBSztBQUFBLFFBQ3pCO0FBRUEsZUFBTyx3QkFBd0IsaUJBQWlCLEdBQUcsS0FBSyxPQUFPLEtBQUssTUFBTTtBQUFBLE1BQzVFO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsdUJBQXVCO0FBQ3JCLFlBQUksS0FBSyw4QkFBOEIsS0FBSyxZQUFZLEdBQUc7QUFDekQsZ0JBQU0sYUFBYSxVQUFVLEtBQUssVUFBVSxDQUFDO0FBQzdDLGVBQUsscUJBQXFCO0FBQUEsWUFDeEIsS0FBSywyQkFBMkI7QUFBQSxZQUNoQztBQUFBLFlBQ0EsS0FBSztBQUFBLFlBQ0wsS0FBSztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUNBLGVBQUssNkJBQTZCLEtBQUssWUFBWTtBQUFBLFFBQ3JEO0FBQ0E7QUFBQTtBQUFBLFVBQ0UsS0FBSztBQUFBO0FBQUEsTUFFVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsbUJBQW1CO0FBQ2pCLGVBQU8sSUFBSSxjQUFNLEtBQUsscUJBQXFCLEdBQUcsS0FBSztBQUFBLE1BQ3JEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLHFCQUFxQjtBQUNuQixlQUFPLEtBQUssTUFBTTtBQUFBLE1BQ3BCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVlBLGNBQWMsT0FBTztBQUNuQixZQUFJLFFBQVEsS0FBSyxLQUFLLE1BQU0sVUFBVSxPQUFPO0FBQzNDLGlCQUFPO0FBQUEsUUFDVDtBQUNBLGVBQU8sSUFBSTtBQUFBLFVBQ1QsS0FBSyxnQkFBZ0I7QUFBQSxZQUNuQixVQUFVLElBQUksSUFBSSxLQUFLLE1BQU0sUUFBUSxDQUFDO0FBQUEsWUFDdEMsS0FBSyxNQUFNLEtBQUs7QUFBQSxVQUNsQjtBQUFBLFVBQ0EsS0FBSztBQUFBLFFBQ1A7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsaUJBQWlCO0FBQ2YsY0FBTSxTQUFTLEtBQUs7QUFDcEIsY0FBTSxrQkFBa0IsS0FBSztBQUM3QixjQUFNLE9BQU8sS0FBSztBQUNsQixjQUFNQyxlQUFjLENBQUM7QUFDckIsWUFBSSxTQUFTO0FBQ2IsaUJBQVMsSUFBSSxHQUFHLEtBQUssS0FBSyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDN0MsZ0JBQU0sTUFBTSxLQUFLLENBQUM7QUFDbEIsZ0JBQU1ELGNBQWEsSUFBSTtBQUFBLFlBQ3JCLGdCQUFnQixNQUFNLFFBQVEsR0FBRztBQUFBLFlBQ2pDO0FBQUEsVUFDRjtBQUNBLFVBQUFDLGFBQVksS0FBS0QsV0FBVTtBQUMzQixtQkFBUztBQUFBLFFBQ1g7QUFDQSxlQUFPQztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLDZCQUE2QjtBQUMzQixZQUFJLEtBQUsscUJBQXFCLEtBQUssWUFBWSxHQUFHO0FBQ2hELGdCQUFNLGtCQUFrQixLQUFLO0FBQzdCLGNBQUksdUJBQXVCLGlCQUFpQixHQUFHLEtBQUssT0FBTyxLQUFLLE1BQU0sR0FBRztBQUN2RSxpQkFBSywyQkFBMkI7QUFBQSxVQUNsQyxPQUFPO0FBQ0wsaUJBQUssMkJBQTJCLGdCQUFnQixNQUFNO0FBQ3RELGlCQUFLLHlCQUF5QixTQUFTO0FBQUEsY0FDckMsS0FBSztBQUFBLGNBQ0w7QUFBQSxjQUNBLEtBQUs7QUFBQSxjQUNMLEtBQUs7QUFBQSxZQUNQO0FBQUEsVUFDRjtBQUNBLGVBQUssb0JBQW9CLEtBQUssWUFBWTtBQUFBLFFBQzVDO0FBQ0E7QUFBQTtBQUFBLFVBQXFDLEtBQUs7QUFBQTtBQUFBLE1BQzVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsOEJBQThCLGtCQUFrQjtBQUU5QyxjQUFNLDRCQUE0QixDQUFDO0FBRW5DLGNBQU0saUJBQWlCLENBQUM7QUFDeEIsa0NBQTBCLFNBQVM7QUFBQSxVQUNqQyxLQUFLO0FBQUEsVUFDTDtBQUFBLFVBQ0EsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsS0FBSyxLQUFLLGdCQUFnQjtBQUFBLFVBQzFCO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBQ0EsZUFBTyxJQUFJLFNBQVEsMkJBQTJCLE1BQU0sY0FBYztBQUFBLE1BQ3BFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxpQkFBaUIsUUFBUTtBQUN2QixlQUFPO0FBQUEsVUFDTCxLQUFLLDJCQUEyQjtBQUFBLFVBQ2hDO0FBQUEsVUFDQSxLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTDtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxlQUFlRixjQUFhLFFBQVE7QUFDbEMsYUFBSyxVQUFVLFFBQVFBLGNBQWEsQ0FBQztBQUNyQyxZQUFJLENBQUMsS0FBSyxpQkFBaUI7QUFDekIsZUFBSyxrQkFBa0IsQ0FBQztBQUFBLFFBQzFCO0FBQ0EsY0FBTSxPQUFPO0FBQUEsVUFDWCxLQUFLO0FBQUEsVUFDTDtBQUFBLFVBQ0FBO0FBQUEsVUFDQSxLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsUUFDUDtBQUNBLGFBQUssZ0JBQWdCLFNBQVMsS0FBSyxXQUFXLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxDQUFDO0FBQzFFLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNGO0FBRUEsSUFBTyxrQkFBUTtBQUFBO0FBQUE7OztBQ3crQ2YsU0FBUyxrQkFBa0IsVUFBVSxhQUFhO0FBQ2hELGFBQVcsV0FBWTtBQUNyQixhQUFTLFdBQVc7QUFBQSxFQUN0QixHQUFHLENBQUM7QUFDTjtBQU1PLFNBQVMsdUJBQXVCLFNBQVM7QUFDOUMsTUFBSSxRQUFRLFdBQVcsUUFBVztBQUNoQyxVQUFNLFNBQ0osUUFBUSwyQkFBMkIsU0FDL0IsUUFBUSx5QkFDUjtBQUNOLFdBQU8sYUFBYSxRQUFRLFFBQVEsUUFBUSxxQkFBcUIsTUFBTTtBQUFBLEVBQ3pFO0FBRUEsUUFBTSxhQUFhLGlCQUFpQixRQUFRLFlBQVksV0FBVztBQUNuRSxNQUFJLFFBQVEsZUFBZSxRQUFRLFdBQVcsU0FBUyxHQUFHO0FBQ3hELFVBQU0sU0FBUyxXQUFXLFVBQVUsRUFBRSxNQUFNO0FBQzVDLFdBQU8sQ0FBQyxJQUFJO0FBQ1osV0FBTyxDQUFDLElBQUk7QUFDWixXQUFPLGFBQWEsUUFBUSxPQUFPLEtBQUs7QUFBQSxFQUMxQztBQUVBLFNBQU87QUFDVDtBQU9PLFNBQVMsMkJBQTJCLFNBQVM7QUFDbEQsTUFBSTtBQUNKLE1BQUk7QUFDSixNQUFJO0FBSUosUUFBTSxpQkFBaUI7QUFDdkIsUUFBTSxvQkFBb0I7QUFFMUIsTUFBSSxVQUNGLFFBQVEsWUFBWSxTQUFZLFFBQVEsVUFBVTtBQUVwRCxNQUFJLFVBQ0YsUUFBUSxZQUFZLFNBQVksUUFBUSxVQUFVO0FBRXBELFFBQU0sYUFDSixRQUFRLGVBQWUsU0FBWSxRQUFRLGFBQWE7QUFFMUQsUUFBTSxhQUNKLFFBQVEsZUFBZSxTQUFZLFFBQVEsYUFBYTtBQUUxRCxRQUFNLFNBQ0osUUFBUSwrQkFBK0IsU0FDbkMsUUFBUSw2QkFDUjtBQUVOLFFBQU0saUJBQ0osUUFBUSxtQkFBbUIsU0FBWSxRQUFRLGlCQUFpQjtBQUVsRSxRQUFNLGFBQWEsaUJBQWlCLFFBQVEsWUFBWSxXQUFXO0FBQ25FLFFBQU0sYUFBYSxXQUFXLFVBQVU7QUFDeEMsTUFBSSxzQkFBc0IsUUFBUTtBQUNsQyxNQUFJLFNBQVMsUUFBUTtBQUNyQixNQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsV0FBVyxTQUFTLEdBQUc7QUFDbkQsMEJBQXNCO0FBQ3RCLGFBQVM7QUFBQSxFQUNYO0FBRUEsTUFBSSxRQUFRLGdCQUFnQixRQUFXO0FBQ3JDLFVBQU0sY0FBYyxRQUFRO0FBQzVCLG9CQUFnQixZQUFZLE9BQU87QUFDbkMsb0JBQ0UsWUFBWSxPQUFPLE1BQU0sU0FDckIsWUFBWSxPQUFPLElBQ25CLFlBQVksWUFBWSxTQUFTLENBQUM7QUFFeEMsUUFBSSxRQUFRLHFCQUFxQjtBQUMvQiw2QkFBdUI7QUFBQSxRQUNyQjtBQUFBLFFBQ0E7QUFBQSxRQUNBLENBQUMsdUJBQXVCO0FBQUEsUUFDeEI7QUFBQSxNQUNGO0FBQUEsSUFDRixPQUFPO0FBQ0wsNkJBQXVCO0FBQUEsUUFDckI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0EsQ0FBQyx1QkFBdUI7QUFBQSxRQUN4QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRixPQUFPO0FBRUwsVUFBTSxPQUFPLENBQUM7QUFBQTtBQUFBLE1BRVQsTUFBTSxnQkFBZ0IsVUFBVyxXQUFXLGlCQUFpQjtBQUFBLFFBQzlELEtBQUssSUFBSSxTQUFTLFVBQVUsR0FBRyxVQUFVLFVBQVUsQ0FBQztBQUV4RCxVQUFNLHVCQUNKLE9BQU8sb0JBQW9CLEtBQUssSUFBSSxtQkFBbUIsZ0JBQWdCO0FBRXpFLFVBQU0sdUJBQ0osdUJBQ0EsS0FBSyxJQUFJLG1CQUFtQixpQkFBaUIsZ0JBQWdCO0FBRy9ELG9CQUFnQixRQUFRO0FBQ3hCLFFBQUksa0JBQWtCLFFBQVc7QUFDL0IsZ0JBQVU7QUFBQSxJQUNaLE9BQU87QUFDTCxzQkFBZ0IsdUJBQXVCLEtBQUssSUFBSSxZQUFZLE9BQU87QUFBQSxJQUNyRTtBQUdBLG9CQUFnQixRQUFRO0FBQ3hCLFFBQUksa0JBQWtCLFFBQVc7QUFDL0IsVUFBSSxRQUFRLFlBQVksUUFBVztBQUNqQyxZQUFJLFFBQVEsa0JBQWtCLFFBQVc7QUFDdkMsMEJBQWdCLGdCQUFnQixLQUFLLElBQUksWUFBWSxPQUFPO0FBQUEsUUFDOUQsT0FBTztBQUNMLDBCQUFnQix1QkFBdUIsS0FBSyxJQUFJLFlBQVksT0FBTztBQUFBLFFBQ3JFO0FBQUEsTUFDRixPQUFPO0FBQ0wsd0JBQWdCO0FBQUEsTUFDbEI7QUFBQSxJQUNGO0FBR0EsY0FDRSxVQUNBLEtBQUs7QUFBQSxNQUNILEtBQUssSUFBSSxnQkFBZ0IsYUFBYSxJQUFJLEtBQUssSUFBSSxVQUFVO0FBQUEsSUFDL0Q7QUFDRixvQkFBZ0IsZ0JBQWdCLEtBQUssSUFBSSxZQUFZLFVBQVUsT0FBTztBQUV0RSxRQUFJLFFBQVEscUJBQXFCO0FBQy9CLDZCQUF1QjtBQUFBLFFBQ3JCO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQSxDQUFDLHVCQUF1QjtBQUFBLFFBQ3hCO0FBQUEsTUFDRjtBQUFBLElBQ0YsT0FBTztBQUNMLDZCQUF1QjtBQUFBLFFBQ3JCO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBLENBQUMsdUJBQXVCO0FBQUEsUUFDeEI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQUEsSUFDTCxZQUFZO0FBQUEsSUFDWjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDRjtBQU1PLFNBQVMseUJBQXlCLFNBQVM7QUFDaEQsUUFBTSxpQkFDSixRQUFRLG1CQUFtQixTQUFZLFFBQVEsaUJBQWlCO0FBQ2xFLE1BQUksZ0JBQWdCO0FBQ2xCLFVBQU0sb0JBQW9CLFFBQVE7QUFDbEMsUUFBSSxzQkFBc0IsVUFBYSxzQkFBc0IsTUFBTTtBQUNqRSxhQUFPLGlCQUFpQjtBQUFBLElBQzFCO0FBQ0EsUUFBSSxzQkFBc0IsT0FBTztBQUMvQixhQUFPRztBQUFBLElBQ1Q7QUFDQSxRQUFJLE9BQU8sc0JBQXNCLFVBQVU7QUFDekMsYUFBTyxjQUFjLGlCQUFpQjtBQUFBLElBQ3hDO0FBQ0EsV0FBT0E7QUFBQSxFQUNUO0FBQ0EsU0FBTztBQUNUO0FBT08sU0FBUyxnQkFBZ0IsV0FBVztBQUN6QyxNQUFJLFVBQVUsZ0JBQWdCLFVBQVUsY0FBYztBQUNwRCxRQUFJLENBQUNDLFFBQWlCLFVBQVUsY0FBYyxVQUFVLFlBQVksR0FBRztBQUNyRSxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFDQSxNQUFJLFVBQVUscUJBQXFCLFVBQVUsa0JBQWtCO0FBQzdELFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxVQUFVLG1CQUFtQixVQUFVLGdCQUFnQjtBQUN6RCxXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU87QUFDVDtBQVVBLFNBQVMsa0JBQWtCLFlBQVksTUFBTSxVQUFVLFlBQVksVUFBVTtBQUUzRSxRQUFNLFdBQVcsS0FBSyxJQUFJLENBQUMsUUFBUTtBQUNuQyxNQUFJLFdBQVcsS0FBSyxJQUFJLENBQUMsUUFBUTtBQUNqQyxNQUFJLE9BQU8sV0FBVyxDQUFDLElBQUksV0FBVyxXQUFXLENBQUMsSUFBSTtBQUN0RCxNQUFJLE9BQU8sV0FBVyxDQUFDLElBQUksV0FBVyxXQUFXLENBQUMsSUFBSTtBQUN0RCxXQUFTLEtBQUssQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLEtBQUs7QUFDdEMsV0FBUyxTQUFTLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLO0FBR3RDLGFBQVcsQ0FBQztBQUNaLFFBQU0sVUFBVSxPQUFPLFdBQVcsT0FBTztBQUN6QyxRQUFNLFVBQVUsT0FBTyxXQUFXLE9BQU87QUFFekMsU0FBTyxDQUFDLFNBQVMsT0FBTztBQUMxQjtBQTdtRUEsSUFtT00sa0JBcUZBLE1BdXpEQztBQS9tRVA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQU1BO0FBQ0E7QUFPQTtBQUNBO0FBb0xBLElBQU0sbUJBQW1CO0FBcUZ6QixJQUFNLE9BQU4sY0FBbUIsZUFBVztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSTVCLFlBQVksU0FBUztBQUNuQixjQUFNO0FBS04sYUFBSztBQUtMLGFBQUs7QUFLTCxhQUFLO0FBRUwsa0JBQVUsT0FBTyxPQUFPLENBQUMsR0FBRyxPQUFPO0FBTW5DLGFBQUssU0FBUyxDQUFDLEdBQUcsQ0FBQztBQU1uQixhQUFLLGNBQWMsQ0FBQztBQU1wQixhQUFLO0FBT0wsYUFBSyxjQUFjLGlCQUFpQixRQUFRLFlBQVksV0FBVztBQU1uRSxhQUFLLGdCQUFnQixDQUFDLEtBQUssR0FBRztBQU05QixhQUFLLGdCQUFnQjtBQU1yQixhQUFLO0FBTUwsYUFBSztBQU1MLGFBQUssY0FBYztBQU1uQixhQUFLO0FBTUwsYUFBSztBQU1MLGFBQUssZ0JBQWdCO0FBRXJCLFlBQUksUUFBUSxZQUFZO0FBQ3RCLG1DQUF5QjtBQUFBLFFBQzNCO0FBQ0EsWUFBSSxRQUFRLFFBQVE7QUFDbEIsa0JBQVEsU0FBUyxtQkFBbUIsUUFBUSxRQUFRLEtBQUssV0FBVztBQUFBLFFBQ3RFO0FBQ0EsWUFBSSxRQUFRLFFBQVE7QUFDbEIsa0JBQVEsU0FBUyxlQUFlLFFBQVEsUUFBUSxLQUFLLFdBQVc7QUFBQSxRQUNsRTtBQUVBLGFBQUssY0FBYyxPQUFPO0FBQUEsTUFDNUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsY0FBYyxTQUFTO0FBQ3JCLGNBQU0sYUFBYSxPQUFPLE9BQU8sQ0FBQyxHQUFHLE9BQU87QUFDNUMsbUJBQVcsT0FBTyxzQkFBYztBQUM5QixpQkFBTyxXQUFXLEdBQUc7QUFBQSxRQUN2QjtBQUNBLGFBQUssY0FBYyxZQUFZLElBQUk7QUFFbkMsY0FBTSwyQkFBMkIsMkJBQTJCLE9BQU87QUFNbkUsYUFBSyxpQkFBaUIseUJBQXlCO0FBTS9DLGFBQUssaUJBQWlCLHlCQUF5QjtBQU0vQyxhQUFLLGNBQWMseUJBQXlCO0FBTTVDLGFBQUssZUFBZSxRQUFRO0FBTTVCLGFBQUssV0FBVyxRQUFRO0FBTXhCLGFBQUssV0FBVyx5QkFBeUI7QUFFekMsY0FBTSxtQkFBbUIsdUJBQXVCLE9BQU87QUFDdkQsY0FBTSx1QkFBdUIseUJBQXlCO0FBQ3RELGNBQU0scUJBQXFCLHlCQUF5QixPQUFPO0FBTTNELGFBQUssZUFBZTtBQUFBLFVBQ2xCLFFBQVE7QUFBQSxVQUNSLFlBQVk7QUFBQSxVQUNaLFVBQVU7QUFBQSxRQUNaO0FBRUEsYUFBSyxZQUFZLFFBQVEsYUFBYSxTQUFZLFFBQVEsV0FBVyxDQUFDO0FBQ3RFLGFBQUs7QUFBQSxVQUNILFFBQVEsV0FBVyxTQUFZLFFBQVEsU0FBUztBQUFBLFFBQ2xEO0FBQ0EsWUFBSSxRQUFRLGVBQWUsUUFBVztBQUNwQyxlQUFLLGNBQWMsUUFBUSxVQUFVO0FBQUEsUUFDdkMsV0FBVyxRQUFRLFNBQVMsUUFBVztBQUNyQyxlQUFLLFFBQVEsUUFBUSxJQUFJO0FBQUEsUUFDM0I7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFXQSxJQUFJLFVBQVU7QUFDWixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUEsTUFDQSxJQUFJLFFBQVEsU0FBUztBQUNuQixZQUFJLGFBQWEsS0FBSztBQUN0QixhQUFLLFdBQVc7QUFDaEIsY0FBTSxTQUFTLEtBQUssa0JBQWtCO0FBQ3RDLFlBQUksUUFBUTtBQUNWLGdCQUFNLGFBQWEsV0FBVyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDekMsdUJBQWEsY0FBYyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDdEMsZ0JBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsZ0JBQU0sVUFDSCxhQUFhLEtBQ2IsV0FBVyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksV0FBVyxDQUFDO0FBQy9ELGdCQUFNLFVBQ0gsYUFBYSxLQUNiLFdBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQztBQUMvRCxlQUFLLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxJQUFJLFNBQVMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQUEsUUFDbkU7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BVUEsbUJBQW1CLFlBQVk7QUFDN0IsY0FBTSxVQUFVLEtBQUssY0FBYztBQUduQyxZQUFJLFFBQVEsZUFBZSxRQUFXO0FBQ3BDLGtCQUFRLGFBQWEsS0FBSyxjQUFjO0FBQUEsUUFDMUMsT0FBTztBQUNMLGtCQUFRLE9BQU8sS0FBSyxRQUFRO0FBQUEsUUFDOUI7QUFHQSxnQkFBUSxTQUFTLEtBQUssa0JBQWtCO0FBR3hDLGdCQUFRLFdBQVcsS0FBSyxZQUFZO0FBRXBDLGVBQU8sT0FBTyxPQUFPLENBQUMsR0FBRyxTQUFTLFVBQVU7QUFBQSxNQUM5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BbUNBLFFBQVEsVUFBVTtBQUNoQixZQUFJLEtBQUssTUFBTSxLQUFLLENBQUMsS0FBSyxhQUFhLEdBQUc7QUFDeEMsZUFBSyxtQkFBbUIsQ0FBQztBQUFBLFFBQzNCO0FBQ0EsY0FBTSxPQUFPLElBQUksTUFBTSxVQUFVLE1BQU07QUFDdkMsaUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEVBQUUsR0FBRztBQUNwQyxjQUFJLFVBQVUsVUFBVSxDQUFDO0FBQ3pCLGNBQUksUUFBUSxRQUFRO0FBQ2xCLHNCQUFVLE9BQU8sT0FBTyxDQUFDLEdBQUcsT0FBTztBQUNuQyxvQkFBUSxTQUFTO0FBQUEsY0FDZixRQUFRO0FBQUEsY0FDUixLQUFLLGNBQWM7QUFBQSxZQUNyQjtBQUFBLFVBQ0Y7QUFDQSxjQUFJLFFBQVEsUUFBUTtBQUNsQixzQkFBVSxPQUFPLE9BQU8sQ0FBQyxHQUFHLE9BQU87QUFDbkMsb0JBQVEsU0FBUztBQUFBLGNBQ2YsUUFBUTtBQUFBLGNBQ1IsS0FBSyxjQUFjO0FBQUEsWUFDckI7QUFBQSxVQUNGO0FBQ0EsZUFBSyxDQUFDLElBQUk7QUFBQSxRQUNaO0FBQ0EsYUFBSyxnQkFBZ0IsTUFBTSxNQUFNLElBQUk7QUFBQSxNQUN2QztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsZ0JBQWdCLFVBQVU7QUFDeEIsWUFBSSxpQkFBaUIsVUFBVTtBQUMvQixZQUFJO0FBQ0osWUFDRSxpQkFBaUIsS0FDakIsT0FBTyxVQUFVLGlCQUFpQixDQUFDLE1BQU0sWUFDekM7QUFDQSxxQkFBVyxVQUFVLGlCQUFpQixDQUFDO0FBQ3ZDLFlBQUU7QUFBQSxRQUNKO0FBRUEsWUFBSSxJQUFJO0FBQ1IsZUFBTyxJQUFJLGtCQUFrQixDQUFDLEtBQUssTUFBTSxHQUFHLEVBQUUsR0FBRztBQUUvQyxnQkFBTSxRQUFRLFVBQVUsQ0FBQztBQUN6QixjQUFJLE1BQU0sUUFBUTtBQUNoQixpQkFBSyxrQkFBa0IsTUFBTSxNQUFNO0FBQUEsVUFDckM7QUFDQSxjQUFJLE1BQU0sU0FBUyxRQUFXO0FBQzVCLGlCQUFLLFFBQVEsTUFBTSxJQUFJO0FBQUEsVUFDekIsV0FBVyxNQUFNLFlBQVk7QUFDM0IsaUJBQUssY0FBYyxNQUFNLFVBQVU7QUFBQSxVQUNyQztBQUNBLGNBQUksTUFBTSxhQUFhLFFBQVc7QUFDaEMsaUJBQUssWUFBWSxNQUFNLFFBQVE7QUFBQSxVQUNqQztBQUFBLFFBQ0Y7QUFDQSxZQUFJLE1BQU0sZ0JBQWdCO0FBQ3hCLGNBQUksVUFBVTtBQUNaLDhCQUFrQixVQUFVLElBQUk7QUFBQSxVQUNsQztBQUNBO0FBQUEsUUFDRjtBQUVBLFlBQUksUUFBUSxLQUFLLElBQUk7QUFDckIsWUFBSSxTQUFTLEtBQUssY0FBYyxNQUFNO0FBQ3RDLFlBQUksYUFBYSxLQUFLO0FBQ3RCLFlBQUksV0FBVyxLQUFLO0FBQ3BCLGNBQU0sU0FBUyxDQUFDO0FBQ2hCLGVBQU8sSUFBSSxnQkFBZ0IsRUFBRSxHQUFHO0FBQzlCLGdCQUFNO0FBQUE7QUFBQSxZQUEyQyxVQUFVLENBQUM7QUFBQTtBQUU1RCxnQkFBTSxZQUFZO0FBQUEsWUFDaEI7QUFBQSxZQUNBLFVBQVU7QUFBQSxZQUNWLFFBQVEsUUFBUTtBQUFBLFlBQ2hCLFVBQVUsUUFBUSxhQUFhLFNBQVksUUFBUSxXQUFXO0FBQUEsWUFDOUQsUUFBUSxRQUFRLFVBQVU7QUFBQSxZQUMxQjtBQUFBLFVBQ0Y7QUFFQSxjQUFJLFFBQVEsUUFBUTtBQUNsQixzQkFBVSxlQUFlO0FBQ3pCLHNCQUFVLGVBQWUsUUFBUSxPQUFPLE1BQU07QUFDOUMscUJBQVMsVUFBVTtBQUFBLFVBQ3JCO0FBRUEsY0FBSSxRQUFRLFNBQVMsUUFBVztBQUM5QixzQkFBVSxtQkFBbUI7QUFDN0Isc0JBQVUsbUJBQW1CLEtBQUsscUJBQXFCLFFBQVEsSUFBSTtBQUNuRSx5QkFBYSxVQUFVO0FBQUEsVUFDekIsV0FBVyxRQUFRLFlBQVk7QUFDN0Isc0JBQVUsbUJBQW1CO0FBQzdCLHNCQUFVLG1CQUFtQixRQUFRO0FBQ3JDLHlCQUFhLFVBQVU7QUFBQSxVQUN6QjtBQUVBLGNBQUksUUFBUSxhQUFhLFFBQVc7QUFDbEMsc0JBQVUsaUJBQWlCO0FBQzNCLGtCQUFNLFFBQ0osT0FBTyxRQUFRLFdBQVcsV0FBVyxLQUFLLElBQUksSUFBSSxLQUFLLEVBQUUsSUFBSSxLQUFLO0FBQ3BFLHNCQUFVLGlCQUFpQixXQUFXO0FBQ3RDLHVCQUFXLFVBQVU7QUFBQSxVQUN2QjtBQUdBLGNBQUksZ0JBQWdCLFNBQVMsR0FBRztBQUM5QixzQkFBVSxXQUFXO0FBQUEsVUFFdkIsT0FBTztBQUNMLHFCQUFTLFVBQVU7QUFBQSxVQUNyQjtBQUNBLGlCQUFPLEtBQUssU0FBUztBQUFBLFFBQ3ZCO0FBQ0EsYUFBSyxZQUFZLEtBQUssTUFBTTtBQUM1QixhQUFLLFFBQVEsaUJBQVMsV0FBVyxDQUFDO0FBQ2xDLGFBQUssa0JBQWtCO0FBQUEsTUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxlQUFlO0FBQ2IsZUFBTyxLQUFLLE9BQU8saUJBQVMsU0FBUyxJQUFJO0FBQUEsTUFDM0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxpQkFBaUI7QUFDZixlQUFPLEtBQUssT0FBTyxpQkFBUyxXQUFXLElBQUk7QUFBQSxNQUM3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxtQkFBbUI7QUFDakIsYUFBSyxRQUFRLGlCQUFTLFdBQVcsQ0FBQyxLQUFLLE9BQU8saUJBQVMsU0FBUyxDQUFDO0FBQ2pFLFlBQUk7QUFDSixpQkFBUyxJQUFJLEdBQUcsS0FBSyxLQUFLLFlBQVksUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQ3pELGdCQUFNLFNBQVMsS0FBSyxZQUFZLENBQUM7QUFDakMsY0FBSSxPQUFPLENBQUMsRUFBRSxVQUFVO0FBQ3RCLDhCQUFrQixPQUFPLENBQUMsRUFBRSxVQUFVLEtBQUs7QUFBQSxVQUM3QztBQUNBLGNBQUksQ0FBQyxRQUFRO0FBQ1gscUJBQVMsSUFBSSxHQUFHLEtBQUssT0FBTyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDL0Msb0JBQU0sWUFBWSxPQUFPLENBQUM7QUFDMUIsa0JBQUksQ0FBQyxVQUFVLFVBQVU7QUFDdkIseUJBQVMsVUFBVTtBQUNuQjtBQUFBLGNBQ0Y7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxhQUFLLFlBQVksU0FBUztBQUMxQixhQUFLLGdCQUFnQjtBQUNyQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxrQkFBa0I7QUFDdkIsYUFBSyxnQkFBZ0I7QUFBQSxNQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esb0JBQW9CO0FBQ2xCLFlBQUksS0FBSyx3QkFBd0IsUUFBVztBQUMxQywrQkFBcUIsS0FBSyxtQkFBbUI7QUFDN0MsZUFBSyxzQkFBc0I7QUFBQSxRQUM3QjtBQUNBLFlBQUksQ0FBQyxLQUFLLGFBQWEsR0FBRztBQUN4QjtBQUFBLFFBQ0Y7QUFDQSxjQUFNLE1BQU0sS0FBSyxJQUFJO0FBQ3JCLFlBQUksT0FBTztBQUNYLGlCQUFTLElBQUksS0FBSyxZQUFZLFNBQVMsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHO0FBQ3JELGdCQUFNLFNBQVMsS0FBSyxZQUFZLENBQUM7QUFDakMsY0FBSSxpQkFBaUI7QUFDckIsbUJBQVMsSUFBSSxHQUFHLEtBQUssT0FBTyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDL0Msa0JBQU0sWUFBWSxPQUFPLENBQUM7QUFDMUIsZ0JBQUksVUFBVSxVQUFVO0FBQ3RCO0FBQUEsWUFDRjtBQUNBLGtCQUFNLFVBQVUsTUFBTSxVQUFVO0FBQ2hDLGdCQUFJLFdBQ0YsVUFBVSxXQUFXLElBQUksVUFBVSxVQUFVLFdBQVc7QUFDMUQsZ0JBQUksWUFBWSxHQUFHO0FBQ2pCLHdCQUFVLFdBQVc7QUFDckIseUJBQVc7QUFBQSxZQUNiLE9BQU87QUFDTCwrQkFBaUI7QUFBQSxZQUNuQjtBQUNBLGtCQUFNLFdBQVcsVUFBVSxPQUFPLFFBQVE7QUFDMUMsZ0JBQUksVUFBVSxjQUFjO0FBQzFCLG9CQUFNLEtBQUssVUFBVSxhQUFhLENBQUM7QUFDbkMsb0JBQU0sS0FBSyxVQUFVLGFBQWEsQ0FBQztBQUNuQyxvQkFBTSxLQUFLLFVBQVUsYUFBYSxDQUFDO0FBQ25DLG9CQUFNLEtBQUssVUFBVSxhQUFhLENBQUM7QUFDbkMsbUJBQUssY0FBYyxVQUFVO0FBQzdCLG9CQUFNLElBQUksS0FBSyxZQUFZLEtBQUs7QUFDaEMsb0JBQU0sSUFBSSxLQUFLLFlBQVksS0FBSztBQUNoQyxtQkFBSyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUM7QUFBQSxZQUM1QjtBQUNBLGdCQUFJLFVBQVUsb0JBQW9CLFVBQVUsa0JBQWtCO0FBQzVELG9CQUFNLGFBQ0osYUFBYSxJQUNULFVBQVUsbUJBQ1YsVUFBVSxtQkFDVixZQUNHLFVBQVUsbUJBQW1CLFVBQVU7QUFDaEQsa0JBQUksVUFBVSxRQUFRO0FBQ3BCLHNCQUFNLE9BQU8sS0FBSyxpQkFBaUIsS0FBSyxZQUFZLENBQUM7QUFDckQsc0JBQU0sd0JBQXdCLEtBQUssYUFBYTtBQUFBLGtCQUM5QztBQUFBLGtCQUNBO0FBQUEsa0JBQ0E7QUFBQSxrQkFDQTtBQUFBLGdCQUNGO0FBQ0EscUJBQUssZ0JBQWdCLEtBQUs7QUFBQSxrQkFDeEI7QUFBQSxrQkFDQSxVQUFVO0FBQUEsZ0JBQ1o7QUFBQSxjQUNGO0FBQ0EsbUJBQUssa0JBQWtCLFVBQVU7QUFDakMsbUJBQUssb0JBQW9CO0FBQ3pCLG1CQUFLLGtCQUFrQixJQUFJO0FBQUEsWUFDN0I7QUFDQSxnQkFDRSxVQUFVLG1CQUFtQixVQUM3QixVQUFVLG1CQUFtQixRQUM3QjtBQUNBLG9CQUFNLFdBQ0osYUFBYSxJQUNULE9BQU8sVUFBVSxpQkFBaUIsS0FBSyxJQUFJLElBQUksS0FBSyxFQUFFLElBQ3RELEtBQUssS0FDTCxVQUFVLGlCQUNWLFlBQ0csVUFBVSxpQkFBaUIsVUFBVTtBQUM5QyxrQkFBSSxVQUFVLFFBQVE7QUFDcEIsc0JBQU0sc0JBQXNCLEtBQUssYUFBYTtBQUFBLGtCQUM1QztBQUFBLGtCQUNBO0FBQUEsZ0JBQ0Y7QUFDQSxxQkFBSyxnQkFBZ0IsS0FBSztBQUFBLGtCQUN4QjtBQUFBLGtCQUNBLFVBQVU7QUFBQSxnQkFDWjtBQUFBLGNBQ0Y7QUFDQSxtQkFBSyxnQkFBZ0IsVUFBVTtBQUMvQixtQkFBSyxrQkFBa0I7QUFBQSxZQUN6QjtBQUNBLGlCQUFLLGtCQUFrQixJQUFJO0FBQzNCLG1CQUFPO0FBQ1AsZ0JBQUksQ0FBQyxVQUFVLFVBQVU7QUFDdkI7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUNBLGNBQUksZ0JBQWdCO0FBQ2xCLGlCQUFLLFlBQVksQ0FBQyxJQUFJO0FBQ3RCLGlCQUFLLFFBQVEsaUJBQVMsV0FBVyxFQUFFO0FBQ25DLGlCQUFLLGNBQWM7QUFDbkIsaUJBQUssa0JBQWtCO0FBQ3ZCLGlCQUFLLGdCQUFnQjtBQUNyQixrQkFBTSxXQUFXLE9BQU8sQ0FBQyxFQUFFO0FBQzNCLGdCQUFJLFVBQVU7QUFDWixnQ0FBa0IsVUFBVSxJQUFJO0FBQUEsWUFDbEM7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUVBLGFBQUssY0FBYyxLQUFLLFlBQVksT0FBTyxPQUFPO0FBQ2xELFlBQUksUUFBUSxLQUFLLHdCQUF3QixRQUFXO0FBQ2xELGVBQUssc0JBQXNCO0FBQUEsWUFDekIsS0FBSyxrQkFBa0IsS0FBSyxJQUFJO0FBQUEsVUFDbEM7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLHNCQUFzQixVQUFVLFFBQVE7QUFDdEMsWUFBSTtBQUNKLGNBQU0sZ0JBQWdCLEtBQUssa0JBQWtCO0FBQzdDLFlBQUksa0JBQWtCLFFBQVc7QUFDL0IsbUJBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxPQUFPLENBQUMsR0FBRyxjQUFjLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQztBQUNwRSxpQkFBaUIsUUFBUSxXQUFXLEtBQUssWUFBWSxDQUFDO0FBQ3RELFVBQUFDLEtBQWMsUUFBUSxNQUFNO0FBQUEsUUFDOUI7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG9CQUFvQixZQUFZLFFBQVE7QUFDdEMsWUFBSTtBQUNKLGNBQU0sZ0JBQWdCLEtBQUssa0JBQWtCO0FBQzdDLGNBQU0sb0JBQW9CLEtBQUssY0FBYztBQUM3QyxZQUFJLGtCQUFrQixVQUFhLHNCQUFzQixRQUFXO0FBQ2xFLGdCQUFNLElBQ0osT0FBTyxDQUFDLElBQ1AsY0FBYyxPQUFPLENBQUMsSUFBSSxjQUFjLENBQUMsS0FBTTtBQUNsRCxnQkFBTSxJQUNKLE9BQU8sQ0FBQyxJQUNQLGNBQWMsT0FBTyxDQUFDLElBQUksY0FBYyxDQUFDLEtBQU07QUFDbEQsbUJBQVMsQ0FBQyxHQUFHLENBQUM7QUFBQSxRQUNoQjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxpQkFBaUIsVUFBVTtBQUN6QixjQUFNLE9BQU8sS0FBSztBQUNsQixZQUFJLFVBQVU7QUFDWixnQkFBTSxJQUFJLEtBQUssQ0FBQztBQUNoQixnQkFBTSxJQUFJLEtBQUssQ0FBQztBQUNoQixpQkFBTztBQUFBLFlBQ0wsS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxRQUFRLENBQUM7QUFBQSxZQUNsRSxLQUFLLElBQUksSUFBSSxLQUFLLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLFFBQVEsQ0FBQztBQUFBLFVBQ3BFO0FBQUEsUUFDRjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGdCQUFnQixNQUFNO0FBQ3BCLGFBQUssZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLElBQUksS0FBSyxNQUFNLElBQUksQ0FBQyxLQUFLLEdBQUc7QUFDbkUsWUFBSSxDQUFDLEtBQUssYUFBYSxHQUFHO0FBQ3hCLGVBQUssbUJBQW1CLENBQUM7QUFBQSxRQUMzQjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFlBQVk7QUFDVixjQUFNLFNBQVMsS0FBSyxrQkFBa0I7QUFDdEMsWUFBSSxDQUFDLFFBQVE7QUFDWCxpQkFBTztBQUFBLFFBQ1Q7QUFDQSxlQUFPLGlCQUFpQixRQUFRLEtBQUssY0FBYyxDQUFDO0FBQUEsTUFDdEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsb0JBQW9CO0FBQ2xCO0FBQUE7QUFBQSxVQUNFLEtBQUssSUFBSSxxQkFBYSxNQUFNO0FBQUE7QUFBQSxNQUVoQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EseUJBQXlCO0FBQ3ZCLGVBQU8sS0FBSyxJQUFJLHFCQUFxQjtBQUFBLE1BQ3ZDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFNBQVMsT0FBTztBQUNkLFlBQUksVUFBVSxRQUFXO0FBQ3ZCLGdCQUFNLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQztBQUN4QixnQkFBTSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUM7QUFDeEIsaUJBQU87QUFBQSxRQUNUO0FBQ0EsZUFBTyxLQUFLLE9BQU8sTUFBTTtBQUFBLE1BQzNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVlBLGdCQUFnQixNQUFNO0FBQ3BCLGNBQU0sU0FBUyxLQUFLLHdCQUF3QixJQUFJO0FBQ2hELGVBQU8sYUFBYSxRQUFRLEtBQUssY0FBYyxDQUFDO0FBQUEsTUFDbEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSx3QkFBd0IsTUFBTTtBQUM1QixlQUFPLFFBQVEsS0FBSyw2QkFBNkI7QUFDakQsY0FBTTtBQUFBO0FBQUEsVUFDSixLQUFLLGtCQUFrQjtBQUFBO0FBRXpCLGVBQU8sUUFBUSxnQ0FBZ0M7QUFDL0MsY0FBTTtBQUFBO0FBQUEsVUFBcUMsS0FBSyxjQUFjO0FBQUE7QUFDOUQsZUFBTyxlQUFlLFFBQVcsb0NBQW9DO0FBQ3JFLGNBQU07QUFBQTtBQUFBLFVBQW1DLEtBQUssWUFBWTtBQUFBO0FBQzFELGVBQU8sYUFBYSxRQUFXLGtDQUFrQztBQUVqRSxlQUFPLGtCQUFrQixRQUFRLFlBQVksVUFBVSxJQUFJO0FBQUEsTUFDN0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxtQkFBbUI7QUFDakIsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG1CQUFtQjtBQUNqQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsYUFBYTtBQUNYO0FBQUE7QUFBQSxVQUNFLEtBQUsscUJBQXFCLEtBQUssY0FBYztBQUFBO0FBQUEsTUFFakQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXLE1BQU07QUFDZixhQUFLLGNBQWMsS0FBSyxtQkFBbUIsRUFBQyxTQUFTLEtBQUksQ0FBQyxDQUFDO0FBQUEsTUFDN0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxhQUFhO0FBQ1g7QUFBQTtBQUFBLFVBQ0UsS0FBSyxxQkFBcUIsS0FBSyxjQUFjO0FBQUE7QUFBQSxNQUVqRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVcsTUFBTTtBQUNmLGFBQUssY0FBYyxLQUFLLG1CQUFtQixFQUFDLFNBQVMsS0FBSSxDQUFDLENBQUM7QUFBQSxNQUM3RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLHVCQUF1QixTQUFTO0FBQzlCLGFBQUssY0FBYyxLQUFLLG1CQUFtQixFQUFDLHFCQUFxQixRQUFPLENBQUMsQ0FBQztBQUFBLE1BQzVFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsZ0JBQWdCO0FBQ2QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsZ0JBQWdCO0FBQ2Q7QUFBQTtBQUFBLFVBQXdDLEtBQUssSUFBSSxxQkFBYSxVQUFVO0FBQUE7QUFBQSxNQUMxRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLHVCQUF1QixRQUFRLE1BQU07QUFDbkMsZUFBTyxLQUFLO0FBQUEsVUFDVixlQUFlLFFBQVEsS0FBSyxjQUFjLENBQUM7QUFBQSxVQUMzQztBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLCtCQUErQixRQUFRLE1BQU07QUFDM0MsZUFBTyxRQUFRLEtBQUssNkJBQTZCO0FBQ2pELGNBQU0sY0FBYyxTQUFTLE1BQU0sSUFBSSxLQUFLLENBQUM7QUFDN0MsY0FBTSxjQUFjLFVBQVUsTUFBTSxJQUFJLEtBQUssQ0FBQztBQUM5QyxlQUFPLEtBQUssSUFBSSxhQUFhLFdBQVc7QUFBQSxNQUMxQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsOEJBQThCLE9BQU87QUFDbkMsZ0JBQVEsU0FBUztBQUNqQixjQUFNLGdCQUFnQixLQUFLLHlCQUF5QixLQUFLLGNBQWM7QUFDdkUsY0FBTSxnQkFBZ0IsS0FBSztBQUMzQixjQUFNLE1BQU0sS0FBSyxJQUFJLGdCQUFnQixhQUFhLElBQUksS0FBSyxJQUFJLEtBQUs7QUFDcEU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBS0UsU0FBVSxPQUFPO0FBQ2Ysa0JBQU0sYUFBYSxnQkFBZ0IsS0FBSyxJQUFJLE9BQU8sUUFBUSxHQUFHO0FBQzlELG1CQUFPO0FBQUEsVUFDVDtBQUFBO0FBQUEsTUFFSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsY0FBYztBQUNaO0FBQUE7QUFBQSxVQUE4QixLQUFLLElBQUkscUJBQWEsUUFBUTtBQUFBO0FBQUEsTUFDOUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLDhCQUE4QixPQUFPO0FBQ25DLGNBQU0sV0FBVyxLQUFLLElBQUksU0FBUyxDQUFDO0FBQ3BDLGNBQU0sZ0JBQWdCLEtBQUsseUJBQXlCLEtBQUssY0FBYztBQUN2RSxjQUFNLGdCQUFnQixLQUFLO0FBQzNCLGNBQU0sTUFBTSxLQUFLLElBQUksZ0JBQWdCLGFBQWEsSUFBSTtBQUN0RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFLRSxTQUFVLFlBQVk7QUFDcEIsa0JBQU0sUUFBUSxLQUFLLElBQUksZ0JBQWdCLFVBQVUsSUFBSSxXQUFXO0FBQ2hFLG1CQUFPO0FBQUEsVUFDVDtBQUFBO0FBQUEsTUFFSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsNkJBQTZCLFVBQVU7QUFDckMsWUFBSSxPQUFPLEtBQUssaUJBQWlCLFFBQVE7QUFDekMsY0FBTSxVQUFVLEtBQUs7QUFDckIsWUFBSSxTQUFTO0FBQ1gsaUJBQU87QUFBQSxZQUNMLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQztBQUFBLFlBQ2hDLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQztBQUFBLFVBQ2xDO0FBQUEsUUFDRjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxXQUFXO0FBQ1QsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxjQUFNLGFBQWEsS0FBSyxjQUFjO0FBQ3RDLGNBQU0sV0FBVyxLQUFLLFlBQVk7QUFDbEMsWUFBSTtBQUFBO0FBQUEsVUFDRixLQUFLLGtCQUFrQjtBQUFBO0FBRXpCLGNBQU0sVUFBVSxLQUFLO0FBQ3JCLFlBQUksU0FBUztBQUNYLGdCQUFNLGNBQWMsS0FBSyw2QkFBNkI7QUFDdEQsbUJBQVM7QUFBQSxZQUNQO0FBQUEsWUFDQSxLQUFLLGlCQUFpQjtBQUFBLFlBQ3RCLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsR0FBRyxZQUFZLENBQUMsSUFBSSxJQUFJLFFBQVEsQ0FBQyxDQUFDO0FBQUEsWUFDakU7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsVUFDTCxRQUFRLE9BQU8sTUFBTSxDQUFDO0FBQUEsVUFDdEIsWUFBWSxlQUFlLFNBQVksYUFBYTtBQUFBLFVBQ3BEO0FBQUEsVUFDQSxZQUFZLEtBQUs7QUFBQSxVQUNqQixnQkFBZ0IsS0FBSztBQUFBLFVBQ3JCLGNBQWMsS0FBSztBQUFBLFVBQ25CO0FBQUEsVUFDQSxNQUFNLEtBQUssUUFBUTtBQUFBLFFBQ3JCO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esd0JBQXdCO0FBQ3RCLGVBQU87QUFBQSxVQUNMLFdBQVcsS0FBSyxTQUFTO0FBQUEsVUFDekIsUUFBUSxLQUFLLGdCQUFnQjtBQUFBLFFBQy9CO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxVQUFVO0FBQ1IsWUFBSTtBQUNKLGNBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxlQUFlLFFBQVc7QUFDNUIsaUJBQU8sS0FBSyxxQkFBcUIsVUFBVTtBQUFBLFFBQzdDO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLHFCQUFxQixZQUFZO0FBQy9CLFlBQUksU0FBUyxLQUFLLFlBQVk7QUFDOUIsWUFBSSxLQUFLO0FBQ1QsWUFBSSxLQUFLLGNBQWM7QUFDckIsZ0JBQU0sVUFBVSxrQkFBa0IsS0FBSyxjQUFjLFlBQVksQ0FBQztBQUNsRSxtQkFBUztBQUNULGdCQUFNLEtBQUssYUFBYSxPQUFPO0FBQy9CLGNBQUksV0FBVyxLQUFLLGFBQWEsU0FBUyxHQUFHO0FBQzNDLHlCQUFhO0FBQUEsVUFDZixPQUFPO0FBQ0wseUJBQWEsTUFBTSxLQUFLLGFBQWEsVUFBVSxDQUFDO0FBQUEsVUFDbEQ7QUFBQSxRQUNGLE9BQU87QUFDTCxnQkFBTSxLQUFLO0FBQ1gsdUJBQWEsS0FBSztBQUFBLFFBQ3BCO0FBQ0EsZUFBTyxTQUFTLEtBQUssSUFBSSxNQUFNLFVBQVUsSUFBSSxLQUFLLElBQUksVUFBVTtBQUFBLE1BQ2xFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxxQkFBcUIsTUFBTTtBQUN6QixZQUFJLEtBQUssY0FBYztBQUNyQixjQUFJLEtBQUssYUFBYSxVQUFVLEdBQUc7QUFDakMsbUJBQU87QUFBQSxVQUNUO0FBQ0EsZ0JBQU0sWUFBWTtBQUFBLFlBQ2hCLEtBQUssTUFBTSxJQUFJO0FBQUEsWUFDZjtBQUFBLFlBQ0EsS0FBSyxhQUFhLFNBQVM7QUFBQSxVQUM3QjtBQUNBLGdCQUFNLGFBQ0osS0FBSyxhQUFhLFNBQVMsSUFBSSxLQUFLLGFBQWEsWUFBWSxDQUFDO0FBQ2hFLGlCQUNFLEtBQUssYUFBYSxTQUFTLElBQzNCLEtBQUssSUFBSSxZQUFZLE1BQU0sT0FBTyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQUEsUUFFdEQ7QUFDQSxlQUNFLEtBQUssaUJBQWlCLEtBQUssSUFBSSxLQUFLLGFBQWEsT0FBTyxLQUFLLFFBQVE7QUFBQSxNQUV6RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFZQSxJQUFJLGtCQUFrQixTQUFTO0FBRTdCLFlBQUk7QUFDSjtBQUFBLFVBQ0UsTUFBTSxRQUFRLGdCQUFnQixLQUM1QjtBQUFBLFVBQTBCLGlCQUFrQiwwQkFDMUM7QUFBQSxVQUNKO0FBQUEsUUFDRjtBQUNBLFlBQUksTUFBTSxRQUFRLGdCQUFnQixHQUFHO0FBQ25DO0FBQUEsWUFDRSxDQUFDQyxTQUFRLGdCQUFnQjtBQUFBLFlBQ3pCO0FBQUEsVUFDRjtBQUNBLGdCQUFNLFNBQVMsZUFBZSxrQkFBa0IsS0FBSyxjQUFjLENBQUM7QUFDcEUscUJBQVcsV0FBa0IsTUFBTTtBQUFBLFFBQ3JDLFdBQVcsaUJBQWlCLFFBQVEsTUFBTSxVQUFVO0FBQ2xELGdCQUFNLFNBQVM7QUFBQSxZQUNiLGlCQUFpQixVQUFVO0FBQUEsWUFDM0IsS0FBSyxjQUFjO0FBQUEsVUFDckI7QUFDQSxxQkFBVyxXQUFrQixNQUFNO0FBQ25DLG1CQUFTLE9BQU8sS0FBSyxZQUFZLEdBQUcsVUFBVSxNQUFNLENBQUM7QUFBQSxRQUN2RCxPQUFPO0FBQ0wsZ0JBQU1DLGtCQUFpQixrQkFBa0I7QUFDekMsY0FBSUEsaUJBQWdCO0FBQ2xCO0FBQUEsWUFDRSxpQkFDRyxNQUFNLEVBQ04sVUFBVUEsaUJBQWdCLEtBQUssY0FBYyxDQUFDO0FBQUEsVUFFckQsT0FBTztBQUNMLHVCQUFXO0FBQUEsVUFDYjtBQUFBLFFBQ0Y7QUFFQSxhQUFLLFlBQVksVUFBVSxPQUFPO0FBQUEsTUFDcEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSx5QkFBeUIsVUFBVTtBQUNqQyxjQUFNLFdBQVcsS0FBSyxZQUFZO0FBQ2xDLGNBQU0sV0FBVyxLQUFLLElBQUksUUFBUTtBQUNsQyxjQUFNLFdBQVcsS0FBSyxJQUFJLENBQUMsUUFBUTtBQUNuQyxjQUFNLFNBQVMsU0FBUyxtQkFBbUI7QUFDM0MsY0FBTSxTQUFTLFNBQVMsVUFBVTtBQUNsQyxZQUFJLFVBQVU7QUFDZCxZQUFJLFVBQVU7QUFDZCxZQUFJLFVBQVU7QUFDZCxZQUFJLFVBQVU7QUFDZCxpQkFBUyxJQUFJLEdBQUcsS0FBSyxPQUFPLFFBQVEsSUFBSSxJQUFJLEtBQUssUUFBUTtBQUN2RCxnQkFBTSxPQUFPLE9BQU8sQ0FBQyxJQUFJLFdBQVcsT0FBTyxJQUFJLENBQUMsSUFBSTtBQUNwRCxnQkFBTSxPQUFPLE9BQU8sQ0FBQyxJQUFJLFdBQVcsT0FBTyxJQUFJLENBQUMsSUFBSTtBQUNwRCxvQkFBVSxLQUFLLElBQUksU0FBUyxJQUFJO0FBQ2hDLG9CQUFVLEtBQUssSUFBSSxTQUFTLElBQUk7QUFDaEMsb0JBQVUsS0FBSyxJQUFJLFNBQVMsSUFBSTtBQUNoQyxvQkFBVSxLQUFLLElBQUksU0FBUyxJQUFJO0FBQUEsUUFDbEM7QUFDQSxlQUFPLENBQUMsU0FBUyxTQUFTLFNBQVMsT0FBTztBQUFBLE1BQzVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFlBQVksVUFBVSxTQUFTO0FBQzdCLGtCQUFVLFdBQVcsQ0FBQztBQUN0QixZQUFJLE9BQU8sUUFBUTtBQUNuQixZQUFJLENBQUMsTUFBTTtBQUNULGlCQUFPLEtBQUssNkJBQTZCO0FBQUEsUUFDM0M7QUFDQSxjQUFNLFVBQ0osUUFBUSxZQUFZLFNBQVksUUFBUSxVQUFVLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUMvRCxjQUFNLFVBQVUsUUFBUSxZQUFZLFNBQVksUUFBUSxVQUFVO0FBQ2xFLFlBQUk7QUFDSixZQUFJLFFBQVEsa0JBQWtCLFFBQVc7QUFDdkMsMEJBQWdCLFFBQVE7QUFBQSxRQUMxQixXQUFXLFFBQVEsWUFBWSxRQUFXO0FBQ3hDLDBCQUFnQixLQUFLLHFCQUFxQixRQUFRLE9BQU87QUFBQSxRQUMzRCxPQUFPO0FBQ0wsMEJBQWdCO0FBQUEsUUFDbEI7QUFFQSxjQUFNLGdCQUFnQixLQUFLLHlCQUF5QixRQUFRO0FBRzVELFlBQUksYUFBYSxLQUFLLCtCQUErQixlQUFlO0FBQUEsVUFDbEUsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDO0FBQUEsVUFDaEMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDO0FBQUEsUUFDbEMsQ0FBQztBQUNELHFCQUFhLE1BQU0sVUFBVSxJQUN6QixnQkFDQSxLQUFLLElBQUksWUFBWSxhQUFhO0FBQ3RDLHFCQUFhLEtBQUsseUJBQXlCLFlBQVksVUFBVSxJQUFJLENBQUM7QUFHdEUsY0FBTSxXQUFXLEtBQUssWUFBWTtBQUNsQyxjQUFNLFdBQVcsS0FBSyxJQUFJLFFBQVE7QUFDbEMsY0FBTSxXQUFXLEtBQUssSUFBSSxRQUFRO0FBQ2xDLGNBQU0sWUFBWSxVQUFVLGFBQWE7QUFDekMsa0JBQVUsQ0FBQyxNQUFPLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLElBQUs7QUFDbEQsa0JBQVUsQ0FBQyxNQUFPLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLElBQUs7QUFDbEQsY0FBTSxVQUFVLFVBQVUsQ0FBQyxJQUFJLFdBQVcsVUFBVSxDQUFDLElBQUk7QUFDekQsY0FBTSxVQUFVLFVBQVUsQ0FBQyxJQUFJLFdBQVcsVUFBVSxDQUFDLElBQUk7QUFDekQsY0FBTSxTQUFTLEtBQUsscUJBQXFCLENBQUMsU0FBUyxPQUFPLEdBQUcsVUFBVTtBQUN2RSxjQUFNLFdBQVcsUUFBUSxXQUFXLFFBQVEsV0FBVztBQUV2RCxZQUFJLFFBQVEsYUFBYSxRQUFXO0FBQ2xDLGVBQUs7QUFBQSxZQUNIO0FBQUEsY0FDRTtBQUFBLGNBQ0E7QUFBQSxjQUNBLFVBQVUsUUFBUTtBQUFBLGNBQ2xCLFFBQVEsUUFBUTtBQUFBLFlBQ2xCO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGLE9BQU87QUFDTCxlQUFLLG9CQUFvQjtBQUN6QixlQUFLLGdCQUFnQjtBQUNyQixlQUFLLGtCQUFrQixPQUFPLElBQUk7QUFDbEMsNEJBQWtCLFVBQVUsSUFBSTtBQUFBLFFBQ2xDO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxTQUFTLFlBQVksTUFBTSxVQUFVO0FBQ25DLGFBQUs7QUFBQSxVQUNILG1CQUFtQixZQUFZLEtBQUssY0FBYyxDQUFDO0FBQUEsVUFDbkQ7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxpQkFBaUIsWUFBWSxNQUFNLFVBQVU7QUFDM0MsYUFBSztBQUFBLFVBQ0g7QUFBQSxZQUNFO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxZQUNBLEtBQUssY0FBYztBQUFBLFlBQ25CLEtBQUssWUFBWTtBQUFBLFVBQ25CO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxxQkFBcUIsUUFBUSxZQUFZLFVBQVUsTUFBTTtBQUN2RCxZQUFJO0FBQ0osY0FBTSxVQUFVLEtBQUs7QUFDckIsWUFBSSxXQUFXLFFBQVE7QUFDckIsZ0JBQU0sY0FBYyxLQUFLLDZCQUE2QixDQUFDLFFBQVE7QUFDL0QsZ0JBQU0sZ0JBQWdCO0FBQUEsWUFDcEI7QUFBQSxZQUNBO0FBQUEsWUFDQSxDQUFDLFlBQVksQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDLEdBQUcsWUFBWSxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsQ0FBQztBQUFBLFlBQ2pFO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFDQSx3QkFBYztBQUFBLFlBQ1osT0FBTyxDQUFDLElBQUksY0FBYyxDQUFDO0FBQUEsWUFDM0IsT0FBTyxDQUFDLElBQUksY0FBYyxDQUFDO0FBQUEsVUFDN0I7QUFBQSxRQUNGO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFFBQVE7QUFDTixlQUFPLENBQUMsQ0FBQyxLQUFLLGtCQUFrQixLQUFLLEtBQUssY0FBYyxNQUFNO0FBQUEsTUFDaEU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxhQUFhLGtCQUFrQjtBQUM3QixjQUFNLFNBQVMsaUJBQWlCLEtBQUssZUFBZSxLQUFLLGNBQWMsQ0FBQztBQUN4RSxhQUFLLFVBQVU7QUFBQSxVQUNiLE9BQU8sQ0FBQyxJQUFJLGlCQUFpQixDQUFDO0FBQUEsVUFDOUIsT0FBTyxDQUFDLElBQUksaUJBQWlCLENBQUM7QUFBQSxRQUNoQyxDQUFDO0FBQUEsTUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxxQkFBcUIsa0JBQWtCO0FBQ3JDLGNBQU0sU0FBUyxLQUFLO0FBQ3BCLGFBQUssa0JBQWtCO0FBQUEsVUFDckIsT0FBTyxDQUFDLElBQUksaUJBQWlCLENBQUM7QUFBQSxVQUM5QixPQUFPLENBQUMsSUFBSSxpQkFBaUIsQ0FBQztBQUFBLFFBQ2hDLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGlCQUFpQixPQUFPLFFBQVE7QUFDOUIsaUJBQVMsVUFBVSxtQkFBbUIsUUFBUSxLQUFLLGNBQWMsQ0FBQztBQUNsRSxhQUFLLHlCQUF5QixPQUFPLE1BQU07QUFBQSxNQUM3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEseUJBQXlCLE9BQU8sUUFBUTtBQUN0QyxjQUFNLFdBQVcsS0FBSyxhQUFhLEtBQUssS0FBSyxlQUFlO0FBQzVELGNBQU0sT0FBTyxLQUFLLGlCQUFpQixLQUFLLFlBQVksQ0FBQztBQUNyRCxjQUFNLGdCQUFnQixLQUFLLGFBQWE7QUFBQSxVQUN0QyxLQUFLLG9CQUFvQjtBQUFBLFVBQ3pCO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNGO0FBRUEsWUFBSSxRQUFRO0FBQ1YsZUFBSyxnQkFBZ0IsS0FBSyxvQkFBb0IsZUFBZSxNQUFNO0FBQUEsUUFDckU7QUFFQSxhQUFLLHFCQUFxQjtBQUMxQixhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFdBQVcsT0FBTyxRQUFRO0FBQ3hCLGFBQUssaUJBQWlCLEtBQUssSUFBSSxLQUFLLGFBQWEsQ0FBQyxLQUFLLEdBQUcsTUFBTTtBQUFBLE1BQ2xFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGVBQWUsT0FBTyxRQUFRO0FBQzVCLFlBQUksUUFBUTtBQUNWLG1CQUFTLG1CQUFtQixRQUFRLEtBQUssY0FBYyxDQUFDO0FBQUEsUUFDMUQ7QUFDQSxhQUFLLHVCQUF1QixPQUFPLE1BQU07QUFBQSxNQUMzQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSx1QkFBdUIsT0FBTyxRQUFRO0FBQ3BDLGNBQU0sV0FBVyxLQUFLLGFBQWEsS0FBSyxLQUFLLGVBQWU7QUFDNUQsY0FBTSxjQUFjLEtBQUssYUFBYTtBQUFBLFVBQ3BDLEtBQUssa0JBQWtCO0FBQUEsVUFDdkI7QUFBQSxRQUNGO0FBQ0EsWUFBSSxRQUFRO0FBQ1YsZUFBSyxnQkFBZ0IsS0FBSyxzQkFBc0IsYUFBYSxNQUFNO0FBQUEsUUFDckU7QUFDQSxhQUFLLG1CQUFtQjtBQUN4QixhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxVQUFVLFFBQVE7QUFDaEIsYUFBSztBQUFBLFVBQ0gsU0FBUyxtQkFBbUIsUUFBUSxLQUFLLGNBQWMsQ0FBQyxJQUFJO0FBQUEsUUFDOUQ7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGtCQUFrQixRQUFRO0FBQ3hCLGFBQUssZ0JBQWdCO0FBQ3JCLGFBQUssa0JBQWtCO0FBQUEsTUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxRQUFRLE1BQU0sT0FBTztBQUNuQixhQUFLLE9BQU8sSUFBSSxLQUFLO0FBQ3JCLGFBQUssUUFBUTtBQUNiLGVBQU8sS0FBSyxPQUFPLElBQUk7QUFBQSxNQUN6QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsY0FBYyxZQUFZO0FBQ3hCLGFBQUssb0JBQW9CO0FBQ3pCLGFBQUssa0JBQWtCO0FBQUEsTUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFlBQVksVUFBVTtBQUNwQixhQUFLLGtCQUFrQjtBQUN2QixhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsUUFBUSxNQUFNO0FBQ1osYUFBSyxjQUFjLEtBQUsscUJBQXFCLElBQUksQ0FBQztBQUFBLE1BQ3BEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BVUEsa0JBQWtCLGtCQUFrQixhQUFhO0FBQy9DLGNBQU0sV0FDSixLQUFLLGFBQWEsS0FBSyxLQUFLLGVBQWUsS0FBSztBQUdsRCxjQUFNLGNBQWMsS0FBSyxhQUFhO0FBQUEsVUFDcEMsS0FBSztBQUFBLFVBQ0w7QUFBQSxRQUNGO0FBQ0EsY0FBTSxPQUFPLEtBQUssaUJBQWlCLFdBQVc7QUFDOUMsY0FBTSxnQkFBZ0IsS0FBSyxhQUFhO0FBQUEsVUFDdEMsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFDQSxjQUFNLFlBQVksS0FBSyxhQUFhO0FBQUEsVUFDbEMsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsS0FBSztBQUFBLFlBQ0gsS0FBSztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBRUEsWUFBSSxLQUFLLElBQUkscUJBQWEsUUFBUSxNQUFNLGFBQWE7QUFDbkQsZUFBSyxJQUFJLHFCQUFhLFVBQVUsV0FBVztBQUFBLFFBQzdDO0FBQ0EsWUFBSSxLQUFLLElBQUkscUJBQWEsVUFBVSxNQUFNLGVBQWU7QUFDdkQsZUFBSyxJQUFJLHFCQUFhLFlBQVksYUFBYTtBQUMvQyxlQUFLLElBQUksUUFBUSxLQUFLLFFBQVEsR0FBRyxJQUFJO0FBQUEsUUFDdkM7QUFDQSxZQUNFLENBQUMsYUFDRCxDQUFDLEtBQUssSUFBSSxxQkFBYSxNQUFNLEtBQzdCLENBQUNILFFBQU8sS0FBSyxJQUFJLHFCQUFhLE1BQU0sR0FBRyxTQUFTLEdBQ2hEO0FBQ0EsZUFBSyxJQUFJLHFCQUFhLFFBQVEsU0FBUztBQUFBLFFBQ3pDO0FBRUEsWUFBSSxLQUFLLGFBQWEsS0FBSyxDQUFDLGtCQUFrQjtBQUM1QyxlQUFLLGlCQUFpQjtBQUFBLFFBQ3hCO0FBQ0EsYUFBSyxnQkFBZ0I7QUFBQSxNQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BV0EsbUJBQW1CLFVBQVUscUJBQXFCLFFBQVE7QUFDeEQsbUJBQVcsYUFBYSxTQUFZLFdBQVc7QUFDL0MsY0FBTSxZQUFZLHVCQUF1QjtBQUV6QyxjQUFNLGNBQWMsS0FBSyxhQUFhLFNBQVMsS0FBSyxlQUFlO0FBQ25FLGNBQU0sT0FBTyxLQUFLLGlCQUFpQixXQUFXO0FBQzlDLGNBQU0sZ0JBQWdCLEtBQUssYUFBYTtBQUFBLFVBQ3RDLEtBQUs7QUFBQSxVQUNMO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFDQSxjQUFNLFlBQVksS0FBSyxhQUFhO0FBQUEsVUFDbEMsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsS0FBSztBQUFBLFlBQ0gsS0FBSztBQUFBLFlBQ0w7QUFBQSxZQUNBO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBRUEsWUFBSSxhQUFhLEtBQUssQ0FBQyxLQUFLLGVBQWU7QUFDekMsZUFBSyxvQkFBb0I7QUFDekIsZUFBSyxrQkFBa0I7QUFDdkIsZUFBSyxnQkFBZ0I7QUFDckIsZUFBSyxrQkFBa0I7QUFDdkI7QUFBQSxRQUNGO0FBRUEsaUJBQVMsV0FBVyxhQUFhLElBQUksS0FBSyxnQkFBZ0I7QUFDMUQsYUFBSyxnQkFBZ0I7QUFFckIsWUFDRSxLQUFLLGNBQWMsTUFBTSxpQkFDekIsS0FBSyxZQUFZLE1BQU0sZUFDdkIsQ0FBQyxLQUFLLGtCQUFrQixLQUN4QixDQUFDQSxRQUFPLEtBQUssa0JBQWtCLEdBQUcsU0FBUyxHQUMzQztBQUNBLGNBQUksS0FBSyxhQUFhLEdBQUc7QUFDdkIsaUJBQUssaUJBQWlCO0FBQUEsVUFDeEI7QUFFQSxlQUFLLGdCQUFnQjtBQUFBLFlBQ25CLFVBQVU7QUFBQSxZQUNWLFFBQVE7QUFBQSxZQUNSLFlBQVk7QUFBQSxZQUNaO0FBQUEsWUFDQSxRQUFRO0FBQUEsWUFDUjtBQUFBLFVBQ0YsQ0FBQztBQUFBLFFBQ0g7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxtQkFBbUI7QUFDakIsYUFBSyxtQkFBbUIsQ0FBQztBQUV6QixhQUFLLFFBQVEsaUJBQVMsYUFBYSxDQUFDO0FBQUEsTUFDdEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxlQUFlLFVBQVUscUJBQXFCLFFBQVE7QUFDcEQsaUJBQVMsVUFBVSxtQkFBbUIsUUFBUSxLQUFLLGNBQWMsQ0FBQztBQUNsRSxhQUFLLHVCQUF1QixVQUFVLHFCQUFxQixNQUFNO0FBQUEsTUFDbkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsdUJBQXVCLFVBQVUscUJBQXFCLFFBQVE7QUFDNUQsWUFBSSxDQUFDLEtBQUssZUFBZSxHQUFHO0FBQzFCO0FBQUEsUUFDRjtBQUNBLGFBQUssUUFBUSxpQkFBUyxhQUFhLEVBQUU7QUFDckMsYUFBSyxtQkFBbUIsVUFBVSxxQkFBcUIsTUFBTTtBQUFBLE1BQy9EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLHFCQUFxQixjQUFjLGtCQUFrQjtBQUNuRCxjQUFNLE9BQU8sS0FBSyxpQkFBaUIsS0FBSyxZQUFZLENBQUM7QUFDckQsZUFBTyxLQUFLLGFBQWE7QUFBQSxVQUN2QjtBQUFBLFVBQ0Esb0JBQW9CLEtBQUssY0FBYztBQUFBLFVBQ3ZDO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVdBLG1CQUFtQixZQUFZLFdBQVc7QUFDeEMsY0FBTSxZQUFZLEtBQUsscUJBQXFCLFVBQVU7QUFDdEQsZUFBTyxLQUFLO0FBQUEsVUFDVixLQUFLLHlCQUF5QixXQUFXLFNBQVM7QUFBQSxRQUNwRDtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVdBLHlCQUF5QixrQkFBa0IsV0FBVztBQUNwRCxvQkFBWSxhQUFhO0FBQ3pCLGNBQU0sT0FBTyxLQUFLLGlCQUFpQixLQUFLLFlBQVksQ0FBQztBQUVyRCxlQUFPLEtBQUssYUFBYSxXQUFXLGtCQUFrQixXQUFXLElBQUk7QUFBQSxNQUN2RTtBQUFBLElBQ0Y7QUFvUEEsSUFBTyxlQUFRO0FBQUE7QUFBQTs7O0FDcG5EUixTQUFTLE9BQU8sWUFBWSxXQUFXO0FBQzVDLE1BQUksQ0FBQyxXQUFXLFNBQVM7QUFDdkIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLGFBQWEsVUFBVTtBQUM3QixNQUNFLGFBQWEsV0FBVyxpQkFDeEIsY0FBYyxXQUFXLGVBQ3pCO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLE9BQU8sVUFBVTtBQUN2QixTQUFPLE9BQU8sV0FBVyxXQUFXLFFBQVEsV0FBVztBQUN6RDtBQXhnQkEsSUFtR00sT0F1YUM7QUExZ0JQO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFBSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeUZBLElBQU0sUUFBTixjQUFvQixhQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJNUIsWUFBWSxTQUFTO0FBQ25CLGNBQU0sY0FBYyxPQUFPLE9BQU8sQ0FBQyxHQUFHLE9BQU87QUFDN0MsZUFBTyxZQUFZO0FBRW5CLGNBQU0sV0FBVztBQUtqQixhQUFLO0FBS0wsYUFBSztBQUtMLGFBQUs7QUFNTCxhQUFLLG9CQUFvQjtBQU16QixhQUFLLGdCQUFnQjtBQU1yQixhQUFLLG1CQUFtQjtBQU14QixhQUFLLFlBQVk7QUFNakIsYUFBSyxlQUFlO0FBTXBCLGFBQUssV0FBVztBQUdoQixZQUFJLFFBQVEsUUFBUTtBQUNsQixlQUFLLFNBQVMsUUFBUTtBQUFBLFFBQ3hCO0FBRUEsWUFBSSxRQUFRLEtBQUs7QUFDZixlQUFLLE9BQU8sUUFBUSxHQUFHO0FBQUEsUUFDekI7QUFFQSxhQUFLO0FBQUEsVUFDSCxpQkFBYztBQUFBLFVBQ2QsS0FBSztBQUFBLFFBQ1A7QUFFQSxjQUFNLFNBQVMsUUFBUTtBQUFBO0FBQUEsVUFDUSxRQUFRO0FBQUEsWUFDbkM7QUFDSixhQUFLLFVBQVUsTUFBTTtBQUFBLE1BQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGVBQWUsT0FBTztBQUNwQixnQkFBUSxRQUFRLFFBQVEsQ0FBQztBQUN6QixjQUFNLEtBQUssSUFBSTtBQUNmLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLG9CQUFvQixRQUFRO0FBQzFCLGlCQUFTLFNBQVMsU0FBUyxDQUFDO0FBQzVCLGVBQU8sS0FBSyxLQUFLLGNBQWMsQ0FBQztBQUNoQyxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWTtBQUNWO0FBQUE7QUFBQSxVQUFrQyxLQUFLLElBQUksaUJBQWMsTUFBTSxLQUFNO0FBQUE7QUFBQSxNQUN2RTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esa0JBQWtCO0FBQ2hCLGVBQU8sS0FBSyxVQUFVO0FBQUEsTUFDeEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGlCQUFpQjtBQUNmLGNBQU0sU0FBUyxLQUFLLFVBQVU7QUFDOUIsZUFBTyxDQUFDLFNBQVMsY0FBYyxPQUFPLFNBQVM7QUFBQSxNQUNqRDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esc0JBQXNCO0FBQ3BCLGFBQUssUUFBUTtBQUNiLFlBQUksS0FBSyxnQkFBZ0IsS0FBSyxVQUFVLEVBQUUsU0FBUyxNQUFNLFNBQVM7QUFDaEU7QUFBQSxRQUNGO0FBQ0EsYUFBSyxlQUFlO0FBQ3BCLGFBQUssY0FBYyxhQUFhO0FBQUEsTUFDbEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLDhCQUE4QjtBQUM1QixZQUFJLEtBQUssa0JBQWtCO0FBQ3pCLHdCQUFjLEtBQUssZ0JBQWdCO0FBQ25DLGVBQUssbUJBQW1CO0FBQUEsUUFDMUI7QUFDQSxhQUFLLGVBQWU7QUFDcEIsY0FBTSxTQUFTLEtBQUssVUFBVTtBQUM5QixZQUFJLFFBQVE7QUFDVixlQUFLLG1CQUFtQjtBQUFBLFlBQ3RCO0FBQUEsWUFDQSxrQkFBVTtBQUFBLFlBQ1YsS0FBSztBQUFBLFlBQ0w7QUFBQSxVQUNGO0FBQ0EsY0FBSSxPQUFPLFNBQVMsTUFBTSxTQUFTO0FBQ2pDLGlCQUFLLGVBQWU7QUFDcEIsdUJBQVcsTUFBTTtBQUNmLG1CQUFLLGNBQWMsYUFBYTtBQUFBLFlBQ2xDLEdBQUcsQ0FBQztBQUFBLFVBQ047QUFBQSxRQUNGO0FBQ0EsYUFBSyxRQUFRO0FBQUEsTUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVksT0FBTztBQUNqQixZQUFJLENBQUMsS0FBSyxXQUFXO0FBQ25CLGlCQUFPLFFBQVEsUUFBUSxDQUFDLENBQUM7QUFBQSxRQUMzQjtBQUNBLGVBQU8sS0FBSyxVQUFVLFlBQVksS0FBSztBQUFBLE1BQ3pDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFFBQVEsT0FBTztBQUNiLFlBQUksQ0FBQyxLQUFLLGFBQWEsQ0FBQyxLQUFLLFVBQVU7QUFDckMsaUJBQU87QUFBQSxRQUNUO0FBQ0EsZUFBTyxLQUFLLFVBQVUsUUFBUSxLQUFLO0FBQUEsTUFDckM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVdBLFVBQVUsTUFBTTtBQUNkLFlBQUk7QUFDSixjQUFNLE1BQU0sS0FBSyxlQUFlO0FBQ2hDLFlBQUksQ0FBQyxRQUFRLEtBQUs7QUFDaEIsaUJBQU8sSUFBSSxRQUFRO0FBQUEsUUFDckI7QUFDQSxZQUFJLGdCQUFnQixjQUFNO0FBQ3hCLHVCQUFhO0FBQUEsWUFDWCxXQUFXLEtBQUssU0FBUztBQUFBLFlBQ3pCLFFBQVEsS0FBSyxnQkFBZ0I7QUFBQSxVQUMvQjtBQUFBLFFBQ0YsT0FBTztBQUNMLHVCQUFhO0FBQUEsUUFDZjtBQUNBLFlBQUksQ0FBQyxXQUFXLG9CQUFvQixLQUFLO0FBQ3ZDLHFCQUFXLG1CQUFtQixJQUFJLGNBQWMsRUFBRSxvQkFBb0I7QUFBQSxRQUN4RTtBQUNBLFlBQUk7QUFDSixZQUFJLFdBQVcsa0JBQWtCO0FBQy9CLHVCQUFhLFdBQVcsaUJBQWlCO0FBQUEsWUFDdkMsQ0FBQ0MsZ0JBQWVBLFlBQVcsVUFBVTtBQUFBLFVBQ3ZDO0FBQUEsUUFDRixPQUFPO0FBQ0wsdUJBQWEsS0FBSyxjQUFjO0FBQUEsUUFDbEM7QUFFQSxjQUFNLGNBQWMsS0FBSyxVQUFVO0FBRW5DLGVBQ0UsT0FBTyxZQUFZLFdBQVcsU0FBUyxNQUN0QyxDQUFDLGVBQWUsV0FBVyxhQUFhLFdBQVcsTUFBTTtBQUFBLE1BRTlEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGdCQUFnQixNQUFNO0FBQ3BCLFlBQUksQ0FBQyxLQUFLLFVBQVUsSUFBSSxHQUFHO0FBQ3pCLGlCQUFPLENBQUM7QUFBQSxRQUNWO0FBQ0EsWUFBSTtBQUNKLGNBQU0sU0FBUyxLQUFLLFVBQVU7QUFDOUIsWUFBSSxRQUFRO0FBQ1YsNEJBQWtCLE9BQU8sZ0JBQWdCO0FBQUEsUUFDM0M7QUFDQSxZQUFJLENBQUMsaUJBQWlCO0FBQ3BCLGlCQUFPLENBQUM7QUFBQSxRQUNWO0FBQ0EsY0FBTSxhQUNKLGdCQUFnQixlQUFPLEtBQUssc0JBQXNCLElBQUk7QUFDeEQsWUFBSSxlQUFlLGdCQUFnQixVQUFVO0FBQzdDLFlBQUksQ0FBQyxNQUFNLFFBQVEsWUFBWSxHQUFHO0FBQ2hDLHlCQUFlLENBQUMsWUFBWTtBQUFBLFFBQzlCO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxPQUFPLFlBQVksUUFBUTtBQUN6QixjQUFNLGdCQUFnQixLQUFLLFlBQVk7QUFFdkMsWUFBSSxjQUFjLGFBQWEsVUFBVSxHQUFHO0FBQzFDLGVBQUssV0FBVztBQUNoQixpQkFBTyxjQUFjLFlBQVksWUFBWSxNQUFNO0FBQUEsUUFDckQ7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsV0FBVztBQUNULGFBQUssV0FBVztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGVBQWUsS0FBSztBQUNsQixZQUFJLENBQUMsS0FBSztBQUNSLGVBQUssU0FBUztBQUFBLFFBQ2hCO0FBQ0EsYUFBSyxJQUFJLGlCQUFjLEtBQUssR0FBRztBQUFBLE1BQ2pDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGlCQUFpQjtBQUNmLGVBQU8sS0FBSyxJQUFJLGlCQUFjLEdBQUc7QUFBQSxNQUNuQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQWFBLE9BQU8sS0FBSztBQUNWLFlBQUksS0FBSyxtQkFBbUI7QUFDMUIsd0JBQWMsS0FBSyxpQkFBaUI7QUFDcEMsZUFBSyxvQkFBb0I7QUFBQSxRQUMzQjtBQUNBLFlBQUksQ0FBQyxLQUFLO0FBQ1IsZUFBSyxRQUFRO0FBQUEsUUFDZjtBQUNBLFlBQUksS0FBSyxlQUFlO0FBQ3RCLHdCQUFjLEtBQUssYUFBYTtBQUNoQyxlQUFLLGdCQUFnQjtBQUFBLFFBQ3ZCO0FBQ0EsWUFBSSxLQUFLO0FBQ1AsZUFBSyxvQkFBb0I7QUFBQSxZQUN2QjtBQUFBLFlBQ0FDLG1CQUFnQjtBQUFBLFlBQ2hCLFNBQVUsS0FBSztBQUNiLG9CQUFNO0FBQUE7QUFBQSxnQkFDaUQ7QUFBQTtBQUN2RCxvQkFBTSxtQkFBbUIsWUFBWSxXQUFXO0FBQ2hELG9CQUFNLGFBQWEsS0FBSyxjQUFjLEtBQUs7QUFDM0M7QUFBQSxnQkFDRSxDQUFDLGlCQUFpQixLQUFLLFNBQVUsaUJBQWlCO0FBQ2hELHlCQUFPLGdCQUFnQixVQUFVLFdBQVc7QUFBQSxnQkFDOUMsQ0FBQztBQUFBLGdCQUNEO0FBQUEsY0FDRjtBQUNBLCtCQUFpQixLQUFLLFVBQVU7QUFBQSxZQUNsQztBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQ0EsZUFBSyxnQkFBZ0IsT0FBTyxNQUFNLGtCQUFVLFFBQVEsSUFBSSxRQUFRLEdBQUc7QUFDbkUsZUFBSyxRQUFRO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFVBQVUsUUFBUTtBQUNoQixhQUFLLElBQUksaUJBQWMsUUFBUSxNQUFNO0FBQUEsTUFDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsY0FBYztBQUNaLFlBQUksQ0FBQyxLQUFLLFdBQVc7QUFDbkIsZUFBSyxZQUFZLEtBQUssZUFBZTtBQUFBLFFBQ3ZDO0FBQ0EsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsY0FBYztBQUNaLGVBQU8sQ0FBQyxDQUFDLEtBQUs7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGlCQUFpQjtBQUNmLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxrQkFBa0I7QUFDaEIsWUFBSSxLQUFLLFdBQVc7QUFDbEIsZUFBSyxVQUFVLFFBQVE7QUFDdkIsaUJBQU8sS0FBSztBQUFBLFFBQ2Q7QUFFQSxhQUFLLFVBQVUsSUFBSTtBQUNuQixjQUFNLGdCQUFnQjtBQUFBLE1BQ3hCO0FBQUEsSUFDRjtBQXdCQSxJQUFPLGdCQUFRO0FBQUE7QUFBQTs7O0FDMWdCZixJQU1NLGFBcUNDQztBQTNDUCxJQUFBQyxjQUFBO0FBQUE7QUFJQTtBQUVBLElBQU0sY0FBTixjQUEwQixjQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVE5QixZQUFZLE1BQU0sdUJBQXVCLFlBQVksU0FBUztBQUM1RCxjQUFNLElBQUk7QUFRVixhQUFLLHdCQUF3QjtBQU83QixhQUFLLGFBQWE7QUFTbEIsYUFBSyxVQUFVO0FBQUEsTUFDakI7QUFBQSxJQUNGO0FBRUEsSUFBT0QsaUJBQVE7QUFBQTtBQUFBOzs7QUMzQ2YsSUFxQmEsY0FnQkEsb0JBZ0JBLGVBU0EsaUJBTVAsV0FhQSxxQkFlTztBQWhHYjtBQUFBO0FBcUJPLElBQU0sZUFBZTtBQWdCckIsSUFBTSxxQkFBcUI7QUFnQjNCLElBQU0sZ0JBQWdCO0FBU3RCLElBQU0sa0JBQWtCO0FBTS9CLElBQU0sWUFBWSxJQUFJO0FBQUEsTUFDcEI7QUFBQSxRQUNFO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRixFQUFFLEtBQUssRUFBRTtBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBRUEsSUFBTSxzQkFBc0I7QUFBQSxNQUMxQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQVFPLElBQU0sb0JBQW9CLFNBQVUsVUFBVTtBQUNuRCxZQUFNLFFBQVEsU0FBUyxNQUFNLFNBQVM7QUFDdEMsVUFBSSxDQUFDLE9BQU87QUFDVixlQUFPO0FBQUEsTUFDVDtBQUNBLFlBQU07QUFBQTtBQUFBLFFBQXVDO0FBQUEsVUFDM0MsWUFBWTtBQUFBLFVBQ1osTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFFBQ1g7QUFBQTtBQUNBLGVBQVMsSUFBSSxHQUFHLEtBQUssb0JBQW9CLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM1RCxjQUFNLFFBQVEsTUFBTSxJQUFJLENBQUM7QUFDekIsWUFBSSxVQUFVLFFBQVc7QUFDdkIsZ0JBQU0sb0JBQW9CLENBQUMsQ0FBQyxJQUFJO0FBQUEsUUFDbEM7QUFBQSxNQUNGO0FBQ0EsWUFBTSxXQUFXLE1BQU0sT0FBTyxNQUFNLE1BQU07QUFDMUMsYUFBTztBQUFBLElBQ1Q7QUFBQTtBQUFBOzs7QUNyR08sU0FBUyxzQkFBc0IsT0FBTyxRQUFRRSxhQUFZLFVBQVU7QUFFekUsTUFBSTtBQUNKLE1BQUlBLGVBQWNBLFlBQVcsUUFBUTtBQUNuQztBQUFBLElBQTJDQSxZQUFXLE1BQU07QUFBQSxFQUM5RCxXQUFXLHlCQUF5QjtBQUNsQyxhQUFTLElBQUksZ0JBQWdCLFNBQVMsS0FBSyxVQUFVLEdBQUc7QUFBQSxFQUMxRCxPQUFPO0FBQ0wsYUFBUyxTQUFTLGNBQWMsUUFBUTtBQUFBLEVBQzFDO0FBQ0EsTUFBSSxPQUFPO0FBQ1QsV0FBTyxRQUFRO0FBQUEsRUFDakI7QUFDQSxNQUFJLFFBQVE7QUFDVixXQUFPLFNBQVM7QUFBQSxFQUNsQjtBQUVBO0FBQUE7QUFBQSxJQUNFLE9BQU8sV0FBVyxNQUFNLFFBQVE7QUFBQTtBQUVwQztBQU9PLFNBQVMsY0FBYyxTQUFTO0FBQ3JDLFFBQU0sU0FBUyxRQUFRO0FBQ3ZCLFNBQU8sUUFBUTtBQUNmLFNBQU8sU0FBUztBQUNoQixVQUFRLFVBQVUsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUM5QjtBQW9DTyxTQUFTLFlBQVksU0FBUyxTQUFTO0FBQzVDLFFBQU0sU0FBUyxRQUFRO0FBQ3ZCLE1BQUksUUFBUTtBQUNWLFdBQU8sYUFBYSxTQUFTLE9BQU87QUFBQSxFQUN0QztBQUNGO0FBTU8sU0FBUyxXQUFXLE1BQU07QUFDL0IsU0FBTyxRQUFRLEtBQUssYUFBYSxLQUFLLFdBQVcsWUFBWSxJQUFJLElBQUk7QUFDdkU7QUFLTyxTQUFTLGVBQWUsTUFBTTtBQUNuQyxTQUFPLEtBQUssV0FBVztBQUNyQixTQUFLLFlBQVksS0FBSyxTQUFTO0FBQUEsRUFDakM7QUFDRjtBQVVPLFNBQVMsZ0JBQWdCLE1BQU0sVUFBVTtBQUM5QyxRQUFNLGNBQWMsS0FBSztBQUV6QixXQUFTLElBQUksR0FBRyxNQUFNLEVBQUUsR0FBRztBQUN6QixVQUFNLFdBQVcsWUFBWSxDQUFDO0FBQzlCLFVBQU0sV0FBVyxTQUFTLENBQUM7QUFHM0IsUUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVO0FBQzFCO0FBQUEsSUFDRjtBQUdBLFFBQUksYUFBYSxVQUFVO0FBQ3pCO0FBQUEsSUFDRjtBQUdBLFFBQUksQ0FBQyxVQUFVO0FBQ2IsV0FBSyxZQUFZLFFBQVE7QUFDekI7QUFBQSxJQUNGO0FBR0EsUUFBSSxDQUFDLFVBQVU7QUFDYixXQUFLLFlBQVksUUFBUTtBQUN6QixRQUFFO0FBQ0Y7QUFBQSxJQUNGO0FBR0EsU0FBSyxhQUFhLFVBQVUsUUFBUTtBQUFBLEVBQ3RDO0FBQ0Y7QUFwSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDb1VBLFNBQVMsWUFBWSxNQUFNLE1BQU07QUFDL0IsTUFBSSxDQUFDLGdCQUFnQjtBQUNuQixxQkFBaUIsc0JBQXNCLEdBQUcsQ0FBQztBQUFBLEVBQzdDO0FBQ0EsTUFBSSxRQUFRLGFBQWE7QUFDdkIsbUJBQWUsT0FBTztBQUN0QixrQkFBYyxlQUFlO0FBQUEsRUFDL0I7QUFDQSxTQUFPLGVBQWUsWUFBWSxJQUFJO0FBQ3hDO0FBT08sU0FBUyxpQkFBaUIsTUFBTSxNQUFNO0FBQzNDLFNBQU8sWUFBWSxNQUFNLElBQUksRUFBRTtBQUNqQztBQVNPLFNBQVMseUJBQXlCLE1BQU0sTUFBTUMsUUFBTztBQUMxRCxNQUFJLFFBQVFBLFFBQU87QUFDakIsV0FBT0EsT0FBTSxJQUFJO0FBQUEsRUFDbkI7QUFDQSxRQUFNLFFBQVEsS0FDWCxNQUFNLElBQUksRUFDVixPQUFPLENBQUMsTUFBTSxTQUFTLEtBQUssSUFBSSxNQUFNLGlCQUFpQixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUM7QUFDekUsRUFBQUEsT0FBTSxJQUFJLElBQUk7QUFDZCxTQUFPO0FBQ1Q7QUFPTyxTQUFTLGtCQUFrQixXQUFXLFFBQVE7QUFDbkQsUUFBTSxTQUFTLENBQUM7QUFDaEIsUUFBTSxVQUFVLENBQUM7QUFDakIsUUFBTSxhQUFhLENBQUM7QUFDcEIsTUFBSSxRQUFRO0FBQ1osTUFBSSxZQUFZO0FBQ2hCLE1BQUksU0FBUztBQUNiLE1BQUksYUFBYTtBQUNqQixXQUFTLElBQUksR0FBRyxLQUFLLE9BQU8sUUFBUSxLQUFLLElBQUksS0FBSyxHQUFHO0FBQ25ELFVBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsUUFBSSxTQUFTLFFBQVEsTUFBTSxJQUFJO0FBQzdCLGNBQVEsS0FBSyxJQUFJLE9BQU8sU0FBUztBQUNqQyxpQkFBVyxLQUFLLFNBQVM7QUFDekIsa0JBQVk7QUFDWixnQkFBVTtBQUNWO0FBQUEsSUFDRjtBQUNBLFVBQU0sT0FBTyxPQUFPLElBQUksQ0FBQyxLQUFLLFVBQVU7QUFDeEMsVUFBTSxlQUFlLGlCQUFpQixNQUFNLElBQUk7QUFDaEQsV0FBTyxLQUFLLFlBQVk7QUFDeEIsaUJBQWE7QUFDYixVQUFNLGdCQUFnQixrQkFBa0IsSUFBSTtBQUM1QyxZQUFRLEtBQUssYUFBYTtBQUMxQixpQkFBYSxLQUFLLElBQUksWUFBWSxhQUFhO0FBQUEsRUFDakQ7QUFDQSxTQUFPLEVBQUMsT0FBTyxRQUFRLFFBQVEsU0FBUyxXQUFVO0FBQ3BEO0FBNkJPLFNBQVMsaUJBQ2QsU0FDQUMsWUFDQSxTQUNBLGNBQ0EsU0FDQSxTQUNBLEdBQ0EsR0FDQSxHQUNBLEdBQ0FDLFFBQ0E7QUFDQSxVQUFRLEtBQUs7QUFFYixNQUFJLFlBQVksR0FBRztBQUNqQixZQUFRLGVBQWU7QUFBQSxFQUN6QjtBQUNBLE1BQUlELFlBQVc7QUFDYixZQUFRLFVBQVUsTUFBTSxTQUFTQSxVQUFTO0FBQUEsRUFDNUM7QUFFQTtBQUFBO0FBQUEsSUFBc0IsYUFBYztBQUFBLElBQXFCO0FBRXZELFlBQVEsVUFBVSxHQUFHLENBQUM7QUFDdEIsWUFBUSxNQUFNQyxPQUFNLENBQUMsR0FBR0EsT0FBTSxDQUFDLENBQUM7QUFDaEM7QUFBQTtBQUFBLE1BQStDO0FBQUEsTUFBZTtBQUFBLElBQU87QUFBQSxFQUN2RSxXQUFXQSxPQUFNLENBQUMsSUFBSSxLQUFLQSxPQUFNLENBQUMsSUFBSSxHQUFHO0FBRXZDLFlBQVEsVUFBVSxHQUFHLENBQUM7QUFDdEIsWUFBUSxNQUFNQSxPQUFNLENBQUMsR0FBR0EsT0FBTSxDQUFDLENBQUM7QUFDaEMsWUFBUTtBQUFBO0FBQUEsTUFFSjtBQUFBLE1BRUY7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLEVBQ0YsT0FBTztBQUVMLFlBQVE7QUFBQTtBQUFBLE1BRUo7QUFBQSxNQUVGO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLElBQUlBLE9BQU0sQ0FBQztBQUFBLE1BQ1gsSUFBSUEsT0FBTSxDQUFDO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFFQSxVQUFRLFFBQVE7QUFDbEI7QUFNQSxTQUFTLHlCQUF5QixPQUFPLFNBQVM7QUFDaEQsUUFBTSxzQkFBc0IsTUFBTTtBQUNsQyxXQUFTLElBQUksR0FBRyxLQUFLLG9CQUFvQixRQUFRLElBQUksSUFBSSxLQUFLLEdBQUc7QUFDL0QsUUFBSSxNQUFNLFFBQVEsb0JBQW9CLElBQUksQ0FBQyxDQUFDLEdBQUc7QUFDN0MsY0FBUSxvQkFBb0IsQ0FBQyxDQUFDLEVBQUU7QUFBQSxRQUM5QjtBQUFBLFFBQ0Esb0JBQW9CLElBQUksQ0FBQztBQUFBLE1BQzNCO0FBQUEsSUFDRixPQUFPO0FBQ0wsY0FBUSxvQkFBb0IsQ0FBQyxDQUFDLElBQUksb0JBQW9CLElBQUksQ0FBQztBQUFBLElBQzdEO0FBQUEsRUFDRjtBQUNGO0FBdGZBLElBMkZhLGFBTUEsa0JBTUEsZ0JBTUEsaUJBTUEsdUJBTUEsaUJBTUEsbUJBTUEsb0JBTUEsa0JBTUEscUJBTUEsZ0JBTUEsa0JBS0EsY0FLVCxnQkFLQSxhQUtTLGFBTUEsY0ErRkE7QUF0UmI7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvRk8sSUFBTSxjQUFjO0FBTXBCLElBQU0sbUJBQW1CO0FBTXpCLElBQU0saUJBQWlCO0FBTXZCLElBQU0sa0JBQWtCLENBQUM7QUFNekIsSUFBTSx3QkFBd0I7QUFNOUIsSUFBTSxrQkFBa0I7QUFNeEIsSUFBTSxvQkFBb0I7QUFNMUIsSUFBTSxxQkFBcUI7QUFNM0IsSUFBTSxtQkFBbUI7QUFNekIsSUFBTSxzQkFBc0I7QUFNNUIsSUFBTSxpQkFBaUIsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBTWxDLElBQU0sbUJBQW1CO0FBS3pCLElBQU0sZUFBZSxJQUFJLGVBQVc7QUFLM0MsSUFBSSxpQkFBaUI7QUFVZCxJQUFNLGNBQWMsQ0FBQztBQU1yQixJQUFNLGVBQWdCLFdBQVk7QUFDdkMsWUFBTSxVQUFVO0FBQ2hCLFlBQU0sT0FBTztBQUNiLFlBQU0saUJBQWlCLENBQUMsYUFBYSxPQUFPO0FBQzVDLFlBQU0sTUFBTSxlQUFlO0FBQzNCLFlBQU0sT0FBTztBQUNiLFVBQUksVUFBVTtBQVFkLGVBQVMsWUFBWSxXQUFXLFlBQVksWUFBWTtBQUN0RCxZQUFJLFlBQVk7QUFDaEIsaUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxFQUFFLEdBQUc7QUFDNUIsZ0JBQU0sZ0JBQWdCLGVBQWUsQ0FBQztBQUN0QywyQkFBaUI7QUFBQSxZQUNmLFlBQVksTUFBTSxhQUFhLE1BQU0sT0FBTztBQUFBLFlBQzVDO0FBQUEsVUFDRjtBQUNBLGNBQUksY0FBYyxlQUFlO0FBQy9CLGtCQUFNLFFBQVE7QUFBQSxjQUNaLFlBQ0UsTUFDQSxhQUNBLE1BQ0EsT0FDQSxhQUNBLE1BQ0E7QUFBQSxjQUNGO0FBQUEsWUFDRjtBQUdBLHdCQUFZLGFBQWEsU0FBUztBQUFBLFVBQ3BDO0FBQUEsUUFDRjtBQUNBLFlBQUksV0FBVztBQUNiLGlCQUFPO0FBQUEsUUFDVDtBQUNBLGVBQU87QUFBQSxNQUNUO0FBRUEsZUFBUyxRQUFRO0FBQ2YsWUFBSSxPQUFPO0FBQ1gsY0FBTSxRQUFRLGFBQWEsUUFBUTtBQUNuQyxpQkFBUyxJQUFJLEdBQUcsS0FBSyxNQUFNLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM5QyxnQkFBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixjQUFJLGFBQWEsSUFBSSxJQUFJLElBQUksU0FBUztBQUNwQyxnQkFBSSxZQUFZLE1BQU0sTUFBTSxLQUFLLE1BQU0sSUFBSSxDQUFDLEdBQUc7QUFDN0Msb0JBQU0sV0FBVztBQUVqQiwrQkFBaUI7QUFDakIsNEJBQWM7QUFDZCwyQkFBYSxJQUFJLE1BQU0sT0FBTztBQUFBLFlBQ2hDLE9BQU87QUFDTCwyQkFBYSxJQUFJLE1BQU0sYUFBYSxJQUFJLElBQUksSUFBSSxHQUFHLElBQUk7QUFDdkQscUJBQU87QUFBQSxZQUNUO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxZQUFJLE1BQU07QUFDUix3QkFBYyxRQUFRO0FBQ3RCLHFCQUFXO0FBQUEsUUFDYjtBQUFBLE1BQ0Y7QUFFQSxhQUFPLFNBQVUsVUFBVTtBQUN6QixjQUFNLE9BQU8sa0JBQWtCLFFBQVE7QUFDdkMsWUFBSSxDQUFDLE1BQU07QUFDVDtBQUFBLFFBQ0Y7QUFDQSxjQUFNLFdBQVcsS0FBSztBQUN0QixpQkFBUyxJQUFJLEdBQUcsS0FBSyxTQUFTLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUNqRCxnQkFBTSxTQUFTLFNBQVMsQ0FBQztBQUN6QixnQkFBTSxNQUFNLEtBQUssUUFBUSxPQUFPLEtBQUssU0FBUyxPQUFPO0FBQ3JELGNBQUksYUFBYSxJQUFJLEdBQUcsTUFBTSxRQUFXO0FBQ3ZDLHlCQUFhLElBQUksS0FBSyxTQUFTLElBQUk7QUFDbkMsZ0JBQUksQ0FBQyxZQUFZLEtBQUssT0FBTyxLQUFLLFFBQVEsTUFBTSxHQUFHO0FBQ2pELDJCQUFhLElBQUksS0FBSyxHQUFHLElBQUk7QUFDN0Isa0JBQUksYUFBYSxRQUFXO0FBQzFCLDJCQUFXLFlBQVksT0FBTyxFQUFFO0FBQUEsY0FDbEM7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRixFQUFHO0FBTUksSUFBTSxvQkFBcUIsMkJBQVk7QUFJNUMsVUFBSTtBQUNKLGFBQU8sU0FBVSxVQUFVO0FBQ3pCLFlBQUksU0FBUyxZQUFZLFFBQVE7QUFDakMsWUFBSSxVQUFVLFFBQVc7QUFDdkIsY0FBSSx5QkFBeUI7QUFDM0Isa0JBQU0sT0FBTyxrQkFBa0IsUUFBUTtBQUN2QyxrQkFBTSxVQUFVLFlBQVksVUFBVSxTQUFJO0FBQzFDLGtCQUFNLGFBQWEsTUFBTSxPQUFPLEtBQUssVUFBVSxDQUFDLElBQzVDLE1BQ0EsT0FBTyxLQUFLLFVBQVU7QUFDMUIscUJBQ0UsY0FDQyxRQUFRLDBCQUEwQixRQUFRO0FBQUEsVUFDL0MsT0FBTztBQUNMLGdCQUFJLENBQUMsZ0JBQWdCO0FBQ25CLCtCQUFpQixTQUFTLGNBQWMsS0FBSztBQUM3Qyw2QkFBZSxZQUFZO0FBQzNCLDZCQUFlLE1BQU0sWUFBWTtBQUNqQyw2QkFBZSxNQUFNLFlBQVk7QUFDakMsNkJBQWUsTUFBTSxTQUFTO0FBQzlCLDZCQUFlLE1BQU0sVUFBVTtBQUMvQiw2QkFBZSxNQUFNLFNBQVM7QUFDOUIsNkJBQWUsTUFBTSxXQUFXO0FBQ2hDLDZCQUFlLE1BQU0sVUFBVTtBQUMvQiw2QkFBZSxNQUFNLE9BQU87QUFBQSxZQUM5QjtBQUNBLDJCQUFlLE1BQU0sT0FBTztBQUM1QixxQkFBUyxLQUFLLFlBQVksY0FBYztBQUN4QyxxQkFBUyxlQUFlO0FBQ3hCLHFCQUFTLEtBQUssWUFBWSxjQUFjO0FBQUEsVUFDMUM7QUFDQSxzQkFBWSxRQUFRLElBQUk7QUFBQSxRQUMxQjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUEsSUFDRixFQUFHO0FBQUE7QUFBQTs7O0FDN1RILElBT087QUFQUDtBQUFBO0FBT0EsSUFBTyx1QkFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1iLFlBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPWixXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT1gsU0FBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9ULFdBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPWCxTQUFTO0FBQUEsSUFDWDtBQUFBO0FBQUE7OztBQzFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBNkNNLFNBbUhDO0FBaEtQO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0NBLElBQU0sVUFBTixjQUFzQixlQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJL0IsWUFBWSxTQUFTO0FBQ25CLGNBQU07QUFFTixjQUFNLFVBQVUsUUFBUTtBQUN4QixZQUFJLFdBQVcsQ0FBQyxRQUFRLFVBQVUsQ0FBQyxRQUFRLE1BQU0sZUFBZTtBQUM5RCxrQkFBUSxNQUFNLGdCQUFnQjtBQUFBLFFBQ2hDO0FBTUEsYUFBSyxVQUFVLFVBQVUsVUFBVTtBQU1uQyxhQUFLLFVBQVU7QUFNZixhQUFLLE9BQU87QUFNWixhQUFLLGVBQWUsQ0FBQztBQUVyQixZQUFJLFFBQVEsUUFBUTtBQUNsQixlQUFLLFNBQVMsUUFBUTtBQUFBLFFBQ3hCO0FBRUEsWUFBSSxRQUFRLFFBQVE7QUFDbEIsZUFBSyxVQUFVLFFBQVEsTUFBTTtBQUFBLFFBQy9CO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esa0JBQWtCO0FBQ2hCLG1CQUFXLEtBQUssT0FBTztBQUN2QixjQUFNLGdCQUFnQjtBQUFBLE1BQ3hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsU0FBUztBQUNQLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxPQUFPLEtBQUs7QUFDVixZQUFJLEtBQUssTUFBTTtBQUNiLHFCQUFXLEtBQUssT0FBTztBQUFBLFFBQ3pCO0FBQ0EsaUJBQVMsSUFBSSxHQUFHLEtBQUssS0FBSyxhQUFhLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUMxRCx3QkFBYyxLQUFLLGFBQWEsQ0FBQyxDQUFDO0FBQUEsUUFDcEM7QUFDQSxhQUFLLGFBQWEsU0FBUztBQUMzQixhQUFLLE9BQU87QUFDWixZQUFJLEtBQUs7QUFDUCxnQkFBTSxTQUFTLEtBQUssVUFDaEIsS0FBSyxVQUNMLElBQUksNkJBQTZCO0FBQ3JDLGlCQUFPLFlBQVksS0FBSyxPQUFPO0FBQy9CLGNBQUksS0FBSyxXQUFXLE1BQU07QUFDeEIsaUJBQUssYUFBYTtBQUFBLGNBQ2hCLE9BQU8sS0FBSyxxQkFBYSxZQUFZLEtBQUssUUFBUSxJQUFJO0FBQUEsWUFDeEQ7QUFBQSxVQUNGO0FBQ0EsY0FBSSxPQUFPO0FBQUEsUUFDYjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxPQUFPLFVBQVU7QUFBQSxNQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFXbEIsVUFBVSxRQUFRO0FBQ2hCLGFBQUssVUFDSCxPQUFPLFdBQVcsV0FBVyxTQUFTLGVBQWUsTUFBTSxJQUFJO0FBQUEsTUFDbkU7QUFBQSxJQUNGO0FBRUEsSUFBTyxrQkFBUTtBQUFBO0FBQUE7OztBQ2pJUixTQUFTLFFBQVEsTUFBTTtBQUM1QixTQUFPLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLElBQUk7QUFDbEM7QUFTTyxTQUFTQyxPQUFNLE1BQU0sT0FBTyxNQUFNO0FBQ3ZDLE1BQUksU0FBUyxRQUFXO0FBQ3RCLFdBQU8sQ0FBQyxHQUFHLENBQUM7QUFBQSxFQUNkO0FBQ0EsT0FBSyxDQUFDLElBQUssS0FBSyxDQUFDLElBQUksUUFBUSxNQUFPO0FBQ3BDLE9BQUssQ0FBQyxJQUFLLEtBQUssQ0FBQyxJQUFJLFFBQVEsTUFBTztBQUNwQyxTQUFPO0FBQ1Q7QUFXTyxTQUFTLE9BQU8sTUFBTSxNQUFNO0FBQ2pDLE1BQUksTUFBTSxRQUFRLElBQUksR0FBRztBQUN2QixXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksU0FBUyxRQUFXO0FBQ3RCLFdBQU8sQ0FBQyxNQUFNLElBQUk7QUFBQSxFQUNwQixPQUFPO0FBQ0wsU0FBSyxDQUFDLElBQUk7QUFDVixTQUFLLENBQUMsSUFBSTtBQUFBLEVBQ1o7QUFDQSxTQUFPO0FBQ1Q7QUF2RUE7QUFBQTtBQUFBO0FBQUE7OztBQ0FBLElBT087QUFQUDtBQUFBO0FBT0EsSUFBTyxxQkFBUTtBQUFBLE1BQ2IsTUFBTTtBQUFBLE1BQ04sU0FBUztBQUFBLE1BQ1QsUUFBUTtBQUFBLE1BQ1IsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLElBQ1Q7QUFBQTtBQUFBOzs7QUM0TU8sU0FBUyxZQUFZLE9BQU8sYUFBYSxjQUFjO0FBQzVELFFBQU07QUFBQTtBQUFBLElBQXVDO0FBQUE7QUFDN0MsTUFBSSxZQUFZO0FBQ2hCLE1BQUksV0FBVztBQUNmLE1BQUksU0FBUztBQUViLFFBQU0sZUFBZTtBQUFBLElBQ25CLFdBQVcsS0FBSyxrQkFBVSxNQUFNLFdBQVk7QUFDMUMsZUFBUztBQUNULFVBQUksQ0FBQyxVQUFVO0FBQ2Isb0JBQVk7QUFBQSxNQUNkO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUVBLE1BQUksSUFBSSxPQUFPLGNBQWM7QUFDM0IsZUFBVztBQUNYLFFBQ0csT0FBTyxFQUNQLEtBQUssV0FBWTtBQUNoQixVQUFJLFdBQVc7QUFDYixvQkFBWTtBQUFBLE1BQ2Q7QUFBQSxJQUNGLENBQUMsRUFDQSxNQUFNLFNBQVUsT0FBTztBQUN0QixVQUFJLFdBQVc7QUFDYixZQUFJLFFBQVE7QUFDVixzQkFBWTtBQUFBLFFBQ2QsT0FBTztBQUNMLHVCQUFhO0FBQUEsUUFDZjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNMLE9BQU87QUFDTCxpQkFBYSxLQUFLLFdBQVcsS0FBSyxrQkFBVSxPQUFPLFlBQVksQ0FBQztBQUFBLEVBQ2xFO0FBRUEsU0FBTyxTQUFTLFdBQVc7QUFDekIsZ0JBQVk7QUFDWixpQkFBYSxRQUFRLGFBQWE7QUFBQSxFQUNwQztBQUNGO0FBU08sU0FBUyxLQUFLLE9BQU8sS0FBSztBQUMvQixTQUFPLElBQUksUUFBUSxDQUFDLFNBQVMsV0FBVztBQUN0QyxhQUFTLGFBQWE7QUFDcEIsZUFBUztBQUNULGNBQVEsS0FBSztBQUFBLElBQ2Y7QUFDQSxhQUFTLGNBQWM7QUFDckIsZUFBUztBQUNULGFBQU8sSUFBSSxNQUFNLGtCQUFrQixDQUFDO0FBQUEsSUFDdEM7QUFDQSxhQUFTLFdBQVc7QUFDbEIsWUFBTSxvQkFBb0IsUUFBUSxVQUFVO0FBQzVDLFlBQU0sb0JBQW9CLFNBQVMsV0FBVztBQUFBLElBQ2hEO0FBQ0EsVUFBTSxpQkFBaUIsUUFBUSxVQUFVO0FBQ3pDLFVBQU0saUJBQWlCLFNBQVMsV0FBVztBQUMzQyxRQUFJLEtBQUs7QUFDUCxZQUFNLE1BQU07QUFBQSxJQUNkO0FBQUEsRUFDRixDQUFDO0FBQ0g7QUFPTyxTQUFTLGVBQWUsT0FBTyxLQUFLO0FBQ3pDLE1BQUksS0FBSztBQUNQLFVBQU0sTUFBTTtBQUFBLEVBQ2Q7QUFDQSxTQUFPLE1BQU0sT0FBTyxlQUNoQixJQUFJO0FBQUEsSUFBUSxDQUFDLFNBQVMsV0FDcEIsTUFDRyxPQUFPLEVBQ1AsS0FBSyxNQUFNLFFBQVEsS0FBSyxDQUFDLEVBQ3pCO0FBQUEsTUFBTSxDQUFDLE1BQ04sTUFBTSxZQUFZLE1BQU0sUUFBUSxRQUFRLEtBQUssSUFBSSxPQUFPLENBQUM7QUFBQSxJQUMzRDtBQUFBLEVBQ0osSUFDQSxLQUFLLEtBQUs7QUFDaEI7QUFwVEE7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUFBO0FBQUE7OztBQzBOQSxTQUFTLGtCQUFrQixpQkFBaUI7QUFDMUMsTUFBSSxDQUFDLGlCQUFpQjtBQUNwQixXQUFPO0FBQUEsRUFDVDtBQUNBLE1BQUksTUFBTSxRQUFRLGVBQWUsR0FBRztBQUNsQyxXQUFPLFNBQVUsWUFBWTtBQUMzQixhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE9BQU8sb0JBQW9CLFlBQVk7QUFDekMsV0FBTztBQUFBLEVBQ1Q7QUFFQSxTQUFPLFNBQVUsWUFBWTtBQUMzQixXQUFPLENBQUMsZUFBZTtBQUFBLEVBQ3pCO0FBQ0Y7QUFsUEEsSUFrRE0sUUFrTUM7QUFwUFA7QUFBQTtBQUdBO0FBQ0E7QUE4Q0EsSUFBTSxTQUFOLGNBQXFCLGVBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUk5QixZQUFZLFNBQVM7QUFDbkIsY0FBTTtBQU1OLGFBQUssYUFBYUMsS0FBYyxRQUFRLFVBQVU7QUFNbEQsYUFBSyxnQkFBZ0Isa0JBQWtCLFFBQVEsWUFBWTtBQU0zRCxhQUFLLDJCQUNILFFBQVEsNEJBQTRCLFNBQ2hDLFFBQVEsMEJBQ1I7QUFPTixhQUFLLFVBQVU7QUFNZixhQUFLLFNBQVMsUUFBUSxVQUFVLFNBQVksUUFBUSxRQUFRO0FBTTVELGFBQUssU0FBUyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVE7QUFNNUQsYUFBSyxlQUFlLENBQUMsQ0FBQyxRQUFRO0FBTTlCLGFBQUssZUFBZTtBQU1wQixhQUFLLGVBQWU7QUFFcEIsY0FBTUMsUUFBTztBQUtiLGFBQUssZUFBZSxJQUFJLFFBQVEsU0FBVSxTQUFTLFFBQVE7QUFDekQsVUFBQUEsTUFBSyxlQUFlO0FBQ3BCLFVBQUFBLE1BQUssZUFBZTtBQUFBLFFBQ3RCLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0Esa0JBQWtCO0FBQ2hCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsNkJBQTZCO0FBQzNCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGVBQWUsWUFBWTtBQUN6QixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsVUFBVTtBQUNSLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsV0FBVztBQUNULGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGlCQUFpQjtBQUNmLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsVUFBVTtBQUNSLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsZ0JBQWdCLGNBQWM7QUFDNUIsYUFBSyxnQkFBZ0Isa0JBQWtCLFlBQVk7QUFDbkQsYUFBSyxRQUFRO0FBQUEsTUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxTQUFTLE9BQU87QUFDZCxhQUFLLFNBQVM7QUFDZCxhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDRjtBQTBCQSxJQUFPLGlCQUFRO0FBQUE7QUFBQTs7O0FDcFBmLElBV00sZUE2TENDO0FBeE1QLElBQUFDLGNBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0EsSUFBTSxnQkFBTixjQUE0QixtQkFBVztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSXJDLFlBQVksT0FBTztBQUNqQixjQUFNO0FBTU4sYUFBSyxRQUFRO0FBR2IsYUFBSywwQkFBMEIsS0FBSyxtQkFBbUIsS0FBSyxJQUFJO0FBTWhFLGFBQUssU0FBUztBQUtkLGFBQUsseUJBQXlCO0FBQUEsTUFDaEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFlBQVksT0FBTztBQUNqQixlQUFPLFNBQVM7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxRQUFRLE9BQU87QUFDYixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsYUFBYSxZQUFZO0FBQ3ZCLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFlBQVksWUFBWSxRQUFRO0FBQzlCLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxtQkFBbUIsT0FBTyxNQUFNLE1BQU07QUFDcEMsWUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHO0FBQ2hCLGdCQUFNLElBQUksSUFBSSxDQUFDO0FBQUEsUUFDakI7QUFDQSxjQUFNLElBQUksRUFBRSxLQUFLLFVBQVUsU0FBUyxDQUFDLElBQUk7QUFDekMsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVdBLHVCQUF1QixRQUFRLFlBQVksT0FBTztBQUNoRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQU1FLENBQUMsTUFBTSxjQUFjO0FBQ25CLGtCQUFNLFdBQVcsS0FBSyxtQkFBbUIsS0FBSyxNQUFNLE9BQU8sSUFBSTtBQUMvRCxtQkFBTyxPQUFPLGtCQUFrQixZQUFZLE1BQU0sV0FBVyxRQUFRO0FBQUEsVUFDdkU7QUFBQTtBQUFBLE1BRUo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BV0EsMkJBQ0UsWUFDQSxZQUNBLGNBQ0EsVUFDQSxTQUNBO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLHFCQUFxQjtBQUFBLE1BQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPdEIsbUJBQW1CLE9BQU87QUFDeEIsY0FBTTtBQUFBO0FBQUEsVUFBc0QsTUFBTTtBQUFBO0FBQ2xFLFlBQ0UsTUFBTSxTQUFTLE1BQU0sbUJBQVcsVUFDaEMsTUFBTSxTQUFTLE1BQU0sbUJBQVcsT0FDaEM7QUFDQSxlQUFLLHdCQUF3QjtBQUFBLFFBQy9CO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxVQUFVLE9BQU87QUFDZixZQUFJLGFBQWEsTUFBTSxTQUFTO0FBQ2hDLFlBQUksY0FBYyxtQkFBVyxVQUFVLGNBQWMsbUJBQVcsT0FBTztBQUNyRSxnQkFBTSxpQkFBaUIsa0JBQVUsUUFBUSxLQUFLLHVCQUF1QjtBQUFBLFFBQ3ZFO0FBQ0EsWUFBSSxjQUFjLG1CQUFXLE1BQU07QUFDakMsZ0JBQU0sS0FBSztBQUNYLHVCQUFhLE1BQU0sU0FBUztBQUFBLFFBQzlCO0FBQ0EsZUFBTyxjQUFjLG1CQUFXO0FBQUEsTUFDbEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLDBCQUEwQjtBQUN4QixjQUFNLFFBQVEsS0FBSyxTQUFTO0FBQzVCLFlBQUksU0FBUyxNQUFNLFdBQVcsS0FBSyxNQUFNLGVBQWUsTUFBTSxTQUFTO0FBQ3JFLGdCQUFNLFFBQVE7QUFBQSxRQUNoQjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGtCQUFrQjtBQUNoQixlQUFPLEtBQUs7QUFDWixjQUFNLGdCQUFnQjtBQUFBLE1BQ3hCO0FBQUEsSUFDRjtBQUVBLElBQU9ELGlCQUFRO0FBQUE7QUFBQTs7O0FDektmLFNBQVMscUJBQXFCO0FBQzVCLGlCQUFlLHNCQUFzQixHQUFHLEdBQUcsUUFBVztBQUFBLElBQ3BELG9CQUFvQjtBQUFBLEVBQ3RCLENBQUM7QUFDSDtBQW5DQSxJQXdCYUUsYUFLVCxjQWFFLHFCQTRSQ0M7QUF0VVAsSUFBQUMsY0FBQTtBQUFBO0FBR0EsSUFBQUE7QUFDQSxJQUFBQztBQUNBLElBQUFDO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQVVPLElBQU1KLGNBQWEsQ0FBQztBQUszQixJQUFJLGVBQWU7QUFhbkIsSUFBTSxzQkFBTixjQUFrQ0MsZUFBYztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSTlDLFlBQVksT0FBTztBQUNqQixjQUFNLEtBQUs7QUFNWCxhQUFLLFlBQVk7QUFNakIsYUFBSztBQVFMLGFBQUssZ0JBQWdCLE9BQWdCO0FBUXJDLGFBQUssaUJBQWlCLE9BQWdCO0FBUXRDLGFBQUssd0JBQXdCLE9BQWdCO0FBSzdDLGFBQUssVUFBVTtBQUtmLGFBQUssa0JBQWtCO0FBTXZCLGFBQUssZ0JBQWdCO0FBTXJCLGFBQUssYUFBYTtBQUFBLE1BQ3BCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxhQUFhLE9BQU8sS0FBSyxLQUFLO0FBQzVCLFlBQUksQ0FBQyxjQUFjO0FBQ2pCLDZCQUFtQjtBQUFBLFFBQ3JCO0FBQ0EscUJBQWEsVUFBVSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBRWpDLFlBQUk7QUFDSixZQUFJO0FBQ0YsdUJBQWEsVUFBVSxPQUFPLEtBQUssS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUN4RCxpQkFBTyxhQUFhLGFBQWEsR0FBRyxHQUFHLEdBQUcsQ0FBQyxFQUFFO0FBQUEsUUFDL0MsU0FBUyxLQUFLO0FBQ1oseUJBQWU7QUFDZixpQkFBTztBQUFBLFFBQ1Q7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxjQUFjLFlBQVk7QUFDeEIsY0FBTSxRQUFRLEtBQUssU0FBUztBQUM1QixZQUFJLGFBQWEsTUFBTSxjQUFjO0FBQ3JDLFlBQUksT0FBTyxlQUFlLFlBQVk7QUFDcEMsdUJBQWEsV0FBVyxXQUFXLFVBQVUsVUFBVTtBQUFBLFFBQ3pEO0FBQ0EsZUFBTyxjQUFjO0FBQUEsTUFDdkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGFBQWEsUUFBUUksWUFBVyxpQkFBaUI7QUFDL0MsY0FBTSxpQkFBaUIsS0FBSyxTQUFTLEVBQUUsYUFBYTtBQUNwRCxZQUFJLFdBQVc7QUFDZixZQUNFLFVBQ0EsT0FBTyxjQUFjLG1CQUNwQixDQUFDLG1CQUNDLFVBQ0MsT0FBTyxNQUFNLG1CQUNiO0FBQUEsVUFDRSxRQUFRLE9BQU8sTUFBTSxlQUFlO0FBQUEsVUFDcEMsUUFBUSxlQUFlO0FBQUEsUUFDekIsSUFDSjtBQUNBLGdCQUFNLFNBQVMsT0FBTztBQUN0QixjQUFJLGtCQUFrQixtQkFBbUI7QUFDdkMsc0JBQVUsT0FBTyxXQUFXLElBQUk7QUFBQSxVQUNsQztBQUFBLFFBQ0Y7QUFDQSxZQUFJLFdBQVcsUUFBUSxPQUFPLE1BQU0sY0FBY0EsWUFBVztBQUUzRCxlQUFLLFlBQVk7QUFDakIsZUFBSyxVQUFVO0FBQ2YsZUFBSyxrQkFBa0I7QUFBQSxRQUN6QixXQUFXLEtBQUssaUJBQWlCO0FBRS9CLGVBQUssWUFBWTtBQUNqQixlQUFLLFVBQVU7QUFDZixlQUFLLGtCQUFrQjtBQUFBLFFBQ3pCLFdBQVcsS0FBSyxXQUFXO0FBQ3pCLGVBQUssVUFBVSxNQUFNLGtCQUFrQjtBQUFBLFFBQ3pDO0FBQ0EsWUFBSSxDQUFDLEtBQUssV0FBVztBQUNuQixzQkFBWSxTQUFTLGNBQWMsS0FBSztBQUN4QyxvQkFBVSxZQUFZO0FBQ3RCLGNBQUksUUFBUSxVQUFVO0FBQ3RCLGdCQUFNLFdBQVc7QUFDakIsZ0JBQU0sUUFBUTtBQUNkLGdCQUFNLFNBQVM7QUFDZixvQkFBVSxzQkFBc0I7QUFDaEMsZ0JBQU0sU0FBUyxRQUFRO0FBQ3ZCLG9CQUFVLFlBQVksTUFBTTtBQUM1QixrQkFBUSxPQUFPO0FBQ2YsZ0JBQU0sV0FBVztBQUNqQixnQkFBTSxPQUFPO0FBQ2IsZ0JBQU0sa0JBQWtCO0FBQ3hCLGVBQUssWUFBWTtBQUNqQixlQUFLLFVBQVU7QUFBQSxRQUNqQjtBQUNBLFlBQ0UsQ0FBQyxLQUFLLG1CQUNOLG1CQUNBLENBQUMsS0FBSyxVQUFVLE1BQU0saUJBQ3RCO0FBQ0EsZUFBSyxVQUFVLE1BQU0sa0JBQWtCO0FBQUEsUUFDekM7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxjQUFjLFNBQVMsWUFBWSxRQUFRO0FBQ3pDLGNBQU0sVUFBVSxXQUFXLE1BQU07QUFDakMsY0FBTSxXQUFXLFlBQVksTUFBTTtBQUNuQyxjQUFNLGNBQWMsZUFBZSxNQUFNO0FBQ3pDLGNBQU0sYUFBYSxjQUFjLE1BQU07QUFFdkMsY0FBZSxXQUFXLDRCQUE0QixPQUFPO0FBQzdELGNBQWUsV0FBVyw0QkFBNEIsUUFBUTtBQUM5RCxjQUFlLFdBQVcsNEJBQTRCLFdBQVc7QUFDakUsY0FBZSxXQUFXLDRCQUE0QixVQUFVO0FBRWhFLGNBQU0sV0FBVyxLQUFLO0FBQ3RCLGNBQWUsVUFBVSxPQUFPO0FBQ2hDLGNBQWUsVUFBVSxRQUFRO0FBQ2pDLGNBQWUsVUFBVSxXQUFXO0FBQ3BDLGNBQWUsVUFBVSxVQUFVO0FBRW5DLGdCQUFRLEtBQUs7QUFDYixnQkFBUSxVQUFVO0FBQ2xCLGdCQUFRLE9BQU8sS0FBSyxNQUFNLFFBQVEsQ0FBQyxDQUFDLEdBQUcsS0FBSyxNQUFNLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDN0QsZ0JBQVEsT0FBTyxLQUFLLE1BQU0sU0FBUyxDQUFDLENBQUMsR0FBRyxLQUFLLE1BQU0sU0FBUyxDQUFDLENBQUMsQ0FBQztBQUMvRCxnQkFBUSxPQUFPLEtBQUssTUFBTSxZQUFZLENBQUMsQ0FBQyxHQUFHLEtBQUssTUFBTSxZQUFZLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLGdCQUFRLE9BQU8sS0FBSyxNQUFNLFdBQVcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxNQUFNLFdBQVcsQ0FBQyxDQUFDLENBQUM7QUFDbkUsZ0JBQVEsS0FBSztBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLHFCQUFxQixNQUFNLFNBQVMsWUFBWTtBQUM5QyxjQUFNLFFBQVEsS0FBSyxTQUFTO0FBQzVCLFlBQUksTUFBTSxZQUFZLElBQUksR0FBRztBQUMzQixnQkFBTSxRQUFRLElBQUlDO0FBQUEsWUFDaEI7QUFBQSxZQUNBLEtBQUs7QUFBQSxZQUNMO0FBQUEsWUFDQTtBQUFBLFVBQ0Y7QUFDQSxnQkFBTSxjQUFjLEtBQUs7QUFBQSxRQUMzQjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVLFNBQVMsWUFBWTtBQUM3QixhQUFLLGFBQWE7QUFDbEIsYUFBSyxxQkFBcUJDLG1CQUFnQixXQUFXLFNBQVMsVUFBVTtBQUFBLE1BQzFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsV0FBVyxTQUFTLFlBQVk7QUFDOUIsYUFBSyxxQkFBcUJBLG1CQUFnQixZQUFZLFNBQVMsVUFBVTtBQUFBLE1BQzNFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFjQSxtQkFDRSxRQUNBLFlBQ0EsVUFDQSxZQUNBLE9BQ0EsUUFDQSxTQUNBO0FBQ0EsY0FBTSxNQUFNLFFBQVE7QUFDcEIsY0FBTSxNQUFNLFNBQVM7QUFDckIsY0FBTSxLQUFLLGFBQWE7QUFDeEIsY0FBTSxLQUFLLENBQUM7QUFDWixjQUFNLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSTtBQUN6QixjQUFNLE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDckIsZUFBTztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLENBQUM7QUFBQSxVQUNEO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxrQkFBa0I7QUFDaEIsZUFBTyxLQUFLO0FBQ1osY0FBTSxnQkFBZ0I7QUFBQSxNQUN4QjtBQUFBLElBQ0Y7QUFFQSxJQUFPTixpQkFBUTtBQUFBO0FBQUE7OztBQ3RVZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMFRPLFNBQVMsb0JBQW9CLEtBQUs7QUFDdkMsTUFBSSxPQUFPLFFBQVEsWUFBWTtBQUM3QixXQUFPO0FBQUEsRUFDVDtBQUlBLE1BQUk7QUFDSixNQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDdEIsYUFBUztBQUFBLEVBQ1gsT0FBTztBQUNMO0FBQUEsTUFDRTtBQUFBLE1BQTBCLElBQUssY0FBZTtBQUFBLE1BQzlDO0FBQUEsSUFDRjtBQUNBLFVBQU07QUFBQTtBQUFBLE1BQTJEO0FBQUE7QUFDakUsYUFBUyxDQUFDLEtBQUs7QUFBQSxFQUNqQjtBQUNBLFNBQU8sV0FBWTtBQUNqQixXQUFPO0FBQUEsRUFDVDtBQUNGO0FBL1VBLElBMEVNLFNBc1FDO0FBaFZQO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQW9FQSxJQUFNLFVBQU4sTUFBTSxpQkFBZ0IsZUFBVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTy9CLFlBQVksc0JBQXNCO0FBQ2hDLGNBQU07QUFLTixhQUFLO0FBS0wsYUFBSztBQUtMLGFBQUs7QUFNTCxhQUFLLE1BQU07QUFNWCxhQUFLLGdCQUFnQjtBQU9yQixhQUFLLFNBQVM7QUFNZCxhQUFLLGlCQUFpQjtBQU10QixhQUFLLHFCQUFxQjtBQUUxQixhQUFLLGtCQUFrQixLQUFLLGVBQWUsS0FBSyxzQkFBc0I7QUFFdEUsWUFBSSxzQkFBc0I7QUFDeEIsY0FDRTtBQUFBLFVBQ29CLHFCQUFzQiwwQkFDcEMsWUFDTjtBQUNBLGtCQUFNO0FBQUE7QUFBQSxjQUFvQztBQUFBO0FBQzFDLGlCQUFLLFlBQVksUUFBUTtBQUFBLFVBQzNCLE9BQU87QUFFTCxrQkFBTSxhQUFhO0FBQ25CLGlCQUFLLGNBQWMsVUFBVTtBQUFBLFVBQy9CO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFFBQVE7QUFDTixjQUFNTztBQUFBO0FBQUEsVUFDSixJQUFJLFNBQVEsS0FBSyxjQUFjLElBQUksS0FBSyxjQUFjLElBQUksSUFBSTtBQUFBO0FBRWhFLFFBQUFBLE9BQU0sZ0JBQWdCLEtBQUssZ0JBQWdCLENBQUM7QUFDNUMsY0FBTSxXQUFXLEtBQUssWUFBWTtBQUNsQyxZQUFJLFVBQVU7QUFDWixVQUFBQSxPQUFNO0FBQUE7QUFBQSxZQUFxQyxTQUFTLE1BQU07QUFBQSxVQUFFO0FBQUEsUUFDOUQ7QUFDQSxjQUFNLFFBQVEsS0FBSyxTQUFTO0FBQzVCLFlBQUksT0FBTztBQUNULFVBQUFBLE9BQU0sU0FBUyxLQUFLO0FBQUEsUUFDdEI7QUFDQSxlQUFPQTtBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxjQUFjO0FBQ1o7QUFBQTtBQUFBLFVBQTBDLEtBQUssSUFBSSxLQUFLLGFBQWE7QUFBQTtBQUFBLE1BQ3ZFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFFBQVE7QUFDTixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGtCQUFrQjtBQUNoQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsbUJBQW1CO0FBQ2pCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLHdCQUF3QjtBQUN0QixhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSx5QkFBeUI7QUFDdkIsWUFBSSxLQUFLLG9CQUFvQjtBQUMzQix3QkFBYyxLQUFLLGtCQUFrQjtBQUNyQyxlQUFLLHFCQUFxQjtBQUFBLFFBQzVCO0FBQ0EsY0FBTSxXQUFXLEtBQUssWUFBWTtBQUNsQyxZQUFJLFVBQVU7QUFDWixlQUFLLHFCQUFxQjtBQUFBLFlBQ3hCO0FBQUEsWUFDQSxrQkFBVTtBQUFBLFlBQ1YsS0FBSztBQUFBLFlBQ0w7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUNBLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsWUFBWSxVQUFVO0FBQ3BCLGFBQUssSUFBSSxLQUFLLGVBQWUsUUFBUTtBQUFBLE1BQ3ZDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFXQSxTQUFTLE9BQU87QUFDZCxhQUFLLFNBQVM7QUFDZCxhQUFLLGlCQUFpQixDQUFDLFFBQVEsU0FBWSxvQkFBb0IsS0FBSztBQUNwRSxhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFXQSxNQUFNLElBQUk7QUFDUixhQUFLLE1BQU07QUFDWCxhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGdCQUFnQixNQUFNO0FBQ3BCLGFBQUsscUJBQXFCLEtBQUssZUFBZSxLQUFLLHNCQUFzQjtBQUN6RSxhQUFLLGdCQUFnQjtBQUNyQixhQUFLLGtCQUFrQixLQUFLLGVBQWUsS0FBSyxzQkFBc0I7QUFDdEUsYUFBSyx1QkFBdUI7QUFBQSxNQUM5QjtBQUFBLElBQ0Y7QUFnQ0EsSUFBTyxrQkFBUTtBQUFBO0FBQUE7OztBQ2hWZixJQWdCTSxNQThDQztBQTlEUDtBQUFBO0FBZ0JBLElBQU0sT0FBTixNQUFNLE1BQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUlULFlBQVksU0FBUztBQUNuQixrQkFBVSxXQUFXLENBQUM7QUFNdEIsYUFBSyxTQUFTLFFBQVEsVUFBVSxTQUFZLFFBQVEsUUFBUTtBQUFBLE1BQzlEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsUUFBUTtBQUNOLGNBQU0sUUFBUSxLQUFLLFNBQVM7QUFDNUIsZUFBTyxJQUFJLE1BQUs7QUFBQSxVQUNkLE9BQU8sTUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLE1BQU0sSUFBSSxTQUFTO0FBQUEsUUFDekQsQ0FBQztBQUFBLE1BQ0g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsU0FBUyxPQUFPO0FBQ2QsYUFBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQSxJQUNGO0FBRUEsSUFBTyxlQUFRO0FBQUE7QUFBQTs7O0FDOUNSLFNBQVMsaUJBQ2QsaUJBQ0EsUUFDQSxLQUNBLFFBQ0EsVUFDQSxNQUNBLFdBQ0E7QUFDQSxNQUFJLEdBQUc7QUFDUCxRQUFNLEtBQUssTUFBTSxVQUFVO0FBQzNCLE1BQUksTUFBTSxHQUFHO0FBQ1gsUUFBSTtBQUFBLEVBQ04sV0FBVyxNQUFNLEdBQUc7QUFDbEIsUUFBSTtBQUNKLFFBQUk7QUFBQSxFQUNOLFdBQVcsTUFBTSxHQUFHO0FBQ2xCLFFBQUksS0FBSyxnQkFBZ0IsTUFBTTtBQUMvQixRQUFJLEtBQUssZ0JBQWdCLFNBQVMsQ0FBQztBQUNuQyxRQUFJLFNBQVM7QUFDYixVQUFNLG9CQUFvQixDQUFDLENBQUM7QUFDNUIsYUFBUyxJQUFJLFNBQVMsUUFBUSxJQUFJLEtBQUssS0FBSyxRQUFRO0FBQ2xELFlBQU0sS0FBSyxnQkFBZ0IsQ0FBQztBQUM1QixZQUFNLEtBQUssZ0JBQWdCLElBQUksQ0FBQztBQUNoQyxnQkFBVSxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssT0FBTyxLQUFLLE9BQU8sS0FBSyxHQUFHO0FBQ2pFLHdCQUFrQixLQUFLLE1BQU07QUFDN0IsV0FBSztBQUNMLFdBQUs7QUFBQSxJQUNQO0FBQ0EsVUFBTSxTQUFTLFdBQVc7QUFDMUIsVUFBTSxRQUFRLGFBQWEsbUJBQW1CLE1BQU07QUFDcEQsUUFBSSxRQUFRLEdBQUc7QUFDYixXQUNHLFNBQVMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLE1BQ3JDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxJQUFJLGtCQUFrQixDQUFDLFFBQVEsQ0FBQztBQUMvRCxVQUFJLFVBQVUsQ0FBQyxRQUFRLEtBQUs7QUFBQSxJQUM5QixPQUFPO0FBQ0wsVUFBSSxTQUFTLFFBQVE7QUFBQSxJQUN2QjtBQUFBLEVBQ0Y7QUFDQSxjQUFZLFlBQVksSUFBSSxZQUFZO0FBQ3hDLFNBQU8sT0FBTyxPQUFPLElBQUksTUFBTSxTQUFTO0FBQ3hDLFdBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxFQUFFLEdBQUc7QUFDbEMsU0FBSyxDQUFDLElBQ0osTUFBTSxTQUNGLE1BQ0EsTUFBTSxTQUNOLGdCQUFnQixJQUFJLENBQUMsSUFDckIsS0FBSyxnQkFBZ0IsSUFBSSxDQUFDLEdBQUcsZ0JBQWdCLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQztBQUFBLEVBQ3ZFO0FBQ0EsU0FBTztBQUNUO0FBbkVBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTs7O0FDT08sU0FBUyxpQkFBaUIsaUJBQWlCLFFBQVEsS0FBSyxRQUFRO0FBQ3JFLE1BQUksS0FBSyxnQkFBZ0IsTUFBTTtBQUMvQixNQUFJLEtBQUssZ0JBQWdCLFNBQVMsQ0FBQztBQUNuQyxNQUFJLFNBQVM7QUFDYixXQUFTLElBQUksU0FBUyxRQUFRLElBQUksS0FBSyxLQUFLLFFBQVE7QUFDbEQsVUFBTSxLQUFLLGdCQUFnQixDQUFDO0FBQzVCLFVBQU0sS0FBSyxnQkFBZ0IsSUFBSSxDQUFDO0FBQ2hDLGNBQVUsS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLE9BQU8sS0FBSyxPQUFPLEtBQUssR0FBRztBQUNqRSxTQUFLO0FBQ0wsU0FBSztBQUFBLEVBQ1A7QUFDQSxTQUFPO0FBQ1Q7QUF2QkE7QUFBQTtBQUFBO0FBQUE7OztBQ0FBLElBeUJNLFFBME1DO0FBbk9QO0FBQUE7QUF5QkEsSUFBTSxTQUFOLE1BQU0sUUFBTztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSVgsWUFBWSxTQUFTO0FBQ25CLGtCQUFVLFdBQVcsQ0FBQztBQU10QixhQUFLLFNBQVMsUUFBUSxVQUFVLFNBQVksUUFBUSxRQUFRO0FBTTVELGFBQUssV0FBVyxRQUFRO0FBTXhCLGFBQUssWUFBWSxRQUFRLGFBQWEsU0FBWSxRQUFRLFdBQVc7QUFNckUsYUFBSyxrQkFBa0IsUUFBUTtBQU0vQixhQUFLLFlBQVksUUFBUTtBQU16QixhQUFLLGNBQWMsUUFBUTtBQU0zQixhQUFLLFNBQVMsUUFBUTtBQUFBLE1BQ3hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsUUFBUTtBQUNOLGNBQU0sUUFBUSxLQUFLLFNBQVM7QUFDNUIsZUFBTyxJQUFJLFFBQU87QUFBQSxVQUNoQixPQUFPLE1BQU0sUUFBUSxLQUFLLElBQUksTUFBTSxNQUFNLElBQUksU0FBUztBQUFBLFVBQ3ZELFNBQVMsS0FBSyxXQUFXO0FBQUEsVUFDekIsVUFBVSxLQUFLLFlBQVksSUFBSSxLQUFLLFlBQVksRUFBRSxNQUFNLElBQUk7QUFBQSxVQUM1RCxnQkFBZ0IsS0FBSyxrQkFBa0I7QUFBQSxVQUN2QyxVQUFVLEtBQUssWUFBWTtBQUFBLFVBQzNCLFlBQVksS0FBSyxjQUFjO0FBQUEsVUFDL0IsT0FBTyxLQUFLLFNBQVM7QUFBQSxRQUN2QixDQUFDO0FBQUEsTUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsYUFBYTtBQUNYLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxjQUFjO0FBQ1osZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsY0FBYztBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsV0FBVztBQUNULGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFNBQVMsT0FBTztBQUNkLGFBQUssU0FBUztBQUFBLE1BQ2hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXLFNBQVM7QUFDbEIsYUFBSyxXQUFXO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFlBQVksVUFBVTtBQUNwQixhQUFLLFlBQVk7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsa0JBQWtCLGdCQUFnQjtBQUNoQyxhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZLFVBQVU7QUFDcEIsYUFBSyxZQUFZO0FBQUEsTUFDbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGNBQWMsWUFBWTtBQUN4QixhQUFLLGNBQWM7QUFBQSxNQUNyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsU0FBUyxPQUFPO0FBQ2QsYUFBSyxTQUFTO0FBQUEsTUFDaEI7QUFBQSxJQUNGO0FBRUEsSUFBTyxpQkFBUTtBQUFBO0FBQUE7OztBQ25PZixJQXVCTSxZQWtSQztBQXpTUCxJQUFBQyxjQUFBO0FBQUE7QUFHQTtBQUNBO0FBbUJBLElBQU0sYUFBTixNQUFNLFlBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUlmLFlBQVksU0FBUztBQUtuQixhQUFLLFdBQVcsUUFBUTtBQU14QixhQUFLLGtCQUFrQixRQUFRO0FBTS9CLGFBQUssWUFBWSxRQUFRO0FBTXpCLGFBQUssU0FBUyxRQUFRO0FBTXRCLGFBQUssY0FBYyxPQUFPLFFBQVEsS0FBSztBQU12QyxhQUFLLGdCQUFnQixRQUFRO0FBTTdCLGFBQUssaUJBQWlCLFFBQVE7QUFBQSxNQUNoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixjQUFNQyxTQUFRLEtBQUssU0FBUztBQUM1QixlQUFPLElBQUksWUFBVztBQUFBLFVBQ3BCLFNBQVMsS0FBSyxXQUFXO0FBQUEsVUFDekIsT0FBTyxNQUFNLFFBQVFBLE1BQUssSUFBSUEsT0FBTSxNQUFNLElBQUlBO0FBQUEsVUFDOUMsVUFBVSxLQUFLLFlBQVk7QUFBQSxVQUMzQixnQkFBZ0IsS0FBSyxrQkFBa0I7QUFBQSxVQUN2QyxjQUFjLEtBQUssZ0JBQWdCLEVBQUUsTUFBTTtBQUFBLFVBQzNDLGVBQWUsS0FBSyxpQkFBaUI7QUFBQSxRQUN2QyxDQUFDO0FBQUEsTUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGFBQWE7QUFDWCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0Esb0JBQW9CO0FBQ2xCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxjQUFjO0FBQ1osZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGdCQUFnQjtBQUNkLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxrQkFBa0I7QUFDaEIsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG1CQUFtQjtBQUNqQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZO0FBQ1YsZUFBTyxTQUFTO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFNBQVMsWUFBWTtBQUNuQixlQUFPLFNBQVM7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSx1QkFBdUI7QUFDckIsZUFBTyxTQUFTO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxjQUFjLFlBQVk7QUFDeEIsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsZ0JBQWdCO0FBQ2QsZUFBTyxTQUFTO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsZUFBZTtBQUNiLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU8sU0FBUztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxnQkFBZ0IsY0FBYztBQUM1QixhQUFLLGdCQUFnQjtBQUFBLE1BQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXLFNBQVM7QUFDbEIsYUFBSyxXQUFXO0FBQUEsTUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGtCQUFrQixnQkFBZ0I7QUFDaEMsYUFBSyxrQkFBa0I7QUFBQSxNQUN6QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWSxVQUFVO0FBQ3BCLGFBQUssWUFBWTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxTQUFTQSxRQUFPO0FBQ2QsYUFBSyxTQUFTQTtBQUNkLGFBQUssY0FBYyxPQUFPQSxNQUFLO0FBQUEsTUFDakM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsa0JBQWtCLFVBQVU7QUFDMUIsaUJBQVM7QUFBQSxNQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLE9BQU87QUFDTCxpQkFBUztBQUFBLE1BQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsb0JBQW9CLFVBQVU7QUFDNUIsaUJBQVM7QUFBQSxNQUNYO0FBQUEsSUFDRjtBQUVBLElBQU8sZ0JBQVE7QUFBQTtBQUFBOzs7QUNuUlIsU0FBUyxZQUFZLE9BQU87QUFDakMsTUFBSSxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ3hCLFdBQU9DLFVBQVMsS0FBSztBQUFBLEVBQ3ZCO0FBQ0EsU0FBTztBQUNUO0FBM0JBO0FBQUE7QUFHQTtBQUFBO0FBQUE7OztBQ0hBLElBeURNLGNBMGlCQztBQW5tQlA7QUFBQTtBQUlBO0FBQ0EsSUFBQUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdEQSxJQUFNLGVBQU4sTUFBTSxzQkFBcUIsY0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSXBDLFlBQVksU0FBUztBQUluQixjQUFNLGlCQUNKLFFBQVEsbUJBQW1CLFNBQVksUUFBUSxpQkFBaUI7QUFFbEUsY0FBTTtBQUFBLFVBQ0osU0FBUztBQUFBLFVBQ1Q7QUFBQSxVQUNBLFVBQVUsUUFBUSxhQUFhLFNBQVksUUFBUSxXQUFXO0FBQUEsVUFDOUQsT0FBTyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVE7QUFBQSxVQUNyRCxjQUNFLFFBQVEsaUJBQWlCLFNBQVksUUFBUSxlQUFlLENBQUMsR0FBRyxDQUFDO0FBQUEsVUFDbkUsZUFBZSxRQUFRO0FBQUEsUUFDekIsQ0FBQztBQU1ELGFBQUs7QUFNTCxhQUFLLHNCQUFzQjtBQU0zQixhQUFLLFFBQVEsUUFBUSxTQUFTLFNBQVksUUFBUSxPQUFPO0FBTXpELGFBQUssVUFBVSxDQUFDLEdBQUcsQ0FBQztBQU1wQixhQUFLLFVBQVUsUUFBUTtBQU12QixhQUFLLFVBQ0gsUUFBUSxXQUFXLFNBQVksUUFBUSxTQUFTLFFBQVE7QUFNMUQsYUFBSyxXQUFXLFFBQVE7QUFNeEIsYUFBSyxTQUFTLFFBQVEsVUFBVSxTQUFZLFFBQVEsUUFBUTtBQU01RCxhQUFLLFVBQVUsUUFBUSxXQUFXLFNBQVksUUFBUSxTQUFTO0FBTS9ELGFBQUs7QUFNTCxhQUFLO0FBRUwsYUFBSyxPQUFPO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixjQUFNQyxTQUFRLEtBQUssU0FBUztBQUM1QixjQUFNLFFBQVEsSUFBSSxjQUFhO0FBQUEsVUFDN0IsTUFBTSxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLElBQUk7QUFBQSxVQUNoRCxRQUFRLEtBQUssVUFBVTtBQUFBLFVBQ3ZCLFFBQVEsS0FBSyxVQUFVO0FBQUEsVUFDdkIsU0FBUyxLQUFLLFdBQVc7QUFBQSxVQUN6QixPQUFPLEtBQUssU0FBUztBQUFBLFVBQ3JCLFFBQVEsS0FBSyxVQUFVLElBQUksS0FBSyxVQUFVLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDdEQsVUFBVSxLQUFLLFlBQVk7QUFBQSxVQUMzQixnQkFBZ0IsS0FBSyxrQkFBa0I7QUFBQSxVQUN2QyxPQUFPLE1BQU0sUUFBUUEsTUFBSyxJQUFJQSxPQUFNLE1BQU0sSUFBSUE7QUFBQSxVQUM5QyxjQUFjLEtBQUssZ0JBQWdCLEVBQUUsTUFBTTtBQUFBLFVBQzNDLGVBQWUsS0FBSyxpQkFBaUI7QUFBQSxRQUN2QyxDQUFDO0FBQ0QsY0FBTSxXQUFXLEtBQUssV0FBVyxDQUFDO0FBQ2xDLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZO0FBQ1YsY0FBTSxPQUFPLEtBQUs7QUFDbEIsY0FBTSxlQUFlLEtBQUssZ0JBQWdCO0FBQzFDLGNBQU1BLFNBQVEsS0FBSyxjQUFjO0FBR2pDLGVBQU87QUFBQSxVQUNMLEtBQUssQ0FBQyxJQUFJLElBQUksYUFBYSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFVBQ3ZDLEtBQUssQ0FBQyxJQUFJLElBQUksYUFBYSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFFBQ3pDO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxRQUFRLE1BQU07QUFDWixhQUFLLFFBQVE7QUFDYixhQUFLLE9BQU87QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSx1QkFBdUI7QUFDckIsWUFBSSxDQUFDLEtBQUsscUJBQXFCO0FBQzdCLGVBQUssc0JBQXNCLEtBQUs7QUFBQSxZQUM5QixLQUFLO0FBQUEsVUFDUDtBQUFBLFFBQ0Y7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxTQUFTLFlBQVk7QUFDbkIsWUFBSSxRQUFRLEtBQUssVUFBVSxVQUFVO0FBQ3JDLFlBQUksQ0FBQyxPQUFPO0FBQ1YsZ0JBQU0sZ0JBQWdCLEtBQUs7QUFDM0IsZ0JBQU0sVUFBVTtBQUFBLFlBQ2QsY0FBYyxPQUFPO0FBQUEsWUFDckIsY0FBYyxPQUFPO0FBQUEsVUFDdkI7QUFDQSxlQUFLLE1BQU0sZUFBZSxTQUFTLFVBQVU7QUFFN0Msa0JBQVEsUUFBUTtBQUNoQixlQUFLLFVBQVUsVUFBVSxJQUFJO0FBQUEsUUFDL0I7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGNBQWMsWUFBWTtBQUN4QixlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsZUFBZTtBQUNiLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGdCQUFnQjtBQUNkLGVBQU8sbUJBQVc7QUFBQSxNQUNwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVk7QUFDVixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGFBQWE7QUFDWCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsVUFBVTtBQUNSLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFVBQVUsUUFBUTtBQUNoQixhQUFLLFVBQVU7QUFDZixhQUFLLE9BQU87QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxrQkFBa0IsVUFBVTtBQUFBLE1BQUM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUs3QixPQUFPO0FBQUEsTUFBQztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS1Isb0JBQW9CLFVBQVU7QUFBQSxNQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BVS9CLHVCQUF1QixVQUFVLGFBQWEsWUFBWTtBQUN4RCxZQUNFLGdCQUFnQixLQUNoQixLQUFLLFlBQVksWUFDaEIsYUFBYSxXQUFXLGFBQWEsU0FDdEM7QUFDQSxpQkFBTztBQUFBLFFBQ1Q7QUF1QkEsWUFBSSxLQUFLLEtBQUs7QUFDZCxZQUFJLEtBQUssS0FBSyxhQUFhLFNBQVksS0FBSyxLQUFLO0FBQ2pELFlBQUksS0FBSyxJQUFJO0FBQ1gsZ0JBQU0sTUFBTTtBQUNaLGVBQUs7QUFDTCxlQUFLO0FBQUEsUUFDUDtBQUNBLGNBQU0sU0FDSixLQUFLLGFBQWEsU0FBWSxLQUFLLFVBQVUsS0FBSyxVQUFVO0FBQzlELGNBQU0sUUFBUyxJQUFJLEtBQUssS0FBTTtBQUM5QixjQUFNLElBQUksS0FBSyxLQUFLLElBQUksS0FBSztBQUM3QixjQUFNLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxJQUFJLENBQUM7QUFDbkMsY0FBTSxJQUFJLEtBQUs7QUFDZixjQUFNLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUM7QUFDakMsY0FBTSxhQUFhLElBQUk7QUFDdkIsWUFBSSxhQUFhLFdBQVcsY0FBYyxZQUFZO0FBQ3BELGlCQUFPLGFBQWE7QUFBQSxRQUN0QjtBQWNBLGNBQU0sSUFBSSxjQUFjLElBQUk7QUFDNUIsY0FBTSxJQUFLLGNBQWMsS0FBTSxJQUFJO0FBQ25DLGNBQU0sT0FBTyxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssS0FBSyxJQUFJLENBQUM7QUFDbEQsY0FBTSxXQUFXLE9BQU87QUFDeEIsWUFBSSxLQUFLLGFBQWEsVUFBYSxhQUFhLFNBQVM7QUFDdkQsaUJBQU8sV0FBVztBQUFBLFFBQ3BCO0FBR0EsY0FBTSxLQUFLLEtBQUssS0FBSyxJQUFJLEtBQUs7QUFDOUIsY0FBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxFQUFFO0FBQ3RDLGNBQU0sS0FBSyxLQUFLO0FBQ2hCLGNBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssRUFBRTtBQUN0QyxjQUFNLGtCQUFrQixLQUFLO0FBQzdCLFlBQUksbUJBQW1CLFlBQVk7QUFDakMsZ0JBQU0sY0FBZSxrQkFBa0IsY0FBZSxJQUFJLEtBQUs7QUFDL0QsaUJBQU8sSUFBSSxLQUFLLElBQUksVUFBVSxXQUFXO0FBQUEsUUFDM0M7QUFDQSxlQUFPLFdBQVc7QUFBQSxNQUNwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxzQkFBc0I7QUFDcEIsWUFBSSxVQUFVO0FBQ2QsWUFBSSxXQUFXO0FBQ2YsWUFBSSxhQUFhO0FBQ2pCLFlBQUksV0FBVztBQUNmLFlBQUksaUJBQWlCO0FBQ3JCLFlBQUk7QUFDSixZQUFJLGNBQWM7QUFFbEIsWUFBSSxLQUFLLFNBQVM7QUFDaEIsd0JBQWMsWUFBWSxLQUFLLFFBQVEsU0FBUyxLQUFLLGtCQUFrQjtBQUN2RSx3QkFBYyxLQUFLLFFBQVEsU0FBUyxLQUFLO0FBQ3pDLHFCQUFXLEtBQUssUUFBUSxZQUFZO0FBQ3BDLDJCQUFpQixLQUFLLFFBQVEsa0JBQWtCLEtBQUs7QUFDckQscUJBQVcsS0FBSyxRQUFRLFlBQVksS0FBSztBQUN6QyxvQkFBVSxLQUFLLFFBQVEsV0FBVyxLQUFLO0FBQ3ZDLHVCQUFhLEtBQUssUUFBUSxjQUFjLEtBQUs7QUFBQSxRQUMvQztBQUVBLGNBQU1DLE9BQU0sS0FBSyx1QkFBdUIsVUFBVSxhQUFhLFVBQVU7QUFDekUsY0FBTSxZQUFZLEtBQUssSUFBSSxLQUFLLFNBQVMsS0FBSyxZQUFZLENBQUM7QUFDM0QsY0FBTSxPQUFPLEtBQUssS0FBSyxJQUFJLFlBQVlBLElBQUc7QUFFMUMsZUFBTztBQUFBLFVBQ0w7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLFNBQVM7QUFDUCxhQUFLLGlCQUFpQixLQUFLLG9CQUFvQjtBQUMvQyxjQUFNLE9BQU8sS0FBSyxlQUFlO0FBQ2pDLGFBQUssWUFBWSxDQUFDO0FBQ2xCLGFBQUssc0JBQXNCO0FBQzNCLGFBQUssUUFBUSxDQUFDLE1BQU0sSUFBSTtBQUFBLE1BQzFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxNQUFNLGVBQWUsU0FBUyxZQUFZO0FBQ3hDLGdCQUFRLE1BQU0sWUFBWSxVQUFVO0FBRXBDLGdCQUFRLFVBQVUsY0FBYyxPQUFPLEdBQUcsY0FBYyxPQUFPLENBQUM7QUFFaEUsYUFBSyxZQUFZLE9BQU87QUFFeEIsWUFBSSxLQUFLLE9BQU87QUFDZCxjQUFJLFFBQVEsS0FBSyxNQUFNLFNBQVM7QUFDaEMsY0FBSSxVQUFVLE1BQU07QUFDbEIsb0JBQVE7QUFBQSxVQUNWO0FBQ0Esa0JBQVEsWUFBWSxZQUFZLEtBQUs7QUFDckMsa0JBQVEsS0FBSztBQUFBLFFBQ2Y7QUFDQSxZQUFJLGNBQWMsYUFBYTtBQUM3QixrQkFBUSxjQUFjLGNBQWM7QUFDcEMsa0JBQVEsWUFBWSxjQUFjO0FBQ2xDLGNBQUksY0FBYyxVQUFVO0FBQzFCLG9CQUFRLFlBQVksY0FBYyxRQUFRO0FBQzFDLG9CQUFRLGlCQUFpQixjQUFjO0FBQUEsVUFDekM7QUFDQSxrQkFBUSxVQUFVLGNBQWM7QUFDaEMsa0JBQVEsV0FBVyxjQUFjO0FBQ2pDLGtCQUFRLGFBQWEsY0FBYztBQUNuQyxrQkFBUSxPQUFPO0FBQUEsUUFDakI7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsMEJBQTBCLGVBQWU7QUFDdkMsWUFBSTtBQUNKLFlBQUksS0FBSyxPQUFPO0FBQ2QsY0FBSSxRQUFRLEtBQUssTUFBTSxTQUFTO0FBR2hDLGNBQUksVUFBVTtBQUNkLGNBQUksT0FBTyxVQUFVLFVBQVU7QUFDN0Isb0JBQVEsUUFBUSxLQUFLO0FBQUEsVUFDdkI7QUFDQSxjQUFJLFVBQVUsTUFBTTtBQUNsQixzQkFBVTtBQUFBLFVBQ1osV0FBVyxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQy9CLHNCQUFVLE1BQU0sV0FBVyxJQUFJLE1BQU0sQ0FBQyxJQUFJO0FBQUEsVUFDNUM7QUFDQSxjQUFJLFlBQVksR0FBRztBQUdqQixzQkFBVSxzQkFBc0IsY0FBYyxNQUFNLGNBQWMsSUFBSTtBQUN0RSxpQkFBSyx3QkFBd0IsZUFBZSxPQUFPO0FBQUEsVUFDckQ7QUFBQSxRQUNGO0FBQ0EsZUFBTyxVQUFVLFFBQVEsU0FBUyxLQUFLLFNBQVMsQ0FBQztBQUFBLE1BQ25EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFlBQVksU0FBUztBQUNuQixZQUFJLFNBQVMsS0FBSztBQUNsQixjQUFNLFNBQVMsS0FBSztBQUNwQixZQUFJLFdBQVcsVUFBVTtBQUN2QixrQkFBUSxJQUFJLEdBQUcsR0FBRyxRQUFRLEdBQUcsSUFBSSxLQUFLLEVBQUU7QUFBQSxRQUMxQyxPQUFPO0FBQ0wsZ0JBQU0sVUFBVSxLQUFLLGFBQWEsU0FBWSxTQUFTLEtBQUs7QUFDNUQsY0FBSSxLQUFLLGFBQWEsUUFBVztBQUMvQixzQkFBVTtBQUFBLFVBQ1o7QUFDQSxnQkFBTSxhQUFhLEtBQUssU0FBUyxLQUFLLEtBQUs7QUFDM0MsZ0JBQU0sT0FBUSxJQUFJLEtBQUssS0FBTTtBQUM3QixtQkFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLEtBQUs7QUFDL0Isa0JBQU0sU0FBUyxhQUFhLElBQUk7QUFDaEMsa0JBQU0sVUFBVSxJQUFJLE1BQU0sSUFBSSxTQUFTO0FBQ3ZDLG9CQUFRLE9BQU8sVUFBVSxLQUFLLElBQUksTUFBTSxHQUFHLFVBQVUsS0FBSyxJQUFJLE1BQU0sQ0FBQztBQUFBLFVBQ3ZFO0FBQ0Esa0JBQVEsVUFBVTtBQUFBLFFBQ3BCO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLHdCQUF3QixlQUFlLFNBQVM7QUFFOUMsZ0JBQVEsVUFBVSxjQUFjLE9BQU8sR0FBRyxjQUFjLE9BQU8sQ0FBQztBQUVoRSxhQUFLLFlBQVksT0FBTztBQUV4QixnQkFBUSxZQUFZO0FBQ3BCLGdCQUFRLEtBQUs7QUFDYixZQUFJLGNBQWMsYUFBYTtBQUM3QixrQkFBUSxjQUFjLGNBQWM7QUFDcEMsa0JBQVEsWUFBWSxjQUFjO0FBQ2xDLGNBQUksY0FBYyxVQUFVO0FBQzFCLG9CQUFRLFlBQVksY0FBYyxRQUFRO0FBQzFDLG9CQUFRLGlCQUFpQixjQUFjO0FBQUEsVUFDekM7QUFDQSxrQkFBUSxXQUFXLGNBQWM7QUFDakMsa0JBQVEsYUFBYSxjQUFjO0FBQ25DLGtCQUFRLE9BQU87QUFBQSxRQUNqQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsSUFBTyx1QkFBUTtBQUFBO0FBQUE7OztBQ25tQmYsSUEwQk0sYUF1REM7QUFqRlA7QUFBQTtBQUlBO0FBc0JBLElBQU0sY0FBTixNQUFNLHFCQUFvQixxQkFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSXJDLFlBQVksU0FBUztBQUNuQixrQkFBVSxVQUFVLFVBQVUsRUFBQyxRQUFRLEVBQUM7QUFFeEMsY0FBTTtBQUFBLFVBQ0osUUFBUTtBQUFBLFVBQ1IsTUFBTSxRQUFRO0FBQUEsVUFDZCxRQUFRLFFBQVE7QUFBQSxVQUNoQixRQUFRLFFBQVE7QUFBQSxVQUNoQixPQUFPLFFBQVEsVUFBVSxTQUFZLFFBQVEsUUFBUTtBQUFBLFVBQ3JELFVBQVUsUUFBUSxhQUFhLFNBQVksUUFBUSxXQUFXO0FBQUEsVUFDOUQsZ0JBQ0UsUUFBUSxtQkFBbUIsU0FBWSxRQUFRLGlCQUFpQjtBQUFBLFVBQ2xFLGNBQ0UsUUFBUSxpQkFBaUIsU0FBWSxRQUFRLGVBQWUsQ0FBQyxHQUFHLENBQUM7QUFBQSxVQUNuRSxlQUFlLFFBQVE7QUFBQSxRQUN6QixDQUFDO0FBQUEsTUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixjQUFNQyxTQUFRLEtBQUssU0FBUztBQUM1QixjQUFNLFFBQVEsSUFBSSxhQUFZO0FBQUEsVUFDNUIsTUFBTSxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLElBQUk7QUFBQSxVQUNoRCxRQUFRLEtBQUssVUFBVSxJQUFJLEtBQUssVUFBVSxFQUFFLE1BQU0sSUFBSTtBQUFBLFVBQ3RELFFBQVEsS0FBSyxVQUFVO0FBQUEsVUFDdkIsT0FBTyxNQUFNLFFBQVFBLE1BQUssSUFBSUEsT0FBTSxNQUFNLElBQUlBO0FBQUEsVUFDOUMsVUFBVSxLQUFLLFlBQVk7QUFBQSxVQUMzQixnQkFBZ0IsS0FBSyxrQkFBa0I7QUFBQSxVQUN2QyxjQUFjLEtBQUssZ0JBQWdCLEVBQUUsTUFBTTtBQUFBLFVBQzNDLGVBQWUsS0FBSyxpQkFBaUI7QUFBQSxRQUN2QyxDQUFDO0FBQ0QsY0FBTSxXQUFXLEtBQUssV0FBVyxDQUFDO0FBQ2xDLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxPQUFPO0FBQUEsTUFDZDtBQUFBLElBQ0Y7QUFFQSxJQUFPLGlCQUFRO0FBQUE7QUFBQTs7O0FDakZmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBK2FPLFNBQVMsV0FBVyxLQUFLO0FBQzlCLE1BQUk7QUFFSixNQUFJLE9BQU8sUUFBUSxZQUFZO0FBQzdCLG9CQUFnQjtBQUFBLEVBQ2xCLE9BQU87QUFJTCxRQUFJO0FBQ0osUUFBSSxNQUFNLFFBQVEsR0FBRyxHQUFHO0FBQ3RCLGVBQVM7QUFBQSxJQUNYLE9BQU87QUFDTDtBQUFBLFFBQ0U7QUFBQSxRQUEwQixJQUFLLGNBQWU7QUFBQSxRQUM5QztBQUFBLE1BQ0Y7QUFDQSxZQUFNO0FBQUE7QUFBQSxRQUE4QjtBQUFBO0FBQ3BDLGVBQVMsQ0FBQyxLQUFLO0FBQUEsSUFDakI7QUFDQSxvQkFBZ0IsV0FBWTtBQUMxQixhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFZTyxTQUFTLG1CQUFtQixTQUFTLFlBQVk7QUFNdEQsTUFBSSxDQUFDLGVBQWU7QUFDbEIsVUFBTSxPQUFPLElBQUksYUFBSztBQUFBLE1BQ3BCLE9BQU87QUFBQSxJQUNULENBQUM7QUFDRCxVQUFNLFNBQVMsSUFBSSxlQUFPO0FBQUEsTUFDeEIsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLElBQ1QsQ0FBQztBQUNELG9CQUFnQjtBQUFBLE1BQ2QsSUFBSSxNQUFNO0FBQUEsUUFDUixPQUFPLElBQUksZUFBWTtBQUFBLFVBQ3JCO0FBQUEsVUFDQTtBQUFBLFVBQ0EsUUFBUTtBQUFBLFFBQ1YsQ0FBQztBQUFBLFFBQ0Q7QUFBQSxRQUNBO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFDQSxTQUFPO0FBQ1Q7QUFNTyxTQUFTLHFCQUFxQjtBQUVuQyxRQUFNLFNBQVMsQ0FBQztBQUNoQixRQUFNLFFBQVEsQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDO0FBQy9CLFFBQU0sT0FBTyxDQUFDLEdBQUcsS0FBSyxLQUFLLENBQUM7QUFDNUIsUUFBTSxRQUFRO0FBQ2QsU0FBTyxTQUFTLElBQUk7QUFBQSxJQUNsQixJQUFJLE1BQU07QUFBQSxNQUNSLE1BQU0sSUFBSSxhQUFLO0FBQUEsUUFDYixPQUFPLENBQUMsS0FBSyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLENBQUM7QUFBQSxJQUNILENBQUM7QUFBQSxFQUNIO0FBQ0EsU0FBTyxjQUFjLElBQUksT0FBTyxTQUFTO0FBRXpDLFNBQU8sWUFBWSxJQUFJO0FBQUEsSUFDckIsSUFBSSxNQUFNO0FBQUEsTUFDUixRQUFRLElBQUksZUFBTztBQUFBLFFBQ2pCLE9BQU87QUFBQSxRQUNQLE9BQU8sUUFBUTtBQUFBLE1BQ2pCLENBQUM7QUFBQSxJQUNILENBQUM7QUFBQSxJQUNELElBQUksTUFBTTtBQUFBLE1BQ1IsUUFBUSxJQUFJLGVBQU87QUFBQSxRQUNqQixPQUFPO0FBQUEsUUFDUDtBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUFBLEVBQ0g7QUFDQSxTQUFPLGlCQUFpQixJQUFJLE9BQU8sWUFBWTtBQUUvQyxTQUFPLFFBQVEsSUFBSSxPQUFPLFNBQVMsRUFBRSxPQUFPLE9BQU8sWUFBWSxDQUFDO0FBRWhFLFNBQU8sT0FBTyxJQUFJO0FBQUEsSUFDaEIsSUFBSSxNQUFNO0FBQUEsTUFDUixPQUFPLElBQUksZUFBWTtBQUFBLFFBQ3JCLFFBQVEsUUFBUTtBQUFBLFFBQ2hCLE1BQU0sSUFBSSxhQUFLO0FBQUEsVUFDYixPQUFPO0FBQUEsUUFDVCxDQUFDO0FBQUEsUUFDRCxRQUFRLElBQUksZUFBTztBQUFBLFVBQ2pCLE9BQU87QUFBQSxVQUNQLE9BQU8sUUFBUTtBQUFBLFFBQ2pCLENBQUM7QUFBQSxNQUNILENBQUM7QUFBQSxNQUNELFFBQVE7QUFBQSxJQUNWLENBQUM7QUFBQSxFQUNIO0FBQ0EsU0FBTyxZQUFZLElBQUksT0FBTyxPQUFPO0FBRXJDLFNBQU8sb0JBQW9CLElBQUksT0FBTyxTQUFTLEVBQUU7QUFBQSxJQUMvQyxPQUFPLFlBQVk7QUFBQSxJQUNuQixPQUFPLE9BQU87QUFBQSxFQUNoQjtBQUVBLFNBQU87QUFDVDtBQU9BLFNBQVMsd0JBQXdCLFNBQVM7QUFDeEMsU0FBTyxRQUFRLFlBQVk7QUFDN0I7QUF0akJBLElBdUpNLE9Bc1RGLGVBMkdHO0FBeGpCUDtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFnSkEsSUFBTSxRQUFOLE1BQU0sT0FBTTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSVYsWUFBWSxTQUFTO0FBQ25CLGtCQUFVLFdBQVcsQ0FBQztBQU10QixhQUFLLFlBQVk7QUFNakIsYUFBSyxvQkFBb0I7QUFFekIsWUFBSSxRQUFRLGFBQWEsUUFBVztBQUNsQyxlQUFLLFlBQVksUUFBUSxRQUFRO0FBQUEsUUFDbkM7QUFNQSxhQUFLLFFBQVEsUUFBUSxTQUFTLFNBQVksUUFBUSxPQUFPO0FBTXpELGFBQUssU0FBUyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVE7QUFNNUQsYUFBSyxZQUFZLFFBQVEsYUFBYSxTQUFZLFFBQVEsV0FBVztBQU1yRSxhQUFLLHdCQUNILFFBQVEseUJBQXlCLFNBQzdCLFFBQVEsdUJBQ1I7QUFNTixhQUFLLFVBQVUsUUFBUSxXQUFXLFNBQVksUUFBUSxTQUFTO0FBTS9ELGFBQUssUUFBUSxRQUFRLFNBQVMsU0FBWSxRQUFRLE9BQU87QUFNekQsYUFBSyxVQUFVLFFBQVE7QUFBQSxNQUN6QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixZQUFJLFdBQVcsS0FBSyxZQUFZO0FBQ2hDLFlBQUksWUFBWSxPQUFPLGFBQWEsVUFBVTtBQUM1QztBQUFBLFVBQ0UsU0FDQSxNQUFNO0FBQUEsUUFDVjtBQUNBLGVBQU8sSUFBSSxPQUFNO0FBQUEsVUFDZixVQUFVLFlBQVk7QUFBQSxVQUN0QixNQUFNLEtBQUssUUFBUSxJQUFJLEtBQUssUUFBUSxFQUFFLE1BQU0sSUFBSTtBQUFBLFVBQ2hELE9BQU8sS0FBSyxTQUFTLElBQUksS0FBSyxTQUFTLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDbkQsVUFBVSxLQUFLLFlBQVksS0FBSztBQUFBLFVBQ2hDLFFBQVEsS0FBSyxVQUFVLElBQUksS0FBSyxVQUFVLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDdEQsTUFBTSxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsRUFBRSxNQUFNLElBQUk7QUFBQSxVQUNoRCxRQUFRLEtBQUssVUFBVTtBQUFBLFFBQ3pCLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxjQUFjO0FBQ1osZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWSxVQUFVO0FBQ3BCLGFBQUssWUFBWTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSx3QkFBd0IsVUFBVTtBQUNoQyxhQUFLLHdCQUF3QjtBQUFBLE1BQy9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSwwQkFBMEI7QUFDeEIsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxjQUFjO0FBQ1osZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsc0JBQXNCO0FBQ3BCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVEsTUFBTTtBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFNBQVMsT0FBTztBQUNkLGFBQUssU0FBUztBQUFBLE1BQ2hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQUEsTUFDakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVEsTUFBTTtBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVVBLFlBQVksVUFBVTtBQUNwQixZQUFJLE9BQU8sYUFBYSxZQUFZO0FBQ2xDLGVBQUssb0JBQW9CO0FBQUEsUUFDM0IsV0FBVyxPQUFPLGFBQWEsVUFBVTtBQUN2QyxlQUFLLG9CQUFvQixTQUFVLFNBQVM7QUFDMUM7QUFBQTtBQUFBLGNBQ0UsUUFBUSxJQUFJLFFBQVE7QUFBQTtBQUFBLFVBRXhCO0FBQUEsUUFDRixXQUFXLENBQUMsVUFBVTtBQUNwQixlQUFLLG9CQUFvQjtBQUFBLFFBQzNCLFdBQVcsYUFBYSxRQUFXO0FBQ2pDLGVBQUssb0JBQW9CLFdBQVk7QUFDbkM7QUFBQTtBQUFBLGNBQTZEO0FBQUE7QUFBQSxVQUMvRDtBQUFBLFFBQ0Y7QUFDQSxhQUFLLFlBQVk7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsVUFBVSxRQUFRO0FBQ2hCLGFBQUssVUFBVTtBQUFBLE1BQ2pCO0FBQUEsSUFDRjtBQXdDQSxJQUFJLGdCQUFnQjtBQTJHcEIsSUFBTyxnQkFBUTtBQUFBO0FBQUE7OztBQ3hqQmYsSUF3Qk0sb0JBK0NBLE1BNmhCQztBQXBtQlA7QUFBQTtBQUdBO0FBQ0E7QUFvQkEsSUFBTSxxQkFBcUI7QUErQzNCLElBQU0sT0FBTixNQUFNLE1BQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUlULFlBQVksU0FBUztBQUNuQixrQkFBVSxXQUFXLENBQUM7QUFNdEIsYUFBSyxRQUFRLFFBQVE7QUFNckIsYUFBSyxZQUFZLFFBQVE7QUFNekIsYUFBSyxrQkFBa0IsUUFBUTtBQU0vQixhQUFLLFNBQVMsUUFBUTtBQU10QixhQUFLLGNBQWMsT0FBTyxRQUFRLFVBQVUsU0FBWSxRQUFRLFFBQVEsQ0FBQztBQU16RSxhQUFLLFFBQVEsUUFBUTtBQU1yQixhQUFLLGFBQWEsUUFBUTtBQU0xQixhQUFLLFdBQVcsUUFBUTtBQU14QixhQUFLLFVBQVUsUUFBUTtBQU12QixhQUFLLGdCQUFnQixRQUFRO0FBTTdCLGFBQUssUUFDSCxRQUFRLFNBQVMsU0FDYixRQUFRLE9BQ1IsSUFBSSxhQUFLLEVBQUMsT0FBTyxtQkFBa0IsQ0FBQztBQU0xQyxhQUFLLFlBQ0gsUUFBUSxhQUFhLFNBQVksUUFBUSxXQUFXLEtBQUssS0FBSztBQU1oRSxhQUFLLGFBQ0gsUUFBUSxjQUFjLFNBQVksUUFBUSxZQUFZO0FBTXhELGFBQUssWUFBWSxDQUFDLENBQUMsUUFBUTtBQU0zQixhQUFLLFVBQVUsUUFBUSxXQUFXLFNBQVksUUFBUSxTQUFTO0FBTS9ELGFBQUssV0FBVyxRQUFRLFlBQVksU0FBWSxRQUFRLFVBQVU7QUFNbEUsYUFBSyxXQUFXLFFBQVEsWUFBWSxTQUFZLFFBQVEsVUFBVTtBQU1sRSxhQUFLLGtCQUFrQixRQUFRLGlCQUMzQixRQUFRLGlCQUNSO0FBTUosYUFBSyxvQkFBb0IsUUFBUSxtQkFDN0IsUUFBUSxtQkFDUjtBQU1KLGFBQUssV0FBVyxRQUFRLFlBQVksU0FBWSxPQUFPLFFBQVE7QUFBQSxNQUNqRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixjQUFNQyxTQUFRLEtBQUssU0FBUztBQUM1QixlQUFPLElBQUksTUFBSztBQUFBLFVBQ2QsTUFBTSxLQUFLLFFBQVE7QUFBQSxVQUNuQixXQUFXLEtBQUssYUFBYTtBQUFBLFVBQzdCLFFBQVEsS0FBSyxVQUFVO0FBQUEsVUFDdkIsVUFBVSxLQUFLLFlBQVk7QUFBQSxVQUMzQixVQUFVLEtBQUssWUFBWTtBQUFBLFVBQzNCLFVBQVUsS0FBSyxZQUFZO0FBQUEsVUFDM0IsZ0JBQWdCLEtBQUssa0JBQWtCO0FBQUEsVUFDdkMsT0FBTyxNQUFNLFFBQVFBLE1BQUssSUFBSUEsT0FBTSxNQUFNLElBQUlBO0FBQUEsVUFDOUMsTUFBTSxLQUFLLFFBQVE7QUFBQSxVQUNuQixXQUFXLEtBQUssYUFBYTtBQUFBLFVBQzdCLFNBQVMsS0FBSyxXQUFXO0FBQUEsVUFDekIsY0FBYyxLQUFLLGdCQUFnQjtBQUFBLFVBQ25DLE1BQU0sS0FBSyxRQUFRLElBQUksS0FBSyxRQUFRLEVBQUUsTUFBTSxJQUFJO0FBQUEsVUFDaEQsUUFBUSxLQUFLLFVBQVUsSUFBSSxLQUFLLFVBQVUsRUFBRSxNQUFNLElBQUk7QUFBQSxVQUN0RCxTQUFTLEtBQUssV0FBVztBQUFBLFVBQ3pCLFNBQVMsS0FBSyxXQUFXO0FBQUEsVUFDekIsZ0JBQWdCLEtBQUssa0JBQWtCLElBQ25DLEtBQUssa0JBQWtCLEVBQUUsTUFBTSxJQUMvQjtBQUFBLFVBQ0osa0JBQWtCLEtBQUssb0JBQW9CLElBQ3ZDLEtBQUssb0JBQW9CLEVBQUUsTUFBTSxJQUNqQztBQUFBLFVBQ0osU0FBUyxLQUFLLFdBQVcsS0FBSztBQUFBLFFBQ2hDLENBQUM7QUFBQSxNQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsY0FBYztBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGNBQWM7QUFDWixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsZUFBZTtBQUNiLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxZQUFZO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGFBQWE7QUFDWCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsYUFBYTtBQUNYLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsY0FBYztBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsWUFBWTtBQUNWLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVO0FBQ1IsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGVBQWU7QUFDYixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsYUFBYTtBQUNYLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxrQkFBa0I7QUFDaEIsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0Esc0JBQXNCO0FBQ3BCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxhQUFhO0FBQ1gsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWSxVQUFVO0FBQ3BCLGFBQUssWUFBWTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxRQUFRLE1BQU07QUFDWixhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZLFVBQVU7QUFDcEIsYUFBSyxZQUFZO0FBQUEsTUFDbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFdBQVcsU0FBUztBQUNsQixhQUFLLFdBQVc7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsV0FBVyxTQUFTO0FBQ2xCLGFBQUssV0FBVztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxhQUFhLFdBQVc7QUFDdEIsYUFBSyxhQUFhO0FBQUEsTUFDcEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQUEsTUFDakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGtCQUFrQixnQkFBZ0I7QUFDaEMsYUFBSyxrQkFBa0I7QUFBQSxNQUN6QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsUUFBUSxNQUFNO0FBQ1osYUFBSyxRQUFRO0FBQUEsTUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWSxVQUFVO0FBQ3BCLGFBQUssWUFBWTtBQUFBLE1BQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxTQUFTQSxRQUFPO0FBQ2QsYUFBSyxTQUFTQTtBQUNkLGFBQUssY0FBYyxPQUFPQSxXQUFVLFNBQVlBLFNBQVEsQ0FBQztBQUFBLE1BQzNEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQUEsTUFDakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFFBQVEsTUFBTTtBQUNaLGFBQUssUUFBUTtBQUFBLE1BQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGFBQWEsV0FBVztBQUN0QixhQUFLLGFBQWE7QUFBQSxNQUNwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsV0FBVyxTQUFTO0FBQ2xCLGFBQUssV0FBVztBQUFBLE1BQ2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxnQkFBZ0IsY0FBYztBQUM1QixhQUFLLGdCQUFnQjtBQUFBLE1BQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxrQkFBa0IsTUFBTTtBQUN0QixhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxvQkFBb0IsUUFBUTtBQUMxQixhQUFLLG9CQUFvQjtBQUFBLE1BQzNCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxXQUFXLFNBQVM7QUFDbEIsYUFBSyxXQUFXO0FBQUEsTUFDbEI7QUFBQSxJQUNGO0FBRUEsSUFBTyxlQUFRO0FBQUE7QUFBQTs7O0FDbm1CQSxTQUFSLFlBQTZCLEtBQUssR0FBRyxNQUFNLE9BQU8sU0FBUztBQUM5RCxrQkFBZ0IsS0FBSyxHQUFHLFFBQVEsR0FBRyxTQUFVLElBQUksU0FBUyxHQUFJLFdBQVcsY0FBYztBQUMzRjtBQUVBLFNBQVMsZ0JBQWdCLEtBQUssR0FBRyxNQUFNLE9BQU8sU0FBUztBQUVuRCxTQUFPLFFBQVEsTUFBTTtBQUNqQixRQUFJLFFBQVEsT0FBTyxLQUFLO0FBQ3BCLFVBQUksSUFBSSxRQUFRLE9BQU87QUFDdkIsVUFBSSxJQUFJLElBQUksT0FBTztBQUNuQixVQUFJLElBQUksS0FBSyxJQUFJLENBQUM7QUFDbEIsVUFBSSxJQUFJLE1BQU0sS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDO0FBQ2hDLFVBQUksS0FBSyxNQUFNLEtBQUssS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUs7QUFDdEUsVUFBSSxVQUFVLEtBQUssSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUMzRCxVQUFJLFdBQVcsS0FBSyxJQUFJLE9BQU8sS0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFLENBQUM7QUFDbkUsc0JBQWdCLEtBQUssR0FBRyxTQUFTLFVBQVUsT0FBTztBQUFBLElBQ3REO0FBRUEsUUFBSSxJQUFJLElBQUksQ0FBQztBQUNiLFFBQUksSUFBSTtBQUNSLFFBQUksSUFBSTtBQUVSLFNBQUssS0FBSyxNQUFNLENBQUM7QUFDakIsUUFBSSxRQUFRLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSTtBQUFHLFdBQUssS0FBSyxNQUFNLEtBQUs7QUFFckQsV0FBTyxJQUFJLEdBQUc7QUFDVixXQUFLLEtBQUssR0FBRyxDQUFDO0FBQ2Q7QUFDQTtBQUNBLGFBQU8sUUFBUSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUk7QUFBRztBQUMvQixhQUFPLFFBQVEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJO0FBQUc7QUFBQSxJQUNuQztBQUVBLFFBQUksUUFBUSxJQUFJLElBQUksR0FBRyxDQUFDLE1BQU07QUFBRyxXQUFLLEtBQUssTUFBTSxDQUFDO0FBQUEsU0FDN0M7QUFDRDtBQUNBLFdBQUssS0FBSyxHQUFHLEtBQUs7QUFBQSxJQUN0QjtBQUVBLFFBQUksS0FBSztBQUFHLGFBQU8sSUFBSTtBQUN2QixRQUFJLEtBQUs7QUFBRyxjQUFRLElBQUk7QUFBQSxFQUM1QjtBQUNKO0FBRUEsU0FBUyxLQUFLLEtBQUssR0FBRyxHQUFHO0FBQ3JCLE1BQUksTUFBTSxJQUFJLENBQUM7QUFDZixNQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDZCxNQUFJLENBQUMsSUFBSTtBQUNiO0FBRUEsU0FBUyxlQUFlLEdBQUcsR0FBRztBQUMxQixTQUFPLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJO0FBQ3BDO0FBckRBO0FBQUE7QUFBQTtBQUFBOzs7QUN5WkEsU0FBUyxTQUFTLE1BQU0sT0FBTyxVQUFVO0FBQ3JDLE1BQUksQ0FBQztBQUFVLFdBQU8sTUFBTSxRQUFRLElBQUk7QUFFeEMsV0FBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNuQyxRQUFJLFNBQVMsTUFBTSxNQUFNLENBQUMsQ0FBQztBQUFHLGFBQU87QUFBQSxFQUN6QztBQUNBLFNBQU87QUFDWDtBQUdBLFNBQVMsU0FBUyxNQUFNLFFBQVE7QUFDNUIsV0FBUyxNQUFNLEdBQUcsS0FBSyxTQUFTLFFBQVEsUUFBUSxJQUFJO0FBQ3hEO0FBR0EsU0FBUyxTQUFTLE1BQU0sR0FBRyxHQUFHLFFBQVEsVUFBVTtBQUM1QyxNQUFJLENBQUM7QUFBVSxlQUFXLFdBQVcsSUFBSTtBQUN6QyxXQUFTLE9BQU87QUFDaEIsV0FBUyxPQUFPO0FBQ2hCLFdBQVMsT0FBTztBQUNoQixXQUFTLE9BQU87QUFFaEIsV0FBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDeEIsVUFBTSxRQUFRLEtBQUssU0FBUyxDQUFDO0FBQzdCLElBQUFDLFFBQU8sVUFBVSxLQUFLLE9BQU8sT0FBTyxLQUFLLElBQUksS0FBSztBQUFBLEVBQ3REO0FBRUEsU0FBTztBQUNYO0FBRUEsU0FBU0EsUUFBTyxHQUFHLEdBQUc7QUFDbEIsSUFBRSxPQUFPLEtBQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJO0FBQ2hDLElBQUUsT0FBTyxLQUFLLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSTtBQUNoQyxJQUFFLE9BQU8sS0FBSyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUk7QUFDaEMsSUFBRSxPQUFPLEtBQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJO0FBQ2hDLFNBQU87QUFDWDtBQUVBLFNBQVMsZ0JBQWdCLEdBQUcsR0FBRztBQUFFLFNBQU8sRUFBRSxPQUFPLEVBQUU7QUFBTTtBQUN6RCxTQUFTLGdCQUFnQixHQUFHLEdBQUc7QUFBRSxTQUFPLEVBQUUsT0FBTyxFQUFFO0FBQU07QUFFekQsU0FBUyxTQUFTLEdBQUs7QUFBRSxVQUFRLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7QUFBTztBQUN2RSxTQUFTLFdBQVcsR0FBRztBQUFFLFNBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUyxFQUFFLE9BQU8sRUFBRTtBQUFPO0FBRXZFLFNBQVMsYUFBYSxHQUFHLEdBQUc7QUFDeEIsVUFBUSxLQUFLLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLE1BQ2xELEtBQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUk7QUFDOUQ7QUFFQSxTQUFTLGlCQUFpQixHQUFHLEdBQUc7QUFDNUIsUUFBTSxPQUFPLEtBQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJO0FBQ3BDLFFBQU0sT0FBTyxLQUFLLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSTtBQUNwQyxRQUFNLE9BQU8sS0FBSyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUk7QUFDcEMsUUFBTSxPQUFPLEtBQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJO0FBRXBDLFNBQU8sS0FBSyxJQUFJLEdBQUcsT0FBTyxJQUFJLElBQ3ZCLEtBQUssSUFBSSxHQUFHLE9BQU8sSUFBSTtBQUNsQztBQUVBLFNBQVMsU0FBUyxHQUFHLEdBQUc7QUFDcEIsU0FBTyxFQUFFLFFBQVEsRUFBRSxRQUNaLEVBQUUsUUFBUSxFQUFFLFFBQ1osRUFBRSxRQUFRLEVBQUUsUUFDWixFQUFFLFFBQVEsRUFBRTtBQUN2QjtBQUVBLFNBQVNDLFlBQVcsR0FBRyxHQUFHO0FBQ3RCLFNBQU8sRUFBRSxRQUFRLEVBQUUsUUFDWixFQUFFLFFBQVEsRUFBRSxRQUNaLEVBQUUsUUFBUSxFQUFFLFFBQ1osRUFBRSxRQUFRLEVBQUU7QUFDdkI7QUFFQSxTQUFTLFdBQVcsVUFBVTtBQUMxQixTQUFPO0FBQUEsSUFDSDtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLEVBQ1Y7QUFDSjtBQUtBLFNBQVMsWUFBWSxLQUFLLE1BQU0sT0FBTyxHQUFHLFNBQVM7QUFDL0MsUUFBTSxRQUFRLENBQUMsTUFBTSxLQUFLO0FBRTFCLFNBQU8sTUFBTSxRQUFRO0FBQ2pCLFlBQVEsTUFBTSxJQUFJO0FBQ2xCLFdBQU8sTUFBTSxJQUFJO0FBRWpCLFFBQUksUUFBUSxRQUFRO0FBQUc7QUFFdkIsVUFBTSxNQUFNLE9BQU8sS0FBSyxNQUFNLFFBQVEsUUFBUSxJQUFJLENBQUMsSUFBSTtBQUN2RCxnQkFBWSxLQUFLLEtBQUssTUFBTSxPQUFPLE9BQU87QUFFMUMsVUFBTSxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUs7QUFBQSxFQUNwQztBQUNKO0FBL2ZBLElBRXFCO0FBRnJCO0FBQUE7QUFBQTtBQUVBLElBQXFCLFFBQXJCLE1BQTJCO0FBQUEsTUFDdkIsWUFBWSxhQUFhLEdBQUc7QUFFeEIsYUFBSyxjQUFjLEtBQUssSUFBSSxHQUFHLFVBQVU7QUFDekMsYUFBSyxjQUFjLEtBQUssSUFBSSxHQUFHLEtBQUssS0FBSyxLQUFLLGNBQWMsR0FBRyxDQUFDO0FBQ2hFLGFBQUssTUFBTTtBQUFBLE1BQ2Y7QUFBQSxNQUVBLE1BQU07QUFDRixlQUFPLEtBQUssS0FBSyxLQUFLLE1BQU0sQ0FBQyxDQUFDO0FBQUEsTUFDbEM7QUFBQSxNQUVBLE9BQU8sTUFBTTtBQUNULFlBQUksT0FBTyxLQUFLO0FBQ2hCLGNBQU0sU0FBUyxDQUFDO0FBRWhCLFlBQUksQ0FBQ0EsWUFBVyxNQUFNLElBQUk7QUFBRyxpQkFBTztBQUVwQyxjQUFNLFNBQVMsS0FBSztBQUNwQixjQUFNLGdCQUFnQixDQUFDO0FBRXZCLGVBQU8sTUFBTTtBQUNULG1CQUFTLElBQUksR0FBRyxJQUFJLEtBQUssU0FBUyxRQUFRLEtBQUs7QUFDM0Msa0JBQU0sUUFBUSxLQUFLLFNBQVMsQ0FBQztBQUM3QixrQkFBTSxZQUFZLEtBQUssT0FBTyxPQUFPLEtBQUssSUFBSTtBQUU5QyxnQkFBSUEsWUFBVyxNQUFNLFNBQVMsR0FBRztBQUM3QixrQkFBSSxLQUFLO0FBQU0sdUJBQU8sS0FBSyxLQUFLO0FBQUEsdUJBQ3ZCLFNBQVMsTUFBTSxTQUFTO0FBQUcscUJBQUssS0FBSyxPQUFPLE1BQU07QUFBQTtBQUN0RCw4QkFBYyxLQUFLLEtBQUs7QUFBQSxZQUNqQztBQUFBLFVBQ0o7QUFDQSxpQkFBTyxjQUFjLElBQUk7QUFBQSxRQUM3QjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFFQSxTQUFTLE1BQU07QUFDWCxZQUFJLE9BQU8sS0FBSztBQUVoQixZQUFJLENBQUNBLFlBQVcsTUFBTSxJQUFJO0FBQUcsaUJBQU87QUFFcEMsY0FBTSxnQkFBZ0IsQ0FBQztBQUN2QixlQUFPLE1BQU07QUFDVCxtQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFNBQVMsUUFBUSxLQUFLO0FBQzNDLGtCQUFNLFFBQVEsS0FBSyxTQUFTLENBQUM7QUFDN0Isa0JBQU0sWUFBWSxLQUFLLE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSTtBQUVuRCxnQkFBSUEsWUFBVyxNQUFNLFNBQVMsR0FBRztBQUM3QixrQkFBSSxLQUFLLFFBQVEsU0FBUyxNQUFNLFNBQVM7QUFBRyx1QkFBTztBQUNuRCw0QkFBYyxLQUFLLEtBQUs7QUFBQSxZQUM1QjtBQUFBLFVBQ0o7QUFDQSxpQkFBTyxjQUFjLElBQUk7QUFBQSxRQUM3QjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFFQSxLQUFLLE1BQU07QUFDUCxZQUFJLEVBQUUsUUFBUSxLQUFLO0FBQVMsaUJBQU87QUFFbkMsWUFBSSxLQUFLLFNBQVMsS0FBSyxhQUFhO0FBQ2hDLG1CQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ2xDLGlCQUFLLE9BQU8sS0FBSyxDQUFDLENBQUM7QUFBQSxVQUN2QjtBQUNBLGlCQUFPO0FBQUEsUUFDWDtBQUdBLFlBQUksT0FBTyxLQUFLLE9BQU8sS0FBSyxNQUFNLEdBQUcsR0FBRyxLQUFLLFNBQVMsR0FBRyxDQUFDO0FBRTFELFlBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxRQUFRO0FBRTVCLGVBQUssT0FBTztBQUFBLFFBRWhCLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxRQUFRO0FBRXpDLGVBQUssV0FBVyxLQUFLLE1BQU0sSUFBSTtBQUFBLFFBRW5DLE9BQU87QUFDSCxjQUFJLEtBQUssS0FBSyxTQUFTLEtBQUssUUFBUTtBQUVoQyxrQkFBTSxVQUFVLEtBQUs7QUFDckIsaUJBQUssT0FBTztBQUNaLG1CQUFPO0FBQUEsVUFDWDtBQUdBLGVBQUssUUFBUSxNQUFNLEtBQUssS0FBSyxTQUFTLEtBQUssU0FBUyxHQUFHLElBQUk7QUFBQSxRQUMvRDtBQUVBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFFQSxPQUFPLE1BQU07QUFDVCxZQUFJO0FBQU0sZUFBSyxRQUFRLE1BQU0sS0FBSyxLQUFLLFNBQVMsQ0FBQztBQUNqRCxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BRUEsUUFBUTtBQUNKLGFBQUssT0FBTyxXQUFXLENBQUMsQ0FBQztBQUN6QixlQUFPO0FBQUEsTUFDWDtBQUFBLE1BRUEsT0FBTyxNQUFNLFVBQVU7QUFDbkIsWUFBSSxDQUFDO0FBQU0saUJBQU87QUFFbEIsWUFBSSxPQUFPLEtBQUs7QUFDaEIsY0FBTSxPQUFPLEtBQUssT0FBTyxJQUFJO0FBQzdCLGNBQU0sT0FBTyxDQUFDO0FBQ2QsY0FBTSxVQUFVLENBQUM7QUFDakIsWUFBSSxHQUFHLFFBQVE7QUFHZixlQUFPLFFBQVEsS0FBSyxRQUFRO0FBRXhCLGNBQUksQ0FBQyxNQUFNO0FBQ1AsbUJBQU8sS0FBSyxJQUFJO0FBQ2hCLHFCQUFTLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDN0IsZ0JBQUksUUFBUSxJQUFJO0FBQ2hCLHNCQUFVO0FBQUEsVUFDZDtBQUVBLGNBQUksS0FBSyxNQUFNO0FBQ1gsa0JBQU0sUUFBUSxTQUFTLE1BQU0sS0FBSyxVQUFVLFFBQVE7QUFFcEQsZ0JBQUksVUFBVSxJQUFJO0FBRWQsbUJBQUssU0FBUyxPQUFPLE9BQU8sQ0FBQztBQUM3QixtQkFBSyxLQUFLLElBQUk7QUFDZCxtQkFBSyxVQUFVLElBQUk7QUFDbkIscUJBQU87QUFBQSxZQUNYO0FBQUEsVUFDSjtBQUVBLGNBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxRQUFRLFNBQVMsTUFBTSxJQUFJLEdBQUc7QUFDaEQsaUJBQUssS0FBSyxJQUFJO0FBQ2Qsb0JBQVEsS0FBSyxDQUFDO0FBQ2QsZ0JBQUk7QUFDSixxQkFBUztBQUNULG1CQUFPLEtBQUssU0FBUyxDQUFDO0FBQUEsVUFFMUIsV0FBVyxRQUFRO0FBQ2Y7QUFDQSxtQkFBTyxPQUFPLFNBQVMsQ0FBQztBQUN4QixzQkFBVTtBQUFBLFVBRWQ7QUFBTyxtQkFBTztBQUFBLFFBQ2xCO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUVBLE9BQU8sTUFBTTtBQUFFLGVBQU87QUFBQSxNQUFNO0FBQUEsTUFFNUIsWUFBWSxHQUFHLEdBQUc7QUFBRSxlQUFPLEVBQUUsT0FBTyxFQUFFO0FBQUEsTUFBTTtBQUFBLE1BQzVDLFlBQVksR0FBRyxHQUFHO0FBQUUsZUFBTyxFQUFFLE9BQU8sRUFBRTtBQUFBLE1BQU07QUFBQSxNQUU1QyxTQUFTO0FBQUUsZUFBTyxLQUFLO0FBQUEsTUFBTTtBQUFBLE1BRTdCLFNBQVMsTUFBTTtBQUNYLGFBQUssT0FBTztBQUNaLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFFQSxLQUFLLE1BQU0sUUFBUTtBQUNmLGNBQU0sZ0JBQWdCLENBQUM7QUFDdkIsZUFBTyxNQUFNO0FBQ1QsY0FBSSxLQUFLO0FBQU0sbUJBQU8sS0FBSyxHQUFHLEtBQUssUUFBUTtBQUFBO0FBQ3RDLDBCQUFjLEtBQUssR0FBRyxLQUFLLFFBQVE7QUFFeEMsaUJBQU8sY0FBYyxJQUFJO0FBQUEsUUFDN0I7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BRUEsT0FBTyxPQUFPLE1BQU0sT0FBTyxRQUFRO0FBRS9CLGNBQU0sSUFBSSxRQUFRLE9BQU87QUFDekIsWUFBSSxJQUFJLEtBQUs7QUFDYixZQUFJO0FBRUosWUFBSSxLQUFLLEdBQUc7QUFFUixpQkFBTyxXQUFXLE1BQU0sTUFBTSxNQUFNLFFBQVEsQ0FBQyxDQUFDO0FBQzlDLG1CQUFTLE1BQU0sS0FBSyxNQUFNO0FBQzFCLGlCQUFPO0FBQUEsUUFDWDtBQUVBLFlBQUksQ0FBQyxRQUFRO0FBRVQsbUJBQVMsS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQztBQUc1QyxjQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBQUEsUUFDN0M7QUFFQSxlQUFPLFdBQVcsQ0FBQyxDQUFDO0FBQ3BCLGFBQUssT0FBTztBQUNaLGFBQUssU0FBUztBQUlkLGNBQU0sS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDO0FBQzFCLGNBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssQ0FBQyxDQUFDO0FBRXRDLG9CQUFZLE9BQU8sTUFBTSxPQUFPLElBQUksS0FBSyxXQUFXO0FBRXBELGlCQUFTLElBQUksTUFBTSxLQUFLLE9BQU8sS0FBSyxJQUFJO0FBRXBDLGdCQUFNLFNBQVMsS0FBSyxJQUFJLElBQUksS0FBSyxHQUFHLEtBQUs7QUFFekMsc0JBQVksT0FBTyxHQUFHLFFBQVEsSUFBSSxLQUFLLFdBQVc7QUFFbEQsbUJBQVMsSUFBSSxHQUFHLEtBQUssUUFBUSxLQUFLLElBQUk7QUFFbEMsa0JBQU0sU0FBUyxLQUFLLElBQUksSUFBSSxLQUFLLEdBQUcsTUFBTTtBQUcxQyxpQkFBSyxTQUFTLEtBQUssS0FBSyxPQUFPLE9BQU8sR0FBRyxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsVUFDaEU7QUFBQSxRQUNKO0FBRUEsaUJBQVMsTUFBTSxLQUFLLE1BQU07QUFFMUIsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUVBLGVBQWUsTUFBTSxNQUFNQyxRQUFPLE1BQU07QUFDcEMsZUFBTyxNQUFNO0FBQ1QsZUFBSyxLQUFLLElBQUk7QUFFZCxjQUFJLEtBQUssUUFBUSxLQUFLLFNBQVMsTUFBTUE7QUFBTztBQUU1QyxjQUFJLFVBQVU7QUFDZCxjQUFJLGlCQUFpQjtBQUNyQixjQUFJO0FBRUosbUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxTQUFTLFFBQVEsS0FBSztBQUMzQyxrQkFBTSxRQUFRLEtBQUssU0FBUyxDQUFDO0FBQzdCLGtCQUFNLE9BQU8sU0FBUyxLQUFLO0FBQzNCLGtCQUFNLGNBQWMsYUFBYSxNQUFNLEtBQUssSUFBSTtBQUdoRCxnQkFBSSxjQUFjLGdCQUFnQjtBQUM5QiwrQkFBaUI7QUFDakIsd0JBQVUsT0FBTyxVQUFVLE9BQU87QUFDbEMsMkJBQWE7QUFBQSxZQUVqQixXQUFXLGdCQUFnQixnQkFBZ0I7QUFFdkMsa0JBQUksT0FBTyxTQUFTO0FBQ2hCLDBCQUFVO0FBQ1YsNkJBQWE7QUFBQSxjQUNqQjtBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBRUEsaUJBQU8sY0FBYyxLQUFLLFNBQVMsQ0FBQztBQUFBLFFBQ3hDO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUVBLFFBQVEsTUFBTUEsUUFBTyxRQUFRO0FBQ3pCLGNBQU0sT0FBTyxTQUFTLE9BQU8sS0FBSyxPQUFPLElBQUk7QUFDN0MsY0FBTSxhQUFhLENBQUM7QUFHcEIsY0FBTSxPQUFPLEtBQUssZUFBZSxNQUFNLEtBQUssTUFBTUEsUUFBTyxVQUFVO0FBR25FLGFBQUssU0FBUyxLQUFLLElBQUk7QUFDdkIsUUFBQUYsUUFBTyxNQUFNLElBQUk7QUFHakIsZUFBT0UsVUFBUyxHQUFHO0FBQ2YsY0FBSSxXQUFXQSxNQUFLLEVBQUUsU0FBUyxTQUFTLEtBQUssYUFBYTtBQUN0RCxpQkFBSyxPQUFPLFlBQVlBLE1BQUs7QUFDN0IsWUFBQUE7QUFBQSxVQUNKO0FBQU87QUFBQSxRQUNYO0FBR0EsYUFBSyxvQkFBb0IsTUFBTSxZQUFZQSxNQUFLO0FBQUEsTUFDcEQ7QUFBQTtBQUFBLE1BR0EsT0FBTyxZQUFZQSxRQUFPO0FBQ3RCLGNBQU0sT0FBTyxXQUFXQSxNQUFLO0FBQzdCLGNBQU0sSUFBSSxLQUFLLFNBQVM7QUFDeEIsY0FBTSxJQUFJLEtBQUs7QUFFZixhQUFLLGlCQUFpQixNQUFNLEdBQUcsQ0FBQztBQUVoQyxjQUFNLGFBQWEsS0FBSyxrQkFBa0IsTUFBTSxHQUFHLENBQUM7QUFFcEQsY0FBTSxVQUFVLFdBQVcsS0FBSyxTQUFTLE9BQU8sWUFBWSxLQUFLLFNBQVMsU0FBUyxVQUFVLENBQUM7QUFDOUYsZ0JBQVEsU0FBUyxLQUFLO0FBQ3RCLGdCQUFRLE9BQU8sS0FBSztBQUVwQixpQkFBUyxNQUFNLEtBQUssTUFBTTtBQUMxQixpQkFBUyxTQUFTLEtBQUssTUFBTTtBQUU3QixZQUFJQTtBQUFPLHFCQUFXQSxTQUFRLENBQUMsRUFBRSxTQUFTLEtBQUssT0FBTztBQUFBO0FBQ2pELGVBQUssV0FBVyxNQUFNLE9BQU87QUFBQSxNQUN0QztBQUFBLE1BRUEsV0FBVyxNQUFNLFNBQVM7QUFFdEIsYUFBSyxPQUFPLFdBQVcsQ0FBQyxNQUFNLE9BQU8sQ0FBQztBQUN0QyxhQUFLLEtBQUssU0FBUyxLQUFLLFNBQVM7QUFDakMsYUFBSyxLQUFLLE9BQU87QUFDakIsaUJBQVMsS0FBSyxNQUFNLEtBQUssTUFBTTtBQUFBLE1BQ25DO0FBQUEsTUFFQSxrQkFBa0IsTUFBTSxHQUFHLEdBQUc7QUFDMUIsWUFBSTtBQUNKLFlBQUksYUFBYTtBQUNqQixZQUFJLFVBQVU7QUFFZCxpQkFBUyxJQUFJLEdBQUcsS0FBSyxJQUFJLEdBQUcsS0FBSztBQUM3QixnQkFBTSxRQUFRLFNBQVMsTUFBTSxHQUFHLEdBQUcsS0FBSyxNQUFNO0FBQzlDLGdCQUFNLFFBQVEsU0FBUyxNQUFNLEdBQUcsR0FBRyxLQUFLLE1BQU07QUFFOUMsZ0JBQU0sVUFBVSxpQkFBaUIsT0FBTyxLQUFLO0FBQzdDLGdCQUFNLE9BQU8sU0FBUyxLQUFLLElBQUksU0FBUyxLQUFLO0FBRzdDLGNBQUksVUFBVSxZQUFZO0FBQ3RCLHlCQUFhO0FBQ2Isb0JBQVE7QUFFUixzQkFBVSxPQUFPLFVBQVUsT0FBTztBQUFBLFVBRXRDLFdBQVcsWUFBWSxZQUFZO0FBRS9CLGdCQUFJLE9BQU8sU0FBUztBQUNoQix3QkFBVTtBQUNWLHNCQUFRO0FBQUEsWUFDWjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBRUEsZUFBTyxTQUFTLElBQUk7QUFBQSxNQUN4QjtBQUFBO0FBQUEsTUFHQSxpQkFBaUIsTUFBTSxHQUFHLEdBQUc7QUFDekIsY0FBTSxjQUFjLEtBQUssT0FBTyxLQUFLLGNBQWM7QUFDbkQsY0FBTSxjQUFjLEtBQUssT0FBTyxLQUFLLGNBQWM7QUFDbkQsY0FBTSxVQUFVLEtBQUssZUFBZSxNQUFNLEdBQUcsR0FBRyxXQUFXO0FBQzNELGNBQU0sVUFBVSxLQUFLLGVBQWUsTUFBTSxHQUFHLEdBQUcsV0FBVztBQUkzRCxZQUFJLFVBQVU7QUFBUyxlQUFLLFNBQVMsS0FBSyxXQUFXO0FBQUEsTUFDekQ7QUFBQTtBQUFBLE1BR0EsZUFBZSxNQUFNLEdBQUcsR0FBRyxTQUFTO0FBQ2hDLGFBQUssU0FBUyxLQUFLLE9BQU87QUFFMUIsY0FBTSxTQUFTLEtBQUs7QUFDcEIsY0FBTSxXQUFXLFNBQVMsTUFBTSxHQUFHLEdBQUcsTUFBTTtBQUM1QyxjQUFNLFlBQVksU0FBUyxNQUFNLElBQUksR0FBRyxHQUFHLE1BQU07QUFDakQsWUFBSSxTQUFTLFdBQVcsUUFBUSxJQUFJLFdBQVcsU0FBUztBQUV4RCxpQkFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLEdBQUcsS0FBSztBQUM1QixnQkFBTSxRQUFRLEtBQUssU0FBUyxDQUFDO0FBQzdCLFVBQUFGLFFBQU8sVUFBVSxLQUFLLE9BQU8sT0FBTyxLQUFLLElBQUksS0FBSztBQUNsRCxvQkFBVSxXQUFXLFFBQVE7QUFBQSxRQUNqQztBQUVBLGlCQUFTLElBQUksSUFBSSxJQUFJLEdBQUcsS0FBSyxHQUFHLEtBQUs7QUFDakMsZ0JBQU0sUUFBUSxLQUFLLFNBQVMsQ0FBQztBQUM3QixVQUFBQSxRQUFPLFdBQVcsS0FBSyxPQUFPLE9BQU8sS0FBSyxJQUFJLEtBQUs7QUFDbkQsb0JBQVUsV0FBVyxTQUFTO0FBQUEsUUFDbEM7QUFFQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BRUEsb0JBQW9CLE1BQU0sTUFBTUUsUUFBTztBQUVuQyxpQkFBUyxJQUFJQSxRQUFPLEtBQUssR0FBRyxLQUFLO0FBQzdCLFVBQUFGLFFBQU8sS0FBSyxDQUFDLEdBQUcsSUFBSTtBQUFBLFFBQ3hCO0FBQUEsTUFDSjtBQUFBLE1BRUEsVUFBVSxNQUFNO0FBRVosaUJBQVMsSUFBSSxLQUFLLFNBQVMsR0FBRyxVQUFVLEtBQUssR0FBRyxLQUFLO0FBQ2pELGNBQUksS0FBSyxDQUFDLEVBQUUsU0FBUyxXQUFXLEdBQUc7QUFDL0IsZ0JBQUksSUFBSSxHQUFHO0FBQ1AseUJBQVcsS0FBSyxJQUFJLENBQUMsRUFBRTtBQUN2Qix1QkFBUyxPQUFPLFNBQVMsUUFBUSxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFBQSxZQUVoRDtBQUFPLG1CQUFLLE1BQU07QUFBQSxVQUV0QjtBQUFPLHFCQUFTLEtBQUssQ0FBQyxHQUFHLEtBQUssTUFBTTtBQUFBLFFBQ3hDO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQTtBQUFBOzs7QUNySU8sU0FBU0csS0FBSSxPQUFPLFVBQVUsYUFBYSxZQUFZLE9BQU87QUFDbkUsTUFBSSxZQUNGLGFBQWEsU0FDVCxTQUNBLE9BQWUsSUFBSSxVQUFVLGFBQWEsS0FBSztBQUNyRCxNQUFJLENBQUMsV0FBVztBQUNkLGdCQUFZLElBQUk7QUFBQSxNQUNkO0FBQUEsTUFDQSxpQkFBaUIsbUJBQW1CLE1BQU0sT0FBTyxTQUFZO0FBQUEsTUFDN0Q7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFDQSxXQUFlLElBQUksVUFBVSxhQUFhLE9BQU8sU0FBUztBQUFBLEVBQzVEO0FBQ0EsU0FBTztBQUNUO0FBbFNBLElBZUksb0JBRUU7QUFqQk47QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0EsSUFBSSxxQkFBcUI7QUFFekIsSUFBTSxZQUFOLGNBQXdCLGVBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUWxDLFlBQVksT0FBTyxLQUFLLGFBQWEsWUFBWSxPQUFPO0FBQ3RELGNBQU07QUFNTixhQUFLLHFCQUFxQjtBQU0xQixhQUFLLFNBQVM7QUFNZCxhQUFLLGVBQWU7QUFNcEIsYUFBSyxVQUFVLENBQUM7QUFNaEIsYUFBSyxTQUFTO0FBTWQsYUFBSyxjQUFjLGVBQWUsU0FBWSxtQkFBVyxPQUFPO0FBTWhFLGFBQUssUUFDSCxTQUFTLE1BQU0sU0FBUyxNQUFNLFNBQVMsQ0FBQyxNQUFNLE9BQU8sTUFBTSxNQUFNLElBQUk7QUFNdkUsYUFBSyxPQUFPO0FBS1osYUFBSztBQUFBLE1BQ1A7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLG1CQUFtQjtBQUNqQixhQUFLLFNBQVMsSUFBSSxNQUFNO0FBQ3hCLFlBQUksS0FBSyxpQkFBaUIsTUFBTTtBQUM5QixlQUFLLE9BQU8sY0FBYyxLQUFLO0FBQUEsUUFDakM7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGFBQWE7QUFDWCxZQUFJLEtBQUssYUFBYSxVQUFhLEtBQUssZ0JBQWdCLG1CQUFXLFFBQVE7QUFDekUsY0FBSSxDQUFDLG9CQUFvQjtBQUN2QixpQ0FBcUIsc0JBQXNCLEdBQUcsR0FBRyxRQUFXO0FBQUEsY0FDMUQsb0JBQW9CO0FBQUEsWUFDdEIsQ0FBQztBQUFBLFVBQ0g7QUFDQSw2QkFBbUIsVUFBVSxLQUFLLFFBQVEsR0FBRyxDQUFDO0FBQzlDLGNBQUk7QUFDRiwrQkFBbUIsYUFBYSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQzFDLGlCQUFLLFdBQVc7QUFBQSxVQUNsQixTQUFTLEdBQUc7QUFDVixpQ0FBcUI7QUFDckIsaUJBQUssV0FBVztBQUFBLFVBQ2xCO0FBQUEsUUFDRjtBQUNBLGVBQU8sS0FBSyxhQUFhO0FBQUEsTUFDM0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLHVCQUF1QjtBQUNyQixhQUFLLGNBQWMsa0JBQVUsTUFBTTtBQUFBLE1BQ3JDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxvQkFBb0I7QUFDbEIsYUFBSyxjQUFjLG1CQUFXO0FBQzlCLGFBQUsscUJBQXFCO0FBQUEsTUFDNUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLG1CQUFtQjtBQUNqQixhQUFLLGNBQWMsbUJBQVc7QUFDOUIsYUFBSyxRQUFRLENBQUMsS0FBSyxPQUFPLE9BQU8sS0FBSyxPQUFPLE1BQU07QUFDbkQsYUFBSyxxQkFBcUI7QUFBQSxNQUM1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxTQUFTLFlBQVk7QUFDbkIsWUFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixlQUFLLGlCQUFpQjtBQUFBLFFBQ3hCO0FBQ0EsYUFBSyxjQUFjLFVBQVU7QUFDN0IsZUFBTyxLQUFLLFFBQVEsVUFBVSxJQUFJLEtBQUssUUFBUSxVQUFVLElBQUksS0FBSztBQUFBLE1BQ3BFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGNBQWMsWUFBWTtBQUN4QixhQUFLLGNBQWMsVUFBVTtBQUM3QixlQUFPLEtBQUssUUFBUSxVQUFVLElBQUksYUFBYTtBQUFBLE1BQ2pEO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSx1QkFBdUI7QUFDckIsWUFBSSxDQUFDLEtBQUssUUFBUTtBQUNoQixlQUFLLGlCQUFpQjtBQUFBLFFBQ3hCO0FBQ0EsWUFBSSxDQUFDLEtBQUssb0JBQW9CO0FBQzVCLGNBQUksS0FBSyxXQUFXLEdBQUc7QUFDckIsa0JBQU0sUUFBUSxLQUFLLE1BQU0sQ0FBQztBQUMxQixrQkFBTSxTQUFTLEtBQUssTUFBTSxDQUFDO0FBQzNCLGtCQUFNLFVBQVUsc0JBQXNCLE9BQU8sTUFBTTtBQUNuRCxvQkFBUSxTQUFTLEdBQUcsR0FBRyxPQUFPLE1BQU07QUFDcEMsaUJBQUsscUJBQXFCLFFBQVE7QUFBQSxVQUNwQyxPQUFPO0FBQ0wsaUJBQUsscUJBQXFCLEtBQUs7QUFBQSxVQUNqQztBQUFBLFFBQ0Y7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLFVBQVU7QUFDUixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxTQUFTO0FBQ1AsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsT0FBTztBQUNMLFlBQUksS0FBSyxnQkFBZ0IsbUJBQVcsTUFBTTtBQUN4QztBQUFBLFFBQ0Y7QUFDQSxZQUFJLENBQUMsS0FBSyxRQUFRO0FBQ2hCLGVBQUssaUJBQWlCO0FBQUEsUUFDeEI7QUFFQSxhQUFLLGNBQWMsbUJBQVc7QUFDOUIsWUFBSTtBQUNGLGNBQUksS0FBSyxTQUFTLFFBQVc7QUFDSyxZQUFDLEtBQUssT0FBUSxNQUFNLEtBQUs7QUFBQSxVQUMzRDtBQUFBLFFBQ0YsU0FBUyxHQUFHO0FBQ1YsZUFBSyxrQkFBa0I7QUFBQSxRQUN6QjtBQUNBLFlBQUksS0FBSyxrQkFBa0Isa0JBQWtCO0FBQzNDLHlCQUFlLEtBQUssUUFBUSxLQUFLLElBQUksRUFDbEMsS0FBSyxDQUFDLFVBQVU7QUFDZixpQkFBSyxTQUFTO0FBQ2QsaUJBQUssaUJBQWlCO0FBQUEsVUFDeEIsQ0FBQyxFQUNBLE1BQU0sS0FBSyxrQkFBa0IsS0FBSyxJQUFJLENBQUM7QUFBQSxRQUM1QztBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsY0FBYyxZQUFZO0FBQ3hCLFlBQ0UsQ0FBQyxLQUFLLFVBQ04sS0FBSyxRQUFRLFVBQVUsS0FDdkIsS0FBSyxnQkFBZ0IsbUJBQVcsUUFDaEM7QUFDQTtBQUFBLFFBQ0Y7QUFFQSxjQUFNLFFBQVEsS0FBSztBQUNuQixjQUFNLFNBQVMsU0FBUyxjQUFjLFFBQVE7QUFDOUMsZUFBTyxRQUFRLEtBQUssS0FBSyxNQUFNLFFBQVEsVUFBVTtBQUNqRCxlQUFPLFNBQVMsS0FBSyxLQUFLLE1BQU0sU0FBUyxVQUFVO0FBRW5ELGNBQU0sTUFBTSxPQUFPLFdBQVcsSUFBSTtBQUNsQyxZQUFJLE1BQU0sWUFBWSxVQUFVO0FBQ2hDLFlBQUksVUFBVSxPQUFPLEdBQUcsQ0FBQztBQUV6QixZQUFJLDJCQUEyQjtBQUMvQixZQUFJLFlBQVksU0FBUyxLQUFLLE1BQU07QUFDcEMsWUFBSSxTQUFTLEdBQUcsR0FBRyxPQUFPLFFBQVEsWUFBWSxPQUFPLFNBQVMsVUFBVTtBQUV4RSxZQUFJLDJCQUEyQjtBQUMvQixZQUFJLFVBQVUsT0FBTyxHQUFHLENBQUM7QUFFekIsYUFBSyxRQUFRLFVBQVUsSUFBSTtBQUFBLE1BQzdCO0FBQUEsSUFDRjtBQUFBO0FBQUE7OztBQ3hRQTtBQUFBO0FBQUE7QUFBQTtBQStEQSxTQUFTLGVBQWUsT0FBTyxRQUFRLGFBQWEsY0FBYztBQUNoRSxNQUFJLGdCQUFnQixVQUFhLGlCQUFpQixRQUFXO0FBQzNELFdBQU8sQ0FBQyxjQUFjLE9BQU8sZUFBZSxNQUFNO0FBQUEsRUFDcEQ7QUFDQSxNQUFJLGdCQUFnQixRQUFXO0FBQzdCLFdBQU8sY0FBYztBQUFBLEVBQ3ZCO0FBQ0EsTUFBSSxpQkFBaUIsUUFBVztBQUM5QixXQUFPLGVBQWU7QUFBQSxFQUN4QjtBQUNBLFNBQU87QUFDVDtBQTFFQSxJQWlGTSxNQW9lQztBQXJqQlA7QUFBQTtBQUdBO0FBQ0E7QUFDQSxJQUFBQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0VBLElBQU0sT0FBTixNQUFNLGNBQWEsY0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSTVCLFlBQVksU0FBUztBQUNuQixrQkFBVSxXQUFXLENBQUM7QUFLdEIsY0FBTSxVQUFVLFFBQVEsWUFBWSxTQUFZLFFBQVEsVUFBVTtBQUtsRSxjQUFNLFdBQVcsUUFBUSxhQUFhLFNBQVksUUFBUSxXQUFXO0FBS3JFLGNBQU1DLFNBQVEsUUFBUSxVQUFVLFNBQVksUUFBUSxRQUFRO0FBSzVELGNBQU0saUJBQ0osUUFBUSxtQkFBbUIsU0FBWSxRQUFRLGlCQUFpQjtBQUVsRSxjQUFNO0FBQUEsVUFDSjtBQUFBLFVBQ0E7QUFBQSxVQUNBLE9BQU9BO0FBQUEsVUFDUCxjQUNFLFFBQVEsaUJBQWlCLFNBQVksUUFBUSxlQUFlLENBQUMsR0FBRyxDQUFDO0FBQUEsVUFDbkU7QUFBQSxVQUNBLGVBQWUsUUFBUTtBQUFBLFFBQ3pCLENBQUM7QUFNRCxhQUFLLFVBQVUsUUFBUSxXQUFXLFNBQVksUUFBUSxTQUFTLENBQUMsS0FBSyxHQUFHO0FBTXhFLGFBQUssb0JBQW9CO0FBTXpCLGFBQUssZ0JBQ0gsUUFBUSxpQkFBaUIsU0FBWSxRQUFRLGVBQWU7QUFNOUQsYUFBSyxnQkFDSCxRQUFRLGlCQUFpQixTQUFZLFFBQVEsZUFBZTtBQU05RCxhQUFLLGdCQUNILFFBQVEsaUJBQWlCLFNBQVksUUFBUSxlQUFlO0FBTTlELGFBQUssZUFDSCxRQUFRLGdCQUFnQixTQUFZLFFBQVEsY0FBYztBQUU1RCxjQUFNLFFBQVEsUUFBUSxRQUFRLFNBQVksUUFBUSxNQUFNO0FBRXhELFlBQUksV0FBVyxRQUFRO0FBRXZCO0FBQUEsVUFDRSxFQUFFLGFBQWEsVUFBYTtBQUFBLFVBQzVCO0FBQUEsUUFDRjtBQUVBLGFBQUssYUFBYSxVQUFhLFNBQVMsV0FBVyxNQUFNLE9BQU87QUFDOUQ7QUFBQSxVQUE0QyxNQUFPLE9BQU8sT0FBTyxLQUFLO0FBQUEsUUFDeEU7QUFDQTtBQUFBLFVBQ0UsYUFBYSxVQUFhLFNBQVMsU0FBUztBQUFBLFVBQzVDO0FBQUEsUUFDRjtBQUVBO0FBQUEsVUFDRSxHQUNHLFFBQVEsVUFBVSxVQUFhLFFBQVEsV0FBVyxXQUNuRCxRQUFRLFVBQVU7QUFBQSxVQUVwQjtBQUFBLFFBQ0Y7QUFFQSxZQUFJO0FBQ0osWUFBSSxRQUFRLFFBQVEsUUFBVztBQUM3Qix1QkFBYSxtQkFBVztBQUFBLFFBQzFCLFdBQVcsVUFBVSxRQUFXO0FBQzlCLGNBQUksaUJBQWlCLGtCQUFrQjtBQUNyQyxnQkFBSSxNQUFNLFVBQVU7QUFDbEIsMkJBQWEsTUFBTSxNQUFNLG1CQUFXLFNBQVMsbUJBQVc7QUFBQSxZQUMxRCxPQUFPO0FBQ0wsMkJBQWEsbUJBQVc7QUFBQSxZQUMxQjtBQUFBLFVBQ0YsT0FBTztBQUNMLHlCQUFhLG1CQUFXO0FBQUEsVUFDMUI7QUFBQSxRQUNGO0FBTUEsYUFBSyxTQUFTLFFBQVEsVUFBVSxTQUFZLFFBQVEsUUFBUSxLQUFLLElBQUk7QUFNckUsYUFBSyxhQUFhQztBQUFBLFVBQ2hCO0FBQUE7QUFBQSxVQUN1QjtBQUFBLFVBQ3ZCLEtBQUs7QUFBQSxVQUNMO0FBQUEsVUFDQSxLQUFLO0FBQUEsUUFDUDtBQU1BLGFBQUssVUFBVSxRQUFRLFdBQVcsU0FBWSxRQUFRLFNBQVMsQ0FBQyxHQUFHLENBQUM7QUFLcEUsYUFBSyxnQkFDSCxRQUFRLGlCQUFpQixTQUFZLFFBQVEsZUFBZTtBQU05RCxhQUFLLFVBQVU7QUFNZixhQUFLLFFBQVEsUUFBUSxTQUFTLFNBQVksUUFBUSxPQUFPO0FBS3pELFlBQUksUUFBUSxVQUFVLFVBQWEsUUFBUSxXQUFXLFFBQVc7QUFDL0QsY0FBSSxPQUFPO0FBQ1gsY0FBSSxRQUFRLE1BQU07QUFDaEIsYUFBQyxPQUFPLE1BQU0sSUFBSSxRQUFRO0FBQUEsVUFDNUIsT0FBTztBQUNMLGtCQUFNQyxTQUFRLEtBQUssU0FBUyxDQUFDO0FBQzdCLGdCQUFJQSxPQUFNLFNBQVNBLE9BQU0sUUFBUTtBQUMvQixzQkFBUUEsT0FBTTtBQUNkLHVCQUFTQSxPQUFNO0FBQUEsWUFDakIsV0FBV0Esa0JBQWlCLGtCQUFrQjtBQUM1QyxtQkFBSyxrQkFBa0I7QUFDdkIsb0JBQU0sU0FBUyxNQUFNO0FBQ25CLHFCQUFLLG9CQUFvQixNQUFNO0FBQy9CLG9CQUFJLENBQUMsS0FBSyxpQkFBaUI7QUFDekI7QUFBQSxnQkFDRjtBQUNBLHNCQUFNLFlBQVksS0FBSyxXQUFXLFFBQVE7QUFDMUMscUJBQUs7QUFBQSxrQkFDSDtBQUFBLG9CQUNFLFVBQVUsQ0FBQztBQUFBLG9CQUNYLFVBQVUsQ0FBQztBQUFBLG9CQUNYLFFBQVE7QUFBQSxvQkFDUixRQUFRO0FBQUEsa0JBQ1Y7QUFBQSxnQkFDRjtBQUFBLGNBQ0Y7QUFDQSxtQkFBSyxrQkFBa0IsTUFBTTtBQUM3QjtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQ0EsY0FBSSxVQUFVLFFBQVc7QUFDdkIsaUJBQUs7QUFBQSxjQUNILGVBQWUsT0FBTyxRQUFRLFFBQVEsT0FBTyxRQUFRLE1BQU07QUFBQSxZQUM3RDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFFBQVE7QUFDTixZQUFJRixRQUFPLE9BQU87QUFDbEIsWUFBSSxLQUFLLGlCQUFpQjtBQUN4QixrQkFBUSxLQUFLLGdCQUFnQjtBQUM3QixtQkFBUyxLQUFLLGdCQUFnQjtBQUFBLFFBQ2hDLE9BQU87QUFDTCxVQUFBQSxTQUFRLEtBQUssU0FBUztBQUN0QixVQUFBQSxTQUFRLE1BQU0sUUFBUUEsTUFBSyxJQUFJQSxPQUFNLE1BQU0sSUFBSUE7QUFBQSxRQUNqRDtBQUNBLGVBQU8sSUFBSSxNQUFLO0FBQUEsVUFDZCxRQUFRLEtBQUssUUFBUSxNQUFNO0FBQUEsVUFDM0IsY0FBYyxLQUFLO0FBQUEsVUFDbkIsY0FBYyxLQUFLO0FBQUEsVUFDbkIsY0FBYyxLQUFLO0FBQUEsVUFDbkIsT0FDRSxLQUFLLFVBQVUsS0FBSyxPQUFPLFFBQ3ZCLEtBQUssT0FBTyxNQUFNLElBQ2xCLEtBQUssVUFBVTtBQUFBLFVBQ3JCLGFBQWEsS0FBSztBQUFBLFVBQ2xCLFFBQVEsS0FBSyxRQUFRLE1BQU07QUFBQSxVQUMzQixjQUFjLEtBQUs7QUFBQSxVQUNuQixTQUFTLEtBQUssV0FBVztBQUFBLFVBQ3pCLGdCQUFnQixLQUFLLGtCQUFrQjtBQUFBLFVBQ3ZDLFVBQVUsS0FBSyxZQUFZO0FBQUEsVUFDM0IsT0FBQUE7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsTUFBTSxLQUFLLFVBQVUsT0FBTyxLQUFLLE1BQU0sTUFBTSxJQUFJO0FBQUEsVUFDakQsS0FBSyxLQUFLLE9BQU87QUFBQSxVQUNqQixjQUFjLEtBQUssZ0JBQWdCLEVBQUUsTUFBTTtBQUFBLFVBQzNDLGVBQWUsS0FBSyxpQkFBaUI7QUFBQSxRQUN2QyxDQUFDO0FBQUEsTUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsWUFBWTtBQUNWLFlBQUksU0FBUyxLQUFLO0FBQ2xCLFlBQUksQ0FBQyxRQUFRO0FBQ1gsbUJBQVMsS0FBSztBQUNkLGdCQUFNLE9BQU8sS0FBSyxRQUFRO0FBQzFCLGNBQ0UsS0FBSyxpQkFBaUIsY0FDdEIsS0FBSyxpQkFBaUIsWUFDdEI7QUFDQSxnQkFBSSxDQUFDLE1BQU07QUFDVCxxQkFBTztBQUFBLFlBQ1Q7QUFDQSxxQkFBUyxLQUFLLFFBQVEsTUFBTTtBQUM1QixnQkFBSSxLQUFLLGlCQUFpQixZQUFZO0FBQ3BDLHFCQUFPLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxZQUNyQjtBQUNBLGdCQUFJLEtBQUssaUJBQWlCLFlBQVk7QUFDcEMscUJBQU8sQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLFlBQ3JCO0FBQUEsVUFDRjtBQUVBLGNBQUksS0FBSyxpQkFBaUIsWUFBWTtBQUNwQyxnQkFBSSxDQUFDLE1BQU07QUFDVCxxQkFBTztBQUFBLFlBQ1Q7QUFDQSxnQkFBSSxXQUFXLEtBQUssU0FBUztBQUMzQix1QkFBUyxLQUFLLFFBQVEsTUFBTTtBQUFBLFlBQzlCO0FBQ0EsZ0JBQ0UsS0FBSyxpQkFBaUIsZUFDdEIsS0FBSyxpQkFBaUIsZ0JBQ3RCO0FBQ0EscUJBQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDO0FBQUEsWUFDakM7QUFDQSxnQkFDRSxLQUFLLGlCQUFpQixpQkFDdEIsS0FBSyxpQkFBaUIsZ0JBQ3RCO0FBQ0EscUJBQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDO0FBQUEsWUFDakM7QUFBQSxVQUNGO0FBQ0EsZUFBSyxvQkFBb0I7QUFBQSxRQUMzQjtBQUNBLGNBQU0sZUFBZSxLQUFLLGdCQUFnQjtBQUMxQyxjQUFNQSxTQUFRLEtBQUssY0FBYztBQUdqQyxlQUFPO0FBQUEsVUFDTCxPQUFPLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSUEsT0FBTSxDQUFDO0FBQUEsVUFDckMsT0FBTyxDQUFDLElBQUksYUFBYSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFFBQ3ZDO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxVQUFVLFFBQVE7QUFDaEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxvQkFBb0I7QUFBQSxNQUMzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFdBQVc7QUFDVCxlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLFNBQVMsWUFBWTtBQUNuQixlQUFPLEtBQUssV0FBVyxTQUFTLFVBQVU7QUFBQSxNQUM1QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsY0FBYyxZQUFZO0FBQ3hCLGVBQU8sS0FBSyxXQUFXLGNBQWMsVUFBVTtBQUFBLE1BQ2pEO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxlQUFlO0FBQ2IsZUFBTyxLQUFLLFdBQVcsUUFBUTtBQUFBLE1BQ2pDO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxnQkFBZ0I7QUFDZCxlQUFPLEtBQUssV0FBVyxjQUFjO0FBQUEsTUFDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLHVCQUF1QjtBQUNyQixlQUFPLEtBQUssV0FBVyxxQkFBcUI7QUFBQSxNQUM5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVk7QUFDVixZQUFJLEtBQUssU0FBUztBQUNoQixpQkFBTyxLQUFLO0FBQUEsUUFDZDtBQUNBLFlBQUksU0FBUyxLQUFLO0FBRWxCLFlBQUksS0FBSyxpQkFBaUIsWUFBWTtBQUNwQyxnQkFBTSxPQUFPLEtBQUssUUFBUTtBQUMxQixnQkFBTSxnQkFBZ0IsS0FBSyxXQUFXLFFBQVE7QUFDOUMsY0FBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlO0FBQzNCLG1CQUFPO0FBQUEsVUFDVDtBQUNBLG1CQUFTLE9BQU8sTUFBTTtBQUN0QixjQUNFLEtBQUssaUJBQWlCLGVBQ3RCLEtBQUssaUJBQWlCLGdCQUN0QjtBQUNBLG1CQUFPLENBQUMsSUFBSSxjQUFjLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUM7QUFBQSxVQUNuRDtBQUNBLGNBQ0UsS0FBSyxpQkFBaUIsaUJBQ3RCLEtBQUssaUJBQWlCLGdCQUN0QjtBQUNBLG1CQUFPLENBQUMsSUFBSSxjQUFjLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUM7QUFBQSxVQUNuRDtBQUFBLFFBQ0Y7QUFDQSxhQUFLLFVBQVU7QUFDZixlQUFPLEtBQUs7QUFBQSxNQUNkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsU0FBUztBQUNQLGVBQU8sS0FBSyxXQUFXLE9BQU87QUFBQSxNQUNoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFVBQVU7QUFDUixlQUFPLENBQUMsS0FBSyxRQUFRLEtBQUssV0FBVyxRQUFRLElBQUksS0FBSztBQUFBLE1BQ3hEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsV0FBVztBQUNULGNBQU1BLFNBQVEsS0FBSyxjQUFjO0FBQ2pDLFlBQUksS0FBSyxPQUFPO0FBQ2QsaUJBQU8sS0FBSyxNQUFNLENBQUMsSUFBSUEsT0FBTSxDQUFDO0FBQUEsUUFDaEM7QUFDQSxZQUFJLEtBQUssV0FBVyxjQUFjLEtBQUssbUJBQVcsUUFBUTtBQUN4RCxpQkFBTyxLQUFLLFdBQVcsUUFBUSxFQUFFLENBQUMsSUFBSUEsT0FBTSxDQUFDO0FBQUEsUUFDL0M7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVk7QUFDVixjQUFNQSxTQUFRLEtBQUssY0FBYztBQUNqQyxZQUFJLEtBQUssT0FBTztBQUNkLGlCQUFPLEtBQUssTUFBTSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFFBQ2hDO0FBQ0EsWUFBSSxLQUFLLFdBQVcsY0FBYyxLQUFLLG1CQUFXLFFBQVE7QUFDeEQsaUJBQU8sS0FBSyxXQUFXLFFBQVEsRUFBRSxDQUFDLElBQUlBLE9BQU0sQ0FBQztBQUFBLFFBQy9DO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFNBQVNBLFFBQU87QUFDZCxlQUFPLEtBQUs7QUFDWixjQUFNLFNBQVNBLE1BQUs7QUFBQSxNQUN0QjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esa0JBQWtCLFVBQVU7QUFDMUIsYUFBSyxXQUFXLGlCQUFpQixrQkFBVSxRQUFRLFFBQVE7QUFBQSxNQUM3RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxPQUFPO0FBQ0wsYUFBSyxXQUFXLEtBQUs7QUFBQSxNQUN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0Esb0JBQW9CLFVBQVU7QUFDNUIsYUFBSyxXQUFXLG9CQUFvQixrQkFBVSxRQUFRLFFBQVE7QUFBQSxNQUNoRTtBQUFBLElBQ0Y7QUFFQSxJQUFPLGVBQVE7QUFBQTtBQUFBOzs7QUN4YVIsU0FBUyxTQUFTLE1BQU07QUFDN0IsUUFBTUcsU0FBUSxDQUFDO0FBQ2YsYUFBVyxhQUFhLFlBQVk7QUFDbEMsUUFBSSxhQUFhLE1BQU0sU0FBUyxHQUFHO0FBQ2pDLE1BQUFBLE9BQU0sS0FBSyxVQUFVLFNBQVMsQ0FBQztBQUFBLElBQ2pDO0FBQUEsRUFDRjtBQUNBLE1BQUlBLE9BQU0sV0FBVyxHQUFHO0FBQ3RCLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSUEsT0FBTSxTQUFTLEdBQUc7QUFDcEIsV0FBT0EsT0FBTSxLQUFLLE1BQU07QUFBQSxFQUMxQjtBQUNBLFNBQU9BLE9BQU0sTUFBTSxHQUFHLEVBQUUsRUFBRSxLQUFLLElBQUksSUFBSSxVQUFVQSxPQUFNQSxPQUFNLFNBQVMsQ0FBQztBQUN6RTtBQU9PLFNBQVMsYUFBYSxPQUFPLFVBQVU7QUFDNUMsVUFBUSxRQUFRLGNBQWM7QUFDaEM7QUFPTyxTQUFTLGFBQWEsU0FBUyxXQUFXO0FBQy9DLFNBQU8sQ0FBQyxFQUFFLFVBQVU7QUFDdEI7QUFPTyxTQUFTLE9BQU8sTUFBTSxVQUFVO0FBQ3JDLFNBQU8sU0FBUztBQUNsQjtBQTZDTyxTQUFTLG9CQUFvQjtBQUNsQyxTQUFPO0FBQUEsSUFDTCxXQUFXLG9CQUFJLElBQUk7QUFBQSxJQUNuQixZQUFZLG9CQUFJLElBQUk7QUFBQSxJQUNwQixXQUFXO0FBQUEsSUFDWCxPQUFPLENBQUM7QUFBQSxFQUNWO0FBQ0Y7QUFNQSxTQUFTLGdCQUFnQixVQUFVO0FBQ2pDLFVBQVEsVUFBVTtBQUFBLElBQ2hCLEtBQUs7QUFDSCxhQUFPO0FBQUEsSUFDVCxLQUFLO0FBQ0gsYUFBTztBQUFBLElBQ1QsS0FBSztBQUNILGFBQU87QUFBQSxJQUNULEtBQUs7QUFDSCxhQUFPO0FBQUEsSUFDVCxLQUFLO0FBQ0gsYUFBTztBQUFBLElBQ1Q7QUFDRSxZQUFNLElBQUksTUFBTSwyQkFBMkIsUUFBUSxFQUFFO0FBQUEsRUFDekQ7QUFDRjtBQVlPLFNBQVNDLE9BQU0sU0FBUyxTQUFTLFVBQVU7QUFDaEQsVUFBUSxPQUFPLFNBQVM7QUFBQSxJQUN0QixLQUFLLFdBQVc7QUFDZCxhQUFPLElBQUksa0JBQWtCLGFBQWEsT0FBTztBQUFBLElBQ25EO0FBQUEsSUFDQSxLQUFLLFVBQVU7QUFDYixhQUFPLElBQUksa0JBQWtCLFlBQVksT0FBTztBQUFBLElBQ2xEO0FBQUEsSUFDQSxLQUFLLFVBQVU7QUFDYixVQUFJQyxRQUFPO0FBQ1gsVUFBSSxjQUFjLE9BQU8sR0FBRztBQUMxQixRQUFBQSxTQUFRO0FBQUEsTUFDVjtBQUVBLFVBQUksQ0FBQyxPQUFPQSxRQUFPLFVBQVUsUUFBUSxHQUFHO0FBQ3RDLFFBQUFBLFNBQVE7QUFBQSxNQUNWO0FBQ0EsYUFBTyxJQUFJLGtCQUFrQkEsT0FBTSxPQUFPO0FBQUEsSUFDNUM7QUFBQSxJQUNBLFNBQVM7QUFBQSxJQUVUO0FBQUEsRUFDRjtBQUVBLE1BQUksQ0FBQyxNQUFNLFFBQVEsT0FBTyxHQUFHO0FBQzNCLFVBQU0sSUFBSSxNQUFNLGtEQUFrRDtBQUFBLEVBQ3BFO0FBRUEsTUFBSSxRQUFRLFdBQVcsR0FBRztBQUN4QixVQUFNLElBQUksTUFBTSxrQkFBa0I7QUFBQSxFQUNwQztBQUVBLE1BQUksT0FBTyxRQUFRLENBQUMsTUFBTSxVQUFVO0FBQ2xDLFdBQU8sb0JBQW9CLFNBQVMsU0FBUyxRQUFRO0FBQUEsRUFDdkQ7QUFFQSxhQUFXLFFBQVEsU0FBUztBQUMxQixRQUFJLE9BQU8sU0FBUyxVQUFVO0FBQzVCLFlBQU0sSUFBSSxNQUFNLDhCQUE4QjtBQUFBLElBQ2hEO0FBQUEsRUFDRjtBQUVBLE1BQUksT0FBTztBQUNYLE1BQUksUUFBUSxXQUFXLEtBQUssUUFBUSxXQUFXLEdBQUc7QUFDaEQsWUFBUTtBQUFBLEVBQ1Y7QUFDQSxNQUFJLFVBQVU7QUFDWixZQUFRO0FBQUEsRUFDVjtBQUNBLFNBQU8sSUFBSSxrQkFBa0IsTUFBTSxPQUFPO0FBQzVDO0FBcVRBLFNBQVMsWUFBWSxTQUFTLFNBQVM7QUFDckMsUUFBTSxNQUFNRCxPQUFNLFFBQVEsQ0FBQyxHQUFHLE9BQU87QUFDckMsTUFBSSxFQUFFLGVBQWUsb0JBQW9CO0FBQ3ZDLFVBQU0sSUFBSSxNQUFNLCtDQUErQztBQUFBLEVBQ2pFO0FBQ0EsTUFBSSxPQUFPLElBQUksVUFBVSxVQUFVO0FBQ2pDLFVBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUFBLEVBQ2hFO0FBQ0EsVUFBUSxXQUFXLElBQUksSUFBSSxLQUFLO0FBQ2hDLE1BQUksUUFBUSxXQUFXLEdBQUc7QUFDeEIsVUFBTSxPQUFPQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLE9BQU87QUFDdEMsV0FBTyxDQUFDLEtBQUssSUFBSTtBQUFBLEVBQ25CO0FBQ0EsU0FBTyxDQUFDLEdBQUc7QUFDYjtBQUtBLFNBQVMsWUFBWSxTQUFTLFNBQVMsWUFBWSxVQUFVO0FBQzNELFFBQU0sVUFBVSxRQUFRLENBQUM7QUFDekIsTUFBSSxPQUFPLFlBQVksVUFBVTtBQUMvQixVQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFBQSxFQUNoRTtBQUNBLFVBQVEsVUFBVSxJQUFJLE9BQU87QUFDN0IsTUFDRSxFQUFFLGVBQWUsUUFBUSxVQUN6QixRQUFRLE1BQU0sVUFBVSxPQUFPLE1BQU0sUUFDckM7QUFDQSxXQUFPLENBQUMsSUFBSSxrQkFBa0IsU0FBUyxPQUFPLENBQUM7QUFBQSxFQUNqRDtBQUNBLFFBQU0sZUFBZSxRQUFRLE1BQU0sVUFBVSxPQUFPO0FBQ3BELFFBQU07QUFBQTtBQUFBLElBQXdDQSxPQUFNLGNBQWMsT0FBTztBQUFBO0FBQ3pFLE1BQUksUUFBUTtBQUNaLE1BQUksWUFBWSxDQUFDLGFBQWEsVUFBVSxJQUFJLElBQUksR0FBRztBQUNqRCxVQUFNLElBQUk7QUFBQSxNQUNSLGdCQUFnQixPQUFPLGFBQWE7QUFBQSxRQUNsQyxJQUFJO0FBQUEsTUFDTixDQUFDLHlDQUF5QyxTQUFTLFFBQVEsQ0FBQztBQUFBLElBQzlEO0FBQUEsRUFDRjtBQUNBLFNBQU8sQ0FBQyxHQUFHO0FBQ2I7QUFLQSxTQUFTLGNBQWMsU0FBUyxTQUFTO0FBQ3ZDLFVBQVEsWUFBWTtBQUN0QjtBQUtBLFNBQVMsV0FBVyxTQUFTLFNBQVM7QUFDcEMsUUFBTSxZQUFZLFFBQVEsQ0FBQztBQUMzQixNQUFJLFFBQVEsV0FBVyxHQUFHO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLDZCQUE2QixTQUFTLFlBQVk7QUFBQSxFQUNwRTtBQUNBLFNBQU8sQ0FBQztBQUNWO0FBT0EsU0FBUyxjQUFjLFNBQVMsU0FBUztBQUN2QyxTQUFPLFNBQVUsU0FBUyxTQUFTO0FBQ2pDLFVBQU0sWUFBWSxRQUFRLENBQUM7QUFDM0IsVUFBTSxXQUFXLFFBQVEsU0FBUztBQUNsQyxRQUFJLFlBQVksU0FBUztBQUN2QixVQUFJLGFBQWEsU0FBUztBQUN4QixjQUFNLFNBQVMsWUFBWSxJQUFJLEtBQUs7QUFDcEMsY0FBTSxJQUFJO0FBQUEsVUFDUixZQUFZLE9BQU8sWUFBWSxNQUFNLFFBQVEsU0FBUyxTQUFTLFFBQVE7QUFBQSxRQUN6RTtBQUFBLE1BQ0Y7QUFBQSxJQUNGLFdBQVcsV0FBVyxXQUFXLFdBQVcsU0FBUztBQUNuRCxZQUFNLFFBQ0osWUFBWSxXQUNSLEdBQUcsT0FBTyxhQUNWLEdBQUcsT0FBTyxPQUFPLE9BQU87QUFDOUIsWUFBTSxJQUFJO0FBQUEsUUFDUixZQUFZLEtBQUssa0JBQWtCLFNBQVMsU0FBUyxRQUFRO0FBQUEsTUFDL0Q7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGO0FBTUEsU0FBUyxnQkFBZ0IsU0FBUztBQUNoQyxTQUFPLFNBQVUsU0FBUyxTQUFTO0FBQ2pDLFVBQU0sWUFBWSxRQUFRLENBQUM7QUFDM0IsVUFBTSxXQUFXLFFBQVEsU0FBUztBQUlsQyxVQUFNLE9BQU8sSUFBSSxNQUFNLFFBQVE7QUFDL0IsYUFBUyxJQUFJLEdBQUcsSUFBSSxVQUFVLEVBQUUsR0FBRztBQUNqQyxZQUFNLGFBQWFBLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxPQUFPO0FBQ2hELFVBQUksQ0FBQyxhQUFhLFNBQVMsV0FBVyxJQUFJLEdBQUc7QUFDM0MsY0FBTSxVQUFVLFNBQVMsT0FBTztBQUNoQyxjQUFNLGVBQWUsU0FBUyxXQUFXLElBQUk7QUFDN0MsY0FBTSxJQUFJO0FBQUEsVUFDUixnQ0FBZ0MsQ0FBQyxPQUFPLFNBQVMsbUJBQ3RDLE9BQU8saUJBQWlCLFlBQVk7QUFBQSxRQUNqRDtBQUFBLE1BQ0Y7QUFDQSxpQkFBVyxRQUFRO0FBQ25CLFdBQUssQ0FBQyxJQUFJO0FBQUEsSUFDWjtBQUNBLFdBQU87QUFBQSxFQUNUO0FBQ0Y7QUFLQSxTQUFTLGVBQWUsU0FBUyxTQUFTLFlBQVk7QUFDcEQsUUFBTSxZQUFZLFFBQVEsQ0FBQztBQUMzQixRQUFNLFdBQVcsUUFBUSxTQUFTO0FBR2xDLE1BQUksV0FBVztBQUNmLFdBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxRQUFRLEVBQUUsR0FBRztBQUMxQyxnQkFBWSxXQUFXLENBQUMsRUFBRTtBQUFBLEVBQzVCO0FBRUEsTUFBSSxhQUFhLFVBQVU7QUFDekIsVUFBTSxJQUFJO0FBQUEsTUFDUixrREFBa0QsU0FBUztBQUFBLElBQzdEO0FBQUEsRUFDRjtBQUdBLFFBQU0sT0FBTyxJQUFJLE1BQU0sUUFBUTtBQUMvQixXQUFTLElBQUksR0FBRyxJQUFJLFVBQVUsRUFBRSxHQUFHO0FBQ2pDLFNBQUssQ0FBQyxJQUFJQSxPQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsU0FBUyxRQUFRO0FBQUEsRUFDbkQ7QUFDQSxTQUFPO0FBQ1Q7QUFLQSxTQUFTLFlBQVksU0FBUyxTQUFTO0FBQ3JDLFFBQU0sWUFBWSxRQUFRLENBQUM7QUFDM0IsUUFBTSxXQUFXLFFBQVEsU0FBUztBQUNsQyxNQUFJLFdBQVcsTUFBTSxHQUFHO0FBQ3RCLFVBQU0sSUFBSTtBQUFBLE1BQ1IseURBQXlELFNBQVMsU0FBUyxLQUFLO0FBQUEsUUFDOUU7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUNGO0FBS0EsU0FBUyxhQUFhLFNBQVMsU0FBUztBQUN0QyxRQUFNLFlBQVksUUFBUSxDQUFDO0FBQzNCLFFBQU0sV0FBVyxRQUFRLFNBQVM7QUFDbEMsTUFBSSxXQUFXLE1BQU0sR0FBRztBQUN0QixVQUFNLElBQUk7QUFBQSxNQUNSLDBEQUEwRCxTQUFTLFNBQVMsS0FBSztBQUFBLFFBQy9FO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFDRjtBQUtBLFNBQVMsZUFBZSxTQUFTLFNBQVMsWUFBWSxVQUFVO0FBQzlELFFBQU0sWUFBWSxRQUFRLFNBQVM7QUFFbkMsUUFBTSxRQUFRQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLE9BQU87QUFDdkMsTUFBSSxZQUFZLE1BQU07QUFDdEIsUUFBTSxXQUFXQSxPQUFNLFFBQVEsUUFBUSxTQUFTLENBQUMsR0FBRyxPQUFPO0FBQzNELE1BQUksYUFDRixhQUFhLFNBQVksV0FBVyxTQUFTLE9BQU8sU0FBUztBQUcvRCxRQUFNLE9BQU8sSUFBSSxNQUFNLFlBQVksQ0FBQztBQUNwQyxXQUFTLElBQUksR0FBRyxJQUFJLFlBQVksR0FBRyxLQUFLLEdBQUc7QUFDekMsVUFBTSxRQUFRQSxPQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsT0FBTztBQUMzQyxVQUFNLFNBQVNBLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxPQUFPO0FBQzVDLGlCQUFhLE1BQU07QUFDbkIsa0JBQWMsT0FBTztBQUNyQixTQUFLLENBQUMsSUFBSTtBQUNWLFNBQUssSUFBSSxDQUFDLElBQUk7QUFBQSxFQUNoQjtBQUdBLFFBQU0sb0JBQW9CLGFBQWEsYUFBYTtBQUNwRCxNQUFJLENBQUMsYUFBYSxtQkFBbUIsU0FBUyxHQUFHO0FBQy9DLFVBQU0sSUFBSTtBQUFBLE1BQ1IsNkJBQTZCO0FBQUEsUUFDM0I7QUFBQSxNQUNGLENBQUMsdUNBQTRDLFNBQVMsU0FBUyxDQUFDO0FBQUEsSUFDbEU7QUFBQSxFQUNGO0FBQ0EsTUFBSSxPQUFPLFlBQVksUUFBUSxHQUFHO0FBQ2hDLFVBQU0sSUFBSTtBQUFBLE1BQ1IsNEVBQ0UsS0FBSyxVQUFVLE9BQU87QUFBQSxJQUMxQjtBQUFBLEVBQ0Y7QUFHQSxXQUFTLElBQUksR0FBRyxJQUFJLFlBQVksR0FBRyxLQUFLLEdBQUc7QUFDekMsVUFBTSxRQUFRQSxPQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsU0FBUyxTQUFTO0FBQ3RELFVBQU0sU0FBU0EsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsVUFBVTtBQUN4RCxTQUFLLENBQUMsSUFBSTtBQUNWLFNBQUssSUFBSSxDQUFDLElBQUk7QUFBQSxFQUNoQjtBQUVBLFNBQU87QUFBQSxJQUNMQSxPQUFNLFFBQVEsQ0FBQyxHQUFHLFNBQVMsU0FBUztBQUFBLElBQ3BDLEdBQUc7QUFBQSxJQUNIQSxPQUFNLFFBQVEsUUFBUSxTQUFTLENBQUMsR0FBRyxTQUFTLFVBQVU7QUFBQSxFQUN4RDtBQUNGO0FBS0EsU0FBUyxxQkFBcUIsU0FBUyxTQUFTLFlBQVksVUFBVTtBQUNwRSxRQUFNLG9CQUFvQixRQUFRLENBQUM7QUFDbkMsTUFBSTtBQUNKLFVBQVEsa0JBQWtCLENBQUMsR0FBRztBQUFBLElBQzVCLEtBQUs7QUFDSCxzQkFBZ0I7QUFDaEI7QUFBQSxJQUNGLEtBQUs7QUFDSCxzQkFBZ0Isa0JBQWtCLENBQUM7QUFDbkMsVUFBSSxPQUFPLGtCQUFrQixVQUFVO0FBQ3JDLGNBQU0sSUFBSTtBQUFBLFVBQ1IsNkRBQ1csS0FBSyxVQUFVLGFBQWEsQ0FBQztBQUFBLFFBQzFDO0FBQUEsTUFDRjtBQUNBO0FBQUEsSUFDRjtBQUNFLHNCQUFnQjtBQUFBLEVBQ3BCO0FBQ0EsTUFBSSxDQUFDLGVBQWU7QUFDbEIsVUFBTSxJQUFJO0FBQUEsTUFDUiwrQkFBK0IsS0FBSyxVQUFVLGlCQUFpQixDQUFDO0FBQUEsSUFDbEU7QUFBQSxFQUNGO0FBQ0Esa0JBQWdCQSxPQUFNLGVBQWUsT0FBTztBQUc1QyxNQUFJLFFBQVFBLE9BQU0sUUFBUSxDQUFDLEdBQUcsT0FBTztBQUNyQyxNQUFJLENBQUMsYUFBYSxZQUFZLE1BQU0sSUFBSSxHQUFHO0FBQ3pDLFVBQU0sSUFBSTtBQUFBLE1BQ1IsdUVBQ1csU0FBUyxNQUFNLElBQUksQ0FBQztBQUFBLElBQ2pDO0FBQUEsRUFDRjtBQUNBLFVBQVFBLE9BQU0sUUFBUSxDQUFDLEdBQUcsU0FBUyxVQUFVO0FBRTdDLFFBQU0sT0FBTyxJQUFJLE1BQU0sUUFBUSxTQUFTLENBQUM7QUFDekMsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSyxHQUFHO0FBQ3ZDLFFBQUksT0FBT0EsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLE9BQU87QUFDeEMsUUFBSSxDQUFDLGFBQWEsWUFBWSxLQUFLLElBQUksR0FBRztBQUN4QyxZQUFNLElBQUk7QUFBQSxRQUNSLHlGQUNXLFNBQVMsS0FBSyxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQztBQUFBLE1BQ3JEO0FBQUEsSUFDRjtBQUNBLFFBQUksU0FBU0EsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLE9BQU87QUFDMUMsUUFBSSxDQUFDLGFBQWEsYUFBYSxXQUFXLE9BQU8sSUFBSSxHQUFHO0FBQ3RELFlBQU0sSUFBSTtBQUFBLFFBQ1IsNkZBQ1csU0FBUyxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDO0FBQUEsTUFDdkQ7QUFBQSxJQUNGO0FBRUEsV0FBT0EsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsVUFBVTtBQUNoRCxhQUFTQSxPQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsU0FBUyxhQUFhLFNBQVM7QUFDOUQsU0FBSyxDQUFDLElBQUk7QUFDVixTQUFLLElBQUksQ0FBQyxJQUFJO0FBQUEsRUFDaEI7QUFFQSxTQUFPLENBQUMsZUFBZSxPQUFPLEdBQUcsSUFBSTtBQUN2QztBQUtBLFNBQVMsY0FBYyxTQUFTLFNBQVMsWUFBWSxVQUFVO0FBQzdELFFBQU0sV0FBV0EsT0FBTSxRQUFRLFFBQVEsU0FBUyxDQUFDLEdBQUcsT0FBTztBQUMzRCxNQUFJLGFBQ0YsYUFBYSxTQUFZLFdBQVcsU0FBUyxPQUFPLFNBQVM7QUFHL0QsUUFBTSxPQUFPLElBQUksTUFBTSxRQUFRLFNBQVMsQ0FBQztBQUN6QyxXQUFTLElBQUksR0FBRyxJQUFJLEtBQUssU0FBUyxHQUFHLEtBQUssR0FBRztBQUMzQyxVQUFNLFlBQVlBLE9BQU0sUUFBUSxJQUFJLENBQUMsR0FBRyxPQUFPO0FBQy9DLFVBQU0sU0FBU0EsT0FBTSxRQUFRLElBQUksQ0FBQyxHQUFHLE9BQU87QUFDNUMsUUFBSSxDQUFDLGFBQWEsYUFBYSxVQUFVLElBQUksR0FBRztBQUM5QyxZQUFNLElBQUk7QUFBQSxRQUNSLDRFQUNXLFNBQVMsVUFBVSxJQUFJLENBQUMsZ0JBQWdCLENBQUM7QUFBQSxNQUN0RDtBQUFBLElBQ0Y7QUFDQSxrQkFBYyxPQUFPO0FBQ3JCLFNBQUssQ0FBQyxJQUFJO0FBQ1YsU0FBSyxJQUFJLENBQUMsSUFBSTtBQUFBLEVBQ2hCO0FBRUEsTUFBSSxPQUFPLFlBQVksUUFBUSxHQUFHO0FBQ2hDLFVBQU0sSUFBSTtBQUFBLE1BQ1IsMkVBQ0UsS0FBSyxVQUFVLE9BQU87QUFBQSxJQUMxQjtBQUFBLEVBQ0Y7QUFHQSxXQUFTLElBQUksR0FBRyxJQUFJLEtBQUssU0FBUyxHQUFHLEtBQUssR0FBRztBQUMzQyxTQUFLLElBQUksQ0FBQyxJQUFJQSxPQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsU0FBUyxVQUFVO0FBQUEsRUFDekQ7QUFDQSxPQUFLLEtBQUssU0FBUyxDQUFDLElBQUlBO0FBQUEsSUFDdEIsUUFBUSxRQUFRLFNBQVMsQ0FBQztBQUFBLElBQzFCO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFFQSxTQUFPO0FBQ1Q7QUFLQSxTQUFTLFlBQVksU0FBUyxTQUFTO0FBRXJDLE1BQUk7QUFBQTtBQUFBLElBQStCLFFBQVEsQ0FBQztBQUFBO0FBQzVDLE1BQUksQ0FBQyxNQUFNLFFBQVEsUUFBUSxHQUFHO0FBQzVCLFVBQU0sSUFBSTtBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksT0FBTyxTQUFTLENBQUMsTUFBTSxVQUFVO0FBQ25DLFFBQUksU0FBUyxDQUFDLE1BQU0sV0FBVztBQUM3QixZQUFNLElBQUk7QUFBQSxRQUNSO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxRQUFJLENBQUMsTUFBTSxRQUFRLFNBQVMsQ0FBQyxDQUFDLEdBQUc7QUFDL0IsWUFBTSxJQUFJO0FBQUEsUUFDUjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsZUFBVyxTQUFTLENBQUM7QUFBQSxFQUN2QjtBQUVBLE1BQUksYUFBYSxhQUFhO0FBQzlCLFFBQU0sT0FBTyxJQUFJLE1BQU0sU0FBUyxNQUFNO0FBQ3RDLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDcEMsVUFBTSxNQUFNQSxPQUFNLFNBQVMsQ0FBQyxHQUFHLE9BQU87QUFDdEMsa0JBQWMsSUFBSTtBQUNsQixTQUFLLENBQUMsSUFBSTtBQUFBLEVBQ1o7QUFDQSxNQUFJLE9BQU8sWUFBWSxRQUFRLEdBQUc7QUFDaEMsVUFBTSxJQUFJO0FBQUEsTUFDUixrRUFDRSxLQUFLLFVBQVUsT0FBTztBQUFBLElBQzFCO0FBQUEsRUFDRjtBQUVBLFFBQU0sU0FBU0EsT0FBTSxRQUFRLENBQUMsR0FBRyxTQUFTLFVBQVU7QUFDcEQsU0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJO0FBQ3pCO0FBS0EsU0FBUyxpQkFBaUIsU0FBUyxTQUFTO0FBQzFDLFFBQU0sUUFBUUEsT0FBTSxRQUFRLENBQUMsR0FBRyxTQUFTLFVBQVU7QUFDbkQsTUFBSSxNQUFNLFNBQVMsWUFBWTtBQUM3QixVQUFNLElBQUk7QUFBQSxNQUNSLHdEQUF3RDtBQUFBLFFBQ3RELE1BQU07QUFBQSxNQUNSLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUNBLFFBQU0sU0FBUyxRQUFRLENBQUM7QUFDeEIsTUFBSSxDQUFDLE1BQU0sUUFBUSxNQUFNLEdBQUc7QUFDMUIsVUFBTSxJQUFJLE1BQU0saURBQWlEO0FBQUEsRUFDbkU7QUFDQSxRQUFNLGVBQWUsSUFBSSxNQUFNLE9BQU8sTUFBTTtBQUM1QyxXQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsUUFBUSxLQUFLO0FBQzVDLFVBQU0sUUFBUUEsT0FBTSxPQUFPLENBQUMsR0FBRyxTQUFTLFNBQVM7QUFDakQsUUFBSSxFQUFFLGlCQUFpQixvQkFBb0I7QUFDekMsWUFBTSxJQUFJO0FBQUEsUUFDUiw4QkFBOEIsQ0FBQztBQUFBLE1BQ2pDO0FBQUEsSUFDRjtBQUNBLFFBQUksQ0FBQyxhQUFhLE1BQU0sTUFBTSxTQUFTLEdBQUc7QUFDeEMsWUFBTSxJQUFJO0FBQUEsUUFDUiw4QkFBOEIsQ0FBQyxpQ0FBaUM7QUFBQSxVQUM5RCxNQUFNO0FBQUEsUUFDUixDQUFDO0FBQUEsTUFDSDtBQUFBLElBQ0Y7QUFDQSxpQkFBYSxDQUFDLElBQUk7QUFBQSxFQUNwQjtBQUNBLFNBQU8sQ0FBQyxPQUFPLEdBQUcsWUFBWTtBQUNoQztBQVNBLFNBQVMsYUFBYSxlQUFlLGVBQWU7QUFDbEQsU0FBTyxTQUFVLFNBQVMsU0FBUyxVQUFVO0FBQzNDLFVBQU0sV0FBVyxRQUFRLENBQUM7QUFDMUIsUUFBSSxhQUFhLENBQUM7QUFDbEIsYUFBUyxJQUFJLEdBQUcsSUFBSSxjQUFjLFFBQVEsS0FBSztBQUM3QyxtQkFDRSxjQUFjLENBQUMsRUFBRSxTQUFTLFNBQVMsWUFBWSxRQUFRLEtBQUs7QUFBQSxJQUNoRTtBQUNBLFFBQUksYUFDRixPQUFPLGVBQWUsYUFBYSxXQUFXLFVBQVUsSUFBSTtBQUM5RCxRQUFJLGFBQWEsUUFBVztBQUMxQixVQUFJLENBQUMsYUFBYSxZQUFZLFFBQVEsR0FBRztBQUN2QyxjQUFNLElBQUk7QUFBQSxVQUNSLG1EQUFtRDtBQUFBLFlBQ2pEO0FBQUEsVUFDRixDQUFDLGlCQUFpQixTQUFTLFVBQVUsQ0FBQyxhQUFhLEtBQUs7QUFBQSxZQUN0RDtBQUFBLFVBQ0YsQ0FBQztBQUFBLFFBQ0g7QUFBQSxNQUNGO0FBQ0Esb0JBQWM7QUFBQSxJQUNoQjtBQUNBLFFBQUksZUFBZSxVQUFVO0FBQzNCLFlBQU0sSUFBSTtBQUFBLFFBQ1IsNERBQTRELEtBQUs7QUFBQSxVQUMvRDtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0g7QUFBQSxJQUNGO0FBQ0EsV0FBTyxJQUFJLGVBQWUsWUFBWSxVQUFVLEdBQUcsVUFBVTtBQUFBLEVBQy9EO0FBQ0Y7QUFRQSxTQUFTLG9CQUFvQixTQUFTLFNBQVMsVUFBVTtBQUN2RCxRQUFNLFdBQVcsUUFBUSxDQUFDO0FBRTFCLFFBQU0sU0FBUyxRQUFRLFFBQVE7QUFDL0IsTUFBSSxDQUFDLFFBQVE7QUFDWCxVQUFNLElBQUksTUFBTSxxQkFBcUIsUUFBUSxFQUFFO0FBQUEsRUFDakQ7QUFDQSxTQUFPLE9BQU8sU0FBUyxTQUFTLFFBQVE7QUFDMUM7QUExa0NBLElBcUhJLFVBQ1MsVUFDQSxhQUNBLFlBQ0EsWUFDQSxXQUNBLGlCQUNBLFNBRVAsV0FRQSxZQXNETyxtQkFXQSxnQkEySEEsS0FzRFA7QUF4WE47QUFBQTtBQUdBO0FBQ0E7QUFpSEEsSUFBSSxXQUFXO0FBQ1IsSUFBTSxXQUFXO0FBQ2pCLElBQU0sY0FBYyxLQUFLO0FBQ3pCLElBQU0sYUFBYSxLQUFLO0FBQ3hCLElBQU0sYUFBYSxLQUFLO0FBQ3hCLElBQU0sWUFBWSxLQUFLO0FBQ3ZCLElBQU0sa0JBQWtCLEtBQUs7QUFDN0IsSUFBTSxVQUFVLEtBQUssSUFBSSxHQUFHLFFBQVEsSUFBSTtBQUUvQyxJQUFNLFlBQVk7QUFBQSxNQUNoQixDQUFDLFdBQVcsR0FBRztBQUFBLE1BQ2YsQ0FBQyxVQUFVLEdBQUc7QUFBQSxNQUNkLENBQUMsVUFBVSxHQUFHO0FBQUEsTUFDZCxDQUFDLFNBQVMsR0FBRztBQUFBLE1BQ2IsQ0FBQyxlQUFlLEdBQUc7QUFBQSxJQUNyQjtBQUVBLElBQU0sYUFBYSxPQUFPLEtBQUssU0FBUyxFQUFFLElBQUksTUFBTSxFQUFFLEtBQUssU0FBUztBQXNEN0QsSUFBTSxvQkFBTixNQUF3QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLN0IsWUFBWSxNQUFNLE9BQU87QUFDdkIsYUFBSyxPQUFPO0FBQ1osYUFBSyxRQUFRO0FBQUEsTUFDZjtBQUFBLElBQ0Y7QUFFTyxJQUFNLGlCQUFOLE1BQXFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTTFCLFlBQVksTUFBTSxhQUFhLE1BQU07QUFDbkMsYUFBSyxPQUFPO0FBQ1osYUFBSyxXQUFXO0FBQ2hCLGFBQUssT0FBTztBQUFBLE1BQ2Q7QUFBQSxJQUNGO0FBZ0hPLElBQU0sTUFBTTtBQUFBLE1BQ2pCLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLFFBQVE7QUFBQSxNQUNSLGNBQWM7QUFBQSxNQUNkLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLFlBQVk7QUFBQSxNQUNaLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLFVBQVU7QUFBQSxNQUNWLGFBQWE7QUFBQSxNQUNiLHNCQUFzQjtBQUFBLE1BQ3RCLFVBQVU7QUFBQSxNQUNWLG1CQUFtQjtBQUFBLE1BQ25CLFVBQVU7QUFBQSxNQUNWLFFBQVE7QUFBQSxNQUNSLEtBQUs7QUFBQSxNQUNMLFVBQVU7QUFBQSxNQUNWLE9BQU87QUFBQSxNQUNQLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLE9BQU87QUFBQSxNQUNQLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLFNBQVM7QUFBQSxNQUNULGFBQWE7QUFBQSxNQUNiLE1BQU07QUFBQSxNQUNOLElBQUk7QUFBQSxNQUNKLFFBQVE7QUFBQSxNQUNSLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxNQUNQLE9BQU87QUFBQSxNQUNQLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFNBQVM7QUFBQSxJQUNYO0FBVUEsSUFBTSxVQUFVO0FBQUEsTUFDZCxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVCxDQUFDLENBQUMsR0FBRyxRQUFRLE1BQU07QUFDakIsY0FBSSxhQUFhLFFBQVc7QUFDMUIsbUJBQU87QUFBQTtBQUFBO0FBQUEsY0FFK0IsU0FBVTtBQUFBLFlBRWhEO0FBQUEsVUFDRjtBQUNBLGlCQUFPO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNULENBQUMsQ0FBQyxRQUFRLE1BQU0sU0FBUztBQUFBLFFBQ3pCLGNBQWMsR0FBRyxDQUFDO0FBQUEsUUFDbEI7QUFBQSxNQUNGO0FBQUEsTUFDQSxDQUFDLElBQUksRUFBRSxHQUFHLGFBQWEsYUFBYSxZQUFZLFlBQVksYUFBYTtBQUFBLE1BQ3pFLENBQUMsSUFBSSxNQUFNLEdBQUc7QUFBQSxRQUNaO0FBQUEsUUFDQSxjQUFjLEdBQUcsUUFBUTtBQUFBLFFBQ3pCLGdCQUFnQixPQUFPO0FBQUEsTUFDekI7QUFBQSxNQUNBLENBQUMsSUFBSSxZQUFZLEdBQUcsYUFBYSxZQUFZLFVBQVU7QUFBQSxNQUN2RCxDQUFDLElBQUksVUFBVSxHQUFHLGFBQWEsWUFBWSxVQUFVO0FBQUEsTUFDckQsQ0FBQyxJQUFJLElBQUksR0FBRyxhQUFhLFlBQVksVUFBVTtBQUFBLE1BQy9DLENBQUMsSUFBSSxJQUFJLEdBQUcsYUFBYSxZQUFZLFVBQVU7QUFBQSxNQUMvQyxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLFFBQVE7QUFBQSxRQUN6QixnQkFBZ0IsV0FBVztBQUFBLE1BQzdCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLFFBQVE7QUFBQSxRQUN6QixnQkFBZ0IsV0FBVztBQUFBLE1BQzdCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsV0FBVztBQUFBLE1BQzdCO0FBQUEsTUFDQSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsUUFDWDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsT0FBTztBQUFBLFFBQ3ZCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsQ0FBQyxJQUFJLFFBQVEsR0FBRztBQUFBLFFBQ2Q7QUFBQSxRQUNBLGNBQWMsR0FBRyxDQUFDO0FBQUEsUUFDbEIsZ0JBQWdCLE9BQU87QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLENBQUMsSUFBSSxXQUFXLEdBQUc7QUFBQSxRQUNqQjtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsT0FBTztBQUFBLFFBQ3ZCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsQ0FBQyxJQUFJLG9CQUFvQixHQUFHO0FBQUEsUUFDMUI7QUFBQSxRQUNBLGNBQWMsR0FBRyxDQUFDO0FBQUEsUUFDbEIsZ0JBQWdCLE9BQU87QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxNQUNBLENBQUMsSUFBSSxRQUFRLEdBQUc7QUFBQSxRQUNkO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixPQUFPO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQUEsTUFDQSxDQUFDLElBQUksaUJBQWlCLEdBQUc7QUFBQSxRQUN2QjtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsT0FBTztBQUFBLFFBQ3ZCO0FBQUEsTUFDRjtBQUFBLE1BQ0EsQ0FBQyxJQUFJLFFBQVEsR0FBRztBQUFBLFFBQ2QsQ0FBQyxlQUFlO0FBQ2QsY0FBSSxhQUFhLGFBQWE7QUFDOUIsbUJBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxRQUFRLEtBQUs7QUFDMUMsMEJBQWMsV0FBVyxDQUFDLEVBQUU7QUFBQSxVQUM5QjtBQUNBLGlCQUFPO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLFFBQVE7QUFBQSxRQUN6QixnQkFBZ0IsYUFBYSxTQUFTO0FBQUEsUUFDdEM7QUFBQSxNQUNGO0FBQUEsTUFDQSxDQUFDLElBQUksTUFBTSxHQUFHO0FBQUEsUUFDWjtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLFFBQVE7QUFBQSxRQUN6QixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksUUFBUSxHQUFHO0FBQUEsUUFDZDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsUUFDWDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsUUFDWDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksSUFBSSxHQUFHO0FBQUEsUUFDVjtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsUUFDWDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFDQSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsUUFDVDtBQUFBLFFBQ0EsY0FBYyxHQUFHLENBQUM7QUFBQSxRQUNsQixnQkFBZ0IsVUFBVTtBQUFBLE1BQzVCO0FBQUEsTUFD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QUFHLElBQUksSUFBSSxRQUFRLEVBQUUsVUFBVTtBQUUzQyxVQUFNLFlBQVksRUFBRSxlQUFlLENBQUNELE1BQUtDLElBQUcsQ0FBQztBQUFBLEVBQ2pEO0FBRUEsTUFBSSxHQUFHLGFBQWEsWUFBWTtBQUNoQyxNQUFJLEdBQUcsV0FBVyxZQUFZO0FBQzlCLFNBQU8sVUFBVSxJQUFJLFVBQVU7QUFDL0IsU0FBTyxJQUFJLE9BQU8sTUFBTSxVQUFVO0FBQ3RDO0FBRUEsT0FBTyxjQUFjLElBQUksQ0FBQztBQUMxQixPQUFPLGNBQWMsRUFBRSxjQUFjOyIsCiAgIm5hbWVzIjogWyJ0cmFuc2Zvcm0iLCAiY29vcmRpbmF0ZXMiLCAiZXF1YWxzIiwgImV4dGVuZCIsICJpc0VtcHR5IiwgImludGVyc2VjdHMiLCAibmFtZXMiLCAidG9TdHJpbmciLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAiaW5pdF9FdmVudFR5cGUiLCAiUkFESVVTIiwgIkVYVEVOVCIsICJNRVRFUlNfUEVSX1VOSVQiLCAiUFJPSkVDVElPTlMiLCAiY2xlYXIiLCAiY2FjaGUiLCAiY2xlYXIiLCAiYWRkIiwgImdldCIsICJ0cmFuc2Zvcm0iLCAiYWRkIiwgImVxdWFscyIsICJzY2FsZSIsICJ3cmFwWCIsICJnZXQiLCAiZGlzYWJsZSIsICJhZGQiLCAidG9FUFNHNDMyNiIsICJjbGVhciIsICJlcXVhbHMiLCAidHJhbnNmb3JtIiwgIlBST0pFQ1RJT05TIiwgIm5vbmUiLCAidHJhbnNmb3JtIiwgInJvdGF0ZSIsICJzY2FsZSIsICJpbml0X3RyYW5zZm9ybSIsICJpbml0X3RyYW5zZm9ybSIsICJ0cmFuc2Zvcm0iLCAiY2xvbmUiLCAiZXh0ZW50IiwgImdldCIsICJzY2FsZSIsICJ0cmFuc2Zvcm0iLCAiaW5pdF90cmFuc2Zvcm0iLCAiY29vcmRpbmF0ZXMiLCAicm90YXRlIiwgInNjYWxlIiwgInNxdWFyZWREaXN0YW5jZSIsICJjb29yZGluYXRlcyIsICJzcXVhcmVkRGlzdGFuY2UiLCAiY29vcmRpbmF0ZXMiLCAiY29vcmRpbmF0ZXMiLCAiY29vcmRpbmF0ZXMiLCAic3F1YXJlZERpc3RhbmNlIiwgImlzRW1wdHkiLCAiY29vcmRpbmF0ZXMiLCAibGluZWFyUmluZyIsICJsaW5lYXJSaW5ncyIsICJub25lIiwgImVxdWFscyIsICJhZGQiLCAiaXNFbXB0eSIsICJ1c2VyUHJvamVjdGlvbiIsICJpbml0X0V2ZW50VHlwZSIsICJsYXllclN0YXRlIiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgIkV2ZW50X2RlZmF1bHQiLCAiaW5pdF9FdmVudCIsICJjYW52YXNQb29sIiwgImNhY2hlIiwgInRyYW5zZm9ybSIsICJzY2FsZSIsICJzY2FsZSIsICJnZXQiLCAic2VsZiIsICJMYXllcl9kZWZhdWx0IiwgImluaXRfTGF5ZXIiLCAiY2FudmFzUG9vbCIsICJMYXllcl9kZWZhdWx0IiwgImluaXRfTGF5ZXIiLCAiaW5pdF9FdmVudCIsICJpbml0X0V2ZW50VHlwZSIsICJ0cmFuc2Zvcm0iLCAiRXZlbnRfZGVmYXVsdCIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJjbG9uZSIsICJpbml0X0ltYWdlIiwgInNjYWxlIiwgInRvU3RyaW5nIiwgImluaXRfSW1hZ2UiLCAic2NhbGUiLCAiYWRkIiwgInNjYWxlIiwgInNjYWxlIiwgImV4dGVuZCIsICJpbnRlcnNlY3RzIiwgImxldmVsIiwgImdldCIsICJpbml0X0ltYWdlIiwgInNjYWxlIiwgImdldCIsICJpbWFnZSIsICJuYW1lcyIsICJwYXJzZSIsICJ0eXBlIiwgInBhcnNlIiwgImV4cHJlc3Npb24iLCAiY29udGV4dCIsICJhbHdheXMiLCAiY29udGV4dCIsICJQcm9wZXJ0eSIsICJjb29yZGluYXRlcyIsICJmaWxsSW5zdHJ1Y3Rpb24iLCAiY29vcmRpbmF0ZXMiLCAiY29vcmRpbmF0ZXMiLCAicDEiLCAicDIiLCAicDMiLCAic2NhbGUiLCAic2NhbGUiLCAibWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoIiwgImNhY2hlIiwgInJvdGF0ZSIsICJpbml0X3RyYW5zZm9ybSIsICJpbml0X3RyYW5zZm9ybSIsICJzY2FsZSIsICJ0ZXh0IiwgInAxIiwgInAyIiwgInAzIiwgInA0IiwgImZpbGxJbnN0cnVjdGlvbiIsICJzdHJva2VJbnN0cnVjdGlvbiIsICJ0cmFuc2Zvcm0iLCAiaW50ZXJzZWN0cyIsICJpIiwgImlpIiwgImluaXRfdHJhbnNmb3JtIiwgInRyYW5zZm9ybSIsICJpIiwgInJlc3VsdCIsICJpbml0X3RyYW5zZm9ybSIsICJ0cmFuc2Zvcm0iLCAiaW5pdF9zdHlsZSIsICJ0cmFuc2Zvcm1zIiwgImkiLCAiZ2VvbWV0cnkiLCAiaW5pdF9zdHlsZSIsICJ0cmFuc2Zvcm0iLCAiaW1hZ2VSZXBsYXkiLCAiaW5pdF9MYXllciIsICJpbml0X0V2ZW50VHlwZSIsICJMYXllcl9kZWZhdWx0IiwgInRyYW5zZm9ybSIsICJjYW52YXNQb29sIiwgInJlbmRlciIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJ0cmFuc2Zvcm1zIiwgIndyYXBYIiwgInVzZXJQcm9qZWN0aW9uIiwgImV4dGVudCIsICJ1c2VyRXh0ZW50IiwgIlJCdXNoIiwgImVxdWFscyIsICJ0bXBUcmFuc2Zvcm0iLCAiRmVhdHVyZV9kZWZhdWx0IiwgImluaXRfRmVhdHVyZSIsICJpbml0X3RyYW5zZm9ybSIsICJ0cmFuc2Zvcm0iLCAiZ2V0IiwgInNjYWxlIiwgImFsbCIsICJmb3JtYXQiLCAieGhyIiwgIlZlY3Rvcl9leHBvcnRzIiwgIlZlY3Rvcl9kZWZhdWx0IiwgImluaXRfVmVjdG9yIiwgImluaXRfRmVhdHVyZSIsICJhbGwiLCAiRmVhdHVyZV9kZWZhdWx0IiwgImVxdWFscyIsICJWQVJTIiwgIkVWRU5UX1RZUEUiLCAiQ09OVFJPTF9UWVBFIiwgIlRBUkdFVF9UWVBFIiwgIlBST1ZJREVSUyIsICJERUZBVUxUX09QVElPTlMiLCAicHJvdmlkZXIiLCAibGFiZWwiLCAicGxhY2Vob2xkZXIiLCAiZmVhdHVyZVN0eWxlIiwgInRhcmdldFR5cGUiLCAibGFuZyIsICJsaW1pdCIsICJrZWVwT3BlbiIsICJwcmV2ZW50RGVmYXVsdCIsICJwcmV2ZW50UGFubmluZyIsICJwcmV2ZW50TWFya2VyIiwgImRlZmF1bHRGbHlSZXNvbHV0aW9uIiwgImRlYnVnIiwgImFzc2VydCIsICJjb25kaXRpb24iLCAibWVzc2FnZSIsICJFcnJvciIsICJyYW5kb21JZCIsICJwcmVmaXgiLCAiaWQiLCAid2luZG93IiwgInBlcmZvcm1hbmNlIiwgIm5vd09mZnNldCIsICJEYXRlIiwgIm5vdyIsICJ0aW1pbmciLCAibmF2aWdhdGlvblN0YXJ0IiwgInRvU3RyaW5nIiwgImlzTnVtZXJpYyIsICJzdHIiLCAidGVzdCIsICJhZGRDbGFzcyIsICJlbGVtZW50IiwgImNsYXNzbmFtZSIsICJ0aW1lb3V0IiwgIkFycmF5IiwgImlzQXJyYXkiLCAiZm9yRWFjaCIsICJlYWNoIiwgImFycmF5IiwgInNwbGl0IiwgImkiLCAibGVuZ3RoIiwgImhhc0NsYXNzIiwgIl9hZGRDbGFzcyIsICJyZW1vdmVDbGFzcyIsICJfcmVtb3ZlQ2xhc3MiLCAiYyIsICJjbGFzc0xpc3QiLCAiY29udGFpbnMiLCAiY2xhc3NSZWdleCIsICJjbGFzc05hbWUiLCAidGVtcGxhdGUiLCAiaHRtbCIsICJyb3ciLCAicmVwbGFjZSIsICJodG0iLCAia2V5IiwgInZhbHVlIiwgIlN0cmluZyIsICJyZXBsYWNlQWxsIiwgImNyZWF0ZUVsZW1lbnQiLCAibm9kZSIsICJlbGVtIiwgImRvY3VtZW50IiwgImF0dHIiLCAic2V0QXR0cmlidXRlIiwgIm5hbWUiLCAiaW5uZXJIVE1MIiwgImZyYWciLCAiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsICJjaGlsZE5vZGVzIiwgImFwcGVuZCIsICJSZWdFeHAiLCAiZWwiLCAia2xhc3MiLCAiYWRkIiwgInRyaW0iLCAic2V0VGltZW91dCIsICJyZW1vdmUiLCAia2xhc3NlcyIsICJjc3NDbGFzc2VzIiwgIkh0bWwiLCAib3B0aW9ucyIsICJ0aGlzIiwgImVscyIsICJjcmVhdGVDb250cm9sIiwgImNvbnRhaW5lciIsICJjb250YWluZXJDbGFzcyIsICJlbGVtZW50cyIsICJuYW1lc3BhY2UiLCAiaW5wdXRUZXh0IiwgImNvbnRhaW5lcklkIiwgImlucHV0IiwgImNvbnRyb2wiLCAicXVlcnlTZWxlY3RvciIsICJzZWFyY2giLCAicmVzdWx0IiwgImdsYXNzIiwgImJ1dHRvbiIsICJqc29uIiwgIm9iaiIsICJQcm9taXNlIiwgInJlc29sdmUiLCAicmVqZWN0IiwgInVybCIsICJkYXRhIiwgInRvUXVlcnlTdHJpbmciLCAiY29uZmlnIiwgIm1ldGhvZCIsICJtb2RlIiwgImNyZWRlbnRpYWxzIiwgImpzb25wIiwgImNhbGxiYWNrIiwgImhlYWQiLCAic2NyaXB0IiwgImNhbGxiYWNrTmFtZSIsICJNYXRoIiwgInJvdW5kIiwgInJhbmRvbSIsICJpbmRleE9mIiwgInJlbW92ZUNoaWxkIiwgImZldGNoIiwgInRoZW4iLCAiciIsICJjYXRjaCIsICJPYmplY3QiLCAia2V5cyIsICJyZWR1Y2UiLCAiYWNjIiwgImsiLCAicHVzaCIsICJlbmNvZGVVUklDb21wb25lbnQiLCAiam9pbiIsICJvbENvbnRyb2wiLCAiYnV0dG9uQ29udHJvbElkIiwgImlucHV0UXVlcnlJZCIsICJpbnB1dFNlYXJjaElkIiwgImhpZGRlbiIsICJpY29uIiwgIlBob3RvbiIsICJjb25zdHJ1Y3RvciIsICJzZXR0aW5ncyIsICJwYXJhbXMiLCAicSIsICJsYW5ncyIsICJ0b0xvd2VyQ2FzZSIsICJxdWVyeSIsICJpbmNsdWRlcyIsICJyZXN1bHRzIiwgImZlYXR1cmVzIiwgIm1hcCIsICJsb24iLCAiZ2VvbWV0cnkiLCAiY29vcmRpbmF0ZXMiLCAibGF0IiwgImFkZHJlc3MiLCAicHJvcGVydGllcyIsICJwb3N0Y29kZSIsICJjaXR5IiwgInN0YXRlIiwgImNvdW50cnkiLCAib3JpZ2luYWwiLCAiZm9ybWF0dGVkIiwgImRldGFpbHMiLCAiT3BlblN0cmVldCIsICJmb3JtYXQiLCAiYWRkcmVzc2RldGFpbHMiLCAiY291bnRyeWNvZGVzIiwgInZpZXdib3giLCAib3B0IiwgImJib3giLCAiYm91bmRpbmdib3giLCAiZGlzcGxheV9uYW1lIiwgInJvYWQiLCAiaG91c2VOdW1iZXIiLCAiaG91c2VfbnVtYmVyIiwgInRvd24iLCAiTWFwUXVlc3QiLCAibmVpZ2hib3VyaG9vZCIsICJCaW5nIiwgImluY2x1ZGVOZWlnaGJvcmhvb2QiLCAibWF4UmVzdWx0cyIsICJyZXNvdXJjZXMiLCAicmVzb3VyY2VTZXRzIiwgInBvaW50IiwgImZvcm1hdHRlZEFkZHJlc3MiLCAiT3BlbkNhZ2UiLCAiY291bnRyeWNvZGUiLCAicHJldHR5IiwgIm5vX2Fubm90YXRpb25zIiwgImxuZyIsICJjb21wb25lbnRzIiwgIk5vbWluYXRpbSIsICJiYXNlIiwgIkJhc2UiLCAibGF5ZXJOYW1lIiwgImxheWVyIiwgIkxheWVyVmVjdG9yIiwgInNvdXJjZSIsICJTb3VyY2VWZWN0b3IiLCAiZGlzcGxheUluTGF5ZXJTd2l0Y2hlciIsICJuZXdQcm92aWRlciIsICJsYXN0UXVlcnkiLCAicmVnaXN0ZXJlZExpc3RlbmVycyIsICJtYXBDbGljayIsICJzZXRMaXN0ZW5lcnMiLCAib3BlblNlYXJjaCIsICJldnQiLCAic3RvcFByb3BhZ2F0aW9uIiwgImV4cGFuZGVkIiwgImNvbGxhcHNlIiwgImV4cGFuZCIsICJhZGRFdmVudExpc3RlbmVyIiwgInRhcmdldCIsICJ3aGljaCIsICJrZXlDb2RlIiwgImZvY3VzIiwgInBhcmFtZXRlcnMiLCAiZ2V0UGFyYW1ldGVycyIsICJmaXJzdENoaWxkIiwgImNsZWFyUmVzdWx0cyIsICJzcGluIiwgImFqYXgiLCAicmVzIiwgImNvbnNvbGUiLCAiaW5mbyIsICJyZXNfIiwgImhhbmRsZVJlc3BvbnNlIiwgImNyZWF0ZUxpc3QiLCAibGlzdGVuTWFwQ2xpY2siLCAibGkiLCAicmVzcG9uc2UiLCAidWwiLCAiYWRkcmVzc0h0bWwiLCAiYWRkcmVzc1RlbXBsYXRlIiwgImNob3NlbiIsICJwbGFjZSIsICJhZGRyZXNzT2JqIiwgImFkZHJlc3NPcmlnaW5hbCIsICJnZXRNYXAiLCAiY29vcmRfIiwgIk51bWJlciIsICJwYXJzZUZsb2F0IiwgInByb2plY3Rpb24iLCAiZ2V0VmlldyIsICJnZXRQcm9qZWN0aW9uIiwgImNvb3JkIiwgInByb2oiLCAidHJhbnNmb3JtIiwgInRyYW5zZm9ybUV4dGVudCIsICJkaXNwYXRjaEV2ZW50IiwgInR5cGUiLCAiY29vcmRpbmF0ZSIsICJmZWF0dXJlIiwgImNyZWF0ZUZlYXR1cmUiLCAiZml0IiwgImR1cmF0aW9uIiwgImFuaW1hdGUiLCAiY2VudGVyIiwgInJlc29sdXRpb24iLCAiRmVhdHVyZSIsICJQb2ludCIsICJhZGRMYXllciIsICJzZXRTdHlsZSIsICJzZXRJZCIsICJnZXRTb3VyY2UiLCAiYWRkRmVhdHVyZSIsICJidWlsZGluZyIsICJ2aWxsYWdlIiwgImJsdXIiLCAidGhhdCIsICJtYXBFbGVtZW50IiwgImdldFRhcmdldEVsZW1lbnQiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJmb3VuZCIsICJnZXRMYXllcnMiLCAiQ29udHJvbCIsICJTdHlsZSIsICJpbWFnZSIsICJJY29uIiwgInNjYWxlIiwgInNyYyIsICIkbm9taW5hdGltIiwgIiRodG1sIiwgInN1cGVyIiwgImdldExheWVyIiwgIndyYXBYIiwgImNvb3JkaW5hdGVzIiwgImNhbGxiYWNrIiwgImluaXRfRXZlbnQiLCAiaW5pdF9FdmVudFR5cGUiLCAiRXZlbnRfZGVmYXVsdCIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJQcm9wZXJ0eSIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJuZXdFdmVudCIsICJpbml0X0V2ZW50VHlwZSIsICJ0cmFuc2Zvcm0iLCAiY29udGFpbnMiLCAiUHJvcGVydHlfZGVmYXVsdCIsICJQcm9wZXJ0eV9kZWZhdWx0IiwgImNlbnRyb2lkIiwgIm1hcCIsICJjb29yZGluYXRlcyIsICJkZWZhdWx0cyIsICJkZWZhdWx0cyIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJpc0VtcHR5IiwgImVxdWFscyIsICJNYXBfZGVmYXVsdCIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJmb3JtYXQiLCAiZ2V0IiwgInVzZXJQcm9qZWN0aW9uIiwgIndyYXBYIiwgImV4dGVuZCIsICJzb3VyY2UiLCAic3RhdGUiLCAiVGlsZV9kZWZhdWx0IiwgImNyZWF0ZU9yVXBkYXRlIiwgImdldEtleSIsICJnZXRLZXkiLCAiY3JlYXRlT3JVcGRhdGUiLCAiY3JlYXRlT3JVcGRhdGUiLCAic2NhbGUiLCAid3JhcFgiLCAiZ2V0IiwgInNjYWxlIiwgIndyYXBYIiwgIlRpbGVfZGVmYXVsdCIsICJUaWxlX2RlZmF1bHQiLCAiY2FjaGUiLCAiZ2V0S2V5IiwgIlRpbGVfZGVmYXVsdCIsICJ6IiwgIngiLCAieSIsICJwaXhlbFJhdGlvIiwgInJlbmRlciIsICJnZXQiLCAiaW5pdF9MYXllciIsICJMYXllcl9kZWZhdWx0IiwgIlRpbGVfZGVmYXVsdCIsICJ0bXBFeHRlbnQiLCAiZHgiLCAiZHkiLCAiaSIsICJlcXVhbHMiLCAidGlsZVNvdXJjZSIsICJmcmFtZVN0YXRlIiwgIlRpbGVfZGVmYXVsdCIsICJpbml0X1ZlY3RvciIsICJpbml0X3N0eWxlIiwgIlZlY3Rvcl9kZWZhdWx0IiwgIlRpbGVfZGVmYXVsdCIsICJNYXBfZGVmYXVsdCIsICJHZW9jb2RlciIsICJsYXQiLCAibG9uIl0KfQo=
